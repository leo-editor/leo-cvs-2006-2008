#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20060531161030:To do: 4.4.3
#@+node:ekr.20061130084909:Improve What's special whitepaper
@nocolor

- Answer the question: how can Leo help me with programming.
#@nonl
#@-node:ekr.20061130084909:Improve What's special whitepaper
#@+node:ekr.20070220082124:Make sure Leo can generate Latex
#@-node:ekr.20070220082124:Make sure Leo can generate Latex
#@+node:ekr.20070220082124.1:Before next release
#@+node:ekr.20070220090145:Fix crasher in rclicker plugin

Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2474, in doHook
    return f(tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 92, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 70, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 49, in callTagHandler
    result = handler(tag,keywords)

  File "C:\prog\tigris-cvs\leo\plugins\rClick.py", line 156, in rClicker
    n0,p0=ind0.split('.',2)

AttributeError: 'int' object has no attribute 'split'

#@-node:ekr.20070220090145:Fix crasher in rclicker plugin
#@+node:ekr.20070220082216:Test with Linux
#@-node:ekr.20070220082216:Test with Linux
#@+node:ekr.20070218144114:Improve docs
#@+node:ekr.20070215093739:Improve Leo's getting started page
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4159734
By: rogererens

Here are some issues with respect to installing Leo on Windows:

I think you should divide the "How to install Leo on Windows" into separate
sections: one section that describes the use of the installer and another one
that describes the use of the .zip-file. In the near future probably Vista deserves
its own section, too.

The notes warn about Python 2.4 and spaces in paths. The installer appears to
work properly with Python 2.5 though, and installing into a path that contains
spaces works fine too, AFAIK. Or are there any usability test cases to check
this?

Also, I would advice the person that is installing Leo to create an environment
variable (either a user variable or a system variable) called HOME with the
value "%USERPROFILE%\My Documents" when %HOME% does not yet exist (check in
a cmd-window by typing "echo %HOME%" without the quotes).
Then, after installing, a user should have the shortcut icon on his/her desktop;
change this by right-clicking and choosing properties to change the directory
where the application starts from the default "C:\Program Files\Leo\test\unittest"
into %HOME%.
I'm not sure if this could all be done automatically by the NSIS installer.

Finally, there's the issue that I installed Leo in the default Program Files
folder, while having the Administrator's role. After which I copied and adapted
the Leo shortcut to the desktop of a user with limited rights.
Unfortunately, when logged on as such a limited user, no plugins can be
enabled/disabled because of the restrictions on writing in program
files\leo\plugin.
(Even if the limited user _could_ write in that folder, it would be problematic:
his set of enabled plugins would overwrite the set of enabled plugins for the
administrator or another user).

Hope this helps to improve the installation experience for novices...
#@-node:ekr.20070215093739:Improve Leo's getting started page
#@+node:ekr.20070218143918:Improve Windows installation instructions
This section is way too confusing:
    
Users Guide-->Chapter 1: Installing Leo-->@rst html\install.html-->How to install Leo on Windows
#@nonl
#@-node:ekr.20070218143918:Improve Windows installation instructions
#@-node:ekr.20070218144114:Improve docs
#@+node:ekr.20070202080824:Enable more plugins by default
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4134565

I have been talking more and more people lately into giving Leo a try. These
are end-users, not programmer-type people. One of the problems I find is that
many features users expect as standard are plug-ins that are disabled at
startup.

From my experience, some of the plug-ins that people seem to want right away
are Cleo, Image, Maximize windows, Export to HTML, and Navibuttons.

Also, everyone seems to ask for spell checking, which I know is a separate install
(I haven't tried putting it in). Perhaps even that could be included?

I think it is a lot easier for power users to turn off things they don't like
than less sophisticated users to turn them on. However, I realize that each
additional plug-in means a longer load time and large memory footprint.

-------------------

From: Rich

These are the plugins that I use often:
Add directives & color markup
Cleo 3
Chapters 2 (unless Chapters works with newer releases, I will stick with Leo 4.4 final)
Group Operations
Nav_buttons
Open_with
RClick
Universal Scrolling

These are the plugins that I do not use too often:
New Buttons
UNL

The following are plugins I would like to use:
Edit Attributes
Conceptual Sort
Labels

"Labels" has a nice assortment of commands; however the labels are (1) not saved
between sessions, and (2) cannot be seen by "Edit Attributes."
I'd be more inclined to use "Edit Attributes" and "C-Sort" IF there was some
way to SEE the attributes (this goes for "Labels," as well).


---- Enable Aspell automatically if possible.

#@-node:ekr.20070202080824:Enable more plugins by default
#@+node:ekr.20070124091018:Recent crash (problem with pmw baloons)
Error: 1
TclError Exception in Tk callback
  Function: <bound method Balloon._destroy of <_Pmw.Pmw_1_2.lib.PmwBalloon.Balloon instance at 0x014C1850>> (type: <type 'instancemethod'>)
  Args: (<Tkinter.Event instance at 0x0542C788>,)
  Event type: DestroyNotify (type num: 17)
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBalloon.py", line 283, in _destroy
    self.withdraw()
  File "<string>", line 1, in withdraw
    None
  File "C:\Python24\lib\lib-tk\Tkinter.py", line 1541, in wm_withdraw
    return self.tk.call('wm', 'withdraw', self._w)
TclError: bad window path name ".14557752.18889184.18889584.21763816.21764336"

================================================
  Event contents:
    char: ??
    delta: 0
    height: ??
    keycode: ??
    keysym: ??
    keysym_num: ??
    num: ??
    send_event: False
    serial: 53150
    state: ??
    time: ??
    type: 17
    widget: .14557752.18889184.18889584.21763816
    width: ??
    x: ??
    x_root: ??
    y: ??
    y_root: ??

#@-node:ekr.20070124091018:Recent crash (problem with pmw baloons)
#@+node:ekr.20070126072723:pychecker errors 3
#leoGlobals.py:3933: No module attribute (CODESET) found
#leoGlobals.py:118: No module attribute (leo_config_directory) found
#leoGlobals.py:4494: No module attribute (mtime) found
#leoGlobals.py:5112: No global (p) found
#leoGlobals.py:5626: No global (c) found

leoFind.py:1465: Redefining attribute (changeAllCommand) original line (1454)

leoFind.py:248: No class attribute (svarDict) found
leoFind.py:253: No class attribute (find_ctrl) found
leoFind.py:254: No class attribute (change_ctrl) found
leoFind.py:257: No class attribute (change_ctrl) found
leoFind.py:257: No class attribute (find_ctrl) found
leoFind.py:272: No class attribute (svarDict) found
leoFind.py:274: No class attribute (svarDict) found
leoFind.py:277: No class attribute (svarDict) found
leoFind.py:285: No class attribute (svarDict) found
leoFind.py:287: No class attribute (svarDict) found
leoFind.py:290: No class attribute (svarDict) found
leoFind.py:1109: No class attribute (find_ctrl) found
leoFind.py:1128: No class attribute (frame) found
leoFind.py:1358: No class attribute (svarDict) found
leoFind.py:1362: No class attribute (svarDict) found
leoFind.py:1369: No class attribute (find_ctrl) found
leoFind.py:1376: No class attribute (change_ctrl) found
leoFind.py:1412: Invalid arguments to (createFrame), got 1, expected 0

leoKeys.py:1177: Local variable (b) not used
leoKeys.py:2364: No module attribute (initAllEditCommanders) found
leoKeys.py:2927: Local variable (gui) not used
leoKeys.py:3756: No global (c) found
leoFind.py:1398: No module attribute (__init__) found

leoTkinterFind.py:389: Overridden method (createFrame) doesn't match signature in class (leoFind.findTab)

leoTkinterMenu.py:145: Overridden method (insert) doesn't match signature in class (leoMenu.leoMenu)

leoTkinterFrame.py:1944: Object (body) has no attribute (leo_p)

leoTkinterGui.py:444: Overridden method (eventChar) doesn't match signature in class (leoGui.leoGui)
leoTkinterGui.py:448: Overridden method (eventKeysym) doesn't match signature in class (leoGui.leoGui)
leoTkinterGui.py:452: Overridden method (eventWidget) doesn't match signature in class (leoGui.leoGui)
leoTkinterGui.py:456: Overridden method (eventXY) doesn't match signature in class (leoGui.leoGui)

leoEditCommands.py:1110: Local variable (pythonDir) not used
leoEditCommands.py:1484: Local variable (gui) not used
leoEditCommands.py:4888: No global (c) found

leoEditCommands.py:7637: Local variable (gui) not used
leoFileCommands.py:2307: No global (c) found

leoImport.py:1317: Global variable (c) not defined in module scope

#@-node:ekr.20070126072723:pychecker errors 3
#@-node:ekr.20070220082124.1:Before next release
#@+node:ekr.20070220082124.2:Before b1
#@+node:ekr.20070211192428:(Make Leo's core gui-indenpendent)
# To do: use baseTextWidget class.  There seem to be problems :-)
#@nonl
#@+node:ekr.20070125103950: Calls to w.xxx
# To be removed outside of tk-specific files.
'cget'  # removed
'clipboard_append'
'clipboard_clear'
'config' # removed
'configure' # removed
'focus_force' # removed
'focus_set' # removed

# Ok: defined in leoTkTextWidget, plainTextWidget, etc.
'_name'
'delete'
'deleteTextSelection'
'flashCharacter'
'get'
'getAllText'
'getInsertPoint'
'getName'
'getSelectedText'
'getSelectionRange'
'getYScrollPosition'
# 'getWidth' # optional.
'hasSelection'
'insert'
'replace'
'rowColToGuiIndex'
'see'
'seeInsertPoint'
'selectAllText'
'setAllText'
'setBackgroundColor'
'setInsertPoint'
'setSelectionRange'
'setYScrollPosition'
'tag_add'
'tag_bind'
'tag_config'
'tag_delete'
'tag_names'
'tag_ranges'
'toGuiIndex'
'toPythonIndex'
'xyToPythonIndex'

# Ok: in leoTkinterTree.
'leo_active'
'leo_frame'
'leo_insertSpot'
'leo_label'
'leo_label_s'
'leo_name'
'leo_p'
'leo_position'
'leo_scrollBarSpot'
'leo_selection'
'leo_v'
'leo_window_id'

# Ok only if in tk-specific files.
'bind'
'bind_all'
'bind_class'
'bindtags'
'button'
'columnconfigure'
'compare'
'dlineinfo'
'event_generate'
'grid'
'image_create'
'index'
'mark_set'
'pack'
'pack_forget'
'rowconfigure'
'search'
'selection_clear'
'selection_get'
'update'
'update_idletasks'
'winfo_id'
'winfo_toplevel'
'wm_iconbitmap'
'yview'
#@nonl
#@+node:ekr.20070213165250:find w.xxx
import string
import leoTkinterFrame
words = {}
word_chars = string.ascii_letters + string.digits + '_'
p = g.findTopLevelNode(c,'Code')
p1 = p.copy()
baseClass = leoTkinterFrame.leoTkTextWidget
allMatches = True
seen = {}
for p in p.self_and_subtree_iter():
    if seen.get(p.v.t): continue # search clones once.
    seen[p.v.t] = True
    s = p.bodyString()
    i = 0
    while 1:
        j = s.find('w.',i)
        if j == -1: break
        ch = s[j-1]
        if j == 0 or ch not in word_chars:
            j += 2
            k = g.skip_c_id(s,j)
            word = s[j:k]
            if allMatches or not hasattr(baseClass,word):
                words[word] = 1 + words.get(word,0)
            i = k
        else:
            i += 2
keys = words.keys()
keys.sort()
aList = ['%3d %s' % (words.get(key),str(key)) for key in keys]
print g.listToString(aList)
g.es('searched %s' % p1.headString())
#@nonl
#@-node:ekr.20070213165250:find w.xxx
#@+node:ekr.20070213100433:Summary
w.dlineinfo:        Replaced by w.indexIsVisible(i)
w.replace:          Valid, but no longer used.
w.index:            Can be converted later.  g.getWord (similar to g.getLine) would be useful.
w.mark_set:         Removed.
w.search:           Can be converted later.
w.selection_clear:  Removed.
w.selection_get:    Removed.
w.winfo_toplevel:   Removed.
#@-node:ekr.20070213100433:Summary
#@+node:ekr.20070213065957:Script results
'  1 bind'
' 64 delete'
'  2 deleteTextSelection'
'  1 event_generate' # ok.
'  1 flashCharacter'
' 22 get'
'118 getAllText'
' 95 getInsertPoint'
' 21 getSelectedText'
' 60 getSelectionRange'
'  1 getYScrollPosition'
' 12 hasSelection'
'  8 index' # later.
'  2 indexIsVisible'
' 72 insert'
'  1 rowColToGuiIndex'
'  3 search' # later.
'  3 see'
' 14 seeInsertPoint'
'  3 selectAllText'
' 14 setAllText'
' 50 setInsertPoint'
' 67 setSelectionRange'
'  3 setWidth'
'  7 tag_add'
'  8 tag_config'
' 10 tag_delete'
'  5 tag_ranges'
'  8 toGuiIndex'
'  4 toPythonIndex'
'  3 xyToPythonIndex'
#@nonl
#@-node:ekr.20070213065957:Script results
#@-node:ekr.20070125103950: Calls to w.xxx
#@+node:ekr.20070212140907:What I did
@nocolor

- Moved makeScriptButton to the gui class.
  This is optional: it is not needed by the wxGui plugin.
  
- Removed calls to w.focus_force from move-line-up/down commands.

- Removed w.configure & w.cget from Leo's core.
  This affected pasteText, cutText commands and c.setHeadString.
  ** The only remaining calls are in classes that are to be refactored into gui-dependent/independent parts.
  
@color
#@nonl
#@+node:ekr.20070130120406:Moved cut/copy/pasteText into base leoFrame class
#@+node:ekr.20070130115927.4:Cut/Copy/Paste (leoFrame)
#@+node:ekr.20070130115927.5:copyText
def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = w.getSelectionRange()
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
#@-node:ekr.20070130115927.5:copyText
#@+node:ekr.20070130115927.6:leoFrame.cutText
def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i,j = w.getSelectionRange()
    
    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        width = f.tree.headWidth(p=None,s=s)
        w.setWidth(width)
    else: pass

OnCutFromMenu = cutText
#@-node:ekr.20070130115927.6:leoFrame.cutText
#@+node:ekr.20070130115927.7:leoFrame.pasteText
def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    # g.trace('isText',g.app.gui.isTextWidget(w),w)
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()
    
    # print 'pasteText',i,j,middleButton,wname,repr(c.k.previousSelection)
    
    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.getAllText()
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                width = f.tree.headWidth(p=None,s=s)
                w.setWidth(width)
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText
#@-node:ekr.20070130115927.7:leoFrame.pasteText
#@+node:ekr.20061016071937:OnPaste (To support middle-button paste)
def OnPaste (self,event=None):
    
    return self.pasteText(event=event,middleButton=True)
#@nonl
#@-node:ekr.20061016071937:OnPaste (To support middle-button paste)
#@-node:ekr.20070130115927.4:Cut/Copy/Paste (leoFrame)
#@-node:ekr.20070130120406:Moved cut/copy/pasteText into base leoFrame class
#@+node:ekr.20070209094628:Replaced leoTextWidgetClass by plainTextWidget or bodyTextWidget
#@-node:ekr.20070209094628:Replaced leoTextWidgetClass by plainTextWidget or bodyTextWidget
#@+node:ekr.20070125102904.1:Removed w.configure & w.cget from Leo's core
@

- Oh joy, tk headlines are plain text widgets!
- We can declare the colorizer to be gui-specific because it isn't used in other guis.
#@nonl
#@+node:ekr.20070130115927.7:leoFrame.pasteText
def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    # g.trace('isText',g.app.gui.isTextWidget(w),w)
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()
    
    # print 'pasteText',i,j,middleButton,wname,repr(c.k.previousSelection)
    
    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.getAllText()
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                width = f.tree.headWidth(p=None,s=s)
                w.setWidth(width)
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText
#@-node:ekr.20070130115927.7:leoFrame.pasteText
#@+node:ekr.20070130115927.6:leoFrame.cutText
def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i,j = w.getSelectionRange()
    
    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        width = f.tree.headWidth(p=None,s=s)
        w.setWidth(width)
    else: pass

OnCutFromMenu = cutText
#@-node:ekr.20070130115927.6:leoFrame.cutText
#@+node:ekr.20040305223225:c.setHeadString
def setHeadString (self,p,s,encoding="utf-8"):

    c = self
    w = c.edit_widget(p) # w only exists for the Tk gui.
    
    p.initHeadString(s,encoding)

    if w:
        w.setAllText(s)
        width = c.frame.tree.headWidth(p=None,s=s)
        w.setWidth(width)

    p.setDirty()
#@nonl
#@-node:ekr.20040305223225:c.setHeadString
#@-node:ekr.20070125102904.1:Removed w.configure & w.cget from Leo's core
#@+node:ekr.20061212110702:Removed Tk code from minibufferFind class
# The minibufferFind class now calls the finder's get/set/toggle methods.
#@nonl
#@+node:ekr.20060123125256:class minibufferFind( (the findHandler)
class minibufferFind (baseEditCommandsClass):

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others
#@+node:ekr.20060123125317.2: ctor (minibufferFind)
def __init__(self,c,finder):
    
    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    # g.trace('minibufferFind: finder',finder)

    self.c = c
    self.k = k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []
    
    commandName = 'replace-string'
    s = k.getShortcutForCommandName(commandName)
    s = k.prettyPrintKey(s)
    s = k.shortcutFromSetting(s)
    self.replaceStringShortcut = s
#@-node:ekr.20060123125317.2: ctor (minibufferFind)
#@+node:ekr.20060124140114: Options (minibufferFind)
#@+node:ekr.20060124123133:setFindScope
def setFindScope(self,where):
    
    '''Set the find-scope radio buttons.
    
    `where` must be in ('node-only','entire-outline','suboutline-only'). '''
    
    h = self.finder
    
    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.svarDict['radio-search-scope'].get()
        if var:
            h.svarDict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
#@-node:ekr.20060124123133:setFindScope
#@+node:ekr.20060124122844:get/set/toggleOption (minibufferFind)
# This redirection is required to remove gui-dependencies.

def getOption (self,ivar):          return self.finder.getOption(ivar)
def setOption (self,ivar,val):      self.finder.setOption(ivar,val)
def toggleOption (self,ivar):       self.finder.toggleOption(ivar)
#@-node:ekr.20060124122844:get/set/toggleOption (minibufferFind)
#@+node:ekr.20060125074939:showFindOptions
def showFindOptions (self):
    
    '''Show the present find options in the status line.'''
    
    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')
    
    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )
        
    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
#@-node:ekr.20060125074939:showFindOptions
#@+node:ekr.20060205105950:setupChangePattern
def setupChangePattern (self,pattern):
    
    h = self.finder ; w = h.change_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    w.delete(0,'end')
    w.insert(0,s)
    
    h.update_ivars()
#@-node:ekr.20060205105950:setupChangePattern
#@+node:ekr.20060125091234:setupSearchPattern
def setupSearchPattern (self,pattern):
    
    h = self.finder ; w = h.find_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    w.delete(0,'end')
    w.insert(0,s)
    
    h.update_ivars()
#@-node:ekr.20060125091234:setupSearchPattern
#@-node:ekr.20060124140114: Options (minibufferFind)
#@+node:ekr.20060210180352:addChangeStringToLabel
def addChangeStringToLabel (self,protect=True):
    
    c = self.c ; k = c.k ; h = self.finder ; w = h.change_ctrl
    
    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()
    
    s = w.getAllText()

    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
#@-node:ekr.20060210180352:addChangeStringToLabel
#@+node:ekr.20060210164421:addFindStringToLabel
def addFindStringToLabel (self,protect=True):
    
    c = self.c ; k = c.k ; h = self.finder ; w = h.find_ctrl
    
    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
#@-node:ekr.20060210164421:addFindStringToLabel
#@+node:ekr.20070105123800:changeAll
def changeAll (self,event):

    k = self.k ; tag = 'change-all' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Change All From: ',protect=True)
        k.getArg(event,tag,1,self.changeAll)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = 'Change All: %s With: ' % (self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,tag,2,self.changeAll,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg,changeAll=True)

#@-node:ekr.20070105123800:changeAll
#@+node:ekr.20060128080201:cloneFindAll
def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
#@-node:ekr.20060128080201:cloneFindAll
#@+node:ekr.20060204120158:findAgain
def findAgain (self,event):

    f = self.finder
    
    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
#@-node:ekr.20060204120158:findAgain
#@+node:ekr.20060209064140:findAll
def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
#@-node:ekr.20060209064140:findAll
#@+node:ekr.20060205105950.1:generalChangeHelper
def generalChangeHelper (self,find_pattern,change_pattern,changeAll=False):
    
    # g.trace(repr(change_pattern))
    
    c = self.c

    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()

    if changeAll:
         self.finder.changeAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@-node:ekr.20060205105950.1:generalChangeHelper
#@+node:ekr.20060124181213.4:generalSearchHelper
def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):
    
    c = self.c
    
    self.setupSearchPattern(pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if findAll:
         self.finder.findAllCommand()
    elif cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@-node:ekr.20060124181213.4:generalSearchHelper
#@+node:ekr.20060210174441:lastStateHelper
def lastStateHelper (self):
    
    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
#@-node:ekr.20060210174441:lastStateHelper
#@+node:ekr.20050920084036.113:replaceString
def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
#@-node:ekr.20050920084036.113:replaceString
#@+node:ekr.20060124140224.3:reSearchBackward/Forward
def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060124140224.3:reSearchBackward/Forward
#@+node:ekr.20060124140224.1:seachForward/Backward
def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060124140224.1:seachForward/Backward
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20060124134356:setupArgs
def setupArgs (self,forward=False,regexp=False,word=False):
    
    h = self.finder ; k = self.k
    
    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)
            
    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
#@-node:ekr.20060124134356:setupArgs
#@+node:ekr.20060210173041:stateZeroHelper
def stateZeroHelper (self,event,tag,prefix,handler,escapes=[]):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w: return

    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)
    
    # g.trace(escapes,g.callers())
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
#@-node:ekr.20060210173041:stateZeroHelper
#@+node:ekr.20060224171851:updateChange/FindList
def updateChangeList (self,s):

    if s not in self.changeTextList:
        self.changeTextList.append(s)
        
def updateFindList (self,s):

    if s not in self.findTextList:
        self.findTextList.append(s)
#@-node:ekr.20060224171851:updateChange/FindList
#@+node:ekr.20060124140224.2:wordSearchBackward/Forward
def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060124140224.2:wordSearchBackward/Forward
#@-node:ekr.20060123125256:class minibufferFind( (the findHandler)
#@+node:ekr.20070212092458:Support for minibufferFind class (tkFindTab)
#@+node:ekr.20070212093026:getOption
def getOption (self,ivar):

    var = self.svarDict.get(ivar)
    
    if var:
        val = var.get()
        # g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
#@-node:ekr.20070212093026:getOption
#@+node:ekr.20070212092525:setOption
def setOption (self,ivar,val):

    if ivar in self.intKeys:
        if val is not None:
            var = self.svarDict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
#@-node:ekr.20070212092525:setOption
#@+node:ekr.20070212093026.1:toggleOption
def toggleOption (self,ivar):

    if ivar in self.intKeys:
        var = self.svarDict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
#@-node:ekr.20070212093026.1:toggleOption
#@-node:ekr.20070212092458:Support for minibufferFind class (tkFindTab)
#@+node:ekr.20060124140114: Options (minibufferFind)
#@+node:ekr.20060124123133:setFindScope
def setFindScope(self,where):
    
    '''Set the find-scope radio buttons.
    
    `where` must be in ('node-only','entire-outline','suboutline-only'). '''
    
    h = self.finder
    
    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.svarDict['radio-search-scope'].get()
        if var:
            h.svarDict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
#@-node:ekr.20060124123133:setFindScope
#@+node:ekr.20060124122844:get/set/toggleOption (minibufferFind)
# This redirection is required to remove gui-dependencies.

def getOption (self,ivar):          return self.finder.getOption(ivar)
def setOption (self,ivar,val):      self.finder.setOption(ivar,val)
def toggleOption (self,ivar):       self.finder.toggleOption(ivar)
#@-node:ekr.20060124122844:get/set/toggleOption (minibufferFind)
#@+node:ekr.20060125074939:showFindOptions
def showFindOptions (self):
    
    '''Show the present find options in the status line.'''
    
    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')
    
    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )
        
    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
#@-node:ekr.20060125074939:showFindOptions
#@+node:ekr.20060205105950:setupChangePattern
def setupChangePattern (self,pattern):
    
    h = self.finder ; w = h.change_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    w.delete(0,'end')
    w.insert(0,s)
    
    h.update_ivars()
#@-node:ekr.20060205105950:setupChangePattern
#@+node:ekr.20060125091234:setupSearchPattern
def setupSearchPattern (self,pattern):
    
    h = self.finder ; w = h.find_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    w.delete(0,'end')
    w.insert(0,s)
    
    h.update_ivars()
#@-node:ekr.20060125091234:setupSearchPattern
#@-node:ekr.20060124140114: Options (minibufferFind)
#@-node:ekr.20061212110702:Removed Tk code from minibufferFind class
#@+node:ekr.20070212102040:Moved Tk color code into tkLog
#@+node:ekr.20051019183105.1:show-colors
def showColors (self,event):
    
    '''Open a tab in the log pane showing various color pickers.'''
    
    c = self.c ; log = c.frame.log ; tabName = 'Colors'
    
    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createColorPicker(tabName)
#@-node:ekr.20051019183105.1:show-colors
#@+node:ekr.20051019183105.3:tkLog color tab stuff
def createColorPicker (self,tabName):
    
    log = self
    
    << define colors >>
    
    parent = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    colors = list(colors)
    bg = parent.cget('background')
    
    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)
    
    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')
    
    label = g.app.gui.plainTextWidget(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    << create optionMenu and callback >>
    << create picker button and callback >>
#@+node:ekr.20051019183105.4:<< create optionMenu and callback >>
colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)
#@-node:ekr.20051019183105.4:<< create optionMenu and callback >>
#@+node:ekr.20051019183105.5:<< create picker button and callback >>
def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)
#@-node:ekr.20051019183105.5:<< create picker button and callback >>
#@+node:ekr.20051019183105.2:<< define colors >>
colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )
#@-node:ekr.20051019183105.2:<< define colors >>
#@-node:ekr.20051019183105.3:tkLog color tab stuff
#@-node:ekr.20070212102040:Moved Tk color code into tkLog
#@+node:ekr.20070212102521.1:Moved Tk font code into tkLog
#@+node:ekr.20051019201809:editCommands.show-fonts & helpers
def showFonts (self,event):
    
    '''Open a tab in the log pane showing a font picker.'''

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createFontPicker(tabName)
#@-node:ekr.20051019201809:editCommands.show-fonts & helpers
#@+node:ekr.20070212102521:tkLog font tab stuff
#@+node:ekr.20051019201809.1:createFontPicker
def createFontPicker (self,tabName):
    
    log = self
    parent = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    bg = parent.cget('background')
    font = self.getFont()
    << create the frames >>
    << create the family combo box >>
    << create the size entry >>
    << create the weight combo box >>
    << create the slant combo box >>
    << create the sample text widget >>
    << create and bind the callbacks >>
    self.createBindings()
#@+node:ekr.20051019202139:<< create the frames >>
f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')
#@-node:ekr.20051019202139:<< create the frames >>
#@+node:ekr.20051019201809.2:<< create the family combo box >>
names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'<None>')

self.familyBox = familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.2:<< create the family combo box >>
#@+node:ekr.20051019201809.3:<< create the size entry >>
Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4)
sizeEntry.insert(0,'12')
sizeEntry.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.3:<< create the size entry >>
#@+node:ekr.20051019201809.4:<< create the weight combo box >>
weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.4:<< create the weight combo box >>
#@+node:ekr.20051019201809.5:<< create the slant combo box>>
slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.5:<< create the slant combo box>>
#@+node:ekr.20051019202139.1:<< create the sample text widget >>
self.sampleWidget = sample = g.app.gui.plainTextWidget(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert(0,s)
#@-node:ekr.20051019202139.1:<< create the sample text widget >>
#@+node:ekr.20051019202328:<< create and bind the callbacks >>
def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('<Return>',fontCallback)
#@-node:ekr.20051019202328:<< create and bind the callbacks >>
#@-node:ekr.20051019201809.1:createFontPicker
#@+node:ekr.20060726133852:createBindings (fontPicker)
def createBindings (self):
    
    c = self.c ; k = c.k
    
    table = (
        ('<Button-1>',  k.masterClickHandler),
        ('<Double-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClickHandler),
        ('<Double-3>',  k.masterClickHandler),
        ('<Key>',       k.masterKeyHandler),
        ("<Escape>",    self.hideFontTab),
    )

    w = self.sampleWidget
    for event, callback in table:
        w.bind(event,callback)
        
    k.completeAllBindingsForWidget(w)
#@-node:ekr.20060726133852:createBindings (fontPicker)
#@+node:ekr.20051019201809.6:getFont
def getFont(self,family=None,size=12,slant='roman',weight='normal'):
    
    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@-node:ekr.20051019201809.6:getFont
#@+node:ekr.20051019201809.7:setFont
def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):
    
    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','<none>',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)
#@-node:ekr.20051019201809.7:setFont
#@+node:ekr.20060726134339:hideFontTab
def hideFontTab (self,event=None):
    
    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@-node:ekr.20060726134339:hideFontTab
#@-node:ekr.20070212102521:tkLog font tab stuff
#@-node:ekr.20070212102521.1:Moved Tk font code into tkLog
#@+node:ekr.20070212065258:Refactored tk spell code tkSpellTab
# The spellTabHandler class is now separate from the tkSpellTab class.
# Added g.app.gui.createSpellTab.
#@nonl
#@+node:ekr.20070212132230:tkGui.createSpellTab
def createSpellTab(self,c,spellHandler,tabName):
    
    return leoTkinterFind.tkSpellTab(c,spellHandler,tabName)
#@-node:ekr.20070212132230:tkGui.createSpellTab
#@+node:ekr.20051025080633:openSpellTab
def openSpellTab (self,event=None):
    
    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'
    
    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        self.handler = spellTabHandler(c,tabName)
        if not self.handler.loaded:
            log.deleteTab(tabName,force=True)
#@+node:ekr.20051025080420.1:commands...
# Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()
        
def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()
        
def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
#@-node:ekr.20051025080420.1:commands...
#@-node:ekr.20051025080633:openSpellTab
#@+node:ekr.20051025071455.18:class spellTabHandler (leoFind.leoFind)
class spellTabHandler (leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""
    
    @others
#@+node:ekr.20051025071455.19:Birth & death
#@+node:ekr.20051025071455.20:spellTabHandler.__init__
def __init__(self,c,tabName):
    
    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = g.app.gui.plainTextWidget(c.frame.top)
        # A text widget for scanning.
        # Must have a parent frame even though it is not packed.
    
    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.tab = g.app.gui.createSpellTab(c,self,tabName)
#@-node:ekr.20051025071455.20:spellTabHandler.__init__
#@+node:ekr.20051025094004:init_aspell
def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"../","plugins",'spellpyx.txt'))
    
    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = AspellClass(c,dictionaryFileName,self.local_language_code)
    
    if self.aspell.aspell:
        self.dictionary = self.readDictionary(dictionaryFileName)
    else:
        self.dictionary = False
        # g.es_print('Can not open Aspell',color='red')
    
    return self.aspell.aspell
#@-node:ekr.20051025094004:init_aspell
#@+node:ekr.20051025071455.16:readDictionary
def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary
    
    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""
    
    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
#@-node:ekr.20051025071455.16:readDictionary
#@-node:ekr.20051025071455.19:Birth & death
#@+node:ekr.20051025071455.36:Commands
#@+node:ekr.20051025071455.37:add
def add(self,event=None):
    """Add the selected suggestion to the dictionary."""
    
    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()
        
    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
#@-node:ekr.20051025071455.37:add
#@+node:ekr.20051025071455.38:change (spellTab) 
def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; w = body.bodyCtrl
    
    selection = self.tab.getSuggestion()
    if selection:
        start,end = oldSel = w.getSelectionRange()
        if start:
            if start > end: start,end = end,start
            w.delete(start,end)
            w.insert(start,selection)
            w.setSelectionRange(start,start+len(selection))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
#@-node:ekr.20051025071455.38:change (spellTab) 
#@+node:ekr.20051025071455.40:find & helpers
def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Copy the working selection range to the body pane
        start, end = self.workCtrl.getSelectionRange()
        w.setSelectionRange(start,end)
        w.see(start)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
#@+node:ekr.20051025071455.45:findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""
    
    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None
   
    try:
        while 1:
            p, word = self.findNextWord(p) 
            if not p or not word:
                alts = None
                break
            << Skip word if ignored or in local dictionary >>
            alts = aspell.processWord(word)
            if alts:
                w = c.frame.body.bodyCtrl
                i,j = w.getSelectionRange()
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                w.setSelectionRange(i,j,insert=j)
                break
    except:
        g.es_exception()
    return alts, word
#@+node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
#@-node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
#@-node:ekr.20051025071455.45:findNextMisspelledWord
#@+node:ekr.20051025071455.47:findNextWord
def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    c = self.c ; w = self.workCtrl ; s = w.getAllText() ; p = p.copy()
    while 1:
        i = w.getInsertPoint()
        while i < len(s) and not g.isWordChar1(s[i]):
            i += 1
        if i < len(s):
            # A non-empty word has been found.
            j = i
            while j < len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # g.trace(repr(word)) # This trace verifies that all words have been checked.
            for w2 in (w,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w2)
                w2.setSelectionRange(i,j,insert=j)
            return p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            w.delete(0,'end')
            w.insert(0,p.bodyString())
            for w2 in (w,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w2)
                w.setSelectionRange(0,0,insert=0)
    return None,None
#@nonl
#@-node:ekr.20051025071455.47:findNextWord
#@-node:ekr.20051025071455.40:find & helpers
#@+node:ekr.20051025121408:hide
def hide (self,event=None):
    
    self.c.frame.log.selectTab('Log')
    
    for message in self.messages:
        g.es(message,color='blue')
        
    self.messages = []
#@-node:ekr.20051025121408:hide
#@+node:ekr.20051025071455.41:ignore
def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""
    
    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
#@-node:ekr.20051025071455.41:ignore
#@-node:ekr.20051025071455.36:Commands
#@-node:ekr.20051025071455.18:class spellTabHandler (leoFind.leoFind)
#@+node:ekr.20051025071455.22:class tkSpellTab
class tkSpellTab:
    
    @others
#@+node:ekr.20070212132230.1:tkSpellTab.__init__
def __init__ (self,c,handler,tabName):

    self.c = c
    self.handler = handler
    self.tabName = tabName
    
    self.createFrame()
    self.createBindings()
    self.fillbox([])
#@-node:ekr.20070212132230.1:tkSpellTab.__init__
#@+node:ekr.20051025120920:createBindings
def createBindings (self):
    
    c = self.c ; k = c.k
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:

        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.handler.hide),
            ('spell-add',               self.handler.add),
            ('spell-find',              self.handler.find),
            ('spell-ignore',            self.handler.ignore),
            ('spell-change-then-find',  self.handler.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut = k.shortcutFromSetting(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
                    
    self.listBox.bind("<Double-1>",self.onChangeThenFindButton)
    self.listBox.bind("<Button-1>",self.onSelectListBox)
    self.listBox.bind("<Map>",self.onMap)
#@nonl
#@-node:ekr.20051025120920:createBindings
#@+node:ekr.20070212132230.2:createFrame
def createFrame (self):
    
    c = self.c ; log = c.frame.log ; tabName = self.tabName
    
    parentFrame = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'

    << Create the outer frames >>
    << Create the text and suggestion panes >>
    << Create the spelling buttons >>
    
    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
#@+node:ekr.20051113090322:<< Create the outer frames >>
self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)
#@-node:ekr.20051113090322:<< Create the outer frames >>
#@+node:ekr.20051025071455.23:<< Create the text and suggestion panes >>
f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')
#@-node:ekr.20051025071455.23:<< Create the text and suggestion panes >>
#@+node:ekr.20051025071455.24:<< Create the spelling buttons >>
# Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList
#@-node:ekr.20051025071455.24:<< Create the spelling buttons >>
#@-node:ekr.20070212132230.2:createFrame
#@+node:ekr.20051025071455.29:Event handlers
#@+node:ekr.20051025071455.30:onAddButton
def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.handler.add()
#@-node:ekr.20051025071455.30:onAddButton
#@+node:ekr.20051025071455.32:onChangeButton & onChangeThenFindButton
def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.handler.change()
    self.updateButtons()
    

def onChangeThenFindButton(self,event=None):
    
    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.change():
        self.find()
    self.updateButtons()
#@-node:ekr.20051025071455.32:onChangeButton & onChangeThenFindButton
#@+node:ekr.20051025071455.33:onFindButton
def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    c = self.c
    self.handler.find()
    self.updateButtons()
    c.invalidateFocus()
    c.bodyWantsFocusNow()
#@-node:ekr.20051025071455.33:onFindButton
#@+node:ekr.20051025071455.34:onHideButton
def onHideButton(self):
    
    """Handle a click in the Hide button in the Spell tab."""
    
    self.handler.hide()
#@-node:ekr.20051025071455.34:onHideButton
#@+node:ekr.20051025071455.31:onIgnoreButton
def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.handler.ignore()
#@-node:ekr.20051025071455.31:onIgnoreButton
#@+node:ekr.20051025071455.49:onMap
def onMap (self, event=None):
    """Respond to a Tk <Map> event."""
    
    self.update(show= False, fill= False)
#@-node:ekr.20051025071455.49:onMap
#@+node:ekr.20051025071455.50:onSelectListBox
def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    
    c = self.c
    self.updateButtons()
    c.bodyWantsFocus()
#@-node:ekr.20051025071455.50:onSelectListBox
#@-node:ekr.20051025071455.29:Event handlers
#@+node:ekr.20051025071455.42:Helpers
#@+node:ekr.20051025071455.43:bringToFront
def bringToFront (self):
    
    self.c.frame.log.selectTab('Spell')
#@-node:ekr.20051025071455.43:bringToFront
#@+node:ekr.20051025071455.44:fillbox
def fillbox(self, alts, word=None):
    """Update the suggestions listBox in the Check Spelling dialog."""
    
    self.suggestions = alts
    
    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])
    
    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1)
#@-node:ekr.20051025071455.44:fillbox
#@+node:ekr.20051025071455.48:getSuggestion
def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    
    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None
#@-node:ekr.20051025071455.48:getSuggestion
#@+node:ekr.20051025071455.51:update
def update(self,show=True,fill=False):
    
    """Update the Spell Check dialog."""
    
    c = self.c
    
    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.bodyWantsFocus()
#@-node:ekr.20051025071455.51:update
#@+node:ekr.20051025071455.52:updateButtons (spellTab)
def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c ; w = c.frame.body.bodyCtrl

    start, end = w.getSelectionRange()
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
#@-node:ekr.20051025071455.52:updateButtons (spellTab)
#@-node:ekr.20051025071455.42:Helpers
#@-node:ekr.20051025071455.22:class tkSpellTab
#@-node:ekr.20070212065258:Refactored tk spell code tkSpellTab
#@+node:ekr.20070212143353:Replaced w.clipboard* by gui methods
#@+node:ekr.20031218072017.3734:Clipboard (leoGui)
def replaceClipboardWith (self,s):
    
    self.oops()

def getTextFromClipboard (self):
    
    self.oops()
#@-node:ekr.20031218072017.3734:Clipboard (leoGui)
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20050920084036.178:kill, killLine
def kill (self,event,frm,to,undoType=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    w.delete(frm,to)
    w.setInsertPoint(frm)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    # g.trace(i,j,ins,len(s),repr(s[i:j]))
    if ins >= len(s) and g.match(s,j-1,'\n'): # Kill the trailing newline.
        i = max(0,len(s)-1)
        j = len(s)
    elif j > i+1 and g.match(s,j-1,'\n'): # Kill the line, but not the newline.
        j -= 1
    else: # Kill the newline.
        pass
    self.kill(event,i,j,undoType='kill-line')
#@-node:ekr.20050920084036.178:kill, killLine
#@+node:ekr.20050920084036.182:killRegion & killRegionSave & helper
def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)
    
def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    theRange = w.tag_ranges('sel')
    if not theRange: return
    
    s = w.get(theRange[0],theRange[-1])
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(theRange[0],theRange[-1])
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    # self.removeRKeys(w)
#@-node:ekr.20050920084036.182:killRegion & killRegionSave & helper
#@-node:ekr.20070212143353:Replaced w.clipboard* by gui methods
#@+node:ekr.20070212151339:Replaced tkFileDialog by gui.runOpenFileDialog
#@+node:ekr.20050920084036.20:readAbbreviations
def readAbbreviations (self,event):
    
    '''Read abbreviations from a file.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Abbreviation File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return
        
    try:
        f = open(fileName)
        for x in f:
            a, b = x.split('=')
            b = b [:-1]
            self.abbrevs [a] = b
        f.close()
    except IOError:
        g.es('Can not open',fileName)
#@-node:ekr.20050920084036.20:readAbbreviations
#@+node:ekr.20050920084036.24:writeAbbreviations
def writeAbbreviations (self,event):
    
    '''Write abbreviations to a file.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Write Abbreviations',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")
        
    if not fileName: return

    try:
        f = open(fileName,'w')
        for x in self.abbrevs:
            f.write('%s=%s\n' % (x,self.abbrevs[x]))
        f.close()
    except IOError:
        g.es('Can not create',fileName)
#@-node:ekr.20050920084036.24:writeAbbreviations
#@+node:ekr.20050920084036.166:getReadableTextFile
def getReadableTextFile (self):
 
    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Text File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")
        
    if not fileName: return None, None

    try:
        f = open(fileName,'rt')
        return f, fileName
    except IOError:
        g.es('Can not open',fileName)
        return None,None
#@-node:ekr.20050920084036.166:getReadableTextFile
#@+node:ekr.20050920084036.196:loadFile & helpers
def loadFile (self,event):

    '''Asks for a macro file name to load.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Macro File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")
        
    if not fileName: return
        
    try:
        f = open(fileName)
        self._loadMacros(f)
    except IOError:
        g.es('Can not open',fileName)
#@+node:ekr.20050920084036.197:_loadMacros
def _loadMacros (self,f):

    '''Loads a macro file into the macros dictionary.'''

    k = self.k
    macros = cPickle.load(f)
    for z in macros:
        k.addToDoAltX(z,macros[z])
#@-node:ekr.20050920084036.197:_loadMacros
#@-node:ekr.20050920084036.196:loadFile & helpers
#@+node:ekr.20050920084036.170:saveFile
def saveFile (self,event):
    
    '''Prompt for the name of a file and put the body text of the selected node into it..'''

    w = self.editWidget(event)
    if not w: return
    
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='save-file',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")
        
    if not fileName: return

    try:
        s = w.getAllText()
        f = open(fileName,'w')
        f.write(s)
        f.close()
    except IOError:
        g.es('Can not create',fileName)
#@-node:ekr.20050920084036.170:saveFile
#@+node:ekr.20050920084036.199:saveMacros & helper
def saveMacros (self,event,macname):

    '''Asks for a file name and saves it.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Save Macros',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")
        
    if not fileName: return
    
    try:
        f = file(fileName,'a+')
        f.seek(0)
        if f:
            self._saveMacros(f,macname)
    except IOError:
        g.es('Can not create',fileName)

#@+node:ekr.20050920084036.200:_saveMacros
def _saveMacros( self, f , name ):
    '''Saves the macros as a pickled dictionary'''
    import cPickle
    fname = f.name
    try:
        macs = cPickle.load( f )
    except:
        macs = {}
    f.close()
    if self.namedMacros.has_key( name ):
        macs[ name ] = self.namedMacros[ name ]
        f = file( fname, 'w' )
        cPickle.dump( macs, f )
        f.close()
#@-node:ekr.20050920084036.200:_saveMacros
#@-node:ekr.20050920084036.199:saveMacros & helper
#@-node:ekr.20070212151339:Replaced tkFileDialog by gui.runOpenFileDialog
#@+node:ekr.20070212144559.1:Removed references to Tk and  Pmw from Leo's core
#@+node:ekr.20050920084036.203:_executeMacro (test)
def _executeMacro (self,macro,w):

    c = self.c ; k = self.k

    for z in macro:
        if len(z) == 2:
            w.event_generate('<Key>',keycode=z[0],keysym=z[1])
        else:
            meth = g.stripBrackets(z[0])
            bunchList = k.bindingsDict.get(meth,[]) ### Probably should not strip < and >
            if bunchList:
                b = bunchList [0]
                # ev = Tk.Event()
                # ev.widget = w
                # ev.keycode = z [1]
                # ev.keysym = z [2]
                # ev.char = z [3]
                event = g.Bunch(c=c,widget=w,keycode=z[1],keysym=z[2],char=z[3])
                k.masterCommand(event,b.f,'<%s>' % meth)
#@-node:ekr.20050920084036.203:_executeMacro (test)
#@+node:ekr.20040629121554.3:c.signOnWithVersion
def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
    g.enl()
#@-node:ekr.20040629121554.3:c.signOnWithVersion
#@+node:ekr.20070212144559:getFullVersion
def getFullVersion (self,c):
    
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    return 'Tk %s, Pmw %s' % (tkLevel,Pmw.version())
#@-node:ekr.20070212144559:getFullVersion
#@+node:ekr.20050328133058:g.createStandAloneTkApp
# This must be defined in leoGlobals: g.app.gui doesn't exist yet.

def createStandAloneTkApp(pluginName=''):
    
    '''Create a Tk version of the g.app object for 'stand-alone' plugins.'''
    
    if not g.app:
        # Important: these references do not make Leo's core gui-dependent.
        # In other words, this function is called only when Tkinter should be the gui.
        import Tkinter as Tk
        Pmw = g.importExtension('Pmw',pluginName=pluginName,verbose=True)
        if Tk and Pmw:
            import leoApp, leoGui
            g.app = leoApp.LeoApp()
            g.app.root = Tk.Tk()
            Pmw.initialise(g.app.root)
            g.app.gui = leoGui.nullGui('<stand-alone app gui>')
            g.computeStandardDirectories()
    return g.app
#@-node:ekr.20050328133058:g.createStandAloneTkApp
#@+node:ekr.20060329083657:cantImportDialog & helpers
def cantImportDialog (pluginName,moduleName):
    
    '''Attempt to show a Tk dialog if an import fails.
    Yes, this is a small Tk dependency, but it can't be helped.'''
    
    message = '''
%s requires the %s module.
Official distributions contain this module in Leo's extensions folder,
but this module may be missing if you get Leo from cvs.
''' % (pluginName,moduleName)

    if 1: # Requires minimal further imports.
        try:
            import Tkinter as Tk
            root = g.app.root or Tk.Tk()
            title = 'Can not import %s' % moduleName
            top = createDialogFrame(Tk,root,title,message)
            root.wait_window(top)
        except ImportError:
            print 'Can not import %s' % moduleName
            print 'Can not import Tkinter'
            print 'Leo must now exit'
        
    else: # Can cause import problems during startup.
        import leoTkinterDialog
        
        d = leoTkinterDialog.tkinterAskOk(
            c=None,title='Can not import %s' %(moduleName),
            message=message)
        d.run(modal=True)
#@+node:ekr.20060329083310.1:createDialogFrame
def createDialogFrame(Tk,root,title,message):
    
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    top = Tk.Toplevel(root)
    top.title(title)

    def onKey(event,top=top):
        if event.char.lower() in ('\n','\r'):
            top.destroy()
    top.bind("<Key>",onKey)

    f = Tk.Frame(top)
    f.pack(side="top",expand=1,fill="both")
    
    label = Tk.Label(f,text=message)
    label.pack(pady=10)
    
    def okButton(top=top):
        top.destroy()
    
    buttons = {"text":'OK',"command":okButton,"default":True}, # Singleton tuple.
    createDialogButtons(Tk,top,buttons)
    
    center(top)
    top.lift()
    top.focus_force()
    
    # Attach the icon at idle time.
    def attachIconCallback(top=top):
        g.app.gui.attachLeoIcon(top)
    top.after_idle(attachIconCallback)

    return top
#@-node:ekr.20060329083310.1:createDialogFrame
#@+node:ekr.20060329083310.2:createDialogButtons
def createDialogButtons (Tk,top,buttons):
    
    """Create a row of buttons.
    
    buttons is a list of dictionaries containing the properties of each button."""
    
    f = Tk.Frame(top)
    f.pack(side="top",padx=30)

    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
#@-node:ekr.20060329083310.2:createDialogButtons
#@+node:ekr.20060329085417.1:center
def center(top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y
#@-node:ekr.20060329085417.1:center
#@+node:ekr.20060329085612:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y
#@-node:ekr.20060329085612:get_window_info
#@-node:ekr.20060329083657:cantImportDialog & helpers
#@-node:ekr.20070212144559.1:Removed references to Tk and  Pmw from Leo's core
#@-node:ekr.20070212140907:What I did
#@+node:ekr.20061113151148.1:class leoTkTextWidget (Tk.Text)
class leoTkTextWidget (Tk.Text): ### (baseTextWidget):
    
    '''A class to wrap the Tk.Text widget.
    Translates Python (integer) indices to and from Tk (string) indices.
    
    This class inherits almost all tkText methods: you call use them as usual.'''
    
    # The signatures of tag_add and insert are different from the Tk.Text signatures.
    __pychecker__ = '--no-override' # suppress warning about changed signature.
        
    def __repr__(self):
        name = hasattr(self,'_name') and self._name or '<no name>'
        return 'leoTkTextWidget id: %s name: %s' % (id(self),name)
        
    @others
#@nonl
#@+node:ekr.20070213170836:plainTextWidget.__init__
if 0:
    def __init__ (self,*args,**keys):
    
        w = self
        
        # Create the actual gui widget.
        self.widget = Tk.Text(*args,**keys)
        
        # Init the base class.
        name = keys.get('name') or '<unknown plainTextWidget>'
        baseTextWidget.__init__(self,
            baseClassName='plainTextWidget',name=name,widget=self.widget)
    
        # self.defaultFont = font = wx.Font(pointSize=10,
            # family = wx.FONTFAMILY_TELETYPE, # wx.FONTFAMILY_ROMAN,
            # style  = wx.FONTSTYLE_NORMAL,
            # weight = wx.FONTWEIGHT_NORMAL,)
#@-node:ekr.20070213170836:plainTextWidget.__init__
#@+node:ekr.20070213170937:bindings (not used)
# Specify the names of widget-specific methods.
# These particular names are the names of wx.TextCtrl methods.

# def _appendText(self,s):            return self.widget.insert(s)
# def _get(self,i,j):                 return self.widget.get(i,j)
# def _getAllText(self):              return self.widget.get('1.0','end')
# def _getFocus(self):                return self.widget.focus_get()
# def _getInsertPoint(self):          return self.widget.index('insert')
# def _getLastPosition(self):         return self.widget.index('end')
# def _getSelectedText(self):         return self.widget.get('sel.start','sel.end')
# def _getSelectionRange(self):       return self.widget.index('sel.start'),self.widget.index('sel.end')
# def _hitTest(self,pos):             pass ###
# def _insertText(self,i,s):          return self.widget.insert(i,s)
# def _scrollLines(self,n):           pass ###
# def _see(self,i):                   return self.widget.see(i)
# def _setAllText(self,s):            self.widget.delete('1.0','end') ; self.widget.insert('1.0',s)
# def _setBackgroundColor(self,color): return self.widget.configure(background=color)
# def _setFocus(self):                return self.widget.focus_set()
# def _setInsertPoint(self,i):        return self.widget.mark_set('insert',i)
# # def _setSelectionRange(self,i,j):   return self.widget.SetSelection(i,j)
#@-node:ekr.20070213170937:bindings (not used)
#@+node:ekr.20061113151148.2:Index conversion (leoTextWidget)
#@+node:ekr.20061117085824:w.toGuiIndex
def toGuiIndex (self,i):
    '''Convert a Python index to a Tk index as needed.'''
    w = self
    if i is None:
        g.trace('can not happen: i is None',g.callers())
        return '1.0'
    elif type(i) == type(99):
        # This *must* be 'end-1c', even if other code must change.
        s = Tk.Text.get(w,'1.0','end-1c')
        row,col = g.convertPythonIndexToRowCol(s,i)
        i = '%s.%s' % (row+1,col)
        # g.trace(len(s),i,repr(s))
    else:
        try:
            i = Tk.Text.index(w,i)
        except Exception:
            # g.es_exception()
            g.trace('Tk.Text.index failed:',repr(i),g.callers())
            i = '1.0'
    return i
#@nonl
#@-node:ekr.20061117085824:w.toGuiIndex
#@+node:ekr.20061117085824.1:w.toPythonIndex
def toPythonIndex (self,i):
    '''Convert a Tk index to a Python index as needed.'''
    w =self
    if i is None:
        g.trace('can not happen: i is None')
        return 0
    elif type(i) in (type('a'),type(u'a')):
        s = Tk.Text.get(w,'1.0','end') # end-1c does not work.
        i = Tk.Text.index(w,i) # Convert to row/column form.
        row,col = i.split('.')
        row,col = int(row),int(col)
        row -= 1
        i = g.convertRowColToPythonIndex(s,row,col)
        #g.es_print(i)
    return i
#@-node:ekr.20061117085824.1:w.toPythonIndex
#@+node:ekr.20061117085824.2:w.rowColToGuiIndex
# This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):
    
    return '%s.%s' % (row+1,col)
#@nonl
#@-node:ekr.20061117085824.2:w.rowColToGuiIndex
#@-node:ekr.20061113151148.2:Index conversion (leoTextWidget)
#@+node:ekr.20061117160129:getName (Tk.Text)
def getName (self):
    
    w = self
    return hasattr(w,'_name') and w._name or repr(w)
#@nonl
#@-node:ekr.20061117160129:getName (Tk.Text)
#@+node:ekr.20070213171850:_setSelectionRange
if 0:
    def _setSelectionRange (self,i,j,insert=None):
    
        w = self.widget
    
        i,j = w.toGuiIndex(i),w.toGuiIndex(j)
        
        # g.trace('i,j,insert',repr(i),repr(j),repr(insert),g.callers())
        
        # g.trace('i,j,insert',i,j,repr(insert))
        if w.compare(w,i, ">", j): i,j = j,i
        w.tag_remove(w,"sel","1.0",i)
        w.tag_add(w,"sel",i,j)
        w.tag_remove(w,"sel",j,"end")
    
        if insert is not None:
            w.setInsertPoint(insert)
#@-node:ekr.20070213171850:_setSelectionRange
#@+node:ekr.20061113151148.3:Wrapper methods (leoTextWidget)
#@+node:ekr.20061113151148.4:delete
def delete(self,i,j=None):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.delete(w,i)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.delete(w,i,j)
#@-node:ekr.20061113151148.4:delete
#@+node:ekr.20061113151148.12:flashCharacter
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75): # tkTextWidget.

    w = self

    def addFlashCallback(w,count,index):
        # g.trace(count,index)
        i,j = w.toGuiIndex(index),w.toGuiIndex(index+1)
        Tk.Text.tag_add(w,'flash',i,j)
        Tk.Text.after(w,delay,removeFlashCallback,w,count-1,index)
    
    def removeFlashCallback(w,count,index):
        # g.trace(count,index)
        Tk.Text.tag_remove(w,'flash','1.0','end')
        if count > 0:
            Tk.Text.after(w,delay,addFlashCallback,w,count,index)

    try:
        Tk.Text.tag_configure(w,'flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass ; g.es_exception()
#@nonl
#@-node:ekr.20061113151148.12:flashCharacter
#@+node:ekr.20061113151148.5:get
def get(self,i,j=None):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        return Tk.Text.get(w,i)
    else:
        j = w.toGuiIndex(j)
        return Tk.Text.get(w,i,j)
#@-node:ekr.20061113151148.5:get
#@+node:ekr.20061113151148.13:getAllText
def getAllText (self): # tkTextWidget.
    
    """Return all the text of Tk.Text widget w converted to unicode."""

    w = self
    s = Tk.Text.get(w,"1.0","end-1c") # New in 4.4.1: use end-1c.

    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@-node:ekr.20061113151148.13:getAllText
#@+node:ekr.20061113151148.14:getInsertPoint
def getInsertPoint(self): # tkTextWidget.
    
    w = self
    i = Tk.Text.index(w,'insert')
    i = w.toPythonIndex(i)
    return i
#@-node:ekr.20061113151148.14:getInsertPoint
#@+node:ekr.20061113151148.15:getSelectedText
def getSelectedText (self): # tkTextWidget.

    w = self
    i,j = w.getSelectionRange()
    if i != j:
        i,j = w.toGuiIndex(i),w.toGuiIndex(j)
        s = Tk.Text.get(w,i,j)
        return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""
#@-node:ekr.20061113151148.15:getSelectedText
#@+node:ekr.20061113151148.16:getSelectionRange
def getSelectionRange (self,sort=True): # tkTextWidget.
    
    """Return a tuple representing the selected range.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    w = self
    sel = Tk.Text.tag_ranges(w,"sel")
    if len(sel) == 2:
        i,j = sel
    else:
        i = j = Tk.Text.index(w,"insert")
      
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)  
    if sort and i > j: i,j = j,i
    return i,j
#@nonl
#@-node:ekr.20061113151148.16:getSelectionRange
#@+node:ekr.20070211185433.1:getYScrollPosition
def getYScrollPosition (self):

     w = self
     return w.yview()
#@-node:ekr.20070211185433.1:getYScrollPosition
#@+node:ekr.20070212204016:getWidth
def getWidth (self):
    
    '''Return the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''
    
    w = self
    return w.cget('width')
#@-node:ekr.20070212204016:getWidth
#@+node:ekr.20061113151148.17:hasSelection
def hasSelection (self):
    
    w = self
    i,j = w.getSelectionRange()
    return i != j
#@-node:ekr.20061113151148.17:hasSelection
#@+node:ekr.20061113151148.6:insert
# The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toGuiIndex(i)
    Tk.Text.insert(w,i,s)

#@-node:ekr.20061113151148.6:insert
#@+node:ekr.20070213104858.1:indexIsVisible
def indexIsVisible (self,i):
    
    w = self
    
    return w.dlineinfo(i)
#@nonl
#@-node:ekr.20070213104858.1:indexIsVisible
#@+node:ekr.20061113151148.7:mark_set NO LONGER USED
# def mark_set(self,markName,i):

    # w = self
    # i = w.toGuiIndex(i)
    # Tk.Text.mark_set(w,markName,i)
#@-node:ekr.20061113151148.7:mark_set NO LONGER USED
#@+node:ekr.20061113151148.18:replace
def replace (self,i,j,s): # tkTextWidget
    
    w = self
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)

    Tk.Text.delete(w,i,j)
    Tk.Text.insert(w,i,s)
#@-node:ekr.20061113151148.18:replace
#@+node:ekr.20061113180616:see
def see (self,i): # tkTextWidget.

    w = self
    i = w.toGuiIndex(i)
    Tk.Text.see(w,i)
#@-node:ekr.20061113180616:see
#@+node:ekr.20061113175002:seeInsertPoint
def seeInsertPoint (self): # tkTextWidget.

    w = self
    Tk.Text.see(w,'insert')
#@-node:ekr.20061113175002:seeInsertPoint
#@+node:ekr.20061113151148.19:selectAllText
def selectAllText (self,insert=None): # tkTextWidget
    
    '''Select all text of the widget, *not* including the extra newline.'''
    
    w = self ; s = w.getAllText()
    if insert is None: insert = len(s)
    w.setSelectionRange(0,len(s),insert=insert)
#@-node:ekr.20061113151148.19:selectAllText
#@+node:ekr.20061113151148.20:setAllText
def setAllText (self,s): # tkTextWidget

    w = self
    
    state = Tk.Text.cget(w,"state")
    Tk.Text.configure(w,state="normal")
    
    Tk.Text.delete(w,'1.0','end')
    Tk.Text.insert(w,'1.0',s)
    
    Tk.Text.configure(w,state=state)
#@-node:ekr.20061113151148.20:setAllText
#@+node:ekr.20070218122857:setBackgroundColor
def setBackgroundColor (self,color):
    
    w = self
    w.configure(background=color)
#@nonl
#@-node:ekr.20070218122857:setBackgroundColor
#@+node:ekr.20061113151148.21:setInsertPoint
def setInsertPoint (self,i): # tkTextWidget.

    w = self
    i = w.toGuiIndex(i)
    # g.trace(i,g.callers())
    Tk.Text.mark_set(w,'insert',i)
#@-node:ekr.20061113151148.21:setInsertPoint
#@+node:ekr.20061113151148.22:setSelectionRange
def setSelectionRange (self,i,j,insert=None): # tkTextWidget
    
    w = self

    i,j = w.toGuiIndex(i),w.toGuiIndex(j)
    
    # g.trace('i,j,insert',repr(i),repr(j),repr(insert),g.callers())
    
    # g.trace('i,j,insert',i,j,repr(insert))
    if Tk.Text.compare(w,i, ">", j): i,j = j,i
    Tk.Text.tag_remove(w,"sel","1.0",i)
    Tk.Text.tag_add(w,"sel",i,j)
    Tk.Text.tag_remove(w,"sel",j,"end")

    if insert is not None:
        w.setInsertPoint(insert)
#@-node:ekr.20061113151148.22:setSelectionRange
#@+node:ekr.20070211185433:setYScrollPosition
def setYScrollPosition (self,i):

     w = self
     w.yview('moveto',i)
#@nonl
#@-node:ekr.20070211185433:setYScrollPosition
#@+node:ekr.20070212081121:setWidth
def setWidth (self,width):
    
    '''Set the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''
    
    w = self
    w.configure(width=width)
#@-node:ekr.20070212081121:setWidth
#@+node:ekr.20061113151148.8:tag_add
# The signature is slightly different than the Tk.Text.insert method.

def tag_add(self,tagName,i,j=None,*args):
    
    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.tag_add(w,tagName,i,*args)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.tag_add(w,tagName,i,j,*args)
        
#@-node:ekr.20061113151148.8:tag_add
#@+node:ekr.20061113151148.9:tag_ranges
def tag_ranges(self,tagName):
    
    w = self
    aList = Tk.Text.tag_ranges(w,tagName)
    aList = [w.toPythonIndex(z) for z in aList]
    return tuple(aList)
#@-node:ekr.20061113151148.9:tag_ranges
#@+node:ekr.20070116073907:tag_remove
def tag_remove (self,tagName,i,j=None,*args):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.tag_remove(w,tagName,i,*args)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.tag_remove(w,tagName,i,j,*args)

    
    
#@nonl
#@-node:ekr.20070116073907:tag_remove
#@+node:ekr.20061113151148.11:w.deleteTextSelection
def deleteTextSelection (self): # tkTextWidget
    
    w = self
    sel = Tk.Text.tag_ranges(w,"sel")
    if len(sel) == 2:
        start,end = sel
        if Tk.Text.compare(w,start,"!=",end):
            Tk.Text.delete(w,start,end)
#@-node:ekr.20061113151148.11:w.deleteTextSelection
#@+node:ekr.20061113151148.23:xyToGui/PythonIndex
def xyToGuiIndex (self,x,y): # tkTextWidget
    
    w = self
    return Tk.Text.index(w,"@%d,%d" % (x,y))
    
def xyToPythonIndex(self,x,y): # tkTextWidget
    
    w = self
    i = Tk.Text.index(w,"@%d,%d" % (x,y))
    i = w.toPythonIndex(i)
    return i
#@-node:ekr.20061113151148.23:xyToGui/PythonIndex
#@-node:ekr.20061113151148.3:Wrapper methods (leoTextWidget)
#@-node:ekr.20061113151148.1:class leoTkTextWidget (Tk.Text)
#@+node:ekr.20070212070512.1:Next
#@+node:ekr.20070201111111: Create unit tests 17
# Indices of the form %s.%s are benign because of w.rowColToGuiIndex.
#@+node:ekr.20060417183606.1:moveLinesUp
def moveLinesUp (self,event):
    
    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))
    
    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i > 0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            w.delete(prev_i,j)
            w.insert(prev_i,lines+prev_line)
            w.setSelectionRange(prev_i,prev_i+n,insert=prev_i+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadBack(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadBack()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            s = w.getAllText()
            if not s.endswith('\n'): w.insert('end','\n')
            w.insert('end',lines)
            s = w.getAllText()
            ins = len(s)-len(lines)+n
            w.setSelectionRange(len(s)-len(lines),ins,insert=ins)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606.1:moveLinesUp
#@+node:ekr.20060417183606:moveLinesDown
def moveLinesDown (self,event):
    
    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))
    
    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j < len(s):
            next_i,next_j = g.getLine(s,j+1)
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            w.insert(i,next_line+lines)
            w.setSelectionRange(i+n2,i+n2+n,insert=i+n2+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadNext(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadNext()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            s = w.getAllText()
            w.insert(0,lines)
            if not lines.endswith('\n'): w.insert(len(lines),'\n')
            s = w.getAllText()
            w.setSelectionRange(0,n,insert=n)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606:moveLinesDown
#@+node:ekr.20050920084036.100:fillRegion
def fillRegion (self,event):

    '''Fill all paragraphs in the selected text.'''
    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return
    
    self.beginCommand(undoType='fill-region')

    s = w.getAllText()
    s1,s2 = w.getSelectionRange()
    w.setInsertPoint(s1)
    self.backwardParagraph(event)
    i = w.getInsertPoint()
    i,junk = g.getLine(s,i)
    if i == 0:
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        if w.getInsertPoint() > s2:
            break
        self.fillParagraph(event)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.100:fillRegion
#@+node:ekr.20050920084036.104:fillRegionAsParagraph
def fillRegionAsParagraph (self,event):
    
    '''Fill the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return
    
    self.beginCommand(undoType='fill-region-as-paragraph')

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.104:fillRegionAsParagraph
#@+node:ekr.20051025071455.40:find & helpers
def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Copy the working selection range to the body pane
        start, end = self.workCtrl.getSelectionRange()
        w.setSelectionRange(start,end)
        w.see(start)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
#@+node:ekr.20051025071455.45:findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""
    
    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None
   
    try:
        while 1:
            p, word = self.findNextWord(p) 
            if not p or not word:
                alts = None
                break
            << Skip word if ignored or in local dictionary >>
            alts = aspell.processWord(word)
            if alts:
                w = c.frame.body.bodyCtrl
                i,j = w.getSelectionRange()
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                w.setSelectionRange(i,j,insert=j)
                break
    except:
        g.es_exception()
    return alts, word
#@+node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
#@-node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
#@-node:ekr.20051025071455.45:findNextMisspelledWord
#@+node:ekr.20051025071455.47:findNextWord
def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    c = self.c ; w = self.workCtrl ; s = w.getAllText() ; p = p.copy()
    while 1:
        i = w.getInsertPoint()
        while i < len(s) and not g.isWordChar1(s[i]):
            i += 1
        if i < len(s):
            # A non-empty word has been found.
            j = i
            while j < len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # g.trace(repr(word)) # This trace verifies that all words have been checked.
            for w2 in (w,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w2)
                w2.setSelectionRange(i,j,insert=j)
            return p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            w.delete(0,'end')
            w.insert(0,p.bodyString())
            for w2 in (w,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w2)
                w.setSelectionRange(0,0,insert=0)
    return None,None
#@nonl
#@-node:ekr.20051025071455.47:findNextWord
#@-node:ekr.20051025071455.40:find & helpers
#@+node:ekr.20060417194232.1:findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward ; self.extend = extend ;
        self.insert = w.getInsertPoint()
        s = '%s character %s' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        c.frame.clearStatusLine()
        c.frame.putStatusLine(s,color='blue')
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = s.rfind('\n',0,i)
            if start == -1: start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        else:
            end = s.find('\n',i)
            if end == -1: end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        c.frame.clearStatusLine()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacterHelper
#@+node:ekr.20050920084036.233:getRectanglePoints
def getRectanglePoints (self,w):

    c = self.c
    c.widgetWantsFocusNow(w)
    
    s = w.getAllText()
    i,j = w.getSelectionRange()
    r1,r2 = g.convertPythonIndexToRowCol(s,i)
    r3,r4 = g.convertPythonIndexToRowCol(s,j)

    return r1+1,r2,r3+1,r4
#@-node:ekr.20050920084036.233:getRectanglePoints
#@+node:ekr.20050920084036.81:lineNumber
def lineNumber (self,event):
    
    '''Print the line and column number and percentage of insert point.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)
    percent = int((i*100)/len(s))

    k.setLabelGrey(
        'char: %s row: %d col: %d pos: %d (%d%% of %d)' % (
            repr(s[i]),row,col,i,percent,len(s)))
#@-node:ekr.20050920084036.81:lineNumber
#@+node:ekr.20050920084036.147:measure
def measure (self,w):

    s = w.getAllText()
    ins = w.getInsertPoint()
    start, junk = g.convertPythonIndexToRowCol(s,ins)
    start += 1 ; delta = 0

    ustart = start - 1
    while ustart >= 1 and w.indexIsVisible('%s.0' % ustart):
        delta += 1 ; ustart -= 1

    ustart = start + 1
    while w.indexIsVisible('%s.0' % ustart):
        delta += 1 ; ustart += 1

    return delta
#@-node:ekr.20050920084036.147:measure
#@+node:ekr.20050920084036.133:setCommentColumn
def setCommentColumn (self,event):
    
    '''Set the comment column for the indent-to-comment-column command.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,ins)
    self.ccolumn = col
#@nonl
#@-node:ekr.20050920084036.133:setCommentColumn
#@+node:ekr.20050930112126:shellCommandOnRegion
def shellCommandOnRegion (self,event):
    
    '''Execute a command taken from the selected text in a separate process.'''
    
    k = self.k
    w = self.editWidget(event)
    if not w: return

    if subprocess:
        if w.hasSelection():
            command = w.getSelectedText()
            k.commandName = 'shell-command: %s' % command
            self.executeSubprocess(event,command,input=None)
        else:
            k.clearState()
            k.resetLabel()
    else:
        k.setLabelGrey('can not execute shell-command: can not import subprocess')
#@-node:ekr.20050930112126:shellCommandOnRegion
#@+node:ekr.20050920084036.120:sortFields
def sortFields (self,event,which=None):
    
    '''Divide the selected text into lines and sort by comparing the contents of
     one field in each line. Fields are defined as separated by whitespace, so
     the first run of consecutive non-whitespace characters in a line
     constitutes field 1, the second such run constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to sort by
     field 1, etc. A negative argument means sort in descending order. Thus,
     minus 2 means sort by field 2 in reverse-alphabetical order.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-fields')
    
    s = w.getAllText()
    ins = w.getInsertPoint()
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    i,junk = g.getLine(s,r1)
    junk,j = g.getLine(s,r4)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for line in txt:
        f = frx.findall(line)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) < i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    #w.delete('%s linestart' % is1,'%s lineend' % is2)
    w.delete(i,j)
    #i = is1.split('.')
    #int1 = int(i[0])
    int1 = i
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.setInsertPoint(ins)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.120:sortFields
#@+node:ekr.20050920084036.123:swapWords
def swapWords (self,event,swapspots):
    
    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()

    txt = w.get('insert wordstart','insert wordend') ###
    if not txt: return
    
    i = w.index('insert wordstart') ###
    
    self.beginCommand(undoType='swap-words')

    if len(swapspots):
        if i > swapspots[1]:
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif i < swapspots[1]:
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.123:swapWords
#@+node:ekr.20050920084036.84:whatLine
def whatLine (self,event):
    
    '''Print the line number of the line containing the cursor.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)

    k.keyboardQuit(event)
    k.setLabel("Line %s" % row)
#@-node:ekr.20050920084036.84:whatLine
#@+node:ekr.20031218072017.4038:get/setYScrollPosition (leoBody)
def getYScrollPosition (self):
    return self.bodyCtrl.getYScrollPosition()
    
def setYScrollPosition (self,scrollPosition):
    if len(scrollPosition) == 2:
        first,last = scrollPosition
    else:
        first = scrollPosition
    self.bodyCtrl.setYScrollPosition(first)
#@-node:ekr.20031218072017.4038:get/setYScrollPosition (leoBody)
#@+node:ekr.20061017083312:selectEditor (tkBody)
def selectEditor(self,w):
    
    c = self.c ; d = self.editorWidgets
    trace = False
    if trace: g.trace(g.app.gui.widget_name(w),id(w),g.callers())
    if w.leo_p is None:
        if trace: g.trace('no w.leo_p') 
        return 'break'
    # Inactivate the previously active editor.
    # Don't capture ivars here! selectMainEditor keeps them up-to-date.
    for key in d.keys():
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            break
    else:
        if trace: g.trace('no active editor!')
    
    # Careful, leo_p may not exist.
    if not c.positionExists(w.leo_p):
        if trace: g.trace('does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v == w.leo_v:
                w.leo_p = p2.copy()
                break
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            if trace: g.trace('previously deleted node')
            return 'break'

    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True
    c.frame.tree.expandAllAncestors(w.leo_p)
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocusNow()
    return 'break'
#@nonl
#@+node:ekr.20061017083312.1:<< restore the selection, insertion point and the scrollbar >>
# g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)
    
if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
#@-node:ekr.20061017083312.1:<< restore the selection, insertion point and the scrollbar >>
#@-node:ekr.20061017083312:selectEditor (tkBody)
#@+node:ekr.20061112172552:Unit tests for menu enablers
#@-node:ekr.20061112172552:Unit tests for menu enablers
#@-node:ekr.20070201111111: Create unit tests 17
#@+node:ekr.20070212065133:Remove Tk code from commands (later)
#@+node:ekr.20061031131434.4:class autoCompleterClass
class autoCompleterClass:
    
    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.
    
    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
#@+node:ekr.20061031131434.5: ctor (autocompleter)
def __init__ (self,k):
    
    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.object = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):
    
    self.allClassesDict = {}
    
    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('<class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z
        
    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@+node:ekr.20061031131434.7:defineObjectDict
def defineObjectDict (self):
    
    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p),             
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]
    
    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)
    
    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        if not obj:
            g.trace('bad object',obj)
            continue
        for z in idList:
            self.objectDict[z]=obj
            # g.trace(obj)
#@-node:ekr.20061031131434.7:defineObjectDict
#@-node:ekr.20061031131434.5: ctor (autocompleter)
#@+node:ekr.20061031131434.8:Top level
#@+node:ekr.20061031131434.9:autoComplete
def autoComplete (self,event=None,force=False):
    
    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k ; gui = g.app.gui
    w = gui.eventWidget(event) or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)
    
    # Don't allow autocompletion in headlines.
    if not c.widget_name(w).startswith('head'):
        self.language = g.scanForAtLanguage(c,c.currentPosition())
        if w and self.language == 'python' and (k.enable_autocompleter or force):
            self.start(event=event,w=w)

    return 'break'
#@-node:ekr.20061031131434.9:autoComplete
#@+node:ekr.20061031131434.10:autoCompleteForce
def autoCompleteForce (self,event=None):
    
    '''Show autocompletion, even if autocompletion is not presently enabled.'''
    
    return self.autoComplete(event,force=True)
#@-node:ekr.20061031131434.10:autoCompleteForce
#@+node:ekr.20061031131434.11:autoCompleterStateHandler
def autoCompleterStateHandler (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.object) == types.DictType:
            self.membersList = self.object.keys()
        elif type(self.object) in (types.ListType,types.TupleType):
            self.membersList = self.object
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
#@-node:ekr.20061031131434.11:autoCompleterStateHandler
#@+node:ekr.20061031131434.12:enable/disable/toggleAutocompleter/Calltips
def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()
    
def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()
    
def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()
    
def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()
    
def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()
    
def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
#@-node:ekr.20061031131434.12:enable/disable/toggleAutocompleter/Calltips
#@+node:ekr.20061031131434.13:showCalltips
def showCalltips (self,event=None,force=False):
    
    '''Show the calltips at the cursor.'''
    
    c = self.c ; k = c.k ; w = g.app.gui.eventWidget(event)
    if not w: return
    
    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        self.leadinWord = self.findCalltipWord(w)
        # g.trace(self.leadinWord)
        self.object = None
        self.membersList = None
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)
        
    return 'break'
#@-node:ekr.20061031131434.13:showCalltips
#@+node:ekr.20061031131434.14:showCalltipsForce
def showCalltipsForce (self,event=None):
    
    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''
    
    return self.showCalltips(event,force=True)
#@-node:ekr.20061031131434.14:showCalltipsForce
#@+node:ekr.20061031131434.15:showAutocompleter/CalltipsStatus
def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''
    
    k = self.k
    g.es('Autocompleter %s' % (g.choose(k.enable_autocompleter,'On','Off')),color='red')
    
def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    g.es('Calltips %s' % (g.choose(k.enable_calltips,'On','Off')),color='red')
#@nonl
#@-node:ekr.20061031131434.15:showAutocompleter/CalltipsStatus
#@-node:ekr.20061031131434.8:Top level
#@+node:ekr.20061031131434.16:Helpers
#@+node:ekr.20061031131434.17:.abort & exit (autocompleter) (test)
def abort (self):
    
    k = self.k
    k.keyboardQuit(event=None)
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.
    
    k = self ; c = self.c 
    w = self.widget or c.frame.body.bodyCtrl
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    if restore:
        if i != j: w.delete(i,j)
        w.insert(i,self.selectedText)
    w.setSelectionRange(j,j,insert=j)
    
    self.clear()
    self.object = None
#@-node:ekr.20061031131434.17:.abort & exit (autocompleter) (test)
#@+node:ekr.20061031131434.18:append/begin/popTabName
def appendTabName (self,word):
    
    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    if word == 'self' and self.selfClassName:
        word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')
    
def clearTabName (self):
    
    self.setTabName('AutoComplete ')
    
def popTabName (self):
    
    s = self.tabName
    i = s.rfind('.',0,-1)
    if i > -1:
        self.setTabName(s[0:i])
    
# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_','') or ''
    c.frame.log.clearTab(self.tabName)
#@-node:ekr.20061031131434.18:append/begin/popTabName
#@+node:ekr.20061031131434.19:appendToKnownObjects
def appendToKnownObjects (self,obj):
    
    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)
#@-node:ekr.20061031131434.19:appendToKnownObjects
#@+node:ekr.20061031131434.20:calltip
def calltip (self,obj=None):
    
    c = self.c
    w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        << try to set s from a Python global function >>

    if not s:
        << get s using inspect >>
        
    << remove 'self' from s, but not from args >>
    if isStringMethod:
        << remove 's' from s *and* args >>

    s = s.rstrip(')') # Convenient.
    << insert the text and set j1 and j2 >>

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    if 1: # Seems to be more useful.
        w.setSelectionRange(j1,j2,insert=j2)
    else:
        w.setInsertPoint(j2)
    << put the status line >>
#@+node:ekr.20061031131434.21:<< try to set s from a Python global function >>
# The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i > -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
#@-node:ekr.20061031131434.21:<< try to set s from a Python global function >>
#@+node:ekr.20061031131434.22:<< get s using inspect >>
isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    # g.es('inspect failed:',repr(obj))
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
#@-node:ekr.20061031131434.22:<< get s using inspect >>
#@+node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
#@-node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
#@+node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
#@-node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
#@+node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
junk,j = w.getSelectionRange() # Returns insert point if no selection.
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')
j1 = j + 1 ; j2 = j + len(s)
#@-node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
#@+node:ekr.20061031131434.26:<< put the status line >>
c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
#@-node:ekr.20061031131434.26:<< put the status line >>
#@-node:ekr.20061031131434.20:calltip
#@+node:ekr.20061031131434.27:chain
def chain (self):
    
    c = self.c ; w = self.widget
    word = w.getSelectedText()
    old_obj = self.object

    if word and old_obj and type(old_obj) == type([]) and old_obj == sys.modules:
        obj = old_obj.get(word)
        if obj:
            self.object = obj
            self.clearTabName()
    elif word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.object = obj = self.getAttr(old_obj,word)
    else: obj = None

    if obj:
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = w.getInsertPoint()
        w.setSelectionRange(i,i,insert=i)
        # g.trace('chaining to',word,self.object)
        # Similar to start logic.
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        if self.membersList:
            # self.autoCompleterStateHandler(event=None)
            self.computeCompletionList()
            return
    self.extendSelection('.')
    self.finish()
                    
#@nonl
#@-node:ekr.20061031131434.27:chain
#@+node:ekr.20061031131434.28:computeCompletionList
def computeCompletionList (self,verbose=False):
    
    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) < 25:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in d.keys()] ; aList.sort()
            self.tabList = aList

    c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
    if self.tabList:
        self.tabListIndex = -1 # The next item will be item 0.
        self.setSelection(common_prefix)
    for name in self.tabList:
        g.es('%s' % (name),tabName=self.tabName)
              
#@nonl
#@-node:ekr.20061031131434.28:computeCompletionList
#@+node:ekr.20061031131434.29:doBackSpace (autocompleter)
def doBackSpace (self):

    '''Cut back to previous prefix.'''
    
    # g.trace(self.prefix,self.object,self.prevObjects)
    
    c = self.c
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.object:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.object
        # g.trace(self.object,obj)
        w = self.widget
        s = w.getAllText()
        i,junk = w.getSelectionRange()
        ch = 0 <= i-1 < len(s) and s[i-1] or ''
        # g.trace(ch)
        if ch == '.':
            self.object = obj
            w.delete(i-1)
            c.frame.body.onBodyChanged(undoType='Typing')
            i,j = g.getWord(s,i-2)
            word = s[i:j]
            # g.trace(i,j,repr(word))
            w.setSelectionRange(i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()            
#@nonl
#@-node:ekr.20061031131434.29:doBackSpace (autocompleter)
#@+node:ekr.20061031131434.30:doTabCompletion
def doTabCompletion (self):
    
    '''Handle tab completion when the user hits a tab.'''
    
    c = self.c ; w = self.widget
    s = w.getSelectedText()

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex >= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)
#@-node:ekr.20061031131434.30:doTabCompletion
#@+node:ekr.20061031131434.31:extendSelection
def extendSelection (self,s):
    
    '''Append s to the presently selected text.'''
    
    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)
    
    i,j = w.getSelectionRange()
    w.insert(j,s)
    j += 1
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')
#@nonl
#@-node:ekr.20061031131434.31:extendSelection
#@+node:ekr.20061031131434.32:findAnchor
def findAnchor (self,w):
    
    '''Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    while i > 0 and s[i-1] == '.':
        i,j = g.getWord(s,i-2)

    word = s[i:j]
    if word == '.': word = None
    
    # g.trace(i,j,repr(word))
    return j,word
#@nonl
#@-node:ekr.20061031131434.32:findAnchor
#@+node:ekr.20061031131434.33:findCalltipWord
def findCalltipWord (self,w):
    
    i = w.getInsertPoint()
    s = w.getAllText()
    if i > 0:
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        return word
    else:
        return ''
#@nonl
#@-node:ekr.20061031131434.33:findCalltipWord
#@+node:ekr.20061031131434.34:finish
def finish (self):
    
    c = self.c ; k = self.k
    
    k.keyboardQuit(event=None)
    
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
        
    c.frame.body.onBodyChanged('Typing')
    c.recolor()
    self.clear()
    self.object = None
    
#@nonl
#@-node:ekr.20061031131434.34:finish
#@+node:ekr.20061031131434.35:getAttr and hasAttr
# The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):
    
    '''Simulate getattr function, regardless of langauge.'''
    
    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):
    
    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList
#@-node:ekr.20061031131434.35:getAttr and hasAttr
#@+node:ekr.20061031131434.36:getLeadinWord
def getLeadinWord (self,w):

    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = w.getInsertPoint()
    s = w.getAllText()
    start -= 1
    i,word = self.findAnchor(w)
    
    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    # g.trace(word,self.object,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.object:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while 0 <= i < start and i <len(s):
            if s[i] != '.':
                return False
            i,j = g.getWord(s,i+1)
            word = s[i:j]
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.object:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
#@-node:ekr.20061031131434.36:getLeadinWord
#@+node:ekr.20061031131434.37:getMembersList
def getMembersList (self,obj):
    
    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []
#@-node:ekr.20061031131434.37:getMembersList
#@+node:ekr.20061031131434.38:info
def info (self):
    
    c = self.c ; doc = None ; obj = self.object ; w = self.widget

    word = w.getSelectedText()
    
    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word): return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es(doc,tabName='Info')
#@-node:ekr.20061031131434.38:info
#@+node:ekr.20061031131434.39:insertNormalChar
def insertNormalChar (self,ch,keysym):
    
    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = w.getSelectedText() + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = w.getSelectedText()
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = w.getSelectedText()
        if ch == '(':
            # Similar to chain logic.
            obj = self.object
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.object)
                self.object = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
#@-node:ekr.20061031131434.39:insertNormalChar
#@+node:ekr.20061031131434.40:push, pop, clear, stackNames
def push (self,obj):
    
    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())
        
def pop (self):
    
    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj
    
def clear (self):
    
    self.prevObjects = []
    # g.trace(g.callers())
    
def stackNames (self):
    
    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList
#@-node:ekr.20061031131434.40:push, pop, clear, stackNames
#@+node:ekr.20061031131434.41:setObjectAndMembersList & helpers
def setObjectAndMembersList (self,word):
    
    c = self.c
    
    if not word:
        # Leading dot shows all classes.
        self.leadinWord = None
        self.object = sys.modules
        self.membersList = sys.modules.keys()
        self.beginTabName('Modules')
    elif word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.object)
        self.object = 'aString'
        self.membersList = self.getMembersList(self.object)
    elif self.object:
        self.getObjectFromAttribute(word)
    # elif word == 'self':
        # self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.object,len(self.membersList))
#@+node:ekr.20061031131434.42:getObjectFromAttribute
def getObjectFromAttribute (self,word):
    
    obj = self.object

    if obj and self.hasAttr(obj,word):
        self.push(self.object)
        self.object = self.getAttr(obj,word)
        self.appendToKnownObjects(self.object)
        self.membersList = self.getMembersList(self.object)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.object = None
#@-node:ekr.20061031131434.42:getObjectFromAttribute
#@+node:ekr.20061031131434.43:completeSelf
def completeSelf (self):
    
    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfTnodesDict [p.v.t] = obj
    if obj:
        self.selfClassName = className
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.object = None
        self.clear()
        self.membersList = []
#@-node:ekr.20061031131434.43:completeSelf
#@+node:ekr.20061031131434.44:completeFromObject
def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.object = None
        self.clear()
        self.membersList = []
#@-node:ekr.20061031131434.44:completeFromObject
#@-node:ekr.20061031131434.41:setObjectAndMembersList & helpers
#@+node:ekr.20061031131434.45:setSelection
def setSelection (self,s):
    
    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
    else:
        i = w.getInsertPoint()
        
    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n > -1: s = s[:n]
    
    w.insert(i,s)
    j = i + len(s)
    w.setSelectionRange(i,j,insert=j)

    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor_now(c.currentPosition(),incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
                
#@nonl
#@-node:ekr.20061031131434.45:setSelection
#@+node:ekr.20061031131434.46:start
def start (self,event=None,w=None):
    
    c = self.c
    if w: self.widget = w
    else: w = self.widget
    
    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = ''
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i > 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        self.autoCompleterStateHandler(event)
    else:
        self.abort()
#@-node:ekr.20061031131434.46:start
#@-node:ekr.20061031131434.16:Helpers
#@+node:ekr.20061031131434.47:Scanning
# Not used at present, but soon.
#@+node:ekr.20061031131434.48:initialScan
# Don't call this finishCreate: the startup logic would call it too soon.

def initialScan (self):
    
    g.trace(g.callers())
    
    self.scan(thread=True)
#@-node:ekr.20061031131434.48:initialScan
#@+node:ekr.20061031131434.49:scan
def scan (self,event=None,verbose=True,thread=True):
    
    __pychecker__ = '--no-argsused' # thread arg not used at present.
    
    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return
    
    # g.trace('autocompleter')
    
    if 0: # thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)
    
        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)
#@-node:ekr.20061031131434.49:scan
#@+node:ekr.20061031131434.50:definePatterns
def definePatterns (self):
    
    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))
    
    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars 
#@nonl
#@-node:ekr.20061031131434.50:definePatterns
#@+node:ekr.20061031131434.51:scanOutline
def scanOutline (self,verbose=True):

    '''Traverse an outline and build the autocommander database.'''
    
    if verbose: g.es_print('Scanning for auto-completer...')

    c = self.c ; k = self.k ; count = 0
    for p in c.allNodes_iter():
        if verbose:
            count += 1 ;
            if (count % 200) == 0: g.es('.',newline=False)
        language = g.scanForAtLanguage(c,p)
        # g.trace('language',language,p.headString())
        s = p.bodyString()
        if k.enable_autocompleter:
            self.scanForAutoCompleter(s)
        if k.enable_calltips:
            self.scanForCallTip(s,language)

    if 0:
        g.trace('watchwords...\n\n')
        keys = self.watchwords.keys() ; keys.sort()
        for key in keys:
            aList = self.watchwords.get(key)
            g.trace('%s:\n\n' % (key), g.listToString(aList))
    if 0:
        g.trace('calltips...\n\n')
        keys = self.calltips.keys() ; keys.sort()
        for key in keys:
            d = self.calltips.get(key)
            if d:
                g.trace('%s:\n\n' % (key), g.dictToString(d))
        
    if verbose:        
        g.es_print('\nauto-completer scan complete',color='blue')
#@-node:ekr.20061031131434.51:scanOutline
#@+node:ekr.20061031131434.52:scanForCallTip
def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')
    
    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, b = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if str(z) not in aList:
            aList.append(str(z))
            d [a] = aList
    
    self.calltips [language] = d
#@-node:ekr.20061031131434.52:scanForCallTip
#@+node:ekr.20061031131434.53:scanForAutoCompleter
def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = [] ; t1 = s.split('.')
    
    if 1: # Slightly faster.
        t1 = s.split('.') ; 
        i = 0 ; n = len(t1)-1
        while i < n:
            self.makeAutocompletionList(t1[i],t1[i+1],aList)
            i += 1
    else:
        reduce(lambda a,b: self.makeAutocompletionList(a,b,aList),t1)

    if aList:
        for a, b in aList:
            z = self.watchwords.get(a,[])
            if str(b) not in z:
                z.append(str(b))
                self.watchwords [a] = z
#@+node:ekr.20061031131434.54:makeAutocompletionList
def makeAutocompletionList (self,a,b,glist):
    
    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''
    
    if 1: # Do everything inline.  It's a few percent faster.

        # Compute reverseFindWhitespace inline.
        i = len(a) -1
        while i >= 0:
            if a[i].isspace() or a [i] == '.':
                a1 = a [i+1:] ; break
            i -= 1
        else:
            a1 = a
            
        # Compute getCleanString inline.
        i = 0
        for ch in b:
            if ch not in self.okchars:
                b1 = b[:i] ; break
            i += 1
        else:
            b1 = b

        if b1:
            glist.append((a1,b1),)
            
        return b # Not needed unless we are using reduce.
    else:
        a1 = self.reverseFindWhitespace(a)
        if a1:
            b1 = self.getCleanString(b)
            if b1:
                glist.append((a1,b1))
        return b
#@+node:ekr.20061031131434.55:reverseFindWhitespace
def reverseFindWhitespace (self,s):

    '''Return the longest tail of s containing no whitespace or period.'''

    i = len(s) -1
    while i >= 0:
        if s[i].isspace() or s [i] == '.': return s [i+1:]
        i -= 1

    return s
#@-node:ekr.20061031131434.55:reverseFindWhitespace
#@+node:ekr.20061031131434.56:getCleanString
def getCleanString (self,s):
    
    '''Return the prefix of s containing only chars in okchars.'''
    
    i = 0
    for ch in s:
        if ch not in self.okchars:
            return s[:i]
        i += 1

    return s
#@-node:ekr.20061031131434.56:getCleanString
#@-node:ekr.20061031131434.54:makeAutocompletionList
#@-node:ekr.20061031131434.53:scanForAutoCompleter
#@-node:ekr.20061031131434.47:Scanning
#@+node:ekr.20061031131434.57:Proxy classes and objects
#@+node:ekr.20061031131434.58:createProxyObjectFromClass
def createProxyObjectFromClass (self,className,theClass):
    
    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in xrange(n)]
        
    def dummyCtor (self):
        pass
        
    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')
        
    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj
#@-node:ekr.20061031131434.58:createProxyObjectFromClass
#@+node:ekr.20061031131434.59:createClassObjectFromString
def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec s

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in computeProxyObject')
            g.es_exception()
        return None
#@-node:ekr.20061031131434.59:createClassObjectFromString
#@-node:ekr.20061031131434.57:Proxy classes and objects
#@+node:ekr.20061031131434.60:class forgivingParserClass
class forgivingParserClass:
    
    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''
    
    @others
#@+node:ekr.20061031131434.61:ctor (forgivingParserClass)
def __init__ (self,c):
    
    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.
#@-node:ekr.20061031131434.61:ctor (forgivingParserClass)
#@+node:ekr.20061031131434.62:parse
def parse (self,p):
    
    '''The top-level parser method.
    
    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''
    
    c = self.c
    
    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody
    
    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody
    
    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody
        return s
#@-node:ekr.20061031131434.62:parse
#@+node:ekr.20061031131434.63:forgivingParser
def forgivingParser (self,p):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            val = compiler.parse(s+'\n')
            break
        except (parser.ParserError,SyntaxError):
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                g.es_print('Syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('Syntax error: deleting %s' % p.headString())
                self.excludedTnodesList.append(p.v.t)
                s = g.getScript(c,root,useSelectedText=False)
    return s or ''
#@-node:ekr.20061031131434.63:forgivingParser
#@+node:ekr.20061031131434.64:computeErrorNode
def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n >= len(lines):
        return root

    vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        lines, n, root, scriptFind = True)

    if vnodeName:
        for p in root.self_and_subtree_iter():
            if p.matchHeadline(vnodeName):
                return p

    return None
#@-node:ekr.20061031131434.64:computeErrorNode
#@+node:ekr.20061031131434.65:newPutBody
def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v.t in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.headString())
    else:
        self.old_putBody(p,oneNodeOnly,fromString)
#@-node:ekr.20061031131434.65:newPutBody
#@-node:ekr.20061031131434.60:class forgivingParserClass
#@+node:ekr.20061031131434.66:class classScannerClass
class classScannerClass:
    
    '''A class to find class definitions in a node or its parents.'''
    
    @others
#@+node:ekr.20061031131434.67:ctor
def __init__ (self,c):
    
    self.c = c
    
    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False
#@-node:ekr.20061031131434.67:ctor
#@+node:ekr.20061031131434.68:scan
def scan (self):
    
    c = self.c

    className,obj,p = self.findParentClass(c.currentPosition())
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None
        
    return className,obj,p,s
#@-node:ekr.20061031131434.68:scan
#@+node:ekr.20061031131434.69:findParentClass
def findParentClass (self,root):
    
    autoCompleter = self.c.k.autoCompleter
    
    # First, see if any parent has already been scanned.
    for p in root.self_and_parents_iter():
        obj = autoCompleter.selfTnodesDict.get(p.v.t)
        if obj:
            # g.trace('found',obj,'in',p.headString())
            return None,obj,p
    
    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents_iter():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.headString())
            return className,None,p
    
    return None,None,None
#@-node:ekr.20061031131434.69:findParentClass
#@+node:ekr.20061031131434.70:findClass & helpers
def findClass (self,p):

    lines = g.splitLines(p.bodyString())
    inDoc = self.start_in_doc
    # g.trace(p.headString())
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None
#@+node:ekr.20061031131434.71:endsDoc
def endsDoc (self,s):
    
    return s.startswith('@c')
#@-node:ekr.20061031131434.71:endsDoc
#@+node:ekr.20061031131434.72:startsClass
def startsClass (self,s):
    
    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None
#@-node:ekr.20061031131434.72:startsClass
#@+node:ekr.20061031131434.73:startsDoc
def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False
#@-node:ekr.20061031131434.73:startsDoc
#@-node:ekr.20061031131434.70:findClass & helpers
#@-node:ekr.20061031131434.66:class classScannerClass
#@-node:ekr.20061031131434.4:class autoCompleterClass
#@+node:ekr.20050920084036.59:dynamicExpansion LATER
def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if not rlist: return
        txt = rlist.pop()
        doDa(txt)
#@-node:ekr.20050920084036.59:dynamicExpansion LATER
#@+node:ekr.20050920084036.60:dynamicExpansion2 LATER
def dynamicExpansion2 (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    dEstring = reduce(g.longestCommonPrefix,rlist)
    if dEstring:
        w.delete(i,i2)
        w.insert(i,dEstring)
#@-node:ekr.20050920084036.60:dynamicExpansion2 LATER
#@+node:ekr.20050920084036.160:executeSubprocess
def executeSubprocess (self,event,command,input):
    
    '''Execute a command in a separate process.'''
    
    k = self.k
    w = self.editWidget(event)
    if not w: return

    k.setLabelBlue('started  shell-command: %s' % command)
    try:
        ofile = os.tmpfile()
        efile = os.tmpfile()
        process = subprocess.Popen(command,bufsize=-1,
            stdout = ofile.fileno(), stderr = ofile.fileno(),
            stdin = subprocess.PIPE, shell = True)
        if input: process.communicate(input)
        process.wait()
        efile.seek(0)
        errinfo = efile.read()
        if errinfo: w.insert('insert',errinfo)
        ofile.seek(0)
        okout = ofile.read()
        if okout: w.insert('insert',okout)
    except Exception, x:
        w.insert('insert',x)
        
    k.setLabelGrey('finished shell-command: %s' % command)
#@-node:ekr.20050920084036.160:executeSubprocess
#@+node:ekr.20050920084036.242:insertRegister
def insertRegister (self,event):
    
    '''Prompt for a register name and and insert the value of another register into its contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('insert-reg')
    
    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ',protect=True)
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.rectangleCommands.yankRectangle(val)
                else:
                    w.insert('insert',val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.242:insertRegister
#@+node:ekr.20050920084036.37:insertToBuffer
def insertToBuffer (self,event):
    
    '''Add the selected body text at the insert point of the body text of a named buffer (node).'''
    
    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Insert to buffer: ')
    self.getBufferName(self.insertToBufferFinisher)

def insertToBufferFinisher (self,event,name):
    
    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.beginUpdate()
        try:
            c.selectPosition(p)
            self.beginCommand('insert-to-buffer: %s' % p.headString())
            i = w.getInsertPoint()
            w.insert(i,s)
            w.seeInsertPoint()
            self.endCommand()
        finally:
            c.endUpdate()
#@-node:ekr.20050920084036.37:insertToBuffer
#@+node:ekr.20031218072017.1329:onBodyChanged (tkBody)
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c
    bodyCtrl = w = body.bodyCtrl
    p = c.currentPosition()
    insert = bodyCtrl.getInsertPoint()
    ch = g.choose(insert==0,'',bodyCtrl.get('insert-1c'))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = w.getAllText() # Note: getAllText converts to unicode.
    # g.trace('newText',repr(newText))
    newSel = w.getSelectionRange()
    if oldText is None: 
        oldText = p.bodyString() ; changed = True
    else:
        changed = oldText != newText
    # g.trace(repr(ch),'changed:',changed,'newText:',repr(newText))
    if not changed: return
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertPoint()
    << recolor the body >>
    if not c.changed: c.setChanged(True)
    self.updateEditors()
    << redraw the screen if necessary >>
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1329:onBodyChanged (tkBody)
#@+node:ekr.20050920084036.39:prependToBuffer
def prependToBuffer (self,event):
    
    '''Add the selected body text to the start of the body text of a named buffer (node).'''
    
    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Prepend to buffer: ')
    self.getBufferName(self.prependToBufferFinisher)
    
def prependToBufferFinisher (self,event,name):
    
    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.beginUpdate()
        try:
            c.selectPosition(p)
            self.beginCommand('prepend-to-buffer: %s' % p.headString())
            w.insert(0,s)
            w.setInsertPoint(0)
            w.seeInsertPoint()
            self.endCommand()
        finally:
            c.endUpdate()
            c.recolor_now()

#@-node:ekr.20050920084036.39:prependToBuffer
#@+node:ekr.20050920084036.212:doOneReplace
def doOneReplace (self,event):

    w = self.editWidget(event)
    if not w: return
    
    i = w.tag_ranges('qR')
    w.delete(i[0],i[1])
    w.insert('insert',self.qR)
    self.replaced += 1
#@-node:ekr.20050920084036.212:doOneReplace
#@+node:ekr.20050920084036.219:findNextMatch (query-replace)
def findNextMatch (self,event):
    
    '''Find the next match and select it.
    Return True if a match was found.
    Otherwise, call quitSearch and return False.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    w.tag_delete('qR')
    if self.regexp:
        << handle regexp >>
    else:
        << handle plain search >>
#@+node:ekr.20051005155611:<< handle regexp >>
try:
    regex = re.compile(self.qQ)
except:
    self.quitSearch(event,'Illegal regular expression')
    return False

txt = w.get('insert','end')
match = regex.search(txt)

if match:
    start = match.start()
    end = match.end()
    length = end - start
    i = w.getInsertPoint()
    w.setInsertPoint(i+start)
    w.tag_add('qR','insert','insert +%sc' % length)
    w.tag_config('qR',background='lightblue')
    txt = w.get('insert','insert +%sc' % length)
    return True
else:
    self.quitSearch(event)
    return False
#@-node:ekr.20051005155611:<< handle regexp >>
#@+node:ekr.20051005160923:<< handle plain search >> (tag_add & tag_config) LATER
i = w.search(self.qQ,'insert',stopindex='end')

if i:
    w.setInsertPoint(i)
    w.tag_add('qR','insert','insert +%sc' % len(self.qQ))
    w.tag_config('qR',background='lightblue')
    return True
else:
    self.quitSearch(event)
    return False
#@-node:ekr.20051005160923:<< handle plain search >> (tag_add & tag_config) LATER
#@-node:ekr.20050920084036.219:findNextMatch (query-replace)
#@+node:ekr.20050920084036.21:regionalExpandAbbrev (TK code)
def regionalExpandAbbrev (self,event):
    
    '''Exapand abbreviations throughout a region.'''

    k = self.k ; w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    i1,i2 = w.getSelectionRange()
    ins = w.getInsertPoint()
    << define a new generator searchXR >>

    # EKR: the 'result' of calling searchXR is a generator object.
    k.regx.iter = searchXR(i1,i2,ins,event)
    k.regx.iter.next() # Call it the first time.
#@nonl
#@+node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
@ This is a generator (it contains a yield).
To make this work we must define a new generator for each call to regionalExpandAbbrev.
@c
def searchXR (i1,i2,ins,event):
    k = self.k
    w = self.editWidget(event)
    if not w: return

    w.tag_add('sXR',i1,i2)
    while i1:
        tr = w.tag_ranges('sXR')
        if not tr: break
        i1 = w.search(r'\w',i1,stopindex=tr[1],regexp=True)
        if i1:
            word = w.get('%s wordstart' % i1,'%s wordend' % i1)
            w.tag_delete('found')
            w.tag_add('found','%s wordstart' % i1,'%s wordend' % i1)
            w.tag_config('found',background='yellow')
            if self.abbrevs.has_key(word):
                k.setLabel('Replace %s with %s? y/n' % (word,self.abbrevs[word]))
                yield None
                if k.regXKey == 'y':
                    ind = w.index('%s wordstart' % i1)
                    w.delete('%s wordstart' % i1,'%s wordend' % i1)
                    w.insert(ind,self.abbrevs[word])
            i1 = '%s wordend' % i1
    w.setInsertPoint(ins,ins,insert=ins)
    w.tag_delete('sXR')
    w.tag_delete('found')
    k.setLabelGrey('')
    self.k.regx = g.bunch(iter=None,key=None)
#@-node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
#@-node:ekr.20050920084036.21:regionalExpandAbbrev (TK code)
#@+node:ekr.20050920084036.265:scolorizer LATER
def scolorizer (self,event,pattern=None):
    
    '''Colorizer for incremental searches.'''

    k = self.k ; w = self.w
    s = pattern or k.getLabel(ignorePrompt=True)
    # g.trace(repr(s))
    w.tag_delete('color','color1')
    if not s: return
    ind = 0
    index = w.getInsertPoint()
    index2 = index + len(s)
    # g.trace(index,index2)
    # Colorize in the forward direction, regardless of the kind of search.
    while ind:
        try:
            ind = w.search(s,ind,stopindex='end',regexp=self.regexp)
        except: break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(s))
            # g.trace(ind)
            if ind in (index,index2):
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
#@-node:ekr.20050920084036.265:scolorizer LATER
#@+node:ekr.20050920084036.117:sort...
'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
#@+node:ekr.20050920084036.118:sortLines
def sortLines (self,event,which=None):
    
    '''Sort lines of the selected text by comparing the entire text of a line.
    A prefix argument means sort in descending order.'''

    c = self.c ; k = c.k
    w = self.editWidget(event)
    if not self._chckSel(event): return

    self.beginCommand(undoType='sort-lines')
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        aList = g.splitLines(s[i:j])
        aList.sort()
        if which: aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.118:sortLines
#@+node:ekr.20050920084036.119:sortColumns
def sortColumns (self,event):
    
    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    k = self.k
    w = self.editWidget(event)
    if not self._chckSel(event): return
    self.beginCommand(undoType='sort-columns')
    try:
        s = w.getAllText()
        ins = w.getInsertPoint()
        sel_1,sel_2 = w.getSelectionRange()
        sint1,sint2 = g.convertPythonIndexToRowCol(s,sel_1)
        sint3,sint4 = g.convertPythonIndexToRowCol(s,sel_2)
        sint1 += 1 ; sint3 += 1
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        txt = s[i:j]
        columns = [w.get('%s.%s' % (z,sint2),'%s.%s' % (z,sint4))
            for z in xrange(sint1,sint3+1)]
        aList = g.splitLines(txt)
        zlist = zip(columns,aList)
        zlist.sort()
        s = g.joinLines([z[1] for z in zlist])
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_1+len(s),insert=sel_1+len(s))
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.119:sortColumns
#@+node:ekr.20050920084036.120:sortFields
def sortFields (self,event,which=None):
    
    '''Divide the selected text into lines and sort by comparing the contents of
     one field in each line. Fields are defined as separated by whitespace, so
     the first run of consecutive non-whitespace characters in a line
     constitutes field 1, the second such run constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to sort by
     field 1, etc. A negative argument means sort in descending order. Thus,
     minus 2 means sort by field 2 in reverse-alphabetical order.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-fields')
    
    s = w.getAllText()
    ins = w.getInsertPoint()
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    i,junk = g.getLine(s,r1)
    junk,j = g.getLine(s,r4)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for line in txt:
        f = frx.findall(line)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) < i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    #w.delete('%s linestart' % is1,'%s lineend' % is2)
    w.delete(i,j)
    #i = is1.split('.')
    #int1 = int(i[0])
    int1 = i
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.setInsertPoint(ins)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.120:sortFields
#@-node:ekr.20050920084036.117:sort...
#@+node:ekr.20050930091642.2:yankPop
def yankPop (self,event):
    
    '''Replaces the just-yanked kill buffer with the contents of the previous kill buffer.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()
    ins = w.getInsertPoint()
    t,t1 = g.convertPythonIndexToRowCol(s,ins)
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        s = clip_text or self.kbiterator.next()
        r = w.tag_ranges('kb') ###
        if r:
            r1,r2 = r
            r1,r2 = w.toPythonIndex(r1),w.toPythonIndex(r2)
            if r1 == ins:
                w.delete(r1,r2)
        w.tag_delete('kb') ###
        w.insert('insert',s,('kb')) ###
        w.setInsertPoint(ins)
#@-node:ekr.20050930091642.2:yankPop
#@-node:ekr.20070212065133:Remove Tk code from commands (later)
#@-node:ekr.20070212070512.1:Next
#@+node:ekr.20070212080350:Maybe never
#@+node:ekr.20070212080131:Font stuff in colorizer (maybe never)
@
At present the only colorizer is only used in by the Tk gui.
There will be no need to deal with this unless a new gui plugin uses the old colorizer.
#@nonl
#@+node:ekr.20041217041016:setFontFromConfig (colorizer)
def setFontFromConfig (self):
    
    c = self.c
    
    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)
    
    if self.bold_font:
        self.bold_font.configure(weight="bold")
    
    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)
        
    if self.italic_font:
        self.italic_font.configure(slant="italic",weight="normal")
    
    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)
        
    if self.bolditalic_font:
        self.bolditalic_font.configure(weight="bold",slant="italic")
        
    self.color_tags_list = []
    self.image_references = []
#@-node:ekr.20041217041016:setFontFromConfig (colorizer)
#@-node:ekr.20070212080131:Font stuff in colorizer (maybe never)
#@+node:ekr.20031218072017.1944:removeAllImages (leoColor)
def removeAllImages (self):
    
    for photo,image,line_index,i in self.image_references:
        try:
            ### self.body.deleteCharacter(image)
            s = self.allBodyText
            w = self.body.bodyCtrl
            index = g.convertRowColToPythonIndex(s,line_index,i)
            w.delete(index)
            self.allBodyText = w.getAllText()
        except:
            pass # The image may have been deleted earlier.
    
    self.image_references = []
#@-node:ekr.20031218072017.1944:removeAllImages (leoColor)
#@-node:ekr.20070212080350:Maybe never
#@+node:ekr.20070212181918.1:Fix failed unit tests 30
@killcolor

Passed tests:
- Length unit tests
- Colorizer tests
- Import/Export tests
- Unit tests for edit commands

Failed tests:
- All other unit tests
- Multiple editors

----------------------------------------------------------------------
Ran 218 tests in 25.484s

FAILED (failures=26, errors=5)

Fixed 1: total 30
#@+node:ekr.20070214072721.1:Most important 4
======================================================================
FAIL: @test typing in empty body text redraws the screen (and icon)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 16, in <module>
AssertionError: too many or too few redraws: 0

======================================================================
FAIL: @test strokeFromSetting
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 24, in <module>
AssertionError: Expected Alt+equal, Got Alt+=

======================================================================
FAIL: @test w.toGuiIndex (test2)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 19, in <module>
AssertionError

======================================================================
FAIL: @test <Delete> key sticks in body
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 15, in <module>
AssertionError
#@nonl
#@-node:ekr.20070214072721.1:Most important 4
#@+node:ekr.20070214072721.2:Headline failures 10
======================================================================
ERROR: @test paste from menu into body sticks

======================================================================
ERROR: @test paste from menu into headline sticks

======================================================================
ERROR: @test paste from menu to body recolors the body

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 10, in <module>
AttributeError: 'Menu' object has no attribute 'index'

======================================================================
FAIL: @test return ends editing of headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 13, in <module>
AssertionError: oops1 headlineWidget: 36546000 != <wx._controls.TreeCtrl; proxy of <Swig Object of type 'wxPyTreeCtrl *'
 at 0x19518e0> >

======================================================================
FAIL: @test paste at end of headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 20, in <module>
AssertionError

======================================================================
FAIL: @test typing and undo in headline - at end

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 20, in <module>
AssertionError: oops2

======================================================================
FAIL: @test paste and undo in headline - at end

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 21, in <module>
AssertionError

======================================================================
FAIL: @test paste and undo in headline - with selection

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 20, in <module>
AssertionError

======================================================================
FAIL: @test selecting new node retains typing in headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 20, in <module>
AssertionError

======================================================================
FAIL: @test selecting new node retains paste in headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 21, in <module>
AssertionError
#@-node:ekr.20070214072721.2:Headline failures 10
#@+node:ekr.20070214072721.4:Minor failures 4
======================================================================
FAIL: @test Find keeps focus in body & shows selected text
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 16, in <module>
AssertionError: focus <wx._controls.TreeCtrl; proxy of <Swig Object of type 'wxPyTreeCtrl *' at 0x280d718> >

======================================================================
ERROR: @test onHyperLinkControlClick
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 3, in <module>
  File "c:\prog\tigris-cvs\leo\src\leoNodes.py", line 1157, in __getattr__
    raise AttributeError,attr
AttributeError: OnHyperLinkControlClick

======================================================================
ERROR: @test rClick.py
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 7, in <module>
  File "C:\prog\tigris-cvs\leo\plugins\rClick.py", line 77, in rClickbinder
    c.frame.log.logCtrl.bind  ('<Button-3>',c.frame.OnBodyRClick)
AttributeError: wxLeoFrame instance has no attribute 'OnBodyRClick'

======================================================================
FAIL: @test colorizerURLs
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 8, in <module>
AssertionError: no URL tags
#@nonl
#@-node:ekr.20070214072721.4:Minor failures 4
#@+node:ekr.20070214072721.5:Command failures 12
======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: addComments: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: convertAllBlanks: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: convertAllTabs: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: convertBlanks: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: convertTabs: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: dedentBody: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: deleteComments: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: extract: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: extractSection: after undo1

======================================================================
FAIL: @test c.editCommands.selfInsertCommand-1
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 13, in <module>
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 2655, in selfInsertCommand
    self.flashMatchingBracketsHelper(w,i,ch)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 2730, in flashMatchingBracketsHelper
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 3526, in skip_matching_python_delims
    assert(g.match(s,i,delim1))
AssertionError

======================================================================
FAIL: @test c.findMatchingBracket (pass)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 21, in <module>
AssertionError: Expected: '(', got: u':'

======================================================================
FAIL: @test c.frame.pasteText
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 14, in <module>
AssertionError
#@-node:ekr.20070214072721.5:Command failures 12
#@-node:ekr.20070212181918.1:Fix failed unit tests 30
#@-node:ekr.20070211192428:(Make Leo's core gui-indenpendent)
#@+node:ekr.20070212181918.1:Fix failed unit tests 30
@killcolor

Passed tests:
- Length unit tests
- Colorizer tests
- Import/Export tests
- Unit tests for edit commands

Failed tests:
- All other unit tests
- Multiple editors

----------------------------------------------------------------------
Ran 218 tests in 25.484s

FAILED (failures=26, errors=5)

Fixed 1: total 30
#@+node:ekr.20070214072721.1:Most important 4
======================================================================
FAIL: @test typing in empty body text redraws the screen (and icon)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 16, in <module>
AssertionError: too many or too few redraws: 0

======================================================================
FAIL: @test strokeFromSetting
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 24, in <module>
AssertionError: Expected Alt+equal, Got Alt+=

======================================================================
FAIL: @test w.toGuiIndex (test2)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 19, in <module>
AssertionError

======================================================================
FAIL: @test <Delete> key sticks in body
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 15, in <module>
AssertionError
#@nonl
#@-node:ekr.20070214072721.1:Most important 4
#@+node:ekr.20070214072721.2:Headline failures 10
======================================================================
ERROR: @test paste from menu into body sticks

======================================================================
ERROR: @test paste from menu into headline sticks

======================================================================
ERROR: @test paste from menu to body recolors the body

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 10, in <module>
AttributeError: 'Menu' object has no attribute 'index'

======================================================================
FAIL: @test return ends editing of headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 13, in <module>
AssertionError: oops1 headlineWidget: 36546000 != <wx._controls.TreeCtrl; proxy of <Swig Object of type 'wxPyTreeCtrl *'
 at 0x19518e0> >

======================================================================
FAIL: @test paste at end of headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 20, in <module>
AssertionError

======================================================================
FAIL: @test typing and undo in headline - at end

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 20, in <module>
AssertionError: oops2

======================================================================
FAIL: @test paste and undo in headline - at end

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 21, in <module>
AssertionError

======================================================================
FAIL: @test paste and undo in headline - with selection

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 20, in <module>
AssertionError

======================================================================
FAIL: @test selecting new node retains typing in headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 20, in <module>
AssertionError

======================================================================
FAIL: @test selecting new node retains paste in headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 21, in <module>
AssertionError
#@-node:ekr.20070214072721.2:Headline failures 10
#@+node:ekr.20070214072721.4:Minor failures 4
======================================================================
FAIL: @test Find keeps focus in body & shows selected text
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 16, in <module>
AssertionError: focus <wx._controls.TreeCtrl; proxy of <Swig Object of type 'wxPyTreeCtrl *' at 0x280d718> >

======================================================================
ERROR: @test onHyperLinkControlClick
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 3, in <module>
  File "c:\prog\tigris-cvs\leo\src\leoNodes.py", line 1157, in __getattr__
    raise AttributeError,attr
AttributeError: OnHyperLinkControlClick

======================================================================
ERROR: @test rClick.py
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 7, in <module>
  File "C:\prog\tigris-cvs\leo\plugins\rClick.py", line 77, in rClickbinder
    c.frame.log.logCtrl.bind  ('<Button-3>',c.frame.OnBodyRClick)
AttributeError: wxLeoFrame instance has no attribute 'OnBodyRClick'

======================================================================
FAIL: @test colorizerURLs
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 8, in <module>
AssertionError: no URL tags
#@nonl
#@-node:ekr.20070214072721.4:Minor failures 4
#@+node:ekr.20070214072721.5:Command failures 12
======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: addComments: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: convertAllBlanks: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: convertAllTabs: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: convertBlanks: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: convertTabs: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: dedentBody: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: deleteComments: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: extract: after undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1040, in runTest
    self.editBody()
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 1031, in editBody
    assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
AssertionError: extractSection: after undo1

======================================================================
FAIL: @test c.editCommands.selfInsertCommand-1
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 13, in <module>
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 2655, in selfInsertCommand
    self.flashMatchingBracketsHelper(w,i,ch)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 2730, in flashMatchingBracketsHelper
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 3526, in skip_matching_python_delims
    assert(g.match(s,i,delim1))
AssertionError

======================================================================
FAIL: @test c.findMatchingBracket (pass)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 21, in <module>
AssertionError: Expected: '(', got: u':'

======================================================================
FAIL: @test c.frame.pasteText
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 143, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 14, in <module>
AssertionError
#@-node:ekr.20070214072721.5:Command failures 12
#@-node:ekr.20070212181918.1:Fix failed unit tests 30
#@+node:ekr.20070220082124.3:Make installing aspell easier
#@-node:ekr.20070220082124.3:Make installing aspell easier
#@-node:ekr.20070220082124.2:Before b1
#@-node:ekr.20060531161030:To do: 4.4.3
#@+node:ekr.20070105135713:To do: 4.4.4 (new positions)
#@+node:ekr.20070202095051:*** Get chapters working
#@-node:ekr.20070202095051:*** Get chapters working
#@+node:ekr.20070105135851.1:Most important
#@+node:ekr.20061028070132:New positions
# None of this code is part of Leo's core yet: it is all highly experimental.

# Important: the new vnode class implies that the read code must be rewritten to be similar to the opml read code.
#@nonl
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.use_new_positions = False
    
    # New positions require the sax-based read code.
    self.use_sax = self.use_new_positions or c.config.getBool('use_sax_based_read')
    
    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5
    if self.use_sax:
        self.currentVnode = None
        self.rootVnode = None
    else:
        self.fileBuffer = None
        self.fileIndex = 0
        self.currentVnodeStack = [] # A stack of vnodes giving the current position.
        self.topVnodeStack     = [] # A stack of vnodes giving the top position.
        self.topPosition = None
    # For writing
    self.read_only = False
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@nonl
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061029093342.75:linkParentAndChildren (changed)
def linkParentAndChildren (self, parent_v, children):
    
    # if children: g.trace(parent_v,len(children))
    
    if self.use_new_positions:
        parent_v.t.links = children
    else:
        firstChild_v = children and children[0] or None
        parent_v.t._firstChild = firstChild_v
        for child in children:
            child._parent = parent_v
            
    v = parent_v
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
#@nonl
#@-node:ekr.20061029093342.75:linkParentAndChildren (changed)
#@+node:ekr.20061029093342.76:linkSiblings (changed)
def linkSiblings (self, sibs):
    
    '''Set the v._back and v._next links for all vnodes v in sibs.'''
    
    if self.use_new_positions:
        pass
    else:
        n = len(sibs)
        for i in xrange(n):
            v = sibs[i]
            v._back = (i-1 >= 0 and sibs[i-1]) or None
            v._next = (i+1 <  n and sibs[i+1]) or None
#@nonl
#@-node:ekr.20061029093342.76:linkSiblings (changed)
#@-node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.5:v.__cmp__ (not used)
if 0: # not used
    def __cmp__(self,other):
        
        g.trace(self,other)
        return not (self is other) # Must return 0, 1 or -1
#@-node:ekr.20061028211424.5:v.__cmp__ (not used)
#@+node:ekr.20061028211424.6:v.__init__
def __init__ (self,t):

    assert(t)
    
    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.unknownAttributes or any mutable vnode object changes.

    self.t = t # The tnode.
    self.statusBits = 0 # status bits
    
    # Structure links.
    #### self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20061028211424.6:v.__init__
#@+node:ekr.20061028211424.7:v.__repr__ & v.__str__
def __repr__ (self):
    
    if self.t:
        return "<vnode %d:'%s'>" % (id(self),self.cleanHeadString())
    else:
        return "<vnode %d:NULL tnode>" % (id(self))
        
__str__ = __repr__
#@-node:ekr.20061028211424.7:v.__repr__ & v.__str__
#@+node:ekr.20061028211424.8:v.dump (to be deleted)
def dumpLink (self,link):
    return g.choose(link,link,"<none>")

def dump (self,label=""):
    
    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)
    
    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v
#@-node:ekr.20061028211424.8:v.dump (to be deleted)
#@+node:ekr.20061028211424.9:v.__hash__ (only for zodb)
if use_zodb and ZODB:
    def __hash__(self):
        return self.t.__hash__()
#@nonl
#@-node:ekr.20061028211424.9:v.__hash__ (only for zodb)
#@-node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
def findAtFileName (self,names):
    
    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()
    
    if not g.match(h,0,'@'):
        return ""
    
    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
#@-node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
#@+node:ekr.20061028211424.12:anyAtFileNodeName
def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)
#@-node:ekr.20061028211424.12:anyAtFileNodeName
#@+node:ekr.20061028211424.13:at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)
    
def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)
    
def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)
    
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@-node:ekr.20061028211424.13:at...FileNodeName
#@+node:ekr.20061028211424.14:isAtAllNode
def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag
#@-node:ekr.20061028211424.14:isAtAllNode
#@+node:ekr.20061028211424.15:isAnyAtFileNode good
def isAnyAtFileNode (self):
    
    """Return True if v is any kind of @file or related node."""
    
    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
#@-node:ekr.20061028211424.15:isAnyAtFileNode good
#@+node:ekr.20061028211424.16:isAt...FileNode (vnode)
def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)
    
def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)
    
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@-node:ekr.20061028211424.16:isAt...FileNode (vnode)
#@+node:ekr.20061028211424.17:isAtIgnoreNode
def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag
#@-node:ekr.20061028211424.17:isAtIgnoreNode
#@+node:ekr.20061028211424.18:isAtOthersNode
def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag
#@-node:ekr.20061028211424.18:isAtOthersNode
#@+node:ekr.20061028211424.19:matchHeadline
def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""
    
    v = self
    
    h = g.toUnicode(v.headString(),'utf-8')
    h = h.lower().replace(' ','').replace('\t','')

    pattern = g.toUnicode(pattern,'utf-8')
    pattern = pattern.lower().replace(' ','').replace('\t','')
    
    return h.startswith(pattern)
#@-node:ekr.20061028211424.19:matchHeadline
#@-node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.22:v.back
# Compatibility routine for scripts

def back (self):

    return self._back
#@-node:ekr.20061028211424.22:v.back
#@+node:ekr.20061028211424.23:v.next
# Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next
#@-node:ekr.20061028211424.23:v.next
#@-node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.25:v.childIndex
def childIndex(self):
    
    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n
#@-node:ekr.20061028211424.25:v.childIndex
#@+node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
def firstChild (self):
    
    return self.t._firstChild
#@-node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
#@+node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
def hasChildren (self):
    
    v = self
    return v.firstChild()

hasFirstChild = hasChildren
#@-node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
#@+node:ekr.20061028211424.28:v.lastChild
def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child
#@-node:ekr.20061028211424.28:v.lastChild
#@+node:ekr.20061028211424.29:v.nthChild
# childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n > 0 and child:
        n -= 1
        child = child.next()
    return child
#@-node:ekr.20061028211424.29:v.nthChild
#@+node:ekr.20061028211424.30:v.numberOfChildren (n)
def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n += 1
        child = child.next()
    return n
#@-node:ekr.20061028211424.30:v.numberOfChildren (n)
#@-node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.32:v.isCloned (4.2)
def isCloned (self):
    
    return len(self.t.vnodeList) > 1
#@-node:ekr.20061028211424.32:v.isCloned (4.2)
#@+node:ekr.20061028211424.33:isDirty
def isDirty (self):

    return self.t.isDirty()
#@-node:ekr.20061028211424.33:isDirty
#@+node:ekr.20061028211424.34:isExpanded
def isExpanded (self):

    return ( self.statusBits & self.expandedBit ) != 0
#@-node:ekr.20061028211424.34:isExpanded
#@+node:ekr.20061028211424.35:isMarked
def isMarked (self):

    return ( self.statusBits & vnode.markedBit ) != 0
#@-node:ekr.20061028211424.35:isMarked
#@+node:ekr.20061028211424.36:isOrphan
def isOrphan (self):

    return ( self.statusBits & vnode.orphanBit ) != 0
#@-node:ekr.20061028211424.36:isOrphan
#@+node:ekr.20061028211424.37:isSelected
def isSelected (self):

    return ( self.statusBits & vnode.selectedBit ) != 0
#@-node:ekr.20061028211424.37:isSelected
#@+node:ekr.20061028211424.38:isTopBitSet
def isTopBitSet (self):

    return ( self.statusBits & self.topBit ) != 0
#@-node:ekr.20061028211424.38:isTopBitSet
#@+node:ekr.20061028211424.39:isVisited
def isVisited (self):

    return ( self.statusBits & vnode.visitedBit ) != 0
#@-node:ekr.20061028211424.39:isVisited
#@+node:ekr.20061028211424.40:status
def status (self):

    return self.statusBits
#@-node:ekr.20061028211424.40:status
#@-node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.41:v.bodyString
# Compatibility routine for scripts

def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.bodyString):
        s = "v.bodyString: Leo internal error: not unicode:" + repr(self.t.bodyString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
#@-node:ekr.20061028211424.41:v.bodyString
#@+node:ekr.20061028211424.42:v.headString & v.cleanHeadString
def headString (self):
    
    """Return the headline string."""
    
    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.headString):
        s = "Leo internal error: not unicode:" + repr(self.t.headString)
        g.es_print(s,color="red")
        
    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):
    
    s = self.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
#@-node:ekr.20061028211424.42:v.headString & v.cleanHeadString
#@+node:ekr.20061028211424.43:v.directParents (new method in 4.2)
def directParents (self):
    
    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.
    
    This is NOT the same as the list of ancestors of the vnode."""
    
    v = self
    
    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []
#@-node:ekr.20061028211424.43:v.directParents (new method in 4.2)
#@-node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
# These remain in 4.2: the file read logic calls these before creating positions.
#@+node:ekr.20061028211424.45:v.detach
def detach (self):
    
    '''Return a standalone copy of a vnode,
    detached from all other nodes and with a new tnode.'''
    
    v = self
    
    # Create a completely separate tnode.
    t2 = tnode(
        bodyString=v.bodyString(),
        headString=v.headString())
    
    return vnode(t2)
#@nonl
#@-node:ekr.20061028211424.45:v.detach
#@+node:ekr.20061028211424.46:v.insertAfter
def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAfter(self)

    return v
#@-node:ekr.20061028211424.46:v.insertAfter
#@+node:ekr.20061028211424.47:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAsNthChild(self,n)

    return v
#@-node:ekr.20061028211424.47:v.insertAsNthChild
#@+node:ekr.20061028211424.48:v.linkAfter
def linkAfter (self,v):

    """Link self after v."""
    
    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
#@-node:ekr.20061028211424.48:v.linkAfter
#@+node:ekr.20061028211424.49:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v
#@-node:ekr.20061028211424.49:v.linkAsNthChild
#@+node:ekr.20061028211424.50:v.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link a vnode as the root node and set the root _position_."""

    v = self

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v
#@nonl
#@-node:ekr.20061028211424.50:v.linkAsRoot
#@+node:ekr.20061028211424.51:v.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a vnode to the root position.
    
    Important: oldRoot must the previous root vnode if it exists.'''

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)
    
    return v
#@nonl
#@-node:ekr.20061028211424.51:v.moveToRoot
#@+node:ekr.20061028211424.52:v.unlink
def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []
#@nonl
#@-node:ekr.20061028211424.52:v.unlink
#@-node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
#@+node:ekr.20061028211424.53:Setters (no change)
#@+node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.55:clearClonedBit
def clearClonedBit (self):

    self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.55:clearClonedBit
#@+node:ekr.20061028211424.56:v.clearDirty (no change needed)
def clearDirty (self):

    v = self
    v.t.clearDirty()
#@nonl
#@-node:ekr.20061028211424.56:v.clearDirty (no change needed)
#@+node:ekr.20061028211424.57:v.clearMarked
def clearMarked (self):

    self.statusBits &= ~ self.markedBit
#@-node:ekr.20061028211424.57:v.clearMarked
#@+node:ekr.20061028211424.58:clearOrphan
def clearOrphan (self):

    self.statusBits &= ~ self.orphanBit
#@-node:ekr.20061028211424.58:clearOrphan
#@+node:ekr.20061028211424.59:clearVisited
def clearVisited (self):

    self.statusBits &= ~ self.visitedBit
#@-node:ekr.20061028211424.59:clearVisited
#@+node:ekr.20061028211424.60:contract & expand & initExpandedBit
def contract(self):

    self.statusBits &= ~ self.expandedBit
    
    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit
    
    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit
#@-node:ekr.20061028211424.60:contract & expand & initExpandedBit
#@+node:ekr.20061028211424.61:initStatus
def initStatus (self, status):

    self.statusBits = status
#@-node:ekr.20061028211424.61:initStatus
#@+node:ekr.20061028211424.62:setClonedBit & initClonedBit
def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.62:setClonedBit & initClonedBit
#@+node:ekr.20061028211424.63:v.setMarked & initMarkedBit
def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
#@-node:ekr.20061028211424.63:v.setMarked & initMarkedBit
#@+node:ekr.20061028211424.64:setOrphan
def setOrphan (self):

    self.statusBits |= self.orphanBit
#@-node:ekr.20061028211424.64:setOrphan
#@+node:ekr.20061028211424.65:setSelected (vnode)
# This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit
#@-node:ekr.20061028211424.65:setSelected (vnode)
#@+node:ekr.20061028211424.66:t.setVisited
# Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit
#@-node:ekr.20061028211424.66:t.setVisited
#@-node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.67:v.computeIcon & setIcon
def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val
    
def setIcon (self):

    pass # Compatibility routine for old scripts
#@-node:ekr.20061028211424.67:v.computeIcon & setIcon
#@+node:ekr.20061028211424.68:v.initHeadString
def initHeadString (self,s,encoding="utf-8"):
    
    v = self
    s = g.toUnicode(s,encoding,reportErrors=True)
    v.t.headString = s
    
    # g.trace(g.callers(5))
#@-node:ekr.20061028211424.68:v.initHeadString
#@+node:ekr.20061028211424.69:v.setSelection
def setSelection (self, start, length):

    self.t.setSelection ( start, length )
#@-node:ekr.20061028211424.69:v.setSelection
#@+node:ekr.20061028211424.70:v.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):
    
    return self.t.setTnodeText(s,encoding)
#@-node:ekr.20061028211424.70:v.setTnodeText
#@-node:ekr.20061028211424.53:Setters (no change)
#@-node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.1:position class
#@+node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.2:p.__cmp__ (changed)
def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self
    
    # g.trace(p1.headString(),p2 and p2.headString())

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal
    elif p1.v == p2.v and p2._childIndex == p2._childIndex and p1.stack == p2.stack:
        return 0 # equal
    else:
        return 1 # not equal

    # # Check entire stack quickly.
    # # The stack contains vnodes, so this is not a recursive call.
    # if p1.v != p2.v or p1.stack != p2.stack:
        # return 1 # notEqual
    # # This is slow: do this last!
    # if p1.childIndex() != p2.childIndex():
        # # Disambiguate clones having the same parents.
        # return 1 # notEqual
    # return 0 # equal
#@nonl
#@-node:ekr.20061028070057.2:p.__cmp__ (changed)
#@+node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                print "unknown position attribute:",attr
                import traceback ; traceback.print_stack()
            raise AttributeError,attr
#@nonl
#@-node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20061028070057.4:p.__init__
def __init__ (self,v,childIndex=0,stack=None):

    '''Create a new position.'''

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    self._childIndex = childIndex
    
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []
    
    g.app.positions += 1
    
    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20061028070057.4:p.__init__
#@+node:ekr.20061028070057.5:p.__nonzero__
@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

def __nonzero__ ( self):
    
    """Return True if a position is valid."""
    
    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None
#@-node:ekr.20061028070057.5:p.__nonzero__
#@+node:ekr.20061028070057.6:p.__str__ and p.__repr__
def __str__ (self):
    
    p = self
    
    if p.v:
        return "<pos %d lvl: %d [%d] %s>" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d        [%d] None>" % (id(p),len(p.stack))
        
__repr__ = __str__
#@-node:ekr.20061028070057.6:p.__str__ and p.__repr__
#@+node:ekr.20061028070057.7:p.archivedPosition
def archivedPosition (self):
    
    '''Return a representation of a position suitable for use in .leo files.'''
    
    p = self
    aList = [p2.v.childIndex() for p2 in p.self_and_parents_iter()]
    aList.reverse()
    return aList
#@nonl
#@-node:ekr.20061028070057.7:p.archivedPosition
#@+node:ekr.20061028070057.8:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""

    return position(self.v,self.stack)
#@-node:ekr.20061028070057.8:p.copy
#@+node:ekr.20061028070057.9:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):
    
    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label
        
def vnodeListIds (self):
    
    p = self
    return [id(v) for v in p.v.t.vnodeList]
#@-node:ekr.20061028070057.9:p.dump & p.vnodeListIds
#@+node:ekr.20061028070057.10:p.equal & isEqual (changed)
def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None.
    """

    p1 = self

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1._childIndex == p2._childIndex and
        p1.stack == p2.stack
    )
        
isEqual = equal
#@-node:ekr.20061028070057.10:p.equal & isEqual (changed)
#@+node:ekr.20061028070057.11:p.key
def key (self):
    
    p = self

    return '%s:%d.%s' % (
        id(p.v),
        p._childIndex,
        ','.join([str(id(v)) for v in p.stack])
    )
#@-node:ekr.20061028070057.11:p.key
#@-node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.12:p.moveToX (many changes)
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
#@+node:ekr.20061028070057.13:p.moveToBack (new)
def moveToBack (self):
    
    '''Move position p to its previous sibling.'''
    
    p = self
    if p.stack and p._childIndex > 0:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex -= 1
            p.v = links[p._childIndex]
        else:
            g.trace('Can not happen: no links')
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # p.v = p.v and p.v._back
    # return p
#@nonl
#@-node:ekr.20061028070057.13:p.moveToBack (new)
#@+node:ekr.20061028070057.14:p.moveToFirstChild (new)
def moveToFirstChild (self):

    '''Move a position to it's first child's position.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = 0
            p.v = links[0]
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # child = p.v.t._firstChild
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.14:p.moveToFirstChild (new)
#@+node:ekr.20061028070057.15:p.moveToLastChild (new)
def moveToLastChild (self):
    
    '''Move a position to it's last child's position.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = len(links)-1
            p.v = links[p._childIndex]
    else:
        p.v = None
    return p
    
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # child = p.v.lastChild()
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.15:p.moveToLastChild (new)
#@+node:ekr.20061028070057.16:p.moveToLastNode (no change)
def moveToLastNode (self):
    
    """Move a position to last node of its tree.
    
    N.B. Returns p if p has no children."""
    
    p = self
    while p.hasChildren():
        p.moveToLastChild()
    return p
#@-node:ekr.20061028070057.16:p.moveToLastNode (no change)
#@+node:ekr.20061028070057.17:p.moveToNext (new)
def moveToNext (self):

    '''Move position p to its next sibling.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if p._childIndex + 1 < len(links):
            p._childIndex += 1
            p.v = links[p._childIndex]
        else:
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # p.v = p.v and p.v._next
    # return p
#@-node:ekr.20061028070057.17:p.moveToNext (new)
#@+node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
def moveToNodeAfterTree (self):
    
    """Move a position to the node after the position's tree."""
    
    p = self
    
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
#@+node:ekr.20061028070057.19:p.moveToNthChild (new)
def moveToNthChild (self,n):
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links and n < len(links)
            p.v = links[n]
            p.childIndex = n
        else:
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # if p:
        # child = p.v.nthChild(n) # Must call vnode method here!
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.19:p.moveToNthChild (new)
#@+node:ekr.20061028070057.20:p.moveToParent (new)
def moveToParent (self):
    
    '''Move a position to its parent position.'''
    
    if p.stack:
        p.v,p._childIndex = p.stack.pop()
    else:
        p.v = None
    return p
    
    # p = self
    # if not p: return p
    # if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        # p.v = p.v._parent
    # elif p.stack:
        # p.v = p.stack.pop()
    # else:
        # p.v = None
    # return p
#@nonl
#@-node:ekr.20061028070057.20:p.moveToParent (new)
#@+node:ekr.20061028070057.21:p.moveToThreadBack (no change)
def moveToThreadBack (self):
    
    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.21:p.moveToThreadBack (no change)
#@+node:ekr.20061028070057.22:p.moveToThreadNext (little change)
def moveToThreadNext (self):
    '''Move a position to the next a position in threading order.'''
    p = self
    if p.hasChildren():
        p.moveToFirstChild()
    elif p.hasNext()
        p.moveToNext()
    else:
        p.moveToParent()
        while p:
            if p.hasNext():
                p.moveToNext()
                break #found
            p.moveToParent()
        # not found.
    return p

# def moveToThreadNext (self):
    # """Move a position to the next a position in threading order."""
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # p.moveToFirstChild()
        # elif p.v._next:
            # p.moveToNext()
        # else:
            # p.moveToParent()
            # while p:
                # if p.v._next:
                    # p.moveToNext()
                    # break #found
                # p.moveToParent()
            # # not found. 
    # return p
#@nonl
#@-node:ekr.20061028070057.22:p.moveToThreadNext (little change)
#@+node:ekr.20061028070057.23:p.moveToVisBack (no change)
def moveToVisBack (self):
    
    """Move a position to the position of the previous visible node."""

    p = self
    
    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p
#@-node:ekr.20061028070057.23:p.moveToVisBack (no change)
#@+node:ekr.20061028070057.24:p.moveToVisNext (no change)
def moveToVisNext (self):
    
    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()
            
    return p
#@-node:ekr.20061028070057.24:p.moveToVisNext (no change)
#@-node:ekr.20061028070057.12:p.moveToX (many changes)
#@+node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.27:p.Comparisons (no change)
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)
#@-node:ekr.20061028070057.27:p.Comparisons (no change)
#@+node:ekr.20061028070057.28:p.Headline & body strings (no change)
def bodyString (self):
    
    return self.v.bodyString()

def headString (self):
    
    return self.v.headString()
    
def cleanHeadString (self):
    
    return self.v.cleanHeadString()
#@-node:ekr.20061028070057.28:p.Headline & body strings (no change)
#@+node:ekr.20061028070057.29:p.Status bits (no change)
def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
#@-node:ekr.20061028070057.29:p.Status bits (no change)
#@+node:ekr.20061028070057.30:p.directParents (new, faster)
def directParents (self):
    
    p = self
    return p and p.stack or []

    # return self.v.directParents()
#@-node:ekr.20061028070057.30:p.directParents (new, faster)
#@+node:ekr.20061028070057.31:p.childIndex (new, much faster)
# This is time-critical code!

def childIndex(self):
    
    return p and p._childIndex or 0

    # p = self ; v = p.v
    # if not v or not v._back:
        # return 0
    # n = 0 ; v = v._back
    # while v:
        # n += 1
        # v = v._back
    # return n
#@nonl
#@-node:ekr.20061028070057.31:p.childIndex (new, much faster)
#@-node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.33:p.hasChildren (new)
def hasChildren(self):
    
    p = self
    
    if p.v and p.v.t:
        return len(p.v.t.links) > 0
    else:
        return False

    # return p.v and p.v.t and p.v.t._firstChild
#@-node:ekr.20061028070057.33:p.hasChildren (new)
#@+node:ekr.20061028070057.34:p.numberOfChildren (new)
def numberOfChildren (self):
    
    if p.v:
        return len(p.v.t.links)
    else:
        return 0
    
    # return self.v.numberOfChildren()
#@-node:ekr.20061028070057.34:p.numberOfChildren (new)
#@-node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@-node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
#@+node:ekr.20061028070057.36:p.hasX (new)
def hasBack(self):
    return self._childIndex > 0
    # return self.v and self.v._back

hasFirstChild = hasChildren
    
def hasNext(self):
    p = self
    if p.stack:
        parent_v,junk = self.stack[-1]
        links = parent_v.t.links
        return p._childIndex + 1 < len(parent.v.t.links)
    else:
        return False
    # return self.v and self.v._next
    
def hasParent(self):
    return len(self.stack) > 1 # The first item of each stack is the dummy parent.
    # return self.v and self.v._parent is not None
    
def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
    
hasVisBack = hasThreadBack
#@-node:ekr.20061028070057.36:p.hasX (new)
#@+node:ekr.20061028070057.37:hasThreadNext (big change)
def hasThreadNext(self):
    
    p = self ; v = p.v
    if not p.v: return False

    if p.hasChildren() or p.hasNext():
        return True
    else:
        # Simulate this code without copying p.
        # p2 = p.copy()
        # p2.moveToParent()
        # while p2:
            # if p2.hasNext():
                # return True
            # p2.moveToParent()
        # return False
        if not p.stack: return False
        n = len(p.stack)-1
        v,childIndex = p.stack[n]
        n -= 1
        while n >= 0:
            # v2,childIndex2 represent v's parent.
            v2,childIndex2 = parent.stack[n]
            links = v2.t.links
            if childIndex + 1 < len(links):
                return True
            # v.moveToParent
            v,childIndex = v2,childIndex2
            n -= 1
        return False

    # p = self ; v = p.v
    # if not p.v: return False
    # if v.t._firstChild or v._next:
        # return True
    # else:
        # n = len(p.stack)-1
        # v,n = p.vParentWithStack(v,p.stack,n)
        # while v:
            # if v._next:
                # return True
            # v,n = p.vParentWithStack(v,p.stack,n)
        # return False

hasVisNext = hasThreadNext
#@nonl
#@-node:ekr.20061028070057.37:hasThreadNext (big change)
#@+node:ekr.20061028070057.38:p.findRootPosition (unchanged)
def findRootPosition (self):
    
    p = self.copy()
    while p.hasParent():
        p.moveToParent()
    while p.hasBack():
        p.moveToBack()
    return p
#@nonl
#@-node:ekr.20061028070057.38:p.findRootPosition (unchanged)
#@+node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
def isAncestorOf (self, p2):
    
    p = self
    if not p.stack:
        return False
    elif p2 is None or not p2.stack:
        return False
    else:
        for v,junk in p2.stack:
            if v == p.v:
                return True
        else:
            return False
    
    # p = self
    # # Avoid calling p.copy() or copying the stack.
    # v2 = p2.v ; n = len(p2.stack)-1
        # # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # while v2:
        # if v2 == p.v:
            # return True
        # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # return False
#@nonl
#@-node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
#@+node:ekr.20061028070057.40:p.isCloned (unchanged)
def isCloned (self):
    
    return len(self.v.t.vnodeList) > 1
#@-node:ekr.20061028070057.40:p.isCloned (unchanged)
#@+node:ekr.20061028070057.41:p.isRoot (unchanged)
def isRoot (self):
    
    p = self

    return not p.hasParent() and not p.hasBack()
#@-node:ekr.20061028070057.41:p.isRoot (unchanged)
#@+node:ekr.20061028070057.42:p.isVisible (new)
def isVisible (self):
    
    """Return True if all of a position's parents are expanded."""
    
    p = self
    for v in p.stack:
        if not v.isExpanded():
            return False
    return True

    # p = self
    # v = p.v ; n = len(p.stack)-1
    # v,n = p.vParentWithStack(v,p.stack,n)
    # while v:
        # if not v.isExpanded():
            # return False
        # v,n = p.vParentWithStack(v,p.stack,n)
    # return True
#@nonl
#@-node:ekr.20061028070057.42:p.isVisible (new)
#@+node:ekr.20061028070057.43:p.level & simpleLevel (new)
def level(self):
    return len(self.stack)
    
simpleLevel = level

# def simpleLevel(self):
    # 
    # return len([p for p in self.parents_iter()])

# def level(self,verbose=False):
    # 
    # p = self ; level = 0
    # if not p: return level
        # 
    # # Avoid calling p.copy() or copying the stack.
    # v = p.v ; n = len(p.stack)-1
    # while 1:
        # assert(p)
        # v,n = p.vParentWithStack(v,p.stack,n)
        # if v:
            # level += 1
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        # else:
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # # if g.app.debug: assert(level==self.simpleLevel())
            # break
    # return level
#@-node:ekr.20061028070057.43:p.level & simpleLevel (new)
#@-node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n >= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
#@+node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)
#@-node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
#@-node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
#@+node:ekr.20061028070057.47:p.restoreLinksInTree
def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""
    
    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    for p in root.children_iter():
        p.restoreLinksInTree()
#@-node:ekr.20061028070057.47:p.restoreLinksInTree
#@+node:ekr.20061028070057.48:p.deleteLinksInTree & allies
def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()

    # for p in root.children_iter():
        # p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@+node:ekr.20061028070057.49:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20061028070057.49:p.deleteLinksInSubtree
#@+node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
#@-node:ekr.20061028070057.48:p.deleteLinksInTree & allies
#@-node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@+node:ekr.20061028070057.52:p.linkAfter
def linkAfter (self,after):

    """Link self after position 'after'."""
    
    p = self
    if not after.stack:
        g.trace('Can not happen: no dummy root.',after)
        return
    
    p.stack = after.stack[:]
    p._childIndex = after._childIndex + 1 #### New
    parent_v,junk = p.stack[-1] #### New
    links = parent_v.t.links #### New
    links.insert(p._childIndex,p.v) #### New
        
    #### p.v._parent = after.v._parent
    
    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.
    
    #### p.v._back = after.v
    #### p.v._next = after.v._next
    #### after.v._next = p.v
    #### if p.v._next:
        #### p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")
#@-node:ekr.20061028070057.52:p.linkAfter
#@+node:ekr.20061028070057.53:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of parent position 'parent'."""
    
    # g.trace(self,parent,n,parent.v)

    p = self
    links = parent.v.t.links
    if n <= len(links):
        links.insert(n,p.v)
    else:
        g.trace('Can not happen: n too large.',n,p)
        return
        
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # # Recreate the stack using the parent.
    # p.stack = parent.stack[:]
    # if parent.isCloned():
        # p.stack.append(parent.v)
    # p.v._parent = parent.v
    # # Add v to it's tnode's vnodeList.
    # if p.v not in p.v.t.vnodeList:
        # p.v.t.vnodeList.append(p.v)
        # p.v.t._p_changed = 1 # Support for tnode class.
    # if n == 0:
        # child1 = parent.v.t._firstChild
        # p.v._back = None
        # p.v._next = child1
        # if child1:
            # child1._back = p.v
        # parent.v.t._firstChild = p.v
    # else:
        # prev = parent.nthChild(n-1) # zero based
        # assert(prev)
        # p.v._back = prev.v
        # p.v._next = prev.v._next
        # prev.v._next = p.v
        # if p.v._next:
            # p.v._next._back = p.v
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.53:p.linkAsNthChild
#@+node:ekr.20061028070057.54:p.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    root_v,junk = p.stack[0]
    links = root_v.t.links
    p.stack = [root_v] # Clear the stack, except for the dummy root.
    links = [p.v]
    if oldRoot:
        links.append(oldRoot.v)
    
    # p.stack = [] # Clear the stack.
    # # Clear all links except the child link.
    # v._parent = None
    # v._back = None
    # v._next = oldRootVnode
    
    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    # if oldRoot:
        # oldRoot.v._back = v
    # p.dump(label="root")
#@nonl
#@-node:ekr.20061028070057.54:p.linkAsRoot
#@+node:ekr.20061028070057.55:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v.t.links does NOT change."""

    p = self ; v = p.v
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)
    
    if p.stack:
        parent,junk = p.stack[-1]
        links = parent.t.links
        if v in links:
            links.remove(v)
        else:
            g.trace("Can not happen: not its father's child.",p)
    else:
        g.trace('Can not happen: missing root.',p)
    
    # Reset the firstChild link in its direct father.
    # if p.v._parent:
        # if 0: # This can fail.  I have no idea why it was present.
            # assert(p.v and p.v._parent in p.v.directParents())
        # if p.v._parent.t._firstChild == v:
            # #g.trace('resetting _parent.v.t._firstChild to',v._next)
            # p.v._parent.t._firstChild = v._next
    # else:
        # parent = p.parent()
        # if parent:
            # if 0: # This can fail.  I have no idea why it was present.
                # assert(parent.v in p.v.directParents())
            # if parent.v.t._firstChild == v:
                # #g.trace('resetting parent().v.t._firstChild to',v._next)
                # parent.v.t._firstChild = v._next
    # # Do NOT delete the links in any child nodes.
    # # Clear the links in other nodes.
    # if v._back: v._back._next = v._next
    # if v._next: v._next._back = v._back
    # # Unlink _this_ node.
    # v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.55:p.unlink
#@-node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
#@-node:ekr.20061028211424.1:position class
#@-node:ekr.20061028070132:New positions
#@+node:ekr.20061206060454:Improve import code
@nocolor

- Make the later munging unnecessary.
	- Don't generate @file or the full file names.
	- Don't add @ignore
	- Put @language python and @tabwidth -4 only in the root node.
- Put the docstring at the top.
- Make sure only imports go in the << imports >> section.
#@-node:ekr.20061206060454:Improve import code
#@+node:ekr.20061127170002.1:Allow multiple lines on the button bar
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3993176
By: rich_ries

How can the button bar be enlarged to take a second (or third!) row of icons? Or maybe the Scripting buttons can have
their own section, like the NodeBar plugin did/does?

add-new-icon-row command?
#@nonl
#@-node:ekr.20061127170002.1:Allow multiple lines on the button bar
#@-node:ekr.20070105135851.1:Most important
#@+node:ekr.20061028065955.4:New features
#@+node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061014050154.2:Binding to None clears all bindings
#@-node:ekr.20061014050154.2:Binding to None clears all bindings
#@+node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@-node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@+node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:new
def new (self,event=None):
    
    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)
    
    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):
    
    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
            
    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):
    
    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save
def save (self,event=None):
    
    '''Save a Leo outline to a file.'''

    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
    
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName != "":
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
#@-node:ekr.20031218072017.2834:save
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):
    
    '''Save a Leo outline to a file with a new filename.'''
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):
    
    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):
    
    '''Revert the contents of a Leo outline to last saved contents.'''
    
    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return
        
    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@-node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@-node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@+node:ekr.20061024093525:Create settings menu
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3977681

How about having a menu Edit -> Settings with the submenu-items 'LeoSettings.leo',
'myLeoSettings.leo', 'this file's settings'?

The menu-items 'Open myLeoSettings.leo' and 'Open LeoSettings.leo' under the
Help-menu seem out-of-place.

#@-node:ekr.20061024093525:Create settings menu
#@+node:ekr.20061116054917.6:Remove blanks in calltips
#@-node:ekr.20061116054917.6:Remove blanks in calltips
#@+node:ekr.20061108100143:Create '*open-&test.leo' command that t.bat or test.leo
# This doesn't seem to work well on XP.
#@nonl
#@+node:ekr.20061209131102.1:openTest
def openTest (self, event=None):
    
    if 1: # Open in a new process.
        cmd = 'c:\Windows\System32\cmd.exe' # Hangs if used.
        python = sys.executable
        leo = g.os_path_abspath(g.os_path_join(g.app.loadDir,'leo.py'))
        test = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test'))
        
        os.system('%s %s %s %s' % (cmd, python,leo,test))
        # args = [python, leo, test]
        
        # if 1: # Use present environment.
            # os.spawnv(os.P_NOWAIT, sys.executable, args)
        # else: # Use a pristine environment.
            # os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
    else:
        c = self
        fileName = g.os_path_join(g.app.loadDir,'..','test','test.leo')
    
        ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es('not found: %s' % fileName)
#@-node:ekr.20061209131102.1:openTest
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):
    
    self.helpMenuTable = [
        # &: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&About Leo...',           'about-leo'),
        ('Online &Home Page',       'open-online-home'),
        '*open-online-&tutorial',
        '*open-&users-guide',
        '-',
        ('Open Leo&Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&Settings.leo',   'open-leoSettings-leo'),
        ('Open &myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&ipts.leo',       'open-scripts-leo'),
        # ('Open t&est.leo',          'open-test-leo'),
        '-',
        '*he&lp-for-minibuffer',
        '*help-for-&command',
        '-',
        '*&apropos-autocompletion',
        '*apropos-&bindings',
        '*apropos-&find-commands',
        '-',
        '*pri&nt-bindings',
        '*print-c&ommands',
    ]
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20061108100143:Create '*open-&test.leo' command that t.bat or test.leo
#@-node:ekr.20061028065955.4:New features
#@-node:ekr.20070105135713:To do: 4.4.4 (new positions)
#@+node:ekr.20060822174843:Most important
#@+node:ekr.20061206084401:Look at launchpad and bazaar
http://launchpad.net 
#@-node:ekr.20061206084401:Look at launchpad and bazaar
#@+node:ekr.20051202094427:Resolve cvs conflicts
Investigate meld:  http://meld.sourceforge.net/
#@nonl
#@+node:ekr.20060823105514:Simulate cvs conflicts by using 2 repositories simultaneously
#@-node:ekr.20060823105514:Simulate cvs conflicts by using 2 repositories simultaneously
#@+node:ekr.20060601073503:Postings
@nocolor
#@nonl
#@+node:ekr.20031218072017.658:Stepen Schaefer 1
@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
#@-node:ekr.20031218072017.658:Stepen Schaefer 1
#@+node:ekr.20050501111900:Stephen Schaefer 2
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3125092
By: thyrsus

About a month ago, I posted a screed on how @thin was inadequate to address
my needs; that what I needed to collaborate on via version control was exactly
the essence of Leo's value: the multiple expressions of structure, which by
their nature must exist outside of @thin.  I said I was going to live the pain
to discover a modus vivendi.

Having done that, let me now say:

AAAAAAAAAAAAGGGGGGGGHHHHHHHHHH!

But the exercise has led me to a vision, which I will implement to the extent
my nonexistent spare time and paltry programming talents permit.

The essence of the pain is "conflicts", which become more  certain to occur
as the leo file encompases ever more related files.  As I work on a change to
the Linux configuration, my colleague works on a change to the Solaris configuration,
and one of us checks in our version of the leo file documenting the site
configuration first, and the other cannot check in his version of that file.
The conflict must be resolved by the human.  Using the "diff" tool on the .leo
XML is not an answer (though thank Heaven and Ed for gnxs).  The resolution
needs two levels of support: outline and node.

With the .leo file declared binary, in the event of a conflict CVS leaves you
with the most recent CVS version and your rejected version, and you're responsible
for performing a reconciliation and then resubmitting that.  Leo will recognize
the problem, and present both versions of the project, side by side, splitting
the outline pane.  The parallel trees will scroll/expand/contract in unison.
Outline branches present in CVS and not yours will display as blank space in
your version; nodes present in your version and not CVS will display as blank
space in the CVS version. The CVS version will be read only, your version editable.
The same node with differences in its text or in its children will be highlighted.
You will be able to drag nodes from the CVS version into your version. If the
text of a selected node has conflicts, the text area will split in two, showing
the CVS version and your version, with differences highlighted, both sides of
the pane scrolling in unison, the CVS side read-only, and you can copy from
that side to your side.  I intend to take as many ideas as I can from tkdiff
(http://sourceforge.net/projects/tkdiff/ - see also
http://freshmeat.net/screenshots/10602/ ).  (I have begun translating tkdiff
from from tcl to python - nearly 9000 lines and I'm still learning both languages,
so draw your own timeline.)  You edit your nodes, you edit your tree, you hit
the "reconcile" button, and your reconciliation of the conflict goes into CVS.
If, meanwhile, another one of your over-achieving colleages has again updated
CVS, the process repeats with the most current CVS version.  Or you can hit
the "abandon" button to give up on your changes.

As the Hebrews say at Passover: "Next year in Jerusalem."
#@nonl
#@-node:ekr.20050501111900:Stephen Schaefer 2
#@+node:ekr.20031218072017.659:Jonathon 1
@nocolor

http://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

In the .leo, if I edit <<bar>>, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@verbatim
#@+leo
#@verbatim
#@+node:0::@file foo.py
#@verbatim
#@+body
#@verbatim
#@+others
#@verbatim
#@+node:1::definition of a
#@verbatim
#@+body
print "a:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"bar"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:1::definition of a
#@verbatim
#@+node:2::definition of b
#@verbatim
#@+body
print "b:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation b"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:2::definition of b
#@verbatim
#@+node:3::definition of c
#@verbatim
#@+body
print "c:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation c"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:3::definition of c
#@verbatim
#@-others
#@verbatim
#@-body
#@verbatim
#@-node:0::@file foo.py
#@verbatim
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
#@-node:ekr.20031218072017.659:Jonathon 1
#@+node:ekr.20031218072017.660:Jonathan 2
@nocolor

By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

<<<<<<< 
blah blah blah? 
======= 
blah blah blah! 
>>>>>>> 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  
#@-node:ekr.20031218072017.660:Jonathan 2
#@+node:ekr.20031218072017.661:Gil 1
http://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
#@-node:ekr.20031218072017.661:Gil 1
#@+node:ekr.20031218072017.662:Gil 2
http://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?
#@nonl
#@-node:ekr.20031218072017.662:Gil 2
#@-node:ekr.20060601073503:Postings
#@-node:ekr.20051202094427:Resolve cvs conflicts
#@+node:ekr.20060823105514.1:Really solid perfect import
@nocolor

- Make sure whitespace is preserved properly.

- Make sure perfect import works.
#@nonl
#@-node:ekr.20060823105514.1:Really solid perfect import
#@-node:ekr.20060822174843:Most important
#@+node:ekr.20060527164612:Important 1-2 day projects
#@+node:ekr.20070211184127:New organization for leoPlugins.leo?
@nocolor

- 1 .leo file per plugin.
- Use @url nodes to refer to the individual .leo files.

The drawback: harder to do mass searches/replaces.
#@nonl
#@-node:ekr.20070211184127:New organization for leoPlugins.leo?
#@+node:ekr.20061207073104:Convert bottlenecks to pyrex code
# To do:  actually generate Leo's bottlenecks.
#@nonl
#@+node:ekr.20061207073104.1:gcc build docs
@nocolor

To build your module using GCC is a three step process on Unix. (I have know
idea how many steps it is on Windows™.)

Start by running the Pyrex compiler over your code as follows, where
mymodule.pyx is the name of the Pyrex module you are writing. python2.2 pyrexc
mymodule.pyx Next, compile the resulting C file into a .o file. The call to gcc
looks like this:

gcc -c -fPIC -I/usr/include/python2.2/ mymodule.c
The arguments to gcc are explained below.

-c 
Produces a .o file instead of an executable. 
-fPIC 
Produces position independent code, so we can dynamically link against it later. 
-I/usr/include/python2.2/ 
is the location of the Python 2.2 include file. The location of your Python include file may differ from /usr/include/python2.2/. 
mymodule.c 
is the name of the C file produced by Pyrex. 
Finally, link the .o into a .so: gcc -shared mymodule.o -lxosd -o mymodule.so
-shared 
produces a shared-object file, instead of an executable. 
mymodule.o 
is the name of the module you wish to compile. 
-lxosd 
links against a C-library, with the name of the library given as the argument. 
-o mymodule.so 
causes gcc to put the output into a file called mymodule.so 
The C library that you are wrapping will probably differ from mymodule. 
#@-node:ekr.20061207073104.1:gcc build docs
#@+node:ekr.20061207073104.2:pyrexc command-line options
@nocolor

The pyrexc command supports the following options:

  Short Long              Argument    Description
  -----------------------------------------------------------------------------
  -v    --version                     Display version number of pyrex compiler
  -l    --create-listing              Write error messages to a .lis file
  -I    --include-dir     <directory> Search for include files in named 
                                       directory (may be repeated)
  -o    --output-file     <filename>  Specify name of generated C file (only
                                       one source file allowed if this is used)

Anything else is taken as the name of a Pyrex source file and compiled
to a C source file. Multiple Pyrex source files can be specified
(unless -o is used), in which case each source file is treated as the
source of a distinct extension module and compiled separately to
produce its own C file.
#@-node:ekr.20061207073104.2:pyrexc command-line options
#@+node:ekr.20061207073104.3:@file myModule.pyx
def spam(int i, char *s):
    if 1:
        print i,s
#@nonl
#@-node:ekr.20061207073104.3:@file myModule.pyx
#@+node:ekr.20061207073104.4:Make myModule.c
# Use pyrexc to create myModule.c from myModule.pyx.
import os,sys
python = sys.executable
theFile = r'C:\prog\tigris-cvs\leo\test\myModule.pyx'
pyrexc = r'c:\prog\Pyrex-0.9.4.1\pyrexc.py'
os.system(r'%s %s %s' % (python,pyrexc,theFile))

if 0: # Build myModule library using distutils.
    from distutils.core import setup, Extension

    # Make the extension module ("mymodule") link against xosd
    xosdExtn = Extension("mymodule", ["mymodule.c"], libraries=["xosd"])
    
    # Compile the extension module
    setup(name="mymodule", ext_modules=[xosdExtn])
    
@ Save the above code in a file called setup.py and run the following code
to build and install your module.
    
    python setup.py build
    python setup.py install
#@nonl
#@-node:ekr.20061207073104.4:Make myModule.c
#@+node:ekr.20061207073104.5:Code to be optimized w/ pyrex
#@+node:ekr.20061207073104.6:Nodes...
#@-node:ekr.20061207073104.6:Nodes...
#@+node:ekr.20061207073104.216:Colorizer
#@-node:ekr.20061207073104.216:Colorizer
#@+node:ekr.20061207073104.268:File code
#@-node:ekr.20061207073104.268:File code
#@-node:ekr.20061207073104.5:Code to be optimized w/ pyrex
#@-node:ekr.20061207073104:Convert bottlenecks to pyrex code
#@+node:ekr.20060531161030.1:Make body editors persistant
#@-node:ekr.20060531161030.1:Make body editors persistant
#@+node:ekr.20061006165447:Let import commands decide what kind of import to do
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3940843
By: ktenney

>the distiction between importing 'foreign' text files and importing derived
files created by Leo.

Couldn't Leo make this distinction by looking at
the file being imported? If so, I think it should.

This could eliminate a lot of confusion IMO, if
I want to bring a file into a node, just
'import' it, and the right thing happens.

An emergency measure could be available in a 
'File Special' menu.
#@nonl
#@-node:ekr.20061006165447:Let import commands decide what kind of import to do
#@+node:ekr.20031218072017.801:Support .leo.gz or .leo.zip files
#@+node:ekr.20050428062312:Request 1
@nocolor

By: samcollett ( Sam Collett ) 
 Compressed LEO files   
2003-01-07 16:57


Would it be possible to have a new file format that was basically a compressed
version of LEO files? Maybe using the gzip compression method. You could then
save a lot of space when you do large files. Not being a professional
programmer myself (I mainly dabble in web design - HTML and Active Server
Pages) how difficult would this be to implement? You would just output using a
different file extension so users of the older versions can still use files
with the LEO extension.
#@-node:ekr.20050428062312:Request 1
#@+node:ekr.20040226092546:Request 2
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2442772
By: ejoy

I made an experiment last night. I replaced the call to open()in leofilecommand.py
with a call to gzip.open().

The LeoPy.leo file saved this way is only 600K! And there is no significant
speed down in saving.

I think it is a good idea to add compression support for load/save .leo files.
When reading or writing file with name ending with ".leo.gz", leo can call gzip
module to uncompress/compress the file, saving a lot of disk space.

What do you think of this?
#@nonl
#@-node:ekr.20040226092546:Request 2
#@+node:ekr.20031218072017.2297:open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    if not self.use_sax: # Read the entire file into the buffer
        self.fileBuffer = theFile.read() ; theFile.close()
        self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    ok, ratio = self.getLeoFile(
        theFile,fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    if not self.use_sax: # Delete the file buffer
        self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.2297:open (leoFileCommands)
#@+node:ekr.20050428063105:newOpen (From chapters.py)
oldOpen = leoFileCommands.fileCommands.open

def newOpen( self,file,fileName,readAtFileNodesFlag=True,silent=False):

    global iscStringIO
    c = self.c
    
    if zipfile.is_zipfile( fileName ):
        iscStringIO = True
        chapters = openChaptersFile( fileName )
        g.es( str( len( chapters ) ) + " Chapters To Read", color = 'blue' )
        insertChapters( chapters, c.frame, c )
        g.es( "Finished Reading Chapters", color = 'blue' )
        iscStringIO = False
        return True

    return oldOpen(self,file,fileName,readAtFileNodesFlag,silent)
#@nonl
#@-node:ekr.20050428063105:newOpen (From chapters.py)
#@-node:ekr.20031218072017.801:Support .leo.gz or .leo.zip files
#@+node:ekr.20060530130736.2:Customize Open With menu without writing code
http://sourceforge.net/forum/message.php?msg_id=3737745

Desparately needs a way to modify the Open-With menu other than going
in and changing the code.
#@+node:ekr.20060619101345:@open-with settings
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3785897

From: Rich

Would it be possible to have the table of "Open With" editors to be part of
the config system? I find myself patching the list every time I D/L a new Leo
version to add the editor I use. This would also help isolate the user from
the "guts" of Leo, theereby being less intimidating.

Yes, it would be possible because everything in the table is a string (and not,
e.g., a reference to a method). This would require support for @open-with in
@settings trees.
#@-node:ekr.20060619101345:@open-with settings
#@-node:ekr.20060530130736.2:Customize Open With menu without writing code
#@+node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
@nocolor

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off.

@color
#@nonl
#@-node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
#@-node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20060306194040:Video and more screen shots Leo's web site
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/


http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

Thanks,
Kent
#@nonl
#@+node:ekr.20060531134434:Tutorials
http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
#@nonl
#@-node:ekr.20060531134434:Tutorials
#@+node:ekr.20060531134434.1:Screencasts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3758303
By: ktenney

My sense is that documentation/screencasts has the
greatest potential for expanding Leo's mindshare.

I really like those produced by the good folks
at Dabo;
http://leafe.com/screencasts/
http://leafe.com/screencasts/populategrid.html

The TurboGears people have taken this to the extreme;
http://www.turbogears.org/ultimate.html

Leo is different enough that it warrants a 
demonstration of it's advantages.
#@nonl
#@-node:ekr.20060531134434.1:Screencasts
#@+node:ekr.20060829103523:Render Leo slideshows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3889246
By: terry_n_brown

Three packages that might be candidates for "rendering" slides authored in Leo:

MagicPoint: http://member.wide.ad.jp/wg/mgp/

  uses a text file format that leo could produce

Slidy: http://www.w3.org/Talks/Tools/Slidy/

  uses XHTML / canned Java script

S5: http://meyerweb.com/eric/tools/s5/

  Similar to Slidy I think, haven't looked at it
#@nonl
#@-node:ekr.20060829103523:Render Leo slideshows
#@-node:ekr.20060306194040:Video and more screen shots Leo's web site
#@+node:ekr.20060202231708.1:@menu nodes in leoSettings.leo
@nocolor

We could allow uses to define Leo menus.
To do this, we must use minibuffer names for all menu entries

@color
#@nonl
#@-node:ekr.20060202231708.1:@menu nodes in leoSettings.leo
#@-node:ekr.20060527164612:Important 1-2 day projects
#@+node:ekr.20060527182117:Important 1-2 week projects
#@+node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060603085719.1:Use IPython autocompleter?
#@-node:ekr.20060603085719.1:Use IPython autocompleter?
#@+node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@-node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@+node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@-node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@+node:ekr.20060603090445.9:Script button that saves environment between runs
This would allow IPython-like operation.
#@nonl
#@-node:ekr.20060603090445.9:Script button that saves environment between runs
#@-node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060629154112:Merge Leo & jyLeo
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3799470
By: leouser

I guess its hard to say what pieces must merge and what can stay different.
Id like it if the blasted nodes were the same.  I guess there is progress again
on a jython 2.2 being complete and work starting on 2.3.  So there is hope that
the nodes will be the same code, at least it will be possible.

At the top of my head the big differences outside of the position changes are:
1. Some modifications to the read/write code so that Chapters can work and also
Serialized positions.
2. Commander has some things different, it looks to the Chapters instance to
determine what is the curentPosition, top Position etc... instead of keeping
track of it itself.
3. GUI layers are very different.  Interesting tidbit here: the work I did to
get the JTree to use positions to determine if a node is expanded or not looks
like it has provided the outline for enhancing the JTree for Java itself to
be able to do this.  We will have to see, but maybe in Java 7 you can say: "Positions
lead to user controled tree expansion models".

There is a tremendous amount that is the same. Im sure you could make an interesting
evening out of comparing the codebases to see where things change.


#@-node:ekr.20060629154112:Merge Leo & jyLeo
#@-node:ekr.20060527182117:Important 1-2 week projects
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
