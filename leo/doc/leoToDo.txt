#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20070521100324:Marketing/tools
#@+node:ekr.20070521100324.1:Using Leo as a notebook
@nocolor
https://sourceforge.net/forum/message.php?msg_id=4314394
By: duanekaufman

I am starting a kinda 'stream-of-thought' document, one in which I can put down
a paragraph of thought (perhaps in a pretty fashion, using ReST markup), develop
some code, to do some calculations, run the code and display the results...rinse,
repeat.

The document, in pseudo-form, would look like:

<Development of thought #1>
<Code to calculate something>
<Results from code execution>
<Discussion of results>

Each of the above would probably be a node, and I have already put together
things that look like the above, all except for the <results> part. I can run
the code, but how can I get the output automatically in my node? I can cut-and-paste
from the underlying command window (I run under Linux and Windows XP), but I
would like o automate it as much as possible.

Does anyone have any ideas on how to accomodate this workflow?

------ Reply

A most interesting and important question--with such a capability one could make Leo into a full-fledged engineering notebook, e.g., as envisaged by the IPython Notebook project: 

http://projects.scipy.org/ipython/ipython/wiki/NbshellManual 

I can think of several possible approaches: 

1. Create a custom version of the execute script command that would put script output in a particular node. Perhaps the headline of the node could be an argument to the enhanced command. 

2. Have your script write to some 'standard place', and create a command to put that script in the presently selected node. Something like insert-script-output. 

3. Create a script button that executes the script in the presently selected node and puts the result in the node *following* the selected node. You can then either move the node by hand, or use another script button to move the node to a 'standard place', say the last child of the <<results>> node. 

As I write this I think the script-button approach is likely to be the simplest, most flexible and most powerful. I'll look into this myself soon... 

Edward


#@-node:ekr.20070521100324.1:Using Leo as a notebook
#@+node:ekr.20070521105645:Improve api docs with epidoc?
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319363
By: ktenney

I think there is room for improvement in documenting Leo's
API, making it easier to write these kind of scripts.
I'm not sure of the best way to do that.

Epydoc seems to be the most active project in this realm.
http://epydoc.sourceforge.net/epydoc.html
#@-node:ekr.20070521105645:Improve api docs with epidoc?
#@+node:ekr.20060306194040:asap: Video and more screen shots on Leo's web site
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/


http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

Thanks,
Kent
#@nonl
#@+node:ekr.20060531134434:Tutorials
http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
#@nonl
#@-node:ekr.20060531134434:Tutorials
#@+node:ekr.20060531134434.1:Screencasts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3758303
By: ktenney

My sense is that documentation/screencasts has the
greatest potential for expanding Leo's mindshare.

I really like those produced by the good folks
at Dabo;
http://leafe.com/screencasts/
http://leafe.com/screencasts/populategrid.html

The TurboGears people have taken this to the extreme;
http://www.turbogears.org/ultimate.html

Leo is different enough that it warrants a 
demonstration of it's advantages.
#@nonl
#@-node:ekr.20060531134434.1:Screencasts
#@+node:ekr.20060829103523:Render Leo slideshows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3889246
By: terry_n_brown

Three packages that might be candidates for "rendering" slides authored in Leo:

MagicPoint: http://member.wide.ad.jp/wg/mgp/

  uses a text file format that leo could produce

Slidy: http://www.w3.org/Talks/Tools/Slidy/

  uses XHTML / canned Java script

S5: http://meyerweb.com/eric/tools/s5/

  Similar to Slidy I think, haven't looked at it
#@nonl
#@-node:ekr.20060829103523:Render Leo slideshows
#@-node:ekr.20060306194040:asap: Video and more screen shots on Leo's web site
#@+node:ekr.20061130084909:Improve What's special whitepaper
@nocolor

- Answer the question: how can Leo help me with programming?
#@nonl
#@-node:ekr.20061130084909:Improve What's special whitepaper
#@+node:ekr.20070414090051:Study
@nocolor

- launchpad http://launchpad.net 

- bazaar (bzr)
#@nonl
#@-node:ekr.20070414090051:Study
#@-node:ekr.20070521100324:Marketing/tools
#@+node:ekr.20070531075258:Fix problems with @enabled-plugins
#@+node:ekr.20070224075914:doEnabledPlugins
def doEnabledPlugins (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c
    s = p.bodyString()

    # This setting is handled differently from all other settings,
    # because the last setting must be retrieved before any commander exists.

    # g.trace('len(s)',len(s))

    # Set the global config ivars.
    g.app.config.enabledPluginsString = s
    g.app.config.enabledPluginsFileName = c and c.shortFileName() or '<no settings file>'
#@-node:ekr.20070224075914:doEnabledPlugins
#@+node:ekr.20070224075914.1:getEnabledPlugins
def getEnabledPlugins (self):

    """Search all dictionaries for the setting & check it's type"""

    return g.app.config.enabledPluginsString
#@-node:ekr.20070224075914.1:getEnabledPlugins
#@+node:ekr.20031218072017.3440:loadHandlers & helper
def loadHandlers(tag):

    """Load all enabled plugins from the plugins directory"""

    def pr (*args,**keys):
        if not g.app.unitTesting:
            g.es_print(*args,**keys)

    fileName = "pluginsManager.txt"
    plugins_path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_abspath(theFile) for theFile in files]
    s = g.app.config.getEnabledPlugins()
    theConfigFile = g.app.config.enabledPluginsFileName
    # g.trace('len(s)',s and len(s) or 0)
    if s:
        pr('@enabled-plugins found in %s' % (theConfigFile),color='blue')
        enabled_files = getEnabledFiles(s,plugins_path)
    else:
        for theDir,place in (
            (g.app.homeDir,'HOME'),
            (plugins_path,'leo/config')
        ):
            manager_path = g.os_path_join(theDir,fileName)
            if g.os_path_exists(manager_path):
                g.es_print('%s: %s' % (fileName,theDir),color='blue')
                break
        else: pr('%s not found. No plugins will be loaded' % fileName)
        if g.os_path_exists(manager_path):
            << set enabled_files from pluginsManager.txt >>
        else:  return

    # Load plugins in the order they appear in the enabled_files list.
    if files and enabled_files:
        for theFile in enabled_files:
            if theFile in files:
                loadOnePlugin(theFile)

    # Note: g.plugin_signon adds module names to g.app.loadedPlugins
    if 0:
        if g.app.loadedPlugins:
            pr("%d plugins loaded" % (len(g.app.loadedPlugins)), color="blue")
#@+node:ekr.20031218072017.3441:<< set enabled_files from pluginsManager.txt >>
try:
    # New in 4.3: The first reference to a plugin in pluginsManager.txt controls.
    theFile = open(manager_path)
    s = theFile.read()
    pr('Using settings in pluginsManager.txt')
    enabled_files = getEnabledFiles(s,plugins_path)
    theFile.close()
except IOError:
    pr("Can not open: %s"  % manager_path)
    # Don't import leoTest initially.  It causes problems.
    import leoTest ; leoTest.fail()
    return
#@-node:ekr.20031218072017.3441:<< set enabled_files from pluginsManager.txt >>
#@+node:ekr.20070224082131:getEnabledFiles
def getEnabledFiles (s,plugins_path):

    enabled_files = []
    disabled_files = []
    for s in g.splitLines(s):
        s = s.strip()
        if s:
            if g.match(s,0,"#"):
                s = s[1:].strip()
                # Kludge: ignore comment lines containing a blank or not ending in '.py'.
                if s and s.find(' ') == -1 and s[-3:] == '.py':
                    path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                    if path not in enabled_files and path not in disabled_files:
                        # print 'disabled',path
                        disabled_files.append(path)
            else:
                path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                if path not in enabled_files and path not in disabled_files:
                    # print 'enabled',path
                    enabled_files.append(path)

    return enabled_files
#@nonl
#@-node:ekr.20070224082131:getEnabledFiles
#@-node:ekr.20031218072017.3440:loadHandlers & helper
#@-node:ekr.20070531075258:Fix problems with @enabled-plugins
#@+node:ekr.20060531161030:To do: 4.4.3
#@+node:ekr.20070515100356:To do: b2
#@+node:ekr.20070325054325:Docs
#@+node:ekr.20070215093739:Improve Leo's getting started page
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4159734
By: rogererens

Here are some issues with respect to installing Leo on Windows:

I think you should divide the "How to install Leo on Windows" into separate
sections: one section that describes the use of the installer and another one
that describes the use of the .zip-file. In the near future probably Vista deserves
its own section, too.

The notes warn about Python 2.4 and spaces in paths. The installer appears to
work properly with Python 2.5 though, and installing into a path that contains
spaces works fine too, AFAIK. Or are there any usability test cases to check
this?

Also, I would advice the person that is installing Leo to create an environment
variable (either a user variable or a system variable) called HOME with the
value "%USERPROFILE%\My Documents" when %HOME% does not yet exist (check in
a cmd-window by typing "echo %HOME%" without the quotes).
Then, after installing, a user should have the shortcut icon on his/her desktop;
change this by right-clicking and choosing properties to change the directory
where the application starts from the default "C:\Program Files\Leo\test\unittest"
into %HOME%.
I'm not sure if this could all be done automatically by the NSIS installer.

Finally, there's the issue that I installed Leo in the default Program Files
folder, while having the Administrator's role. After which I copied and adapted
the Leo shortcut to the desktop of a user with limited rights.
Unfortunately, when logged on as such a limited user, no plugins can be
enabled/disabled because of the restrictions on writing in program
files\leo\plugin.
(Even if the limited user _could_ write in that folder, it would be problematic:
his set of enabled plugins would overwrite the set of enabled plugins for the
administrator or another user).

Hope this helps to improve the installation experience for novices...
#@-node:ekr.20070215093739:Improve Leo's getting started page
#@+node:ekr.20070218143918:Improve Windows installation instructions
This section is way too confusing:

Users Guide-->Chapter 1: Installing Leo-->@rst html\install.html-->How to install Leo on Windows
#@nonl
#@-node:ekr.20070218143918:Improve Windows installation instructions
#@-node:ekr.20070325054325:Docs
#@+node:ekr.20070515113707:Dist
#@+node:ekr.20070202080824:Enable more plugins by default
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4134565

I have been talking more and more people lately into giving Leo a try. These
are end-users, not programmer-type people. One of the problems I find is that
many features users expect as standard are plug-ins that are disabled at
startup.

From my experience, some of the plug-ins that people seem to want right away
are Cleo, Image, Maximize windows, Export to HTML, and Navibuttons.

Also, everyone seems to ask for spell checking, which I know is a separate install
(I haven't tried putting it in). Perhaps even that could be included?

I think it is a lot easier for power users to turn off things they don't like
than less sophisticated users to turn them on. However, I realize that each
additional plug-in means a longer load time and large memory footprint.

-------------------

From: Rich

These are the plugins that I use often:
Add directives & color markup
Cleo 3
Chapters 2 (unless Chapters works with newer releases, I will stick with Leo 4.4 final)
Group Operations
Nav_buttons
Open_with
RClick
Universal Scrolling

These are the plugins that I do not use too often:
New Buttons
UNL

The following are plugins I would like to use:
Edit Attributes
Conceptual Sort
Labels

"Labels" has a nice assortment of commands; however the labels are (1) not saved
between sessions, and (2) cannot be seen by "Edit Attributes."
I'd be more inclined to use "Edit Attributes" and "C-Sort" IF there was some
way to SEE the attributes (this goes for "Labels," as well).


---- Enable Aspell automatically if possible.

#@-node:ekr.20070202080824:Enable more plugins by default
#@+node:ekr.20070307082503.1:Create Linux distribution
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319356
By: ktenney

> - A proper Ubuntu/Linux distribution 

- "eggification" of Leo

register Leo at http://cheeseshop.python.org/pypi

Pythonistas have come to expect that::

 $ easy_install <app>

will locate and install the most recent version of app and install it.
#@-node:ekr.20070307082503.1:Create Linux distribution
#@-node:ekr.20070515113707:Dist
#@+node:ekr.20070509074834:Rewrite chapters code
#@+node:ekr.20070325104222:Birth...
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.

    '''Finish creating the commander after frame.finishCreate.

    Important: this is the last step in the startup process.'''

    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName())

    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = g.app.gui.createKeyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    c.frame.log.finishCreate()

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)

    c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):

    c = self

    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@+node:ekr.20031218072017.1623:new
def new (self,event=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2176:tkFrame.finishCreate & helpers
def finishCreate (self,c):

    f = self ; f.c = c
    # g.trace('tkFrame')

    self.use_chapters = True and c.config.getBool('use_chapters')

    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBar()
    f.createSplitterComponents()
    f.createStatusLine()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()
    self.trace_status_line = c.config.getBool('trace_status_line')
    # f.enableTclTraces()
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.

    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)

    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("<Button-1>", f.OnActivateLeoEvent)

    f.top.bind("<Control-KeyPress>",f.OnControlKeyDown)
    f.top.bind("<Control-KeyRelease>",f.OnControlKeyUp)

    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    # f.top.bind("<Activate>",f.OnActivateLeoEvent)
    # f.top.bind("<Deactivate>",f.OnDeactivateLeoEvent)

    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
#@nonl
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20051009045208:createSplitterComponents
def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)

    # Create the canvas, tree, log and body.
    if self.use_chapters:
        c.chapterController = cc = leoChapters.chapterController(c)

    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)

    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl

    # Configure.
    f.setTabWidth(c.tab_width)
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
#@nonl
#@-node:ekr.20051009045208:createSplitterComponents
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):

    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot(oldRoot=None)
    c.setRootPosition(p) # New in 4.4.2.
    c.editPosition(p)
#@-node:ekr.20051009045404:createFirstTreeNode
#@+node:ekr.20051121092320:f.enableTclTraces
def enableTclTraces (self):

    c = self.c

    # pychecker complains that trace/untracewidget are not used.

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)

    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)

    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("<FocusIn>")
    # c.frame.bar1.unbind_all("<FocusOut>")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("<FocusIn>", focusIn)
        w.bind_all("<FocusOut>", focusOut)
    else:
        w.bind_all("<Control-1>", tracewidget)
        w.bind_all("<Control-Shift-1>", untracewidget)
#@-node:ekr.20051121092320:f.enableTclTraces
#@-node:ekr.20031218072017.2176:tkFrame.finishCreate & helpers
#@+node:ekr.20070325104904:cc.finishCreate
def finishCreate (self):

    '''Find or make the @chapters and @chapter trash nodes.'''

    # This must be called late in the init process:
    # at present, called by g.openWithFileName and c.new.

    cc = self ; c = cc.c

    # Create the @chapters node if needed, and set cc.chaptersNode.
    if not cc.chaptersNode and not cc.findChaptersNode():
        cc.createChaptersNode()

    # Create the main chapter
    cc.chaptersDict['main'] = chapter(c=c,chapterController=cc,name='main',root=c.rootPosition())

    tag = '@chapter'
    for p in c.allNodes_iter():
        h = p.headString()
        if h.startswith(tag):
            tabName = h[len(tag):].strip()
            if tabName and tabName not in ('main',):
                if cc.chaptersDict.get(tabName):
                    self.error('duplicate chapter name: %s' % tabName)
                else:
                    cc.chaptersDict[tabName] = chapter(c=c,chapterController=cc,name=tabName,root=p)

    cc.selectChapterByName('main')
#@nonl
#@-node:ekr.20070325104904:cc.finishCreate
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(fileName)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        k and k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20070327103016:tkTree.setCanvasBindings
def setCanvasBindings (self,canvas):

    k = self.c.k

    canvas.bind('<Key>',k.masterKeyHandler)
    canvas.bind('<Button-1>',self.onTreeClick)

    << make bindings for tagged items on the canvas >>
    << create baloon bindings for tagged items on the canvas >>
#@nonl
#@+node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '<Button-1>',self.onClickBoxClick),
    ('iconBox','<Button-1>',self.onIconBoxClick),
    ('iconBox','<Double-1>',self.onIconBoxDoubleClick),
    ('iconBox','<Button-3>',self.onIconBoxRightClick),
    ('iconBox','<Double-3>',self.onIconBoxRightClick),
    ('iconBox','<B1-Motion>',self.onDrag),
    ('iconBox','<Any-ButtonRelease-1>',self.onEndDrag),
)
for tag,event,callback in table:
    canvas.tag_bind(tag,event,callback)
#@-node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
#@+node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
if 0: # I find these very irritating.
    for tag,text in (
        # ('plusBox','plusBox'),
        ('iconBox','Icon Box'),
        ('selectBox','Click to select'),
        ('clickBox','Click to expand or contract'),
        # ('textBox','Headline'),
    ):
        # A fairly long wait is best.
        balloon = Pmw.Balloon(self.canvas,initwait=700)
        balloon.tagbind(self.canvas,tag,balloonHelp=text)
#@-node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
#@-node:ekr.20070327103016:tkTree.setCanvasBindings
#@+node:ekr.20051024102724:tkTtree.setBindings
def setBindings (self,):

    '''Create master bindings for all headlines.'''

    tree = self ; k = self.c.k ; canvas = self.canvas

    # g.trace('self',self,'canvas',canvas)

    << make bindings for a common binding widget >>

    tree.setCanvasBindings(canvas)

    k.completeAllBindingsForWidget(canvas)

    k.completeAllBindingsForWidget(self.bindingWidget)

#@+node:ekr.20060131173440:<< make bindings for a common binding widget >>
self.bindingWidget = w = g.app.gui.plainTextWidget(
    self.canvas,name='bindingWidget')

w.bind('<Key>',k.masterKeyHandler)

table = (
    ('<Button-1>',       k.masterClickHandler,          tree.onHeadlineClick),
    ('<Button-3>',       k.masterClick3Handler,         tree.onHeadlineRightClick),
    ('<Double-Button-1>',k.masterDoubleClickHandler,    tree.onHeadlineClick),
    ('<Double-Button-3>',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
)

for a,handler,func in table:
    def treeBindingCallback(event,handler=handler,func=func):
        # g.trace('func',func)
        return handler(event,func)
    w.bind(a,treeBindingCallback)

self.textBindings = w.bindtags()
#@-node:ekr.20060131173440:<< make bindings for a common binding widget >>
#@-node:ekr.20051024102724:tkTtree.setBindings
#@-node:ekr.20070325104222:Birth...
#@+node:ekr.20070509075200:Drawing stuff
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):

    """Draws the top-level tree, taking into account the hoist state."""

    c = self.c ; canvas = self.canvas
    trace = False or self.trace or self.trace_redraw

    self.redrawing = True

    # Recycle all widgets and clear all widget lists.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.redrawCount += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if trace:
        g.trace('redrawCount',self.redrawCount,'len(c.hoistStack)',len(c.hoistStack)) # g.callers())
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())

    self.prevPositions = g.app.positions
    if self.trace_gc: g.printNewObjects(tag='top 1')

    if c.hoistStack:
        bunch = c.hoistStack[-1] ; p = bunch.p
    else:
        p = c.rootPosition()

    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=c.hoistStack)

    if self.trace_gc: g.printNewObjects(tag='top 2')
    if self.trace_stats: self.showStats()

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y ; h1 = None
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data

    while p: # Do not use iterator.
        # This is the ONLY copy of p that needs to be made;
        # no other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h # Set h1 *after* calling drawNode.
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
    # Draw the vertical line.
    if h1 is None: h1 = h
    y2 = g.choose(level==0,yfirst+(h1-1)/2,yfirst-h1/2-1)
    self.drawLine(None,x,y2,x,ylast+self.hline_y-h)
    return y
#@-node:ekr.20040803072955.53:drawTree
#@-node:ekr.20070509075200:Drawing stuff
#@+node:ekr.20070509081411.2:Creating a new chapter
#@+node:ekr.20070317085437.31:cc.createChapter
def createChapter (self,event=None,name=None):

    ### To do: use minibuffer to get the chapter name,
    ### Then call cc.createChapterByName.

    pass
#@nonl
#@-node:ekr.20070317085437.31:cc.createChapter
#@+node:ekr.20031218072017.1759:Insert, Delete & Clone (Commands)
#@+node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if warningFlag:
                g.alert(message)
            return False
    return True
#@-node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if p.hasVisBack(): newNode = p.visBack()
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    try:
       c.endEditing() # Make sure we capture the headline for Undo.
       undoData = u.beforeDeleteNode(p)
       dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
       p.doDelete()
       c.selectPosition(newNode)
       c.setChanged(True)
       u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()

    c.validateOutline()
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node"):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if (
            (current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)
        ):
            if c.config.getBool('insert_new_nodes_at_end'):
                p = current.insertAsLastChild()
            else:
                p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
    c.beginUpdate()
    try:
        c.editPosition(p,selectAll=True)
    finally:
        c.endUpdate(False)

    return p # for mod_labels plugin.
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20031218072017.1762:c.clone
def clone (self,event=None):

    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone()
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    finally:
        c.endUpdate()

    return clone # For mod_labels and chapters plugins.
#@-node:ekr.20031218072017.1762:c.clone
#@+node:ekr.20031218072017.1765:c.validateOutline
# Makes sure all nodes are valid.

def validateOutline (self,event=None):

    c = self

    if not g.app.debug:
        return True

    root = c.rootPosition()
    parent = c.nullPosition()

    if root:
        return root.validateOutlineWithParent(parent)
    else:
        return True
#@-node:ekr.20031218072017.1765:c.validateOutline
#@-node:ekr.20031218072017.1759:Insert, Delete & Clone (Commands)
#@+node:ekr.20070509081915.1:cc.createChild
def createChild (self,parent,s):

    '''Create a child node of parent without changing the undo stack.
    set the headString of the new node to s.'''

    c = self.c

    # g.trace('parent',parent,'s',s)

    p = parent.insertAsLastChild()
    p.initHeadString(s)
    c.setChanged(True)

    return p
#@-node:ekr.20070509081915.1:cc.createChild
#@-node:ekr.20070509081411.2:Creating a new chapter
#@+node:ekr.20070603162533:Save commands
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    c.beginUpdate()
    try:
        if c.mFileName != "":
            # Calls c.setChanged(False) if no error.
            c.fileCommands.save(c.mFileName)
        else:
            fileName = g.app.gui.runSaveFileDialog(
                initialfile = c.mFileName,
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
            c.bringToFront()

            if fileName:
                # Don't change mFileName until the dialog has suceeded.
                c.mFileName = g.ensure_extension(fileName, ".leo")
                c.frame.title = c.mFileName
                c.frame.setTitle(g.computeWindowTitle(c.mFileName))
                c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
                c.fileCommands.save(c.mFileName)
                c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save As",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # 7/2/02: don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            # Calls c.setChanged(False) if no error.
            c.fileCommands.saveAs(c.mFileName)
            c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2835:saveAs
#@-node:ekr.20070603162533:Save commands
#@+node:ekr.20070603174534:currentPosition & rootPosition stuff
#@+node:ekr.20060906134053:c.findRootPosition New in 4.4.2
@ Aha! The Commands class can easily recompute the root position::

    c.setRootPosition(c.findRootPosition(p))

Any command that changes the outline should call this code.

As a result, the fundamental p and v methods that alter trees need never
convern themselves about reporting the changed root.  A big improvement.
@c

def findRootPosition (self,p):

    '''Return the root position of the outline containing p.'''

    c = self ; p = p.copy()

    while p and p.hasParent():
        p.moveToParent()
        # g.trace(p.headString(),g.callers())

    while p and p.hasBack():
        p.moveToBack()

    # g.trace(p and p.headString())

    return p
#@nonl
#@-node:ekr.20060906134053:c.findRootPosition New in 4.4.2
#@+node:ekr.20040803140033.1:c.setCurrentPosition
def setCurrentPosition (self,p):

    """Set the presently selected position. For internal use only.

    Client code should use c.selectPosition instead."""

    c = self ; cc = c.chapterController

    # g.trace(p.headString(),g.callers())

    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()

        # New in Leo 4.4.2: always recompute the root position here.
        # This *guarantees* that c.rootPosition always returns the proper value.
        newRoot = c.findRootPosition(c._currentPosition)
        if newRoot:
            c.setRootPosition(newRoot)
        # This is *not* an error: newRoot can be None when switching chapters.
        # else: g.trace('******** no new root')
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@nonl
#@-node:ekr.20040803140033.1:c.setCurrentPosition
#@+node:ekr.20040803140033.3:c.setRootPosition
def setRootPosition(self,p):

    """Set the root positioin."""

    c = self

    # g.trace(p and p.headString(),g.callers())

    if p:
        # Important: p.equal requires c._rootPosition to be non-None.
        if c._rootPosition and p.equal(c._rootPosition):
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None
#@nonl
#@-node:ekr.20040803140033.3:c.setRootPosition
#@-node:ekr.20070603174534:currentPosition & rootPosition stuff
#@+node:ekr.20070509075654.1:Selection stuff
#@+node:ekr.20070317131708:chapter.findPositionInChapter
def findPositionInChapter (self,p1):

    '''Return a valid position p such that p.v == v.'''

    # Do nothing if the present position is in the proper chapter.
    c = self.c ; name = self.name 

    root = g.choose(self.name=='main',c.rootPosition(),self.root)
    # g.trace('root',root,'p',p)
    if p1 and c.positionExists(p1,root=root):
        # g.trace('using existing position',p)
        return p1

    if name == 'main':
        for p in self.c.allNodes_iter():
            if p.v == p1.v:
                # g.trace('*** found in main chapter',p)
                self.p = p.copy()
                return self.p
        self.p = c.rootPosition()
    else:
        for p in self.root.self_and_subtree_iter():
            if p.v == p1.v:
                # g.trace('*** found in chapter',p)
                self.p = p.copy()
                return self.p
        self.p = self.root.copy()

    if 1:
        self.error('***** findPositionInChapter: lost %s in %s' % (
            p1.v.t.headString,self.name))
        g.trace(g.callers())

    return self.p.copy()
#@-node:ekr.20070317131708:chapter.findPositionInChapter
#@+node:ekr.20070424084012:switchToChapter (leoBody)
def switchToChapter (self,w):

    '''select w.leo_chapter.'''

    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            # g.trace('===','old',oldChapter.name,'new',name,w.leo_p)
            cc.selectChapterByName(name)
            c.bodyWantsFocusNow()
#@-node:ekr.20070424084012:switchToChapter (leoBody)
#@+node:ekr.20031218072017.2997:c.selectPosition
def selectPosition(self,p,updateBeadList=True):

    """Select a new position."""

    c = self

    # g.trace(p.headString(),g.callers())

    c.frame.tree.select(p,updateBeadList)

    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
#@-node:ekr.20031218072017.2997:c.selectPosition
#@+node:ekr.20070317131205.1:chapter.select & helpers
def select (self,w=None,selectEditor=True):

    '''Restore chapter information and redraw the tree when a chapter is selected.'''

    if self.selectLockout: return

    try:
        self.selectLockout = True
        self.chapterSelectHelper(w,selectEditor)
    finally:
        self.selectLockout = False
#@+node:ekr.20070423102603.1:chapterSelectHelper
def chapterSelectHelper (self,w=None,selectEditor=True):

    c = self.c ; cc = self.cc ; name = self.name

    g.trace(name,'self.p',self.p,'self.root',self.root) # 'w.leo_p',w and w.leo_p)

    cc.selectedChapter = self

    # Next, recompute p and possibly select a new editor.
    if w:
        assert w == c.frame.body.bodyCtrl
        assert w == c.frame.bodyCtrl
        assert w.leo_p
        ### root = w.leo_p or self.root.firstChild() or self.root
        self.p = p = self.findPositionInChapter(w.leo_p)
        if p != w.leo_p: g.trace('****** can not happen: lost p',w.leo_p)
    else:
        # This must be done *after* switching roots.
        target_p = self.p or self.root.firstChild() or self.root
        self.p = p = self.findPositionInChapter(target_p)
        if selectEditor:
            w = self.findEditorInChapter(p)
            c.frame.body.selectEditor(w) # Switches text.

    c.beginUpdate()
    try:
        if name == 'main' and cc.chaptersNode:
            cc.chaptersNode.contract()    
        c.hoistStack = self.hoistStack[:]
        c.selectPosition(p)
    finally:
        c.endUpdate()
        c.bodyWantsFocusNow()
#@nonl
#@-node:ekr.20070423102603.1:chapterSelectHelper
#@+node:ekr.20070317131708:chapter.findPositionInChapter
def findPositionInChapter (self,p1):

    '''Return a valid position p such that p.v == v.'''

    # Do nothing if the present position is in the proper chapter.
    c = self.c ; name = self.name 

    root = g.choose(self.name=='main',c.rootPosition(),self.root)
    # g.trace('root',root,'p',p)
    if p1 and c.positionExists(p1,root=root):
        # g.trace('using existing position',p)
        return p1

    if name == 'main':
        for p in self.c.allNodes_iter():
            if p.v == p1.v:
                # g.trace('*** found in main chapter',p)
                self.p = p.copy()
                return self.p
        self.p = c.rootPosition()
    else:
        for p in self.root.self_and_subtree_iter():
            if p.v == p1.v:
                # g.trace('*** found in chapter',p)
                self.p = p.copy()
                return self.p
        self.p = self.root.copy()

    if 1:
        self.error('***** findPositionInChapter: lost %s in %s' % (
            p1.v.t.headString,self.name))
        g.trace(g.callers())

    return self.p.copy()
#@-node:ekr.20070317131708:chapter.findPositionInChapter
#@+node:ekr.20070425175522:chapter.findEditorInChapter
def findEditorInChapter (self,p):

    '''return w, an editor displaying position p.'''

    chapter = self ; c = self.c

    w = c.frame.body.findEditorForChapter(chapter,p)
    w.leo_chapter = chapter
    w.leo_p = p and p.copy()
    return w
#@nonl
#@-node:ekr.20070425175522:chapter.findEditorInChapter
#@+node:ekr.20070529171934.1:chapter.rename (not used)
def rename (self,newName):

    p = self.root
    s = '@chapter ' + newName
    p.setHeadString(s)
#@-node:ekr.20070529171934.1:chapter.rename (not used)
#@-node:ekr.20070317131205.1:chapter.select & helpers
#@-node:ekr.20070509075654.1:Selection stuff
#@-node:ekr.20070509074834:Rewrite chapters code
#@-node:ekr.20070515100356:To do: b2
#@-node:ekr.20060531161030:To do: 4.4.3
#@+node:ekr.20070325052041:To do: 4.4.4 (@auto)
#@+node:ekr.20070512162750:@url http://simpleparse.sourceforge.net/
#@-node:ekr.20070512162750:@url http://simpleparse.sourceforge.net/
#@+node:ekr.20061006165447:Let import commands decide what kind of import to do
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3940843
By: ktenney

>the distiction between importing 'foreign' text files and importing derived
files created by Leo.

Couldn't Leo make this distinction by looking at
the file being imported? If so, I think it should.

This could eliminate a lot of confusion IMO, if
I want to bring a file into a node, just
'import' it, and the right thing happens.

An emergency measure could be available in a 
'File Special' menu.
#@nonl
#@-node:ekr.20061006165447:Let import commands decide what kind of import to do
#@+node:ekr.20070324084040:Prototype of @auto
#@+node:ekr.20070324084040.1:NEWscanPythonText
def NEWscanPythonText (self,s,parent):

    scanner = self.pythonScanner(self,s,parent)

    scanner.parse()
        # Discover the node boundaries.
    scanner.checkWhitespace()
        # Check that whitespace passes TabNanny.
        # Check that whitespace is compatible with @tabwidth.
        # Check for underindented lines.
    scanner.generateNodes()
        # Generate a single node if there are errors,
        # otherwise generate the imported tree.
    scanner.checkImport()
        # Do trial write, verify that it would produce the original file.
        # Insert an @ignore directive in the root if there are errors.
#@nonl
#@-node:ekr.20070324084040.1:NEWscanPythonText
#@+node:ekr.20070324084040.13:class pythonScanner (not ready yet)
class pythonScanner:

    @others

#@+node:ekr.20070324084040.14:ctor (pythonScanner)
def __init__ (self,importer,s,parent):

    baseScannerClass.__init__(self,importer)
        # Init the base class.
        # Copies ivars from importer class to scanner class.

    # Other ivars.
    self.preamble_seen = False
    self.s = s
    self.className = None
    self.methodsSeen = False
    self.root = parent
    self.start = 0
#@-node:ekr.20070324084040.14:ctor (pythonScanner)
#@+node:ekr.20070324084040.15:scanPythonText
# See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    c = self.c
    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << handle possible Python function or class >>
        else: i += 1
        assert(progress < i)
    if not decls_seen: # 2/17/03
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
    << Append a reference to the methods of this file >>
    << Append any unused python text to the parent's body text >>
#@+node:ekr.20070324084040.16:<< Append a reference to the methods of this file >>
if self.treeType == "@root" and self.methodsSeen:
    c.appendStringToBody(parent,
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
#@-node:ekr.20070324084040.16:<< Append a reference to the methods of this file >>
#@+node:ekr.20070324084040.9:<< handle possible Python function or class >> (NOT USED)
if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file":
            c.appendStringToBody(parent,"@others\n")
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)
#@-node:ekr.20070324084040.9:<< handle possible Python function or class >> (NOT USED)
#@+node:ekr.20070324084040.17:<< Append any unused python text to the parent's body text >>
# Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i < len(s):
    c.appendStringToBody(parent,s[start:])
#@-node:ekr.20070324084040.17:<< Append any unused python text to the parent's body text >>
#@-node:ekr.20070324084040.15:scanPythonText
#@+node:ekr.20070324084040.18:doPythonClass & helpers
def doPythonClass (self,i,parent):

    c = self.c ; s = self.s

    if not self.preamble_seen:
        self.doPreamble(i)

    class_indent = self.getLeadingIndent(s,i)
    i,className,headline = self.getClassHeadline(i)
    if self.className:
        oldClassName = self.className
        self.className = className
        i = g.skip_line(s,i) # Skip the class line.
        i,prefix,body = self.createClassNodeText(s,i,start)
        class_vnode = self.createHeadline(parent,prefix + body,headline)
        start,i = self.scanPythonClass(i,class_indent,class_vnode)
        s2 = s[start:i]
        if s2: c.appendStringToBody(class_vnode,s2)
        self.className = oldClassName

    return i
#@nonl
#@+node:ekr.20070324084040.19:getClassHeadline
# Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    class_name = s[j:i]
    headline = "class " + class_name
else:
    headline = ''
    class_name = ''
#@-node:ekr.20070324084040.19:getClassHeadline
#@+node:ekr.20070324084040.20:createParentText
def createParentText (self,class_vnode,class_name):

    '''Insert the proper body text in the class_vnode.'''

    c = self.c

    # This must be done after the declaration reference is generated.
    if self.treeType == "@file":
        c.appendStringToBody(class_vnode,"\t@others\n")
    else:
        ref = g.angleBrackets(' class %s methods ' % (class_name))
        c.appendStringToBody(class_vnode,"\t" + ref + "\n\n")
#@-node:ekr.20070324084040.20:createParentText
#@+node:ekr.20070324084040.21:createClassNodeText
def createClassNodeText (self,s,i,start):

    # Create the section name using the old value of self.methodName.
    if  self.treeType == "@file":
        prefix = ""
    else:
        prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
        self.methodsSeen = True

    # i points just after the class line.

    # Add a docstring to the class node.
    docStringSeen = False
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j != len(s): # No scanning error.
            i = j ; docStringSeen = True

    body = s[start:i]
    body = self.undentBody(body)
    if docStringSeen: body = body + '\n'

    return i,prefix,body
#@-node:ekr.20070324084040.21:createClassNodeText
#@-node:ekr.20070324084040.18:doPythonClass & helpers
#@+node:ekr.20070324084040.22:doPythonDef
def doPythonDef (self,i,parent):

    if not self.preamble_seen:
        self.doPreamble(i)

    i = self.scanPythonDef(i,parent)

    return i
#@nonl
#@-node:ekr.20070324084040.22:doPythonDef
#@+node:ekr.20070324084040.23:doPreamble
def doPreamble (self,i):

    self.preamble_seen = True

    if i > 0:
        # Append the preamble to the root's body text.
        c.appendStringToBody(self.root,s[:i])

    if self.treeType == '@file':
        c.appendStringToBody(self.root,'@others\n')
#@-node:ekr.20070324084040.23:doPreamble
#@+node:ekr.20070324084040.24:scanPythonClass
def scanPythonClassHelper(self,s,i,class_indent,class_name,class_vnode):

    indent =  self.getLeadingIndent(s,i)
    start = i = g.skip_blank_lines(s,i)
    parent_vnode = None
    while i < len(s):
        progress = i
        # New in Leo 4.4.1: ignore comment lines, whatever their indentation.
        if indent <= class_indent:
            j = g.skip_ws(s,i)
            if g.match(s,j,'#'):
                i = g.skip_to_end_of_line(s,j)
            else: break
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            j = g.skip_nl(s,i)
            if not backslashNewline:
                indent = self.getLeadingIndent(s,j)
                if indent > class_indent: i = j
                else: break
            else: i = j
        elif g.match_c_word(s,i,"def"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonDef(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif g.match_c_word(s,i,"class"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonClass(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
        elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
        else: i += 1
        assert(progress < i)
    return start,i
#@-node:ekr.20070324084040.24:scanPythonClass
#@+node:ekr.20070324084040.25:scanPythonDef & helpers
def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    << set headline or return i >>
    i = self.skipPythonDef(s,i,start)
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    << Create def node >>
    self.methodName = savedMethodName
    return i
#@+node:ekr.20070324084040.26:createDefNode
# Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)
#@-node:ekr.20070324084040.26:createDefNode
#@+node:ekr.20070324084040.27:getDefHeadline
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i
#@-node:ekr.20070324084040.27:getDefHeadline
#@-node:ekr.20070324084040.25:scanPythonDef & helpers
#@+node:ekr.20070324084040.28:skipPythonDef
def skipPythonDef (self,s,i,start):

    # g.trace(g.get_line(s,i))

    # Set defIndent to the indentation of the def line.
    defIndent = self.getLeadingIndent(s,start)
    parenCount = 0
    << skip the entire signature >>
    indent = self.getLeadingIndent(s,i)
    while i < len(s): # and indent > defIndent
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            if not backslashNewline:
                # New in Leo 4.4.1: don't set indent for comment lines.
                j = g.skip_ws(s,i)
                if not g.match(s,j,'#'):
                    indent = self.getLeadingIndent(s,i)
                    if indent <= defIndent and parenCount == 0:
                        break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)

    return i
#@+node:ekr.20070324084040.29:<< skip the entire signature >>
# Now that we count parens, we must be careful to skip the entire signature.

j = s.find('(',i)
if j != -1:
    j = g.skip_matching_python_parens(s,j)

if j == -1 or not g.match(s,j+1,':'):
    g.es_print('Warning: improper signature: %s' % g.get_line(s,i))
    return i
else:
    i = g.skip_line(s,j) # Still not quite 100% correct.
#@-node:ekr.20070324084040.29:<< skip the entire signature >>
#@-node:ekr.20070324084040.28:skipPythonDef
#@-node:ekr.20070324084040.13:class pythonScanner (not ready yet)
#@-node:ekr.20070324084040:Prototype of @auto
#@+node:ekr.20051202094427:Resolve cvs conflicts
Investigate meld:  http://meld.sourceforge.net/
#@nonl
#@+node:ekr.20060601073503:Postings
@nocolor
#@nonl
#@+node:ekr.20031218072017.658:Stepen Schaefer 1
@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
#@-node:ekr.20031218072017.658:Stepen Schaefer 1
#@+node:ekr.20050501111900:Stephen Schaefer 2
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3125092
By: thyrsus

About a month ago, I posted a screed on how @thin was inadequate to address
my needs; that what I needed to collaborate on via version control was exactly
the essence of Leo's value: the multiple expressions of structure, which by
their nature must exist outside of @thin.  I said I was going to live the pain
to discover a modus vivendi.

Having done that, let me now say:

AAAAAAAAAAAAGGGGGGGGHHHHHHHHHH!

But the exercise has led me to a vision, which I will implement to the extent
my nonexistent spare time and paltry programming talents permit.

The essence of the pain is "conflicts", which become more  certain to occur
as the leo file encompases ever more related files.  As I work on a change to
the Linux configuration, my colleague works on a change to the Solaris configuration,
and one of us checks in our version of the leo file documenting the site
configuration first, and the other cannot check in his version of that file.
The conflict must be resolved by the human.  Using the "diff" tool on the .leo
XML is not an answer (though thank Heaven and Ed for gnxs).  The resolution
needs two levels of support: outline and node.

With the .leo file declared binary, in the event of a conflict CVS leaves you
with the most recent CVS version and your rejected version, and you're responsible
for performing a reconciliation and then resubmitting that.  Leo will recognize
the problem, and present both versions of the project, side by side, splitting
the outline pane.  The parallel trees will scroll/expand/contract in unison.
Outline branches present in CVS and not yours will display as blank space in
your version; nodes present in your version and not CVS will display as blank
space in the CVS version. The CVS version will be read only, your version editable.
The same node with differences in its text or in its children will be highlighted.
You will be able to drag nodes from the CVS version into your version. If the
text of a selected node has conflicts, the text area will split in two, showing
the CVS version and your version, with differences highlighted, both sides of
the pane scrolling in unison, the CVS side read-only, and you can copy from
that side to your side.  I intend to take as many ideas as I can from tkdiff
(http://sourceforge.net/projects/tkdiff/ - see also
http://freshmeat.net/screenshots/10602/ ).  (I have begun translating tkdiff
from from tcl to python - nearly 9000 lines and I'm still learning both languages,
so draw your own timeline.)  You edit your nodes, you edit your tree, you hit
the "reconcile" button, and your reconciliation of the conflict goes into CVS.
If, meanwhile, another one of your over-achieving colleages has again updated
CVS, the process repeats with the most current CVS version.  Or you can hit
the "abandon" button to give up on your changes.

As the Hebrews say at Passover: "Next year in Jerusalem."
#@nonl
#@-node:ekr.20050501111900:Stephen Schaefer 2
#@+node:ekr.20031218072017.659:Jonathon 1
@nocolor

http://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

In the .leo, if I edit <<bar>>, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@verbatim
#@+leo
#@verbatim
#@+node:0::@file foo.py
#@verbatim
#@+body
#@verbatim
#@+others
#@verbatim
#@+node:1::definition of a
#@verbatim
#@+body
print "a:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"bar"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:1::definition of a
#@verbatim
#@+node:2::definition of b
#@verbatim
#@+body
print "b:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation b"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:2::definition of b
#@verbatim
#@+node:3::definition of c
#@verbatim
#@+body
print "c:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation c"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:3::definition of c
#@verbatim
#@-others
#@verbatim
#@-body
#@verbatim
#@-node:0::@file foo.py
#@verbatim
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
#@-node:ekr.20031218072017.659:Jonathon 1
#@+node:ekr.20031218072017.660:Jonathan 2
@nocolor

By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

<<<<<<< 
blah blah blah? 
======= 
blah blah blah! 
>>>>>>> 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  
#@-node:ekr.20031218072017.660:Jonathan 2
#@+node:ekr.20031218072017.661:Gil 1
http://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
#@-node:ekr.20031218072017.661:Gil 1
#@+node:ekr.20031218072017.662:Gil 2
http://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?
#@nonl
#@-node:ekr.20031218072017.662:Gil 2
#@-node:ekr.20060601073503:Postings
#@-node:ekr.20051202094427:Resolve cvs conflicts
#@+node:ekr.20040919182750.1:Better handling of whitespace (cvs fiendly)
http://sourceforge.net/forum/message.php?msg_id=3578166
#@nonl
#@+node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
#@+node:ekr.20060808103849:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2674828
By: bwmulder

If I understand correctly, there are two different problems:

- Trailing whitespaces
- Left indented comments

1. Before commenting on these, a question:

If I write something like
    a=b
    if a:
        @others

[four spaces indentation]

I sometimes see tab characters before the lines inserted for '@others'.

It seems that Leo remembers 'two levels of indentation', and then
fabricates this indentation using tab characters.

I think it might be more robust if Leo remembered the actual
characters in front of @others and would use them for indentation.

I suspect that many indentation errors I had with Leo could have been
avoided had not Leo had its own ideas on how to do indentation.

Maybe Leo could use the exact sequence of characters in front of
@others for all inserted lines?

2. I do not care much about trailing whitespaces. Most of the time
they are invisible, but sometimes they are very misleading (trailing in python or C).

As far as I am concerned, Leo need never produce trailing whitespaces.

Maybe we need special machinery if sources have trailing whitespaces
and the sources are not under our control. 

Not sure if everybody would be happy if we essentially ban all trailing
whitespaces.

3. Unindented commentlines could be dealt with by using indentation to
indicate structure.

Of course, this might break the correspondance Leo structure / Python
structure, which is very ugly.

4. One possible alternative might be a new directive which indicates outindent:

@outindent <number>.

This would apply to the next comment block.

To me, 4. looks a little bit less ugly than 3.

5. As indicated in a different post, I suspect that Leo has a problem
if almost every node in an outline is changed. Profiling should point
to the culprit.

> 2. Have Leo strip whitespace from otherwise blank lines, and hope
that that solves all problems in Perfect Import. This is solving the
problem in the atFile code. The problem is that if we apply settings
in general we will get massive changes to derived files. In most
programming settings these changes might be welcome, but the problem
is actually making these changes. My first few attempts met with
abject failure.

Are you saying that you could not remove trailing blanks? What kind of
problems did you run into?

Summary:
- Use actual characters in front of @others or <<>> for indentation.
- Don't write trailing whitespaces
- Introduce directive for left-indendet comments.
- Profile to find out what slows Leo down if many nodes change.
#@nonl
#@-node:ekr.20060808103849:Report
#@+node:ekr.20041005105605.210:putIndent
def putIndent(self,n):

    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w > 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
#@-node:ekr.20041005105605.210:putIndent
#@-node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
#@+node:EKR.20040603092958.1:Add new options for handling newlines in body text
@nocolor

- "asis":
- "zero": no trailing newlines.
- "one": exactly one trailing newline.

Special case code is required so empty nodes stay empty with "one" option.
#@nonl
#@-node:EKR.20040603092958.1:Add new options for handling newlines in body text
#@-node:ekr.20040919182750.1:Better handling of whitespace (cvs fiendly)
#@-node:ekr.20070325052041:To do: 4.4.4 (@auto)
#@+node:ekr.20070105135713:To do: 4.5 (new positions)
#@+node:ekr.20061028070132:New positions
# None of this code is part of Leo's core yet: it is all highly experimental.

# Important: the new vnode class implies that the read code must be rewritten to be similar to the opml read code.
#@nonl
#@+node:ekr.20070512131018:Thoughts about positions 1
http://sourceforge.net/forum/message.php?msg_id=4308503

@nocolor

After more thought I am ready to back off my earlier post. Positions are perfectly reasonable things to support. Indeed, they can be, and probably should be, coequal with iterators. 

My 'revulsion' to positions stems from their present implementation--the 'optimization' of positions to avoid adding items to p.stack is certainly the worst optimization presently in Leo. It dates from the days when I was obsessing about reducing the amount of positions created. That was a valid concern then, but Leo now does an excellent job of not generating excess positions. Thus, there is no reason not to have p.stack contain all the parent vnodes at the present spot in a traversal. 

The idea of representing a position by a count in a traversal is cute, but of no practical importance. Indeed, why should Leo be forced to stupidly step through an entire traversal when a list of vnodes in p.stack would get to the proper spot in exponentially shorter time. Moreover, a list of vnodes in p.stack is great information to have, while a count N is almost exactly useless :-) 

Still, it is good to emphasize that *any* position, no matter how it is represented, makes sense *only* for a particular outline, that is, for a particular set of vnodes. In short, positions will stay, but will be reimplemented for the graph world. 
#@nonl
#@-node:ekr.20070512131018:Thoughts about positions 1
#@+node:ekr.20070512130855:Thoughts about positions 2
@nocolor

There will be some significant changes to the position and vnode classes for the graph world (Leo 4.5).  These changes will be common to both the graph and clone worlds:

Only vnode methods will be allowed to alter outline/graph data.  This would have been a good rule to following earlier, but up until now Leo has allowed 'confused' scripts--script that treat positions like vnodes.  This confusion will not be allowed in Leo 4.5.  The need for strict separation between vnodes and positions has become apparent in the recent chapters work.

It would be best to think of a position as a *path* to a particular vnode.  In the present (clone) world, the path is used exclusively by the tree drawing logic.  That logic tests whether the node being drawn matches (has the same position) as c.currentPosition.  In the graph world it probably makes sense to speak only of the current *vnode*, say v, so a position p is *a* current position if p.v == v.

The (renewed) focus on vnodes will be necessary.  For example, there will be no such things as p.back() or v._back in the graph world.  That is, a vnode v will have no *intrinsic* siblings.  Instead, siblings are relative to a parent: the order of vnodes in the parent.children links implicitly define sibling relationships, but a vnode v may have many 'parents', i.e. there may be many nodes that point to v.  We could speak of 'siblings with respect to a particular parent', but I suspect that will not be a particularly useful concept.  Rather, it will probably be more natural simply to define node relationships using iterators.  We shall see...
#@-node:ekr.20070512130855:Thoughts about positions 2
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.use_new_positions = False

    # New positions require the sax-based read code.
    self.use_sax = self.use_new_positions or c.config.getBool('use_sax_based_read')

    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5
    if self.use_sax:
        self.currentVnode = None
        self.rootVnode = None
    else:
        self.fileBuffer = None
        self.fileIndex = 0
        self.currentVnodeStack = [] # A stack of vnodes giving the current position.
        self.topVnodeStack     = [] # A stack of vnodes giving the top position.
        self.topPosition = None
    # For writing
    self.read_only = False
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@nonl
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061029093342.75:linkParentAndChildren (changed)
def linkParentAndChildren (self, parent_v, children):

    # if children: g.trace(parent_v,len(children))

    if self.use_new_positions:
        parent_v.t.links = children
    else:
        firstChild_v = children and children[0] or None
        parent_v.t._firstChild = firstChild_v
        for child in children:
            child._parent = parent_v

    v = parent_v
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
#@nonl
#@-node:ekr.20061029093342.75:linkParentAndChildren (changed)
#@+node:ekr.20061029093342.76:linkSiblings (changed)
def linkSiblings (self, sibs):

    '''Set the v._back and v._next links for all vnodes v in sibs.'''

    if self.use_new_positions:
        pass
    else:
        n = len(sibs)
        for i in xrange(n):
            v = sibs[i]
            v._back = (i-1 >= 0 and sibs[i-1]) or None
            v._next = (i+1 <  n and sibs[i+1]) or None
#@nonl
#@-node:ekr.20061029093342.76:linkSiblings (changed)
#@-node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.5:v.__cmp__ (not used)
if 0: # not used
    def __cmp__(self,other):

        g.trace(self,other)
        return not (self is other) # Must return 0, 1 or -1
#@-node:ekr.20061028211424.5:v.__cmp__ (not used)
#@+node:ekr.20061028211424.6:v.__init__
def __init__ (self,t):

    assert(t)

    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.unknownAttributes or any mutable vnode object changes.

    self.t = t # The tnode.
    self.statusBits = 0 # status bits

    # Structure links.
    #### self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20061028211424.6:v.__init__
#@+node:ekr.20061028211424.7:v.__repr__ & v.__str__
def __repr__ (self):

    if self.t:
        return "<vnode %d:'%s'>" % (id(self),self.cleanHeadString())
    else:
        return "<vnode %d:NULL tnode>" % (id(self))

__str__ = __repr__
#@-node:ekr.20061028211424.7:v.__repr__ & v.__str__
#@+node:ekr.20061028211424.8:v.dump (to be deleted)
def dumpLink (self,link):
    return g.choose(link,link,"<none>")

def dump (self,label=""):

    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)

    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v
#@-node:ekr.20061028211424.8:v.dump (to be deleted)
#@+node:ekr.20061028211424.9:v.__hash__ (only for zodb)
if use_zodb and ZODB:
    def __hash__(self):
        return self.t.__hash__()
#@nonl
#@-node:ekr.20061028211424.9:v.__hash__ (only for zodb)
#@-node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
def findAtFileName (self,names):

    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()

    if not g.match(h,0,'@'):
        return ""

    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
#@-node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
#@+node:ekr.20061028211424.12:anyAtFileNodeName
def anyAtFileNodeName (self):

    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)
#@-node:ekr.20061028211424.12:anyAtFileNodeName
#@+node:ekr.20061028211424.13:at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)

def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)

def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@-node:ekr.20061028211424.13:at...FileNodeName
#@+node:ekr.20061028211424.14:isAtAllNode
def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag
#@-node:ekr.20061028211424.14:isAtAllNode
#@+node:ekr.20061028211424.15:isAnyAtFileNode good
def isAnyAtFileNode (self):

    """Return True if v is any kind of @file or related node."""

    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
#@-node:ekr.20061028211424.15:isAnyAtFileNode good
#@+node:ekr.20061028211424.16:isAt...FileNode (vnode)
def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)

def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@-node:ekr.20061028211424.16:isAt...FileNode (vnode)
#@+node:ekr.20061028211424.17:isAtIgnoreNode
def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag
#@-node:ekr.20061028211424.17:isAtIgnoreNode
#@+node:ekr.20061028211424.18:isAtOthersNode
def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag
#@-node:ekr.20061028211424.18:isAtOthersNode
#@+node:ekr.20061028211424.19:matchHeadline
def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.

    The headline may contain characters following the successfully matched pattern."""

    v = self

    h = g.toUnicode(v.headString(),'utf-8')
    h = h.lower().replace(' ','').replace('\t','')

    pattern = g.toUnicode(pattern,'utf-8')
    pattern = pattern.lower().replace(' ','').replace('\t','')

    return h.startswith(pattern)
#@-node:ekr.20061028211424.19:matchHeadline
#@-node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.22:v.back
# Compatibility routine for scripts

def back (self):

    return self._back
#@-node:ekr.20061028211424.22:v.back
#@+node:ekr.20061028211424.23:v.next
# Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next
#@-node:ekr.20061028211424.23:v.next
#@-node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.25:v.childIndex
def childIndex(self):

    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n
#@-node:ekr.20061028211424.25:v.childIndex
#@+node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
def firstChild (self):

    return self.t._firstChild
#@-node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
#@+node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
def hasChildren (self):

    v = self
    return v.firstChild()

hasFirstChild = hasChildren
#@-node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
#@+node:ekr.20061028211424.28:v.lastChild
def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child
#@-node:ekr.20061028211424.28:v.lastChild
#@+node:ekr.20061028211424.29:v.nthChild
# childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n > 0 and child:
        n -= 1
        child = child.next()
    return child
#@-node:ekr.20061028211424.29:v.nthChild
#@+node:ekr.20061028211424.30:v.numberOfChildren (n)
def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n += 1
        child = child.next()
    return n
#@-node:ekr.20061028211424.30:v.numberOfChildren (n)
#@-node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.32:v.isCloned (4.2)
def isCloned (self):

    return len(self.t.vnodeList) > 1
#@-node:ekr.20061028211424.32:v.isCloned (4.2)
#@+node:ekr.20061028211424.33:isDirty
def isDirty (self):

    return self.t.isDirty()
#@-node:ekr.20061028211424.33:isDirty
#@+node:ekr.20061028211424.34:isExpanded
def isExpanded (self):

    return ( self.statusBits & self.expandedBit ) != 0
#@-node:ekr.20061028211424.34:isExpanded
#@+node:ekr.20061028211424.35:isMarked
def isMarked (self):

    return ( self.statusBits & vnode.markedBit ) != 0
#@-node:ekr.20061028211424.35:isMarked
#@+node:ekr.20061028211424.36:isOrphan
def isOrphan (self):

    return ( self.statusBits & vnode.orphanBit ) != 0
#@-node:ekr.20061028211424.36:isOrphan
#@+node:ekr.20061028211424.37:isSelected
def isSelected (self):

    return ( self.statusBits & vnode.selectedBit ) != 0
#@-node:ekr.20061028211424.37:isSelected
#@+node:ekr.20061028211424.38:isTopBitSet
def isTopBitSet (self):

    return ( self.statusBits & self.topBit ) != 0
#@-node:ekr.20061028211424.38:isTopBitSet
#@+node:ekr.20061028211424.39:isVisited
def isVisited (self):

    return ( self.statusBits & vnode.visitedBit ) != 0
#@-node:ekr.20061028211424.39:isVisited
#@+node:ekr.20061028211424.40:status
def status (self):

    return self.statusBits
#@-node:ekr.20061028211424.40:status
#@-node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.41:v.bodyString
# Compatibility routine for scripts

def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.bodyString):
        s = "v.bodyString: Leo internal error: not unicode:" + repr(self.t.bodyString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
#@-node:ekr.20061028211424.41:v.bodyString
#@+node:ekr.20061028211424.42:v.headString & v.cleanHeadString
def headString (self):

    """Return the headline string."""

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.headString):
        s = "Leo internal error: not unicode:" + repr(self.t.headString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):

    s = self.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
#@-node:ekr.20061028211424.42:v.headString & v.cleanHeadString
#@+node:ekr.20061028211424.43:v.directParents (new method in 4.2)
def directParents (self):

    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.

    This is NOT the same as the list of ancestors of the vnode."""

    v = self

    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []
#@-node:ekr.20061028211424.43:v.directParents (new method in 4.2)
#@-node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
# These remain in 4.2: the file read logic calls these before creating positions.
#@+node:ekr.20061028211424.45:v.detach
def detach (self):

    '''Return a standalone copy of a vnode,
    detached from all other nodes and with a new tnode.'''

    v = self

    # Create a completely separate tnode.
    t2 = tnode(
        bodyString=v.bodyString(),
        headString=v.headString())

    return vnode(t2)
#@nonl
#@-node:ekr.20061028211424.45:v.detach
#@+node:ekr.20061028211424.46:v.insertAfter
def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAfter(self)

    return v
#@-node:ekr.20061028211424.46:v.insertAfter
#@+node:ekr.20061028211424.47:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAsNthChild(self,n)

    return v
#@-node:ekr.20061028211424.47:v.insertAsNthChild
#@+node:ekr.20061028211424.48:v.linkAfter
def linkAfter (self,v):

    """Link self after v."""

    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
#@-node:ekr.20061028211424.48:v.linkAfter
#@+node:ekr.20061028211424.49:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v
#@-node:ekr.20061028211424.49:v.linkAsNthChild
#@+node:ekr.20061028211424.50:v.linkAsRoot
def linkAsRoot (self,oldRoot):

    """Link a vnode as the root node and set the root _position_."""

    v = self

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot

    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v
#@nonl
#@-node:ekr.20061028211424.50:v.linkAsRoot
#@+node:ekr.20061028211424.51:v.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a vnode to the root position.

    Important: oldRoot must the previous root vnode if it exists.'''

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)

    return v
#@nonl
#@-node:ekr.20061028211424.51:v.moveToRoot
#@+node:ekr.20061028211424.52:v.unlink
def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []
#@nonl
#@-node:ekr.20061028211424.52:v.unlink
#@-node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
#@+node:ekr.20061028211424.53:Setters (no change)
#@+node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.55:clearClonedBit
def clearClonedBit (self):

    self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.55:clearClonedBit
#@+node:ekr.20061028211424.56:v.clearDirty (no change needed)
def clearDirty (self):

    v = self
    v.t.clearDirty()
#@nonl
#@-node:ekr.20061028211424.56:v.clearDirty (no change needed)
#@+node:ekr.20061028211424.57:v.clearMarked
def clearMarked (self):

    self.statusBits &= ~ self.markedBit
#@-node:ekr.20061028211424.57:v.clearMarked
#@+node:ekr.20061028211424.58:clearOrphan
def clearOrphan (self):

    self.statusBits &= ~ self.orphanBit
#@-node:ekr.20061028211424.58:clearOrphan
#@+node:ekr.20061028211424.59:clearVisited
def clearVisited (self):

    self.statusBits &= ~ self.visitedBit
#@-node:ekr.20061028211424.59:clearVisited
#@+node:ekr.20061028211424.60:contract & expand & initExpandedBit
def contract(self):

    self.statusBits &= ~ self.expandedBit

    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit

    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit
#@-node:ekr.20061028211424.60:contract & expand & initExpandedBit
#@+node:ekr.20061028211424.61:initStatus
def initStatus (self, status):

    self.statusBits = status
#@-node:ekr.20061028211424.61:initStatus
#@+node:ekr.20061028211424.62:setClonedBit & initClonedBit
def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.62:setClonedBit & initClonedBit
#@+node:ekr.20061028211424.63:v.setMarked & initMarkedBit
def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
#@-node:ekr.20061028211424.63:v.setMarked & initMarkedBit
#@+node:ekr.20061028211424.64:setOrphan
def setOrphan (self):

    self.statusBits |= self.orphanBit
#@-node:ekr.20061028211424.64:setOrphan
#@+node:ekr.20061028211424.65:setSelected (vnode)
# This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit
#@-node:ekr.20061028211424.65:setSelected (vnode)
#@+node:ekr.20061028211424.66:t.setVisited
# Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit
#@-node:ekr.20061028211424.66:t.setVisited
#@-node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.67:v.computeIcon & setIcon
def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val

def setIcon (self):

    pass # Compatibility routine for old scripts
#@-node:ekr.20061028211424.67:v.computeIcon & setIcon
#@+node:ekr.20061028211424.68:v.initHeadString
def initHeadString (self,s,encoding="utf-8"):

    v = self
    s = g.toUnicode(s,encoding,reportErrors=True)
    v.t.headString = s

    # g.trace(g.callers(5))
#@-node:ekr.20061028211424.68:v.initHeadString
#@+node:ekr.20061028211424.69:v.setSelection
def setSelection (self, start, length):

    self.t.setSelection ( start, length )
#@-node:ekr.20061028211424.69:v.setSelection
#@+node:ekr.20061028211424.70:v.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):

    return self.t.setTnodeText(s,encoding)
#@-node:ekr.20061028211424.70:v.setTnodeText
#@-node:ekr.20061028211424.53:Setters (no change)
#@-node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.1:position class
#@+node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.2:p.__cmp__ (changed)
def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self

    # g.trace(p1.headString(),p2 and p2.headString())

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal
    elif p1.v == p2.v and p2._childIndex == p2._childIndex and p1.stack == p2.stack:
        return 0 # equal
    else:
        return 1 # not equal

    # # Check entire stack quickly.
    # # The stack contains vnodes, so this is not a recursive call.
    # if p1.v != p2.v or p1.stack != p2.stack:
        # return 1 # notEqual
    # # This is slow: do this last!
    # if p1.childIndex() != p2.childIndex():
        # # Disambiguate clones having the same parents.
        # return 1 # notEqual
    # return 0 # equal
#@nonl
#@-node:ekr.20061028070057.2:p.__cmp__ (changed)
#@+node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):

        """Convert references to p.t into references to p.v.t.

        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                print "unknown position attribute:",attr
                import traceback ; traceback.print_stack()
            raise AttributeError,attr
#@nonl
#@-node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20061028070057.4:p.__init__
def __init__ (self,v,childIndex=0,stack=None):

    '''Create a new position.'''

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    self._childIndex = childIndex

    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20061028070057.4:p.__init__
#@+node:ekr.20061028070057.5:p.__nonzero__
@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

def __nonzero__ ( self):

    """Return True if a position is valid."""

    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None
#@-node:ekr.20061028070057.5:p.__nonzero__
#@+node:ekr.20061028070057.6:p.__str__ and p.__repr__
def __str__ (self):

    p = self

    if p.v:
        return "<pos %d lvl: %d [%d] %s>" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d        [%d] None>" % (id(p),len(p.stack))

__repr__ = __str__
#@-node:ekr.20061028070057.6:p.__str__ and p.__repr__
#@+node:ekr.20061028070057.7:p.archivedPosition
def archivedPosition (self):

    '''Return a representation of a position suitable for use in .leo files.'''

    p = self
    aList = [p2.v.childIndex() for p2 in p.self_and_parents_iter()]
    aList.reverse()
    return aList
#@nonl
#@-node:ekr.20061028070057.7:p.archivedPosition
#@+node:ekr.20061028070057.8:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):

    """"Return an independent copy of a position."""

    return position(self.v,self.stack)
#@-node:ekr.20061028070057.8:p.copy
#@+node:ekr.20061028070057.9:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):

    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label

def vnodeListIds (self):

    p = self
    return [id(v) for v in p.v.t.vnodeList]
#@-node:ekr.20061028070057.9:p.dump & p.vnodeListIds
#@+node:ekr.20061028070057.10:p.equal & isEqual (changed)
def equal(self,p2):

    """Return True if two postions are equivalent.

    Use this method when the speed comparisons is crucial

    N.B. Unlike __cmp__, p2 must not be None.
    """

    p1 = self

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1._childIndex == p2._childIndex and
        p1.stack == p2.stack
    )

isEqual = equal
#@-node:ekr.20061028070057.10:p.equal & isEqual (changed)
#@+node:ekr.20061028070057.11:p.key
def key (self):

    p = self

    return '%s:%d.%s' % (
        id(p.v),
        p._childIndex,
        ','.join([str(id(v)) for v in p.stack])
    )
#@-node:ekr.20061028070057.11:p.key
#@-node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.12:p.moveToX (many changes)
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
#@+node:ekr.20061028070057.13:p.moveToBack (new)
def moveToBack (self):

    '''Move position p to its previous sibling.'''

    p = self
    if p.stack and p._childIndex > 0:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex -= 1
            p.v = links[p._childIndex]
        else:
            g.trace('Can not happen: no links')
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # p.v = p.v and p.v._back
    # return p
#@nonl
#@-node:ekr.20061028070057.13:p.moveToBack (new)
#@+node:ekr.20061028070057.14:p.moveToFirstChild (new)
def moveToFirstChild (self):

    '''Move a position to it's first child's position.'''

    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = 0
            p.v = links[0]
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # child = p.v.t._firstChild
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.14:p.moveToFirstChild (new)
#@+node:ekr.20061028070057.15:p.moveToLastChild (new)
def moveToLastChild (self):

    '''Move a position to it's last child's position.'''

    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = len(links)-1
            p.v = links[p._childIndex]
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # if p.v.t._firstChild:
            # child = p.v.lastChild()
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.15:p.moveToLastChild (new)
#@+node:ekr.20061028070057.16:p.moveToLastNode (no change)
def moveToLastNode (self):

    """Move a position to last node of its tree.

    N.B. Returns p if p has no children."""

    p = self
    while p.hasChildren():
        p.moveToLastChild()
    return p
#@-node:ekr.20061028070057.16:p.moveToLastNode (no change)
#@+node:ekr.20061028070057.17:p.moveToNext (new)
def moveToNext (self):

    '''Move position p to its next sibling.'''

    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if p._childIndex + 1 < len(links):
            p._childIndex += 1
            p.v = links[p._childIndex]
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # p.v = p.v and p.v._next
    # return p
#@-node:ekr.20061028070057.17:p.moveToNext (new)
#@+node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
def moveToNodeAfterTree (self):

    """Move a position to the node after the position's tree."""

    p = self

    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
#@+node:ekr.20061028070057.19:p.moveToNthChild (new)
def moveToNthChild (self,n):

    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links and n < len(links)
            p.v = links[n]
            p.childIndex = n
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # child = p.v.nthChild(n) # Must call vnode method here!
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.19:p.moveToNthChild (new)
#@+node:ekr.20061028070057.20:p.moveToParent (new)
def moveToParent (self):

    '''Move a position to its parent position.'''

    if p.stack:
        p.v,p._childIndex = p.stack.pop()
    else:
        p.v = None
    return p

    # p = self
    # if not p: return p
    # if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        # p.v = p.v._parent
    # elif p.stack:
        # p.v = p.stack.pop()
    # else:
        # p.v = None
    # return p
#@nonl
#@-node:ekr.20061028070057.20:p.moveToParent (new)
#@+node:ekr.20061028070057.21:p.moveToThreadBack (no change)
def moveToThreadBack (self):

    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.21:p.moveToThreadBack (no change)
#@+node:ekr.20061028070057.22:p.moveToThreadNext (little change)
def moveToThreadNext (self):
    '''Move a position to the next a position in threading order.'''
    p = self
    if p.hasChildren():
        p.moveToFirstChild()
    elif p.hasNext()
        p.moveToNext()
    else:
        p.moveToParent()
        while p:
            if p.hasNext():
                p.moveToNext()
                break #found
            p.moveToParent()
        # not found.
    return p

# def moveToThreadNext (self):
    # """Move a position to the next a position in threading order."""
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # p.moveToFirstChild()
        # elif p.v._next:
            # p.moveToNext()
        # else:
            # p.moveToParent()
            # while p:
                # if p.v._next:
                    # p.moveToNext()
                    # break #found
                # p.moveToParent()
            # # not found. 
    # return p
#@nonl
#@-node:ekr.20061028070057.22:p.moveToThreadNext (little change)
#@+node:ekr.20061028070057.23:p.moveToVisBack (no change)
def moveToVisBack (self):

    """Move a position to the position of the previous visible node."""

    p = self

    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p
#@-node:ekr.20061028070057.23:p.moveToVisBack (no change)
#@+node:ekr.20061028070057.24:p.moveToVisNext (no change)
def moveToVisNext (self):

    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()

    return p
#@-node:ekr.20061028070057.24:p.moveToVisNext (no change)
#@-node:ekr.20061028070057.12:p.moveToX (many changes)
#@+node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.27:p.Comparisons (no change)
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)
#@-node:ekr.20061028070057.27:p.Comparisons (no change)
#@+node:ekr.20061028070057.28:p.Headline & body strings (no change)
def bodyString (self):

    return self.v.bodyString()

def headString (self):

    return self.v.headString()

def cleanHeadString (self):

    return self.v.cleanHeadString()
#@-node:ekr.20061028070057.28:p.Headline & body strings (no change)
#@+node:ekr.20061028070057.29:p.Status bits (no change)
def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
#@-node:ekr.20061028070057.29:p.Status bits (no change)
#@+node:ekr.20061028070057.30:p.directParents (new, faster)
def directParents (self):

    p = self
    return p and p.stack or []

    # return self.v.directParents()
#@-node:ekr.20061028070057.30:p.directParents (new, faster)
#@+node:ekr.20061028070057.31:p.childIndex (new, much faster)
# This is time-critical code!

def childIndex(self):

    return p and p._childIndex or 0

    # p = self ; v = p.v
    # if not v or not v._back:
        # return 0
    # n = 0 ; v = v._back
    # while v:
        # n += 1
        # v = v._back
    # return n
#@nonl
#@-node:ekr.20061028070057.31:p.childIndex (new, much faster)
#@-node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.33:p.hasChildren (new)
def hasChildren(self):

    p = self

    if p.v and p.v.t:
        return len(p.v.t.links) > 0
    else:
        return False

    # return p.v and p.v.t and p.v.t._firstChild
#@-node:ekr.20061028070057.33:p.hasChildren (new)
#@+node:ekr.20061028070057.34:p.numberOfChildren (new)
def numberOfChildren (self):

    if p.v:
        return len(p.v.t.links)
    else:
        return 0

    # return self.v.numberOfChildren()
#@-node:ekr.20061028070057.34:p.numberOfChildren (new)
#@-node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@-node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
#@+node:ekr.20061028070057.36:p.hasX (new)
def hasBack(self):
    return self._childIndex > 0
    # return self.v and self.v._back

hasFirstChild = hasChildren

def hasNext(self):
    p = self
    if p.stack:
        parent_v,junk = self.stack[-1]
        links = parent_v.t.links
        return p._childIndex + 1 < len(parent.v.t.links)
    else:
        return False
    # return self.v and self.v._next

def hasParent(self):
    return len(self.stack) > 1 # The first item of each stack is the dummy parent.
    # return self.v and self.v._parent is not None

def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.

hasVisBack = hasThreadBack
#@-node:ekr.20061028070057.36:p.hasX (new)
#@+node:ekr.20061028070057.37:hasThreadNext (big change)
def hasThreadNext(self):

    p = self ; v = p.v
    if not p.v: return False

    if p.hasChildren() or p.hasNext():
        return True
    else:
        # Simulate this code without copying p.
        # p2 = p.copy()
        # p2.moveToParent()
        # while p2:
            # if p2.hasNext():
                # return True
            # p2.moveToParent()
        # return False
        if not p.stack: return False
        n = len(p.stack)-1
        v,childIndex = p.stack[n]
        n -= 1
        while n >= 0:
            # v2,childIndex2 represent v's parent.
            v2,childIndex2 = parent.stack[n]
            links = v2.t.links
            if childIndex + 1 < len(links):
                return True
            # v.moveToParent
            v,childIndex = v2,childIndex2
            n -= 1
        return False

    # p = self ; v = p.v
    # if not p.v: return False
    # if v.t._firstChild or v._next:
        # return True
    # else:
        # n = len(p.stack)-1
        # v,n = p.vParentWithStack(v,p.stack,n)
        # while v:
            # if v._next:
                # return True
            # v,n = p.vParentWithStack(v,p.stack,n)
        # return False

hasVisNext = hasThreadNext
#@nonl
#@-node:ekr.20061028070057.37:hasThreadNext (big change)
#@+node:ekr.20061028070057.38:p.findRootPosition (unchanged)
def findRootPosition (self):

    p = self.copy()
    while p.hasParent():
        p.moveToParent()
    while p.hasBack():
        p.moveToBack()
    return p
#@nonl
#@-node:ekr.20061028070057.38:p.findRootPosition (unchanged)
#@+node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
def isAncestorOf (self, p2):

    p = self
    if not p.stack:
        return False
    elif p2 is None or not p2.stack:
        return False
    else:
        for v,junk in p2.stack:
            if v == p.v:
                return True
        else:
            return False

    # p = self
    # # Avoid calling p.copy() or copying the stack.
    # v2 = p2.v ; n = len(p2.stack)-1
        # # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # while v2:
        # if v2 == p.v:
            # return True
        # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # return False
#@nonl
#@-node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
#@+node:ekr.20061028070057.40:p.isCloned (unchanged)
def isCloned (self):

    return len(self.v.t.vnodeList) > 1
#@-node:ekr.20061028070057.40:p.isCloned (unchanged)
#@+node:ekr.20061028070057.41:p.isRoot (unchanged)
def isRoot (self):

    p = self

    return not p.hasParent() and not p.hasBack()
#@-node:ekr.20061028070057.41:p.isRoot (unchanged)
#@+node:ekr.20061028070057.42:p.isVisible (new)
def isVisible (self):

    """Return True if all of a position's parents are expanded."""

    p = self
    for v in p.stack:
        if not v.isExpanded():
            return False
    return True

    # p = self
    # v = p.v ; n = len(p.stack)-1
    # v,n = p.vParentWithStack(v,p.stack,n)
    # while v:
        # if not v.isExpanded():
            # return False
        # v,n = p.vParentWithStack(v,p.stack,n)
    # return True
#@nonl
#@-node:ekr.20061028070057.42:p.isVisible (new)
#@+node:ekr.20061028070057.43:p.level & simpleLevel (new)
def level(self):
    return len(self.stack)

simpleLevel = level

# def simpleLevel(self):
    # 
    # return len([p for p in self.parents_iter()])

# def level(self,verbose=False):
    # 
    # p = self ; level = 0
    # if not p: return level
        # 
    # # Avoid calling p.copy() or copying the stack.
    # v = p.v ; n = len(p.stack)-1
    # while 1:
        # assert(p)
        # v,n = p.vParentWithStack(v,p.stack,n)
        # if v:
            # level += 1
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        # else:
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # # if g.app.debug: assert(level==self.simpleLevel())
            # break
    # return level
#@-node:ekr.20061028070057.43:p.level & simpleLevel (new)
#@-node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):

    """A utility that allows the computation of p.v without calling p.copy().

    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n >= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
#@+node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)
#@-node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
#@-node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
#@+node:ekr.20061028070057.47:p.restoreLinksInTree
def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""

    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    for p in root.children_iter():
        p.restoreLinksInTree()
#@-node:ekr.20061028070057.47:p.restoreLinksInTree
#@+node:ekr.20061028070057.48:p.deleteLinksInTree & allies
def deleteLinksInTree (self):

    """Delete and otherwise adjust links when deleting node."""

    root = self

    root.deleteLinksInSubtree()

    # for p in root.children_iter():
        # p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@+node:ekr.20061028070057.49:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20061028070057.49:p.deleteLinksInSubtree
#@+node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
def adjustParentLinksInSubtree (self,parent):

    root = p = self

    assert(parent)

    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]

    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
#@-node:ekr.20061028070057.48:p.deleteLinksInTree & allies
#@-node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@+node:ekr.20061028070057.52:p.linkAfter
def linkAfter (self,after):

    """Link self after position 'after'."""

    p = self
    if not after.stack:
        g.trace('Can not happen: no dummy root.',after)
        return

    p.stack = after.stack[:]
    p._childIndex = after._childIndex + 1 #### New
    parent_v,junk = p.stack[-1] #### New
    links = parent_v.t.links #### New
    links.insert(p._childIndex,p.v) #### New

    #### p.v._parent = after.v._parent

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    #### p.v._back = after.v
    #### p.v._next = after.v._next
    #### after.v._next = p.v
    #### if p.v._next:
        #### p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")
#@-node:ekr.20061028070057.52:p.linkAfter
#@+node:ekr.20061028070057.53:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of parent position 'parent'."""

    # g.trace(self,parent,n,parent.v)

    p = self
    links = parent.v.t.links
    if n <= len(links):
        links.insert(n,p.v)
    else:
        g.trace('Can not happen: n too large.',n,p)
        return

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # # Recreate the stack using the parent.
    # p.stack = parent.stack[:]
    # if parent.isCloned():
        # p.stack.append(parent.v)
    # p.v._parent = parent.v
    # # Add v to it's tnode's vnodeList.
    # if p.v not in p.v.t.vnodeList:
        # p.v.t.vnodeList.append(p.v)
        # p.v.t._p_changed = 1 # Support for tnode class.
    # if n == 0:
        # child1 = parent.v.t._firstChild
        # p.v._back = None
        # p.v._next = child1
        # if child1:
            # child1._back = p.v
        # parent.v.t._firstChild = p.v
    # else:
        # prev = parent.nthChild(n-1) # zero based
        # assert(prev)
        # p.v._back = prev.v
        # p.v._next = prev.v._next
        # prev.v._next = p.v
        # if p.v._next:
            # p.v._next._back = p.v
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.53:p.linkAsNthChild
#@+node:ekr.20061028070057.54:p.linkAsRoot
def linkAsRoot (self,oldRoot):

    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None

    root_v,junk = p.stack[0]
    links = root_v.t.links
    p.stack = [root_v] # Clear the stack, except for the dummy root.
    links = [p.v]
    if oldRoot:
        links.append(oldRoot.v)

    # p.stack = [] # Clear the stack.
    # # Clear all links except the child link.
    # v._parent = None
    # v._back = None
    # v._next = oldRootVnode

    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    # if oldRoot:
        # oldRoot.v._back = v
    # p.dump(label="root")
#@nonl
#@-node:ekr.20061028070057.54:p.linkAsRoot
#@+node:ekr.20061028070057.55:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.

    The p.v.t.links does NOT change."""

    p = self ; v = p.v

    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)

    if p.stack:
        parent,junk = p.stack[-1]
        links = parent.t.links
        if v in links:
            links.remove(v)
        else:
            g.trace("Can not happen: not its father's child.",p)
    else:
        g.trace('Can not happen: missing root.',p)

    # Reset the firstChild link in its direct father.
    # if p.v._parent:
        # if 0: # This can fail.  I have no idea why it was present.
            # assert(p.v and p.v._parent in p.v.directParents())
        # if p.v._parent.t._firstChild == v:
            # #g.trace('resetting _parent.v.t._firstChild to',v._next)
            # p.v._parent.t._firstChild = v._next
    # else:
        # parent = p.parent()
        # if parent:
            # if 0: # This can fail.  I have no idea why it was present.
                # assert(parent.v in p.v.directParents())
            # if parent.v.t._firstChild == v:
                # #g.trace('resetting parent().v.t._firstChild to',v._next)
                # parent.v.t._firstChild = v._next
    # # Do NOT delete the links in any child nodes.
    # # Clear the links in other nodes.
    # if v._back: v._back._next = v._next
    # if v._next: v._next._back = v._back
    # # Unlink _this_ node.
    # v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.55:p.unlink
#@-node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
#@-node:ekr.20061028211424.1:position class
#@-node:ekr.20061028070132:New positions
#@+node:ekr.20070105135851.1:Most important
#@+node:ekr.20061206060454:Improve import code
@nocolor

- Make the later munging unnecessary.
	- Don't generate @file or the full file names.
	- Don't add @ignore
	- Put @language python and @tabwidth -4 only in the root node.
- Put the docstring at the top.
- Make sure only imports go in the << imports >> section.
#@-node:ekr.20061206060454:Improve import code
#@+node:ekr.20061127170002.1:Allow multiple lines on the button bar
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3993176
By: rich_ries

How can the button bar be enlarged to take a second (or third!) row of icons? Or maybe the Scripting buttons can have
their own section, like the NodeBar plugin did/does?

add-new-icon-row command?
#@nonl
#@-node:ekr.20061127170002.1:Allow multiple lines on the button bar
#@-node:ekr.20070105135851.1:Most important
#@+node:ekr.20061028065955.4:New features
#@+node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061014050154.2:Binding to None clears all bindings
#@-node:ekr.20061014050154.2:Binding to None clears all bindings
#@+node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@-node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@+node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:new
def new (self,event=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """

    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"

if ext[0] != ".":
    ext = "."+ext

# print "ext",ext
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None

body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed

if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):

    """Return the path to the temp file corresponding to p and ext."""

    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)

        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)

        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)

        name = g.toUnicode(name,g.app.tkEncoding)

        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))

        path = g.os_path_join(td,name)

        return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    c.beginUpdate()
    try:
        if c.mFileName != "":
            # Calls c.setChanged(False) if no error.
            c.fileCommands.save(c.mFileName)
        else:
            fileName = g.app.gui.runSaveFileDialog(
                initialfile = c.mFileName,
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
            c.bringToFront()

            if fileName:
                # Don't change mFileName until the dialog has suceeded.
                c.mFileName = g.ensure_extension(fileName, ".leo")
                c.frame.title = c.mFileName
                c.frame.setTitle(g.computeWindowTitle(c.mFileName))
                c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
                c.fileCommands.save(c.mFileName)
                c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save As",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # 7/2/02: don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            # Calls c.setChanged(False) if no error.
            c.fileCommands.saveAs(c.mFileName)
            c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
#@-node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        # set local fileName, _not_ c.mFileName
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save To",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            fileName = g.ensure_extension(fileName, ".leo")
            c.fileCommands.saveTo(fileName)
            c.updateRecentFiles(fileName)

    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@-node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@-node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@+node:ekr.20061024093525:Create settings menu
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3977681

How about having a menu Edit -> Settings with the submenu-items 'LeoSettings.leo',
'myLeoSettings.leo', 'this file's settings'?

The menu-items 'Open myLeoSettings.leo' and 'Open LeoSettings.leo' under the
Help-menu seem out-of-place.

#@-node:ekr.20061024093525:Create settings menu
#@+node:ekr.20061116054917.6:Remove blanks in calltips
#@-node:ekr.20061116054917.6:Remove blanks in calltips
#@+node:ekr.20061108100143:Create '*open-&test.leo' command that t.bat or test.leo
# This doesn't seem to work well on XP.
#@nonl
#@+node:ekr.20061209131102.1:openTest
def openTest (self, event=None):

    if 1: # Open in a new process.
        cmd = 'c:\Windows\System32\cmd.exe' # Hangs if used.
        python = sys.executable
        leo = g.os_path_abspath(g.os_path_join(g.app.loadDir,'leo.py'))
        test = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test'))

        os.system('%s %s %s %s' % (cmd, python,leo,test))
        # args = [python, leo, test]

        # if 1: # Use present environment.
            # os.spawnv(os.P_NOWAIT, sys.executable, args)
        # else: # Use a pristine environment.
            # os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
    else:
        c = self
        fileName = g.os_path_join(g.app.loadDir,'..','test','test.leo')

        ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es('not found: %s' % fileName)
#@-node:ekr.20061209131102.1:openTest
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):

    self.helpMenuTable = [
        # &: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&About Leo...',           'about-leo'),
        ('Online &Home Page',       'open-online-home'),
        '*open-online-&tutorial',
        '*open-&users-guide',
        '-',
        ('Open Leo&Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&Settings.leo',   'open-leoSettings-leo'),
        ('Open &myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&ipts.leo',       'open-scripts-leo'),
        # ('Open t&est.leo',          'open-test-leo'),
        '-',
        '*he&lp-for-minibuffer',
        '*help-for-&command',
        '-',
        '*&apropos-autocompletion',
        '*apropos-&bindings',
        '*apropos-&debugging-commands',
        '*apropos-&find-commands',
        '-',
        '*pri&nt-bindings',
        '*print-c&ommands',
    ]
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20061108100143:Create '*open-&test.leo' command that t.bat or test.leo
#@-node:ekr.20061028065955.4:New features
#@-node:ekr.20070105135713:To do: 4.5 (new positions)
#@+node:ekr.20060822174843:Most important projects
# Most of these projects will take a week or more.
#@nonl
#@+node:ekr.20070220082124:Make sure Leo can generate Latex
#@-node:ekr.20070220082124:Make sure Leo can generate Latex
#@+node:ekr.20070226075816.1:Update plugin manager to handle @enabled-plugins nodes
#@-node:ekr.20070226075816.1:Update plugin manager to handle @enabled-plugins nodes
#@+node:ekr.20070307082503:Make Leo an IPython notebook
#@+node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060603085719.1:Use IPython autocompleter?
#@-node:ekr.20060603085719.1:Use IPython autocompleter?
#@+node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@-node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@+node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@-node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@+node:ekr.20060603090445.9:Script button that saves environment between runs
This would allow IPython-like operation.
#@nonl
#@-node:ekr.20060603090445.9:Script button that saves environment between runs
#@-node:ekr.20060603090445.7:Ipython stuff
#@-node:ekr.20070307082503:Make Leo an IPython notebook
#@+node:ekr.20060629154112:Merge Leo & jyLeo
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3799470
By: leouser

I guess its hard to say what pieces must merge and what can stay different.
Id like it if the blasted nodes were the same.  I guess there is progress again
on a jython 2.2 being complete and work starting on 2.3.  So there is hope that
the nodes will be the same code, at least it will be possible.

At the top of my head the big differences outside of the position changes are:
1. Some modifications to the read/write code so that Chapters can work and also
Serialized positions.
2. Commander has some things different, it looks to the Chapters instance to
determine what is the curentPosition, top Position etc... instead of keeping
track of it itself.
3. GUI layers are very different.  Interesting tidbit here: the work I did to
get the JTree to use positions to determine if a node is expanded or not looks
like it has provided the outline for enhancing the JTree for Java itself to
be able to do this.  We will have to see, but maybe in Java 7 you can say: "Positions
lead to user controled tree expansion models".

There is a tremendous amount that is the same. Im sure you could make an interesting
evening out of comparing the codebases to see where things change.


#@+node:ekr.20070307082814:Create g.startupController class
#@-node:ekr.20070307082814:Create g.startupController class
#@-node:ekr.20060629154112:Merge Leo & jyLeo
#@+node:ekr.20060202231708.1:@menu nodes in leoSettings.leo
@nocolor

We could allow users to define Leo menus.
To do this, we must use minibuffer names for all menu entries

@color
#@nonl
#@-node:ekr.20060202231708.1:@menu nodes in leoSettings.leo
#@+node:ekr.20061207073104:Convert bottlenecks to pyrex code
# To do:  actually generate Leo's bottlenecks.
#@nonl
#@+node:ekr.20061207073104.1:gcc build docs
@nocolor

To build your module using GCC is a three step process on Unix. (I have know
idea how many steps it is on Windows™.)

Start by running the Pyrex compiler over your code as follows, where
mymodule.pyx is the name of the Pyrex module you are writing. python2.2 pyrexc
mymodule.pyx Next, compile the resulting C file into a .o file. The call to gcc
looks like this:

gcc -c -fPIC -I/usr/include/python2.2/ mymodule.c
The arguments to gcc are explained below.

-c 
Produces a .o file instead of an executable. 
-fPIC 
Produces position independent code, so we can dynamically link against it later. 
-I/usr/include/python2.2/ 
is the location of the Python 2.2 include file. The location of your Python include file may differ from /usr/include/python2.2/. 
mymodule.c 
is the name of the C file produced by Pyrex. 
Finally, link the .o into a .so: gcc -shared mymodule.o -lxosd -o mymodule.so
-shared 
produces a shared-object file, instead of an executable. 
mymodule.o 
is the name of the module you wish to compile. 
-lxosd 
links against a C-library, with the name of the library given as the argument. 
-o mymodule.so 
causes gcc to put the output into a file called mymodule.so 
The C library that you are wrapping will probably differ from mymodule. 
#@-node:ekr.20061207073104.1:gcc build docs
#@+node:ekr.20061207073104.2:pyrexc command-line options
@nocolor

The pyrexc command supports the following options:

  Short Long              Argument    Description
  -----------------------------------------------------------------------------
  -v    --version                     Display version number of pyrex compiler
  -l    --create-listing              Write error messages to a .lis file
  -I    --include-dir     <directory> Search for include files in named 
                                       directory (may be repeated)
  -o    --output-file     <filename>  Specify name of generated C file (only
                                       one source file allowed if this is used)

Anything else is taken as the name of a Pyrex source file and compiled
to a C source file. Multiple Pyrex source files can be specified
(unless -o is used), in which case each source file is treated as the
source of a distinct extension module and compiled separately to
produce its own C file.
#@-node:ekr.20061207073104.2:pyrexc command-line options
#@+node:ekr.20061207073104.3:@file myModule.pyx
def spam(int i, char *s):
    if 1:
        print i,s
#@nonl
#@-node:ekr.20061207073104.3:@file myModule.pyx
#@+node:ekr.20061207073104.4:Make myModule.c
# Use pyrexc to create myModule.c from myModule.pyx.
import os,sys
python = sys.executable
theFile = r'C:\prog\tigris-cvs\leo\test\myModule.pyx'
pyrexc = r'c:\prog\Pyrex-0.9.4.1\pyrexc.py'
os.system(r'%s %s %s' % (python,pyrexc,theFile))

if 0: # Build myModule library using distutils.
    from distutils.core import setup, Extension

    # Make the extension module ("mymodule") link against xosd
    xosdExtn = Extension("mymodule", ["mymodule.c"], libraries=["xosd"])

    # Compile the extension module
    setup(name="mymodule", ext_modules=[xosdExtn])

@ Save the above code in a file called setup.py and run the following code
to build and install your module.

    python setup.py build
    python setup.py install
#@nonl
#@-node:ekr.20061207073104.4:Make myModule.c
#@+node:ekr.20061207073104.5:Code to be optimized w/ pyrex
#@+node:ekr.20061207073104.6:Nodes...
#@-node:ekr.20061207073104.6:Nodes...
#@+node:ekr.20061207073104.216:Colorizer
#@-node:ekr.20061207073104.216:Colorizer
#@+node:ekr.20061207073104.268:File code
#@-node:ekr.20061207073104.268:File code
#@-node:ekr.20061207073104.5:Code to be optimized w/ pyrex
#@-node:ekr.20061207073104:Convert bottlenecks to pyrex code
#@+node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
@nocolor

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off.

@color
#@nonl
#@-node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
#@-node:ekr.20060530085844:Improve autocompletion
#@-node:ekr.20060822174843:Most important projects
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
