#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20060927172440:To do before 4.4.2 final
#@+node:ekr.20060929042321:Allow two copies of myLeoSettings.leo
#@-node:ekr.20060929042321:Allow two copies of myLeoSettings.leo
#@+node:ekr.20060912091922:Test all plugins
** Create separate @test node for each plugin.
#@nonl
#@+node:ekr.20060914085747:Have plugin-specific unit tests
chapter_hoist.py
leoOPML.py
leo_to_html.py
leo_to_rtf.py
mod_scripting.py
paste_as_headlines.py
open_with.py
rst3.py
UNL.py
#@-node:ekr.20060914085747:Have plugin-specific unit tests
#@+node:ekr.20060914130034:Tested, no unit tests
# No unit tests needed: these are always active.
plugins_manager.py
plugins_menu.py

# Unit tests needed...
word_count.py
zodb.py
#@nonl
#@-node:ekr.20060914130034:Tested, no unit tests
#@+node:ekr.20060914090250:To test next
__jEdit_colorizer__.py


vim.py
word_export.py
xemacs.py
#@nonl
#@-node:ekr.20060914090250:To test next
#@+node:ekr.20060914085747.1:To test
ConceptualSort.py
EditAttributes.py
FileActions.py
Library.py
TabWindow.py
UASearch.py
URLloader.py
UniversalScrolling.py

add_directives.py
arrows.py
at_view.py
autotrees.py
base64Packager.py
bibtex.py
cleo.py
color_markup.py
datenodes.py
detect_urls.py
dyna_menu.py
fastGotoNode.py
footprints.py
groupOperations.py
hoist.py
image.py
import_cisco_config.py
leoupdate.py
macros.py
mod_autosave.py
mod_http.py
mod_labels.py
mod_read_dir_outline.py
mod_shadow.py
nav_buttons.py
newButtons.py
niceNosent.py
nodebar.py
nodenavigator.py
open_shell.py
pie_menus.py
pretty_print.py
print_cp.py
rClick.py
read_only_nodes.py
rowcol.py
run_nodes.py
scheduler.py
scripts_menu.py
searchbox.py
shortcut_button.py
slideshow.py
table.py
templates.py
trace_tags.py
xcc_nodes.py
xsltWithNodes.py
#@nonl
#@-node:ekr.20060914085747.1:To test
#@-node:ekr.20060912091922:Test all plugins
#@+node:ekr.20060928111002:Make showing the Run Script button optional
#@-node:ekr.20060928111002:Make showing the Run Script button optional
#@+node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@-node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@+node:ekr.20060927100500.1:Fix bugs in new colorizer
@nocolor

- Does not restore selection after indent/undent commands.
#@nonl
#@-node:ekr.20060927100500.1:Fix bugs in new colorizer
#@+node:ekr.20060927073203:Fix rst3 problem
http://sourceforge.net/forum/message.php?msg_id=3932641
By: craigj3

Has anybody got the rst3 pluging to handle rst Block Quotes in a single node?

They are indented paragraphs that should then be rendered indented.

Looking at the intermediate file, it would appear that LEO *always* outputs
the first line of a node without indentation even if it is indented in the node.
#@-node:ekr.20060927073203:Fix rst3 problem
#@+node:ekr.20060927173836.7:The default script button buttons should create press-x-button commands
#@-node:ekr.20060927173836.7:The default script button buttons should create press-x-button commands
#@+node:ekr.20060915175024:Maintain vertical node position?
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3916155

When a node is among several other nodes at the same level of hierarchy, which
are all children of a node, and the "MOVE LFET" command is executed, the node
does move left in the outline hierarchy, but it also move down to just before
the next node at the higher hierarchy level - the level to which it is moving
left.
#@nonl
#@-node:ekr.20060915175024:Maintain vertical node position?
#@+node:ekr.20060920190138:Document tnodeList, vnodeList and make better unit tests
#@-node:ekr.20060920190138:Document tnodeList, vnodeList and make better unit tests
#@+node:ekr.20060920150119:Fix undo problems (important)
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3924236

Clear the * mark if all changes have been done.
There are serious problems with undoing and redoing text.
#@nonl
#@-node:ekr.20060920150119:Fix undo problems (important)
#@+node:ekr.20060927173836.1:Disable calltips in @nocolor sections
@nocolor

Show calltips treats the node as code, and that can have very weird effects in @nocolor sections.
#@nonl
#@-node:ekr.20060927173836.1:Disable calltips in @nocolor sections
#@+node:ekr.20060824112937.1:Fix unicode problem with double-click word Stéphane
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3882798
By: jujusl

When I double-click in the body on a word with accents, only a part of the word
is selected (up to the accentuated char, forward and backward)

This does not happen in headlines.

I saw that using Windows ; I will test it on Linux machine.

Maybe is it a Tk problem, may be not. You'll tell me...

Stéphane

@color
#@nonl
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.widgetWantsFocus(w)
    s = w.get('1.0','end') ; n = len(s)

    def toGui (i): return g.app.gui.toGuiIndex(s,w,i)
    def toPython (i): return g.app.gui.toPythonIndex(s,w,i)
    def isWordChar(ch): return ch in (string.letters + string.digits + '_')

    i = toPython(w.index('insert'))
    delta = g.choose(forward,1,-1)
    
    if not forward: i -= 1
    while 0 <= i < n and isWordChar(s[i]):
        i += delta
    while 0 <= i < n and not isWordChar(s[i]):
        i += delta
    if not forward: i += 1

    self.moveToHelper(event,toGui(i),extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20060131084938:masterDoubleClickHandler
def masterDoubleClickHandler (self,event,func=None):
    
    k = self ; c = k.c ; w = event and event.widget
    
    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        i = w.index("@%d,%d" % (event.x,event.y))
        start = w.index(i+' wordstart')
        end = w.index(i+' wordend')
        g.app.gui.setTextSelection(w,start,end)
        return 'break'
#@-node:ekr.20060131084938:masterDoubleClickHandler
#@+node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodydclick1",c=c,p=p,v=p,event=event):
            if event: # Prevent wandering insertion point.
                w = self.bodyCtrl
                index = w.index("@%d,%d" % (event.x, event.y)) # Find where we clicked.
                start = w.index(index + " wordstart")
                end   = w.index(index + " wordend")
                # g.trace(index,start,end,w.get('1.0','end'))
                self.body.setTextSelection(start,end)
        g.doHook("bodydclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodydclick")
        
    return "break" # Restore this to handle proper double-click logic.
#@-node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
#@+node:ekr.20060203114017:f.setMinibufferBindings
def setMinibufferBindings (self):
    
    '''Create bindings for the minibuffer..'''
    
    f = self ; c = f.c ; k = c.k ; t = f.miniBufferWidget
    
    if not c.useTextMinibuffer: return
    
    for kind,callback in (
        ('<Key>',           k.masterKeyHandler),
        ('<Button-1>',      k.masterClickHandler),
        ('<Button-3>',      k.masterClick3Handler),
        ('<Double-1>',      k.masterDoubleClickHandler),
        ('<Double-3>',      k.masterDoubleClick3Handler),
    ):
        t.bind(kind,callback)

    if 0:
        if sys.platform.startswith('win'):
            # Support Linux middle-button paste easter egg.
            t.bind("<Button-2>",frame.OnPaste)
#@-node:ekr.20060203114017:f.setMinibufferBindings
#@+node:ekr.20040803072955.87:onHeadlineClick
def onHeadlineClick (self,event,p=None):
    
    c = self.c ; w = event.widget
    
    if not p:
        try:
            p = w.leo_position
        except AttributeError:
            g.trace('*'*20,'oops')
    if not p: return 'break'
        
    # g.trace(p.headString())
    
    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal
#@-node:ekr.20040803072955.87:onHeadlineClick
#@+node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
def OnActivateHeadline (self,p,event=None):
    
    '''Handle common process when any part of a headline is clicked.'''
    
    # g.trace(p.headString())
    
    returnVal = 'break' # Default: do nothing more.

    try:
        c = self.c
        c.setLog()
        << activate this window >>
    except:
        g.es_event_exception("activate tree")
        
    return returnVal
#@+node:ekr.20040803072955.106:<< activate this window >>
if p == c.currentPosition():
    # g.trace("is current")
    # The *second* click in the headline starts editing.
    if self.active:
        self.editLabel(p)
        returnVal = 'continue'
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.treeWantsFocusNow()
        returnVal = 'break'
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    returnVal = 'break'

# The next click *in the same headline* will start editing.
self.active = True
#@-node:ekr.20040803072955.106:<< activate this window >>
#@-node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
#@+node:ekr.20051024102724:tkTtree.setBindings
def setBindings (self):
    
    '''Create master bindings for all headlines.'''
    
    tree = self ; k = self.c.k
    
    << make bindings for a common binding widget >>

    self.canvas.bind('<Key>',k.masterKeyHandler)
    self.canvas.bind('<Button-1>',self.onTreeClick)

    << make bindings for tagged items on the canvas >>
    << create baloon bindings for tagged items on the canvas >>
#@+node:ekr.20060131173440:<< make bindings for a common binding widget >>
self.bindingWidget = t = Tk.Text(self.canvas,name='bindingWidget')

t.bind('<Key>',k.masterKeyHandler)

table = (
    ('<Button-1>',       k.masterClickHandler,          tree.onHeadlineClick),
    ('<Button-3>',       k.masterClick3Handler,         tree.onHeadlineRightClick),
    ('<Double-Button-1>',k.masterDoubleClickHandler,    tree.onHeadlineClick),
    ('<Double-Button-3>',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
)

for a,handler,func in table:
    def treeBindingCallback(event,handler=handler,func=func):
        return handler(event,func)
    t.bind(a,treeBindingCallback)
    
self.textBindings = t.bindtags()
#@-node:ekr.20060131173440:<< make bindings for a common binding widget >>
#@+node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '<Button-1>',self.onClickBoxClick),
    ('iconBox','<Button-1>',self.onIconBoxClick),
    ('iconBox','<Double-1>',self.onIconBoxDoubleClick),
    ('iconBox','<Button-3>',self.onIconBoxRightClick),
    ('iconBox','<Double-3>',self.onIconBoxRightClick),
    ('iconBox','<B1-Motion>',self.onDrag),
    ('iconBox','<Any-ButtonRelease-1>',self.onEndDrag),
)
for tag,event,callback in table:
    self.canvas.tag_bind(tag,event,callback)
#@-node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
#@+node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
if 0: # I find these very irritating.
    for tag,text in (
        # ('plusBox','plusBox'),
        ('iconBox','Icon Box'),
        ('selectBox','Click to select'),
        ('clickBox','Click to expand or contract'),
        # ('textBox','Headline'),
    ):
        # A fairly long wait is best.
        balloon = Pmw.Balloon(self.canvas,initwait=700)
        balloon.tagbind(self.canvas,tag,balloonHelp=text)
#@-node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
#@-node:ekr.20051024102724:tkTtree.setBindings
#@-node:ekr.20060824112937.1:Fix unicode problem with double-click word Stéphane
#@+node:ekr.20060928194335:Fix bug: closing a window after removing a script button can crash
#@-node:ekr.20060928194335:Fix bug: closing a window after removing a script button can crash
#@-node:ekr.20060927172440:To do before 4.4.2 final
#@+node:ekr.20060822174843:Most important
#@+node:ekr.20050831131028:opml
#@+node:ekr.20050831131452:Original post
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3280949
By: billp9619

>>Making Leo a friendly part of the opml world has the potential to be very
important to Leo. <<

This is probably point 5. and covers the implementation of opml features as
exposed in Leo.

Because Leo is highly scripted there may be many requests... currently out on
the OPML list... that are solveable....such as how to see their outlines as
HTML without passing thru the OPML web server /host. BTW...all this new opml
stuff is only a week or two in production. The first message on
http://groups.yahoo.com/group/opml-newbies/
is July 25.

>> The question of whether to duplicate body text in <outline> elements
is minor<<

Good. 

Really, the opml tools are pretty much raw text/xml  and I was thinking the
default fallback is ... all clone text is "duplicate". If you want clones then
you will take care to only edit them in Leo. But if opml users all know and
use clones routinely in other editors,  then this is good news for opml
as technology.

>>more complicated than it needs to be<<

Well, both Leo and opml have only a few elements and each primarilly uses one
which recusively nests to make up the outline portion. I suppose body nodes
could be included more directly in headlines ... allowing un-numbered headlines
basically, ... but I am not sure that the current way is inferior
or complicated.

 A simpler (forgiving?) format might make it easier to create with external
apps and encourage transforming other xml to Leo via XSLT. It would have to
just "work".

(One thing about Leo's bias towards elements to contain markup, versus attributes,
is that ...you can cheat a little on escaping &quot; in vh or t nodes ?...which
makes code blocks smaller in the Leo xml.)

Your list above is pretty much how I see it as well.

regards,

bill p

#@-node:ekr.20050831131452:Original post
#@+node:ekr.20050831131452.1:opml attributes v elements
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3282460
By: billp9619

Looking at some discussion of outline formats there was a remark that because
opml places all text in attributes it is limited in not being able to contan
other elements. On xml-dev I also saw some advice about opml followed by the
comment that it is not a good format.

opml is crippled in this regard but  Leo only restricts itself as a choice in
order to  discern leo xml from content.(out of necessity we know).

Of course with xml you can mix vocabularies based on the use of namespaces.
By becoming namespace aware Leo could be adapted for non-escaped markup. The
purpose then is xml parsing of leo as a standard container of other xml. I do
not believe this is unthinkable  for some future capabilities... especially
if such nodes would contain exclusively xml from another namespace.

Just interesting that leo's format is more versatile than opml, 
but, ...by choice for its own purposes, ...
 is in this part "backward" compatible with opml. :)  

regards,

bill p
#@-node:ekr.20050831131452.1:opml attributes v elements
#@+node:ekr.20050912063133:@url http://sourceforge.net/forum/message.php?msg_id=3273977
#@-node:ekr.20050912063133:@url http://sourceforge.net/forum/message.php?msg_id=3273977
#@+node:ekr.20050912065811:@url http://sourceforge.net/forum/message.php?msg_id=3279900 (summary)
#@-node:ekr.20050912065811:@url http://sourceforge.net/forum/message.php?msg_id=3279900 (summary)
#@+node:ekr.20050915062404:My post
@nocolor

Hi,

I am the author of Leo http://webpages.charter.net/edreamleo/front.html an outline editor supporting clones http://webpages.charter.net/edreamleo/intro.html#clones-views.

I am interested in having Leo be able to read and write opml files.  My understanding is that applications are free to use attributes of <outline> elements as they please, but I am wondering whether there are guidelines or existing conventions for representing clones.  Have any namespaces been defined for that purpose?

Thanks.

Edward
#@-node:ekr.20050915062404:My post
#@-node:ekr.20050831131028:opml
#@+node:ekr.20041228084830.3:Finish wxWindows plugin
# Don't use body wrappers, use g.app.gui methods instead
#@-node:ekr.20041228084830.3:Finish wxWindows plugin
#@+node:ekr.20060823105514.1:Really solid perfect import
@nocolor

- Make sure whitespace is preserved properly.

- Make sure perfect import works.
#@nonl
#@-node:ekr.20060823105514.1:Really solid perfect import
#@+node:ekr.20051202094427:Resolve cvs conflicts
Investigate meld:  http://meld.sourceforge.net/
#@nonl
#@+node:ekr.20060823105514:Simulate cvs conflicts by using 2 repositories simultaneously
#@-node:ekr.20060823105514:Simulate cvs conflicts by using 2 repositories simultaneously
#@+node:ekr.20060601073503:Postings
@nocolor
#@nonl
#@+node:ekr.20031218072017.658:Stepen Schaefer 1
@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
#@-node:ekr.20031218072017.658:Stepen Schaefer 1
#@+node:ekr.20050501111900:Stephen Schaefer 2
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3125092
By: thyrsus

About a month ago, I posted a screed on how @thin was inadequate to address
my needs; that what I needed to collaborate on via version control was exactly
the essence of Leo's value: the multiple expressions of structure, which by
their nature must exist outside of @thin.  I said I was going to live the pain
to discover a modus vivendi.

Having done that, let me now say:

AAAAAAAAAAAAGGGGGGGGHHHHHHHHHH!

But the exercise has led me to a vision, which I will implement to the extent
my nonexistent spare time and paltry programming talents permit.

The essence of the pain is "conflicts", which become more  certain to occur
as the leo file encompases ever more related files.  As I work on a change to
the Linux configuration, my colleague works on a change to the Solaris configuration,
and one of us checks in our version of the leo file documenting the site
configuration first, and the other cannot check in his version of that file.
The conflict must be resolved by the human.  Using the "diff" tool on the .leo
XML is not an answer (though thank Heaven and Ed for gnxs).  The resolution
needs two levels of support: outline and node.

With the .leo file declared binary, in the event of a conflict CVS leaves you
with the most recent CVS version and your rejected version, and you're responsible
for performing a reconciliation and then resubmitting that.  Leo will recognize
the problem, and present both versions of the project, side by side, splitting
the outline pane.  The parallel trees will scroll/expand/contract in unison.
Outline branches present in CVS and not yours will display as blank space in
your version; nodes present in your version and not CVS will display as blank
space in the CVS version. The CVS version will be read only, your version editable.
The same node with differences in its text or in its children will be highlighted.
You will be able to drag nodes from the CVS version into your version. If the
text of a selected node has conflicts, the text area will split in two, showing
the CVS version and your version, with differences highlighted, both sides of
the pane scrolling in unison, the CVS side read-only, and you can copy from
that side to your side.  I intend to take as many ideas as I can from tkdiff
(http://sourceforge.net/projects/tkdiff/ - see also
http://freshmeat.net/screenshots/10602/ ).  (I have begun translating tkdiff
from from tcl to python - nearly 9000 lines and I'm still learning both languages,
so draw your own timeline.)  You edit your nodes, you edit your tree, you hit
the "reconcile" button, and your reconciliation of the conflict goes into CVS.
If, meanwhile, another one of your over-achieving colleages has again updated
CVS, the process repeats with the most current CVS version.  Or you can hit
the "abandon" button to give up on your changes.

As the Hebrews say at Passover: "Next year in Jerusalem."
#@nonl
#@-node:ekr.20050501111900:Stephen Schaefer 2
#@+node:ekr.20031218072017.659:Jonathon 1
@nocolor

http://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

In the .leo, if I edit <<bar>>, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@verbatim
#@+leo
#@verbatim
#@+node:0::@file foo.py
#@verbatim
#@+body
#@verbatim
#@+others
#@verbatim
#@+node:1::definition of a
#@verbatim
#@+body
print "a:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"bar"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:1::definition of a
#@verbatim
#@+node:2::definition of b
#@verbatim
#@+body
print "b:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation b"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:2::definition of b
#@verbatim
#@+node:3::definition of c
#@verbatim
#@+body
print "c:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation c"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:3::definition of c
#@verbatim
#@-others
#@verbatim
#@-body
#@verbatim
#@-node:0::@file foo.py
#@verbatim
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
#@-node:ekr.20031218072017.659:Jonathon 1
#@+node:ekr.20031218072017.660:Jonathan 2
@nocolor

By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

<<<<<<< 
blah blah blah? 
======= 
blah blah blah! 
>>>>>>> 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  
#@-node:ekr.20031218072017.660:Jonathan 2
#@+node:ekr.20031218072017.661:Gil 1
http://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
#@-node:ekr.20031218072017.661:Gil 1
#@+node:ekr.20031218072017.662:Gil 2
http://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?
#@nonl
#@-node:ekr.20031218072017.662:Gil 2
#@-node:ekr.20060601073503:Postings
#@-node:ekr.20051202094427:Resolve cvs conflicts
#@-node:ekr.20060822174843:Most important
#@+node:ekr.20060927173836.3:New & improved commands
#@+node:ekr.20060628103226:Finish emacs commands
#@+node:ekr.20060628103226.2:Alt-x handlers should add to lossage
#@-node:ekr.20060628103226.2:Alt-x handlers should add to lossage
#@+node:ekr.20060628095110:Fix yank and kill-line commands
Blank lines: deletes the newline.
Non-blank lines: deletes up to the newline.
#@nonl
#@+node:ekr.20050920084036.183:addToKillBuffer
def addToKillBuffer (self,text):
    
    killKeys =(
        '<Control-k>', '<Control-w>',
        '<Alt-d>', '<Alt-Delete', '<Alt-z>', '<Delete>',
        '<Control-Alt-w>')

    k = self.k
    self.reset = True

    # g.trace(repr(text))

    if self.killBuffer and k.stroke in killKeys:
        self.killBuffer [0] = self.killBuffer [0] + text
    else:
        self.killBuffer.insert(0,text)
#@-node:ekr.20050920084036.183:addToKillBuffer
#@+node:ekr.20050920084036.174:killBufferCommandsClass (add docstrings)
class killBufferCommandsClass (baseEditCommandsClass):
    
    '''A class to manage the kill buffer.'''

    @others
#@+node:ekr.20050920084036.175: ctor & finishCreate
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.reset = False
    try:
        self.widget = c.frame.body.bodyCtrl
    except AttributeError:
        self.widget = None

def finishCreate (self):
    
    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k
    
    if self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
#@-node:ekr.20050920084036.175: ctor & finishCreate
#@+node:ekr.20050920084036.176: getPublicCommands
def getPublicCommands (self):
    
    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
#@-node:ekr.20050920084036.176: getPublicCommands
#@+node:ekr.20050920084036.183:addToKillBuffer
def addToKillBuffer (self,text):
    
    killKeys =(
        '<Control-k>', '<Control-w>',
        '<Alt-d>', '<Alt-Delete', '<Alt-z>', '<Delete>',
        '<Control-Alt-w>')

    k = self.k
    self.reset = True

    # g.trace(repr(text))

    if self.killBuffer and k.stroke in killKeys:
        self.killBuffer [0] = self.killBuffer [0] + text
    else:
        self.killBuffer.insert(0,text)
#@-node:ekr.20050920084036.183:addToKillBuffer
#@+node:ekr.20050920084036.181:backwardKillSentence
def backwardKillSentence (self,event):
    
    '''Kill the previous sentence.'''
    
    w = event.widget
    i = w.search('.','insert',backwards=True,stopindex='1.0')

    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i,undoType='backward-kill-sentence')
#@-node:ekr.20050920084036.181:backwardKillSentence
#@+node:ekr.20050920084036.180:backwardKillWord
def backwardKillWord (self,event):
    
    '''Kill the previous word.'''

    c = self.c
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.killWord(event)
    # c.editCommands.backwardWord(event)
#@-node:ekr.20050920084036.180:backwardKillWord
#@+node:ekr.20051216151811:clearKillRing
def clearKillRing (self,event=None):
    
    '''Clear the kill ring.'''
    
    self.killBuffer = []
#@-node:ekr.20051216151811:clearKillRing
#@+node:ekr.20050920084036.185:getClipboard
def getClipboard (self,w):

    try:
        ctxt = w.selection_get(selection='CLIPBOARD')
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except: pass

    return None
#@-node:ekr.20050920084036.185:getClipboard
#@+node:ekr.20050920084036.184:iterateKillBuffer
def iterateKillBuffer (self):

    while 1:
        if self.killBuffer:
            self.last_clipboard = None
            for z in self.killBuffer:
                if self.reset:
                    self.reset = False
                    break
                yield z
#@-node:ekr.20050920084036.184:iterateKillBuffer
#@+node:ekr.20050920084036.178:kill, killLine, killWord
def kill (self,event,frm,to,undoType=None):

    k = self.k ; w = event.widget
    s = w.get(frm,to)
    
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    w.clipboard_clear()
    w.clipboard_append(s)
    w.delete(frm,to)
    if undoType: self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    self.kill(event,'insert linestart','insert lineend+1c','kill-line')

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    self.kill(event,'insert wordstart','insert wordend','kill-word')
    self.killWs(event)
#@-node:ekr.20050920084036.178:kill, killLine, killWord
#@+node:ekr.20050920084036.182:killRegion & killRegionSave & helper
def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)
    
def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = event.widget

    if g.app.gui.isTextWidget(w):
        theRange = w.tag_ranges('sel')
        if theRange:
            s = w.get(theRange[0],theRange[-1])
            if deleteFlag:
                w.delete(theRange[0],theRange[-1])
            self.addToKillBuffer(s)
            w.clipboard_clear()
            w.clipboard_append(s)
            self.removeRKeys(w)
#@-node:ekr.20050920084036.182:killRegion & killRegionSave & helper
#@+node:ekr.20050930095323.1:killSentence
def killSentence (self,event):
    
    '''Kill the sentence containing the cursor.'''

    w = event.widget
    i  = w.search('.','insert',stopindex='end')
    if i:
        i2 = w.search('.','insert',backwards=True,stopindex='1.0')
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i,undoType='kill-sentence')
#@-node:ekr.20050930095323.1:killSentence
#@+node:ekr.20050930100733:killWs
def killWs (self,event):
    
    ws = '' ; w = event.widget

    while 1:
        s = w.get('insert')
        if s in (' ','\t'):
            w.delete('insert')
            ws = ws + s
        else:
            break
            
    if ws:
        self.addToKillBuffer(ws)
#@-node:ekr.20050930100733:killWs
#@+node:ekr.20050930091642.1:yank
def yank (self,event):
    
    '''Insert the next entry in the kill ring at the insert point.'''

    k = self.k ; w = self.w
    i = w.index('insert')
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        self.reset = True
        s = clip_text or self.kbiterator.next()
        w.tag_delete('kb')
        w.insert('insert',s,('kb'))
        w.mark_set('insert',i)
#@-node:ekr.20050930091642.1:yank
#@+node:ekr.20050930091642.2:yankPop
def yankPop (self,event):
    
    '''Replaces the just-yanked kill buffer with the contents of the previous kill buffer.'''

    k = self.k ; w = event.widget
    i = w.index('insert') ; t, t1 = i.split('.')
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        if clip_text: s = clip_text
        else:         s = self.kbiterator.next()
        t1 = str(int(t1)+len(s))
        r = w.tag_ranges('kb')
        if r and r [0] == i:
            w.delete(r[0],r[-1])
        w.tag_delete('kb')
        w.insert('insert',s,('kb'))
        w.mark_set('insert',i)
#@-node:ekr.20050930091642.2:yankPop
#@+node:ekr.20050920084036.128:zapToCharacter
def zapToCharacter (self,event):
    
    '''Kill characters from the insertion point to a given character.'''

    k = self.k ; state = k.getState('zap-to-char')

    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        c = k.c ; w = event.widget ; ch = event.char
        k.resetLabel()
        k.clearState()
        if (
            len(event.char) != 0 and
            ch in (string.ascii_letters + string.digits + string.punctuation)
        ):
            i = w.search(ch,'insert',stopindex='end')
            if i:
                t = w.get('insert','%s+1c' % i)
                self.addToKillBuffer(t)
                w.delete('insert','%s+1c' % i)
#@-node:ekr.20050920084036.128:zapToCharacter
#@-node:ekr.20050920084036.174:killBufferCommandsClass (add docstrings)
#@-node:ekr.20060628095110:Fix yank and kill-line commands
#@+node:ekr.20060628094329.2:Test/Fix macros
#@-node:ekr.20060628094329.2:Test/Fix macros
#@+node:ekr.20060628103226.3:Make sure repeat counts work on basic editing commands
#@-node:ekr.20060628103226.3:Make sure repeat counts work on basic editing commands
#@-node:ekr.20060628103226:Finish emacs commands
#@+node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@-node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@+node:ekr.20060927174531:New gui commands
- delete-completion-tab (somewhat useful for cycling focus)
#@nonl
#@-node:ekr.20060927174531:New gui commands
#@+node:ekr.20060927173836.4:New move outlihe commands
- move-to-last-sibling
- move-to-first-sibling
- move-outline-all-the-way-left
#@nonl
#@-node:ekr.20060927173836.4:New move outlihe commands
#@+node:ekr.20060927173836.5:Repeat counts for cursor moves
#@-node:ekr.20060927173836.5:Repeat counts for cursor moves
#@+node:ekr.20060927173836:Better print-binding command
# Separate sections for single-character Ctrl and Alt keys.
#@nonl
#@-node:ekr.20060927173836:Better print-binding command
#@+node:ekr.20060927173836.2:Find next doesn't find any more if regexp matches an empty string.
#@-node:ekr.20060927173836.2:Find next doesn't find any more if regexp matches an empty string.
#@-node:ekr.20060927173836.3:New & improved commands
#@+node:ekr.20060531161030:To do: 4.4.x
#@+node:ekr.20060822162521:Make headlines scroll
Limit the with of the headline to the width of the outline pane.
#@nonl
#@-node:ekr.20060822162521:Make headlines scroll
#@+node:ekr.20060724071225:Look at Paste Node As Clone
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3835397
By: nobody

In my large outline with probably thousands of nodes, "paste node as clone"
takes almost a minute to complete, always. Is this normal behavior? It slows
down my thought processes significantly to have to wait 1 minute to clone a
node...

@color
#@nonl
#@+node:EKR.20040610130943:pasteOutlineRetainingClones
def pasteOutlineRetainingClones (self,event=None):
    
    '''Paste an outline into the present outline from the clipboard.
    Nodes *retain* their original identify.'''
    
    c = self

    return c.pasteOutline(reassignIndices=False)
#@-node:EKR.20040610130943:pasteOutlineRetainingClones
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):
    
    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')
    
    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        << remember all data for undo/redo Paste As Clone >>

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return

    c.beginUpdate()
    try:
        copiedBunchList = []
        if pasteAsClone:
            << put only needed info in copiedBunchList >>
        undoData = u.beforeInsertNode(current,
            pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
        c.endEditing()
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        c.setRootPosition(c.findRootPosition(pasted)) # New in 4.4.2.
        u.afterInsertNode(pasted,undoType,undoData)
    finally:
        c.endUpdate()
        c.recolor()
#@+node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())
#@-node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
#@+node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
# Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t
        
# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
#@-node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:ekr.20031218072017.1559:getLeoOutlineFromClipboard & helpers
def getLeoOutlineFromClipboard (self,s,reassignIndices=True):
    
    '''Read a Leo outline from string s in clipboard format.'''

    try:
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=True)
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=False)
    except invalidPaste:
        v = None
        g.es("Invalid Paste As Clone",color="blue")
    except BadLeoFile:
        v = None
        g.es("The clipboard is not valid ",color="blue")

    return v
    
getLeoOutline = getLeoOutlineFromClipboard # for compatibility
#@nonl
#@+node:ekr.20031218072017.1557:finishPaste
def finishPaste(self,reassignIndices=True):
    
    """Finish pasting an outline from the clipboard.
    
    Retain clone links if reassignIndices is False."""

    c = self.c
    current = c.currentPosition()
    if reassignIndices:
        << reassign tnode indices >>
    c.selectPosition(current)
    return current
#@+node:ekr.20031218072017.1558:<< reassign tnode indices >>
@ putLeoOutline calls assignFileIndices (when copying nodes) so that vnode can be associated with tnodes.
However, we must _reassign_ the indices here so that no "False clones" are created.
@c

current.clearVisitedInTree()

for p in current.self_and_subtree_iter():
    t = p.v.t
    if not t.isVisited():
        t.setVisited()
        self.maxTnodeIndex += 1
        t.setFileIndex(self.maxTnodeIndex)
#@-node:ekr.20031218072017.1558:<< reassign tnode indices >>
#@-node:ekr.20031218072017.1557:finishPaste
#@+node:ekr.20060826052453.1:getLeoOutlineHelper
def getLeoOutlineHelper (self,s,reassignIndices,checking):
    
    self.checking = checking
    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.descendentUnknownAttributesDictList = []
    v = None

    self.tnodesDict = {}
    if not reassignIndices:
        << recreate tnodesDict >>
    try:
        self.getXmlVersionTag()
        self.getXmlStylesheetTag()
        self.getTag("<leo_file>")
        self.getClipboardHeader()
        self.getVnodes(reassignIndices)
        self.getTnodes()
        self.getTag("</leo_file>")
        if not checking:
            v = self.finishPaste(reassignIndices)
    finally:
        self.fileBuffer = None ; self.fileIndex = 0
        self.usingClipboard = False
        self.tnodesDict = {}
    return v
#@nonl
#@+node:EKR.20040610134756:<< recreate tnodesDict >>
nodeIndices = g.app.nodeIndices

self.tnodesDict = {}

for t in self.c.all_unique_tnodes_iter():
    tref = t.fileIndex
    if nodeIndices.isGnx(tref):
        tref = nodeIndices.toString(tref)
    self.tnodesDict[tref] = t
    
if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]
#@-node:EKR.20040610134756:<< recreate tnodesDict >>
#@-node:ekr.20060826052453.1:getLeoOutlineHelper
#@+node:ekr.20031218072017.3022:getClipboardHeader
def getClipboardHeader (self):

    if self.getOpenTag("<leo_header"):
        return # <leo_header> or <leo_header/> has been seen.

    while 1:
        if self.matchTag("file_format="):
            self.getDquote() ; self.fileFormatNumber = self.getLong() ; self.getDquote()
        elif self.matchTag("tnodes="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("max_tnode_index="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("></leo_header>"): # new in 4.2: allow this form.
            break
        else:
            self.getTag("/>")
            break
#@-node:ekr.20031218072017.3022:getClipboardHeader
#@-node:ekr.20031218072017.1559:getLeoOutlineFromClipboard & helpers
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self,reassignIndices=True):

    c = self.c

    if self.getOpenTag("<vnodes>"):
        return # <vnodes/> seen.
        
    self.forbiddenTnodes = []
    back = parent = None # This routine _must_ work on vnodes!
    self.currentVnodeStack = []
    self.topVnodeStack = []
        
    if self.usingClipboard:
        oldRoot = c.rootPosition()
        oldCurrent = c.currentPosition()
        if not reassignIndices:
            << set self.forbiddenTnodes to tnodes than must not be pasted >>

    while self.matchTag("<v"):
        append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
        append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if self.usingClipboard and not self.checking:
        # Link in the pasted nodes after the current position.
        newRoot = c.rootPosition()
        c.setRootPosition(oldRoot)
        newRoot.v.linkAfter(oldCurrent.v)
        newCurrent = oldCurrent.copy()
        newCurrent.v = newRoot.v
        c.setCurrentPosition(newCurrent)

    self.getTag("</vnodes>")
#@+node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
self.forbiddenTnodes = []

for p in oldCurrent.self_and_parents_iter():
    if p.v.t not in self.forbiddenTnodes:
        self.forbiddenTnodes.append(p.v.t)
        
# g.trace("forbiddenTnodes",self.forbiddenTnodes)
#@-node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20031218072017.1566:getVnode & helpers
# changed for 4.2 & 4.4
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = '' ; tnodeList = None ; attrDict = {}

    # we have already matched <v.
    
    # New in Leo 4.4: support collapsed tnodes.
    if self.matchTag('/>'): # A collapsed vnode.
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        if self.checking: return None
        else: return v
    
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2, deprecated for 4.3?
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2.
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
        if v: # Bug fix: 4/18/05: The headline may change during paste as clone.
            v.initHeadString(headline,encoding=self.leo_file_encoding)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        if not self.checking:
            skip = skip or skip2
            if tnodeList:
                v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
            
    if not self.checking:
        << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
    
    if not self.checking:
        << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@+node:ekr.20031218072017.1860:createVnode
# (changed for 4.2) sets skip

def createVnode (self,parent,back,tref,headline,attrDict):
    
    # g.trace(parent,headline)
    v = None ; c = self.c
    # Shared tnodes are placed in the file even if empty.
    if tref == -1:
        t = leoNodes.tnode()
    else:
        tref = self.canonicalTnodeIndex(tref)
        t = self.tnodesDict.get(tref)
        if not t:
            t = self.newTnode(tref)
            
    if self.checking: return None,False
    
    if back: # create v after back.
        v = back.insertAfter(t)
    elif parent: # create v as the parent's first child.
        v = parent.insertAsNthChild(0,t)
    else: # create a root vnode
        v = leoNodes.vnode(t)
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.

    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v) # New in 4.2.

    skip = len(v.t.vnodeList) > 1
    v.initHeadString(headline,encoding=self.leo_file_encoding)
    << handle unknown vnode attributes >>
    # g.trace(skip,tref,v,v.t,len(v.t.vnodeList))
    return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
    v.unknownAttributes = attrDict
    v._p_changed = 1

    if 0: # For debugging.
        s = "unknown attributes for " + v.headString()
        g.es_print(s,color="blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            g.es_print(s)
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode
#@+node:ekr.20040701065235.1:getDescendentAttributes
def getDescendentAttributes (self,s,tag=""):
    
    '''s is a list of gnx's, separated by commas from a <v> or <t> element.
    Parses s into a list.
    
    This is used to record marked and expanded nodes.
    '''
    
    __pychecker__ = '--no-argsused' # tag used only for debugging.

    gnxs = s.split(',')
    result = [gnx for gnx in gnxs if len(gnx) > 0]
    # g.trace(tag,result)
    return result
#@-node:ekr.20040701065235.1:getDescendentAttributes
#@+node:EKR.20040627114602:getDescendentUnknownAttributes
# Only @thin vnodes have the descendentTnodeUnknownAttributes field.
# The question is: what are we to do about this?

def getDescendentUnknownAttributes (self,s):
    
    try:
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except (TypeError,pickle.UnpicklingError,ImportError):
        g.trace('oops: getDescendentUnknownAttributes')
        return None
#@-node:EKR.20040627114602:getDescendentUnknownAttributes
#@+node:ekr.20040326063413:getExistingVnode
def getExistingVnode (self,tref,headline):

    assert(tref > -1)
    tref = self.canonicalTnodeIndex(tref)
    t = self.tnodesDict.get(tref)
    try:
        return t.vnodeList[0]
    except (IndexError,AttributeError):
        g.es("Missing vnode:",headline,color="red")
        g.es("Probably an outline topology error.")
        return None
#@-node:ekr.20040326063413:getExistingVnode
#@-node:ekr.20031218072017.1566:getVnode & helpers
#@-node:ekr.20060724071225:Look at Paste Node As Clone
#@-node:ekr.20060531161030:To do: 4.4.x
#@+node:ekr.20060527164612:Important 1-2 day projects
#@+node:ekr.20060531161030.1:Make body editors persistant
#@-node:ekr.20060531161030.1:Make body editors persistant
#@+node:ekr.20060624082529:Fix minor bugs
#@+node:ekr.20060117074259:Handle Mac issues
#@+node:ekr.20060117074259.1:Mac indentation problem
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3526056
By: nobody

Hi Edward. I've been using the linux and windows version but would like to try
leo on the mac. The install instructions seem a bit out of date. I take it any
additional downloading of TclTkAqua is unneccessary?

I have python2.4 in addition to the stock python 2.3.5 that comes with osx 10.4.
Launching leo like so:  "python2.4 leo.py", as I do on linux, seems to run just
fine.

I don't know if this was fixed on osx or in leo in general, but moving the mouse
to each of the panes and scrolling with the wheel works just great now. Thanks.

Plugin manager: the plugin text font is really tiny, and the window opens to
a default width such that the 'Installed Plugins' button reads 'talled Plugi'.
Resizing the window does stretch the buttons horizontally.

Ok -- here's maybe a big issue. I open a new leo file (File->New) and type in:

for i in range(3):

I hit return after the colon, but a newline is not entered.

Stephen
#@-node:ekr.20060117074259.1:Mac indentation problem
#@+node:ekr.20051112080017:Problem removing script buttons on the mac
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3423121
By: nobody

Hi! I need help removing script buttons. It says I should right click the ofending
button. I have a mac and Ctl-click, Command-click, etc doesn't work. What should
I do?

EKR: This is on the list of unfixable bugs, but I have a hard time believing there is no workaround.
#@nonl
#@-node:ekr.20051112080017:Problem removing script buttons on the mac
#@+node:ekr.20060116083043:Use special Help menu on the Mac
# http://sourceforge.net/forum/message.php?msg_id=3237845
#@nonl
#@+node:ekr.20031218072017.3803:createHelpMenuFromTable
def createHelpMenuFromTable (self):

    if 0: ## sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu()
        if not helpMenu: return
    else:
        helpMenu = self.createNewMenu("&Help")
    
    self.createMenuEntries(helpMenu,self.helpMenuTable)
#@nonl
#@-node:ekr.20031218072017.3803:createHelpMenuFromTable
#@+node:ekr.20031218072017.4113:new_menu
def new_menu(self,parent,tearoff=False):
    
    """Wrapper for the Tkinter new_menu menu method."""
    
    if self.font:
        try:
            return Tk.Menu(parent,tearoff=tearoff,font=self.font)
        except Exception:
            g.es_exception()
            return Tk.Menu(parent,tearoff=tearoff)
    else:
        return Tk.Menu(parent,tearoff=tearoff)
#@-node:ekr.20031218072017.4113:new_menu
#@+node:ekr.20031218072017.3804:createNewMenu
def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName) # parent may be None.
        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists: " + menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&")
            label = label.replace("&","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&")
                index_label = index_label.replace("&","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating " + menuName + " menu")
        g.es_exception()
        return None
#@-node:ekr.20031218072017.3804:createNewMenu
#@+node:ekr.20031218072017.3807:getMenu, setMenu, destroyMenu
def getMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    return self.menus.get(cmn)
    
def setMenu (self,menuName,menu):
    
    cmn = self.canonicalizeMenuName(menuName)
    self.menus [cmn] = menu
    
def destroyMenu (self,menuName):
    
    cmn = self.canonicalizeMenuName(menuName)
    del self.menus[cmn]
#@-node:ekr.20031218072017.3807:getMenu, setMenu, destroyMenu
#@+node:ekr.20060211144330.1:getMacHelpMenu
def getMacHelpMenu (self):
    
    return None ###
    
    try:
        helpMenu = Tk.Menu('top.help')
        return helpMenu
        
    except Exception:
        g.trace('Can not get MacOS Help menu')
        g.es_exception()
        return None
#@-node:ekr.20060211144330.1:getMacHelpMenu
#@-node:ekr.20060116083043:Use special Help menu on the Mac
#@-node:ekr.20060117074259:Handle Mac issues
#@+node:ekr.20060202235215.3:Remove deprecation warning
#@+node:EKR.20040627114602:getDescendentUnknownAttributes
# Only @thin vnodes have the descendentTnodeUnknownAttributes field.
# The question is: what are we to do about this?

def getDescendentUnknownAttributes (self,s):
    
    try:
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except (TypeError,pickle.UnpicklingError,ImportError):
        g.trace('oops: getDescendentUnknownAttributes')
        return None
#@-node:EKR.20040627114602:getDescendentUnknownAttributes
#@-node:ekr.20060202235215.3:Remove deprecation warning
#@+node:ekr.20060610193837:open python window does not appear to work on Solaris
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3771068
By: leouser

The open python window does not appear to work on Solaris.

http://sourceforge.net/forum/message.php?msg_id=3771167
By: nobody

from what I could see it looked like it was trying to start the shell up with
a location that pointed to a nonexistent path.
#@nonl
#@-node:ekr.20060610193837:open python window does not appear to work on Solaris
#@-node:ekr.20060624082529:Fix minor bugs
#@+node:ekr.20031218072017.801:Support .leo.gz or .leo.zip files
#@+node:ekr.20050428062312:Request 1
@nocolor

By: samcollett ( Sam Collett ) 
 Compressed LEO files   
2003-01-07 16:57


Would it be possible to have a new file format that was basically a compressed
version of LEO files? Maybe using the gzip compression method. You could then
save a lot of space when you do large files. Not being a professional
programmer myself (I mainly dabble in web design - HTML and Active Server
Pages) how difficult would this be to implement? You would just output using a
different file extension so users of the older versions can still use files
with the LEO extension.
#@-node:ekr.20050428062312:Request 1
#@+node:ekr.20040226092546:Request 2
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2442772
By: ejoy

I made an experiment last night. I replaced the call to open()in leofilecommand.py
with a call to gzip.open().

The LeoPy.leo file saved this way is only 600K! And there is no significant
speed down in saving.

I think it is a good idea to add compression support for load/save .leo files.
When reading or writing file with name ending with ".leo.gz", leo can call gzip
module to uncompress/compress the file, saving a lot of disk space.

What do you think of this?
#@nonl
#@-node:ekr.20040226092546:Request 2
#@+node:ekr.20031218072017.2297:open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    if not use_sax: # Read the entire file into the buffer
        self.fileBuffer = theFile.read() ; theFile.close()
        self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    ok, ratio = self.getLeoFile(
        theFile,fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    if not use_sax: # Delete the file buffer
        self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.2297:open (leoFileCommands)
#@+node:ekr.20050428063105:newOpen (From chapters.py)
oldOpen = leoFileCommands.fileCommands.open

def newOpen( self,file,fileName,readAtFileNodesFlag=True,silent=False):

    global iscStringIO
    c = self.c
    
    if zipfile.is_zipfile( fileName ):
        iscStringIO = True
        chapters = openChaptersFile( fileName )
        g.es( str( len( chapters ) ) + " Chapters To Read", color = 'blue' )
        insertChapters( chapters, c.frame, c )
        g.es( "Finished Reading Chapters", color = 'blue' )
        iscStringIO = False
        return True

    return oldOpen(self,file,fileName,readAtFileNodesFlag,silent)
#@nonl
#@-node:ekr.20050428063105:newOpen (From chapters.py)
#@-node:ekr.20031218072017.801:Support .leo.gz or .leo.zip files
#@+node:ekr.20060530130736.2:Customize Open With menu without writing code
http://sourceforge.net/forum/message.php?msg_id=3737745

Desparately needs a way to modify the Open-With menu other than going
in and changing the code.
#@+node:ekr.20060619101345:@open-with settings
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3785897

From: Rich

Would it be possible to have the table of "Open With" editors to be part of
the config system? I find myself patching the list every time I D/L a new Leo
version to add the editor I use. This would also help isolate the user from
the "guts" of Leo, theereby being less intimidating.

Yes, it would be possible because everything in the table is a string (and not,
e.g., a reference to a method). This would require support for @open-with in
@settings trees.
#@-node:ekr.20060619101345:@open-with settings
#@-node:ekr.20060530130736.2:Customize Open With menu without writing code
#@+node:ekr.20060530085844:Improve autocompletion
#@-node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20041022091645.4:Pymacs
#@+node:ekr.20040125121407:Postings
@nocolor
#@nonl
#@+node:ekr.20040125121407.1:randomandy
http://sourceforge.net/forum/message.php?msg_id=2389876
By: randomandy

Is it only me who sees this as a question on how to reinvent the wheel? (or
in the case of emacs, how to reinvent the <i>everything</i>.)

Leo and Python both seem so well suited as wonderful hierarchal glue programs.
And both are so elegant in the way their simple functionality brings such power
and order to the cause. It just seems it would be a shame to take something
so novel and unique and try to turn it into <i>yet another</i> huge text editor.

I'm with <A HREF="http://sourceforge.net/forum/message.php?msg_id=2345873">Danny
</A> on this one. The ideal solution is to find the most elegant and seamless
way to splice one's own beloved text editor (or multipurpose editor/OS) in with
the Leo paradigm. Have Leo hand off the text duties to the editor, or have the
editor deliver heirarchy commands to Leo.

I'm also quite curious if this makes a good tie in with SciTE. SciTE produces
stunningly readible language highlighting/formatting. Could it be employed for
basic cell text display, and then for heavier editing, a keystroke or button
could open the cell text in one's preferred weapons grade text editor?

Scintilla also has a similarly beautiful code-to-html and code-to-pdf capability
that seems very suited to the literary part of the Leo paradigm: publication.
It would be nice if that code could be exploited as well.

This Leo is really a marvelous work. It's transforming the way I think (i.e.
making it possible again). Nice work, Edward.
#@-node:ekr.20040125121407.1:randomandy
#@+node:ekr.20040125121407.2:dannyobrien
By: dannyobrien ( danny o'brien ) 
 RE: What would it take to turn Leo into Emacs   
2003-12-23 09:18  

 I agree with the embedding; I've used the vim plugin and it works well, but actually embedding the editor directly into the text field of leo (and allowing a range of keyboard shortcuts for eg headline editing) would be perfect.

There is some support for this in gvim, the GUI version of vim that comes as standard. This can be run so as its GUI is "embedded" in another GTK widget, using that library's GtkSocket/GtkPlug system. A quick demo of that (and how to do it in python) is here:

http://www.daa.com.au/pipermail/pygtk/2003-October/006185.html

To see this working with gvim, run the second (socket.py) program on that page then type

gvim --socketid <number generated by socket.py>

I'm not sure how you could do this in other widget libraries - I don't know much about X Windows, but I suppose it would need support in vim as well as the widget set.
 
#@-node:ekr.20040125121407.2:dannyobrien
#@+node:ekr.20040125121407.3:mdawson
http://sourceforge.net/forum/message.php?msg_id=2388448
By: mdawson

I use XEmacs as my text editor.  The first thing I did when
evaluating Leo was to set up "open with" to use XEmacs for editing
Leo body text.

My progress so far:

- my Open_With Plugin opens a Leo node as a foreground buffer in
XEmacs, or a background (invisible) buffer in XEmacs.

- my Open_Tree Plugin opens a sub-tree of Leo nodes as background
buffers in XEmacs.

- my filename modification plugin changes the temporary file names
used by Leo so that they can be spotted more easily in an XEmacs
buffer listing (e.g. ibuffer).

- an elisp function to kill all XEmacs Leo buffers at once.

- another elisp function to indent and unindent the Leo comments in
derived Python source, which improves the readability of code.

- my setup of the elisp Multiple-Major-Modes XEmacs package, so that
XEmacs is in text-mode in Leo @doc sections, and the correct
language mode in @code sections.

Any of these might be able to be adapted for your own use. They
should all work with Emacs as well as XEmacs, but I've not tested
that.

These are all outlined in Appendix "C. XEmacs Text Editor" of the
document at:
    http://devguide.leo.marshallresearch.ca

and the Leo outline that contains them is available at:
    http://leo.marshallresearch.ca


    ----------------------------------------
    Michael Dawson
#@nonl
#@-node:ekr.20040125121407.3:mdawson
#@-node:ekr.20040125121407:Postings
#@+node:ekr.20041022144159:Q: Pymacs bridge
I'm trying to use the Pymacs bridge to add a symbol completion facility to
Emacs's python-mode.  Neither the Python nor Emacs Lisp portions are all
that complex, but I'm having trouble passing a list of strings from Emacs
Lisp into Python.  On the Emacs Lisp side it looks like this:

    (pymacs-load "pycomplete")

    (defun py-complete ()
      (interactive)
      (pycomplete-pycomplete (py-symbol-near-point)
                             (py-find-global-imports)))

(py-find-global-imports) returns a (Lisp) list of strings, e.g.:

    ("import time", "import sys")

On the Python side I have this function:

    def pycomplete(s, imports=None):
        completions = get_all_completions(s, imports)
        dots = s.split(".")
        return os.path.commonprefix([k[len(dots[-1]):] for k in completions])

Unfortunately, the imports arg does not come across as a Python list of
strings (s does come across the bridge as a normal Python string).  Its
repr() prints out like this:

    lisp('("import time")')

What do I need to do to convert that object into a true Python list of
strings?  I'm afraid I don't quite understand the description of the lisp
object in the Pymacs docs.  I tried imports.value() but that just gave me

    (aref pymacs-lisp 0)

Any help appreciated...

Skip
#@nonl
#@-node:ekr.20041022144159:Q: Pymacs bridge
#@+node:ekr.20041022144159.1:A: pymacs-forget-mutability
"""
Proper Emacs Lisp lists, those for which the cdr of last cell is nil, are
normally transmitted opaquely to Python. If pymacs-forget-mutability is
set, or if Python later asks for these to be expanded, proper Emacs Lisp
lists get converted into Python lists, if we except the empty list, which
is always converted as Python None. In the other direction, Python lists
are always converted into proper Emacs Lisp lists.
"""

So, maybe try

    (defun py-complete ()
      (interactive)
      (let ((pymacs-forget-mutability t)) 
	(pycomplete-pycomplete (py-symbol-near-point)
                               (py-find-global-imports))))
#@-node:ekr.20041022144159.1:A: pymacs-forget-mutability
#@-node:ekr.20041022091645.4:Pymacs
#@+node:ekr.20060306194040:Video and more screen shots Leo's web site
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/


http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

Thanks,
Kent
#@nonl
#@+node:ekr.20060531134434:Tutorials
http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
#@nonl
#@-node:ekr.20060531134434:Tutorials
#@+node:ekr.20060531134434.1:Screencasts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3758303
By: ktenney

My sense is that documentation/screencasts has the
greatest potential for expanding Leo's mindshare.

I really like those produced by the good folks
at Dabo;
http://leafe.com/screencasts/
http://leafe.com/screencasts/populategrid.html

The TurboGears people have taken this to the extreme;
http://www.turbogears.org/ultimate.html

Leo is different enough that it warrants a 
demonstration of it's advantages.
#@nonl
#@-node:ekr.20060531134434.1:Screencasts
#@+node:ekr.20060829103523:Render Leo slideshows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3889246
By: terry_n_brown

Three packages that might be candidates for "rendering" slides authored in Leo:

MagicPoint: http://member.wide.ad.jp/wg/mgp/

  uses a text file format that leo could produce

Slidy: http://www.w3.org/Talks/Tools/Slidy/

  uses XHTML / canned Java script

S5: http://meyerweb.com/eric/tools/s5/

  Similar to Slidy I think, haven't looked at it
#@nonl
#@-node:ekr.20060829103523:Render Leo slideshows
#@-node:ekr.20060306194040:Video and more screen shots Leo's web site
#@-node:ekr.20060527164612:Important 1-2 day projects
#@+node:ekr.20060527182117:Important 1-2 week projects
#@+node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060603085719.1:Use IPython autocompleter?
#@-node:ekr.20060603085719.1:Use IPython autocompleter?
#@+node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@-node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@+node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@-node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@+node:ekr.20060603090445.9:Script button that saves environment between runs
This would allow IPython-like operation.
#@nonl
#@-node:ekr.20060603090445.9:Script button that saves environment between runs
#@-node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060629154112:Merge Leo & jyLeo
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3799470
By: leouser

I guess its hard to say what pieces must merge and what can stay different.
Id like it if the blasted nodes were the same.  I guess there is progress again
on a jython 2.2 being complete and work starting on 2.3.  So there is hope that
the nodes will be the same code, at least it will be possible.

At the top of my head the big differences outside of the position changes are:
1. Some modifications to the read/write code so that Chapters can work and also
Serialized positions.
2. Commander has some things different, it looks to the Chapters instance to
determine what is the curentPosition, top Position etc... instead of keeping
track of it itself.
3. GUI layers are very different.  Interesting tidbit here: the work I did to
get the JTree to use positions to determine if a node is expanded or not looks
like it has provided the outline for enhancing the JTree for Java itself to
be able to do this.  We will have to see, but maybe in Java 7 you can say: "Positions
lead to user controled tree expansion models".

There is a tremendous amount that is the same. Im sure you could make an interesting
evening out of comparing the codebases to see where things change.


#@-node:ekr.20060629154112:Merge Leo & jyLeo
#@-node:ekr.20060527182117:Important 1-2 week projects
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
