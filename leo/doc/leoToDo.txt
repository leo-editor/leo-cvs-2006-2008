#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20070521100324:Marketing/tools
#@+node:ekr.20070521100324.1:Using Leo as a notebook
@nocolor
https://sourceforge.net/forum/message.php?msg_id=4314394
By: duanekaufman

I am starting a kinda 'stream-of-thought' document, one in which I can put down
a paragraph of thought (perhaps in a pretty fashion, using ReST markup), develop
some code, to do some calculations, run the code and display the results...rinse,
repeat.

The document, in pseudo-form, would look like:

<Development of thought #1>
<Code to calculate something>
<Results from code execution>
<Discussion of results>

Each of the above would probably be a node, and I have already put together
things that look like the above, all except for the <results> part. I can run
the code, but how can I get the output automatically in my node? I can cut-and-paste
from the underlying command window (I run under Linux and Windows XP), but I
would like o automate it as much as possible.

Does anyone have any ideas on how to accomodate this workflow?

------ Reply

A most interesting and important question--with such a capability one could make Leo into a full-fledged engineering notebook, e.g., as envisaged by the IPython Notebook project: 
 
http://projects.scipy.org/ipython/ipython/wiki/NbshellManual 
 
I can think of several possible approaches: 
 
1. Create a custom version of the execute script command that would put script output in a particular node. Perhaps the headline of the node could be an argument to the enhanced command. 
 
2. Have your script write to some 'standard place', and create a command to put that script in the presently selected node. Something like insert-script-output. 
 
3. Create a script button that executes the script in the presently selected node and puts the result in the node *following* the selected node. You can then either move the node by hand, or use another script button to move the node to a 'standard place', say the last child of the <<results>> node. 
 
As I write this I think the script-button approach is likely to be the simplest, most flexible and most powerful. I'll look into this myself soon... 
 
Edward


#@-node:ekr.20070521100324.1:Using Leo as a notebook
#@+node:ekr.20070521105645:Improve api docs with epidoc?
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319363
By: ktenney

I think there is room for improvement in documenting Leo's
API, making it easier to write these kind of scripts.
I'm not sure of the best way to do that.

Epydoc seems to be the most active project in this realm.
http://epydoc.sourceforge.net/epydoc.html
#@-node:ekr.20070521105645:Improve api docs with epidoc?
#@+node:ekr.20060306194040:asap: Video and more screen shots on Leo's web site
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/


http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

Thanks,
Kent
#@nonl
#@+node:ekr.20060531134434:Tutorials
http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
#@nonl
#@-node:ekr.20060531134434:Tutorials
#@+node:ekr.20060531134434.1:Screencasts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3758303
By: ktenney

My sense is that documentation/screencasts has the
greatest potential for expanding Leo's mindshare.

I really like those produced by the good folks
at Dabo;
http://leafe.com/screencasts/
http://leafe.com/screencasts/populategrid.html

The TurboGears people have taken this to the extreme;
http://www.turbogears.org/ultimate.html

Leo is different enough that it warrants a 
demonstration of it's advantages.
#@nonl
#@-node:ekr.20060531134434.1:Screencasts
#@+node:ekr.20060829103523:Render Leo slideshows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3889246
By: terry_n_brown

Three packages that might be candidates for "rendering" slides authored in Leo:

MagicPoint: http://member.wide.ad.jp/wg/mgp/

  uses a text file format that leo could produce

Slidy: http://www.w3.org/Talks/Tools/Slidy/

  uses XHTML / canned Java script

S5: http://meyerweb.com/eric/tools/s5/

  Similar to Slidy I think, haven't looked at it
#@nonl
#@-node:ekr.20060829103523:Render Leo slideshows
#@-node:ekr.20060306194040:asap: Video and more screen shots on Leo's web site
#@+node:ekr.20061130084909:Improve What's special whitepaper
@nocolor

- Answer the question: how can Leo help me with programming?
#@nonl
#@-node:ekr.20061130084909:Improve What's special whitepaper
#@+node:ekr.20070414090051:Study
@nocolor

- launchpad http://launchpad.net 

- bazaar (bzr)
#@nonl
#@-node:ekr.20070414090051:Study
#@-node:ekr.20070521100324:Marketing/tools
#@+node:ekr.20060531161030:To do: 4.4.3
#@+node:ekr.20070515100356:To do: b2
#@+node:ekr.20070325054325:Docs
#@+node:ekr.20070215093739:Improve Leo's getting started page
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4159734
By: rogererens

Here are some issues with respect to installing Leo on Windows:

I think you should divide the "How to install Leo on Windows" into separate
sections: one section that describes the use of the installer and another one
that describes the use of the .zip-file. In the near future probably Vista deserves
its own section, too.

The notes warn about Python 2.4 and spaces in paths. The installer appears to
work properly with Python 2.5 though, and installing into a path that contains
spaces works fine too, AFAIK. Or are there any usability test cases to check
this?

Also, I would advice the person that is installing Leo to create an environment
variable (either a user variable or a system variable) called HOME with the
value "%USERPROFILE%\My Documents" when %HOME% does not yet exist (check in
a cmd-window by typing "echo %HOME%" without the quotes).
Then, after installing, a user should have the shortcut icon on his/her desktop;
change this by right-clicking and choosing properties to change the directory
where the application starts from the default "C:\Program Files\Leo\test\unittest"
into %HOME%.
I'm not sure if this could all be done automatically by the NSIS installer.

Finally, there's the issue that I installed Leo in the default Program Files
folder, while having the Administrator's role. After which I copied and adapted
the Leo shortcut to the desktop of a user with limited rights.
Unfortunately, when logged on as such a limited user, no plugins can be
enabled/disabled because of the restrictions on writing in program
files\leo\plugin.
(Even if the limited user _could_ write in that folder, it would be problematic:
his set of enabled plugins would overwrite the set of enabled plugins for the
administrator or another user).

Hope this helps to improve the installation experience for novices...
#@-node:ekr.20070215093739:Improve Leo's getting started page
#@+node:ekr.20070218143918:Improve Windows installation instructions
This section is way too confusing:
    
Users Guide-->Chapter 1: Installing Leo-->@rst html\install.html-->How to install Leo on Windows
#@nonl
#@-node:ekr.20070218143918:Improve Windows installation instructions
#@-node:ekr.20070325054325:Docs
#@+node:ekr.20070515113707:Dist
#@+node:ekr.20070202080824:Enable more plugins by default
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4134565

I have been talking more and more people lately into giving Leo a try. These
are end-users, not programmer-type people. One of the problems I find is that
many features users expect as standard are plug-ins that are disabled at
startup.

From my experience, some of the plug-ins that people seem to want right away
are Cleo, Image, Maximize windows, Export to HTML, and Navibuttons.

Also, everyone seems to ask for spell checking, which I know is a separate install
(I haven't tried putting it in). Perhaps even that could be included?

I think it is a lot easier for power users to turn off things they don't like
than less sophisticated users to turn them on. However, I realize that each
additional plug-in means a longer load time and large memory footprint.

-------------------

From: Rich

These are the plugins that I use often:
Add directives & color markup
Cleo 3
Chapters 2 (unless Chapters works with newer releases, I will stick with Leo 4.4 final)
Group Operations
Nav_buttons
Open_with
RClick
Universal Scrolling

These are the plugins that I do not use too often:
New Buttons
UNL

The following are plugins I would like to use:
Edit Attributes
Conceptual Sort
Labels

"Labels" has a nice assortment of commands; however the labels are (1) not saved
between sessions, and (2) cannot be seen by "Edit Attributes."
I'd be more inclined to use "Edit Attributes" and "C-Sort" IF there was some
way to SEE the attributes (this goes for "Labels," as well).


---- Enable Aspell automatically if possible.

#@-node:ekr.20070202080824:Enable more plugins by default
#@+node:ekr.20070307082503.1:Create Linux distribution
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319356
By: ktenney

> - A proper Ubuntu/Linux distribution 

- "eggification" of Leo

register Leo at http://cheeseshop.python.org/pypi

Pythonistas have come to expect that::

 $ easy_install <app>

will locate and install the most recent version of app and install it.
#@-node:ekr.20070307082503.1:Create Linux distribution
#@-node:ekr.20070515113707:Dist
#@+node:ekr.20070522052905:Bugs 6
#@+node:ekr.20070513175217:Allow permanent renames
#@-node:ekr.20070513175217:Allow permanent renames
#@+node:ekr.20070521104213:Get aspell working on Linux
Make installing aspell easier.

-----

http://sourceforge.net/forum/message.php?msg_id=4318634
By: billpage

wspage@suse-linux:~> leo
reading settings in /usr/local/lib/leo/config/leoSettings.leo
reading /home/wspage/.leoRecentFiles.txt
rst3 plugin: SilverCity not loaded
Traceback (most recent call last):

  File "/home/wspage/leo-4-4-3-alpha-2/src/leoEditCommands.py", line 7903, in
getAspellWithCtypes
    self.aspell = aspell = ctypes.CDLL(g.os_path_join(self.aspell_bin_dir,
"aspell-15.dll"))

  File "/usr/lib/python2.5/ctypes/__init__.py", line 312, in __init__
    self._handle = _dlopen(self._name, mode)

OSError: /home/wspage/c:\aspell\bin/aspell-15.dll: cannot open shared object
file: No such file or directory

#@-node:ekr.20070521104213:Get aspell working on Linux
#@+node:ekr.20070518062728:Fix noweb problems
@ The fix was to g.skip_to_end_of_line (!)

All such functions now return len(s) as a boundary condition.
This is a major change.  All unit tests pass.
#@nonl
#@+node:ekr.20070521100543:Reports
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4315027
By: billpage

In Leo 4.4.3 alpha 2 using "Import noweb files" causes Leo to crash. I first
tried omething more complex but I found that even if I create a simple one node
test outline, use "Export Outline to noweb" to create a .nw file then try to
import that noweb file I get the same result.

https://sourceforge.net/forum/message.php?msg_id=4318521
By: billpage

On May 15, 2007 9:48 AM Ralf Hemmecke (another Axiom developer)
sent to me the following example:

Then the first thing I tried was to import a noweb file. I used 
leo-4-4-3-alpha-2 on the following file (dont put the %--- line into the 
file but keep the final empty line.

%---BEGIN asfiles.pl.nw
<<*>>=
Here is the code
@

%---END asfile.pl.nw

LEO hangs itself up. I seem to be unlucky. Unfortunately, I am not a 
python programmer myself so that I could dig into the problem.

I now give up for the second time. The empty line at the end seems not 
the only problem.

I know that LEO has some good ideas, especially I like the cloning 
stuff, but I cannot appreciate LEO not only for the reason that it 
doesn't let me import my files.

-----
http://sourceforge.net/forum/message.php?msg_id=4318542
By: billpage

Here is last part of the the error message traceback that I get
when doing the above test on OpenSuSE 10.2 with Leo 4.4.3 alpha 2:

  ... 
  File "/home/wspage/leo-4-4-3-alpha-2/src/leoImport.py", line 3118, in
isDocStart
    if not g.match(s,i,"@"):

  File "/home/wspage/leo-4-4-3-alpha-2/src/leoGlobals.py", line 3432, in match
    return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i

KeyboardInterrupt

wrote /home/wspage/.leoRecentFiles.txt

--------

after hitting Control-C in the console window that started Leo.

#@-node:ekr.20070521100543:Reports
#@+node:ekr.20070521101229:Bill Page
@nocolor
https://sourceforge.net/forum/message.php?msg_id=4315078
By: billpage

I have a similar problem to that described by the author of this thread. I am
one of the developers of the Axiom open source project (see:
http://wiki.axiom-developer.org ). Axiom uses noweb format for all source files
in the distribution and includes C, Lisp, make, awk scripts, Boot, and Spad
code (the last two programming languages specific to Axiom).

Pervasive use of Literate Programming is a accepted goal of the project but
it is not yet fully achieved. We still have many discussions concerning the
merits of different approaches to adding documentation to such a large "illiterate"
legacy code base. (Some of the code in Axiom was written more than 30 years
ago and was never properly documented.) The issue of building "traditional"
(Knuth-style) monolithic book-sized volumes for the various components of Axiom
by merging large numbers of legacy source code files and newly developed
documentation into a small number of noweb files is especially contentious.
Based on information on the Leo web site and experience with the Leo tutorials,
I have repeatedly advocated the use of Leo as an alternative to this traditional
approach. Now some of the other Axiom developers might finally be listening...

But as I said, I have a problem. When I try to import the Axiom noweb files
into Leo I get "odd" results. These files are processed properly by noweb's
notangle and noweave commands but I can not reproduce this using Leo. The
documentation and code chunks (sections) are not always represented as nodes
in the outline in the way I would expect, e.g. I see nodes named "Limbo", "avoiding"
and "center" in addition to most (but not all) of the << chunk names >> in the
noweb file.  Plus Leo's "Export Weave" command does not produce output that
sufficiently closely resembles the noweave output of noweb. We need/expect to
be able to process this output of weave by LaTeX but it contains other generated
text that is clearly not LaTeX compatible.

More specifically: I do not see any @ignore directive in the root node following
import of the noweb file. Nor do I see any generated @file, @root or other
directives. At the moment I am using "Leo 4.4.2.1 final, build  1.83 , October
29, 2006" from the Windows exe install file, but my comments also apply to the
same version of Leo on Linux.

I have other questions as well concerning customization of Leo's parsing and
generation of comments in target source languages other than Java and C which
I have not found answered in the Leo users guide or tutorials. But I will save
that for another time.

http://wiki.axiom-developer.org
#@-node:ekr.20070521101229:Bill Page
#@+node:ekr.20031218072017.3209:Import
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent):

    c = self.c ; u = c.undoer
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".lua", ".pas", ".py", ".pyw", ".php")
    << Read file into s >>
    # Create the top-level headline.
    undoData = u.beforeInsertNode(parent)
    p = parent.insertAsLastChild()
    if self.treeType == "@file":
        p.initHeadString("@file " + fileName)
    else:
        p.initHeadString(fileName)
    u.afterInsertNode(p,'Import',undoData)
        
    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        c.setBodyString(p,body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p)
    elif ext == ".el":
        self.scanElispText(s,p)
    elif ext in (".fs", ".fi"):
        self.scanForthText(s,p)
    elif ext == ".java":
        self.scanJavaText(s,p,True) #outer level
    elif ext == ".lua":
        self.scanLuaText(s,p)
    elif ext == ".pas":
        self.scanPascalText(s,p)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p)
    elif ext == ".php":
        self.scanPHPText(s,p) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20041126042730:getTabWidth
def getTabWidth (self):
    
    d = g.scanDirectives(self.c)
    w = d.get("tabwidth")
    if w not in (0,None):
        return w
    else:
        return self.c.tab_width
#@-node:ekr.20041126042730:getTabWidth
#@+node:ekr.20031218072017.1810:importDerivedFiles
def importDerivedFiles (self,parent=None,paths=None):
    # Not a command.  It must *not* have an event arg.
    
    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            g.setGlobalOpenDir(fileName)
            << set isThin if fileName is a thin derived file >>
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()
#@+node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
#@-node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
#@+node:ekr.20051208100903.1:forceGnxOnPosition
def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)
#@-node:ekr.20051208100903.1:forceGnxOnPosition
#@-node:ekr.20031218072017.1810:importDerivedFiles
#@+node:ekr.20031218072017.3212:importFilesCommand
def importFilesCommand (self,files=None,treeType=None,
    perfectImport=True,testing=False,verbose=False):
        # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) < 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    c.beginUpdate()
    try: # range of update...
        if len(files) == 2:
            << Create a parent for two files having a common prefix >>
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                perfectImport = False ###
                testing = True; verbose = True
                if perfectImport and treeType == "@file": # Can't correct @root trees.
                    self.perfectImport(fileName,v,testing=testing,verbose=verbose,verify=False)
                else:
                    g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    finally:
        c.endUpdate()
    c.selectVnode(current)
#@+node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) > 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)
#@-node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
#@-node:ekr.20031218072017.3212:importFilesCommand
#@+node:ekr.20031218072017.3214:importFlattenedOutline & allies
#@+node:ekr.20031218072017.3215:convertMoreString/StringsToOutlineAfter
# Used by paste logic.

def convertMoreStringToOutlineAfter (self,s,firstVnode):
    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.convertMoreStringsToOutlineAfter(strings,firstVnode)

# Almost all the time spent in this command is spent here.

def convertMoreStringsToOutlineAfter (self,strings,firstVnode):
    
    __pychecker__ = '--no-objattrs' # suppress bad warnings re lastVnode.

    c = self.c
    if len(strings) == 0: return None
    if not self.stringsAreValidMoreFile(strings): return None
    c.beginUpdate()
    try: # range of update...
        firstLevel, junk = self.moreHeadlineLevel(strings[0])
        lastLevel = -1 ; theRoot = lastVnode = None
        index = 0
        while index < len(strings):
            progress = index
            s = strings[index]
            level, newFlag = self.moreHeadlineLevel(s)
            level -= firstLevel
            if level >= 0:
                << Link a new vnode v into the outline >>
                << Set the headline string, skipping over the leader >>
                << Count the number of following body lines >>
                << Add the lines to the body text of v >>
                v.setDirty()
            else: index += 1
            assert progress < index
        if theRoot:
            theRoot.setDirty()
            c.setChanged(True)
    finally:
        c.endUpdate()
    return theRoot
#@+node:ekr.20031218072017.3216:<< Link a new vnode v into the outline >>
assert(level >= 0)
if lastVnode is None:
    # g.trace(firstVnode)
    theRoot = v = firstVnode.insertAfter()
elif level == lastLevel:
    v = lastVnode.insertAfter()
elif level == lastLevel + 1:
    v = lastVnode.insertAsNthChild(0)
else:
    assert(level < lastLevel)
    while level < lastLevel:
        lastLevel -= 1
        lastVnode = lastVnode.parent()
        assert(lastVnode)
        assert(lastLevel >= 0)
    v = lastVnode.insertAfter()
lastVnode = v
lastLevel = level
#@-node:ekr.20031218072017.3216:<< Link a new vnode v into the outline >>
#@+node:ekr.20031218072017.3217:<< Set the headline string, skipping over the leader >>
j = 0
while g.match(s,j,'\t'):
    j += 1
if g.match(s,j,"+ ") or g.match(s,j,"- "):
    j += 2

v.initHeadString(s[j:])
#@-node:ekr.20031218072017.3217:<< Set the headline string, skipping over the leader >>
#@+node:ekr.20031218072017.3218:<< Count the number of following body lines >>
bodyLines = 0
index += 1 # Skip the headline.
while index < len(strings):
    s = strings[index]
    level, junk = self.moreHeadlineLevel(s)
    level -= firstLevel
    if level >= 0:
        break
    # Remove first backslash of the body line.
    if g.match(s,0,'\\'):
        strings[index] = s[1:]
    bodyLines += 1
    index += 1
#@-node:ekr.20031218072017.3218:<< Count the number of following body lines >>
#@+node:ekr.20031218072017.3219:<< Add the lines to the body text of v >>
if bodyLines > 0:
    body = ""
    n = index - bodyLines
    while n < index:
        body += strings[n]
        if n != index - 1:
            body += "\n"
        n += 1
    v.setTnodeText(body)
#@-node:ekr.20031218072017.3219:<< Add the lines to the body text of v >>
#@-node:ekr.20031218072017.3215:convertMoreString/StringsToOutlineAfter
#@+node:ekr.20031218072017.3220:importFlattenedOutline
def importFlattenedOutline (self,files): # Not a command, so no event arg.

    c = self.c ; u = c.undoer ; current = c.currentPosition()
    if current == None: return
    if len(files) < 1: return

    self.setEncoding()
    fileName = files[0] # files contains at most one file.
    g.setGlobalOpenDir(fileName)
    << Read the file into array >>

    # Convert the string to an outline and insert it after the current node.
    undoData = u.beforeInsertNode(current)
    p = self.convertMoreStringsToOutlineAfter(array,current)
    if p:
        c.endEditing()
        c.validateOutline()
        c.editPosition(p)
        p.setDirty()
        c.setChanged(True)
        u.afterInsertNode(p,'Import',undoData)
    else:
        g.es(fileName + " is not a valid MORE file.")
#@+node:ekr.20031218072017.3221:<< Read the file into array >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = string.replace(s,"\r","")
    s = g.toUnicode(s,self.encoding)
    array = string.split(s,"\n")
    theFile.close()
except IOError:
    g.es("Can not open " + fileName, color="blue")
    leoTest.fail()
    return
#@-node:ekr.20031218072017.3221:<< Read the file into array >>
#@-node:ekr.20031218072017.3220:importFlattenedOutline
#@+node:ekr.20031218072017.3222:moreHeadlineLevel
# return the headline level of s,or -1 if the string is not a MORE headline.
def moreHeadlineLevel (self,s):

    level = 0 ; i = 0
    while g.match(s,i,'\t'):
        level += 1
        i += 1
    plusFlag = g.choose(g.match(s,i,"+"),True,False)
    if g.match(s,i,"+ ") or g.match(s,i,"- "):
        return level, plusFlag
    else:
        return -1, plusFlag
#@-node:ekr.20031218072017.3222:moreHeadlineLevel
#@+node:ekr.20031218072017.3223:stringIs/stringsAreValidMoreFile
# Used by paste logic.

def stringIsValidMoreFile (self,s):
    
    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.stringsAreValidMoreFile(strings)

def stringsAreValidMoreFile (self,strings):

    if len(strings) < 1: return False
    level1, plusFlag = self.moreHeadlineLevel(strings[0])
    if level1 == -1: return False
    # Check the level of all headlines.
    i = 0 ; lastLevel = level1
    while i < len(strings):
        s = strings[i] ; i += 1
        level, newFlag = self.moreHeadlineLevel(s)
        if level > 0:
            if level < level1 or level > lastLevel + 1:
                return False # improper level.
            elif level > lastLevel and not plusFlag:
                return False # parent of this node has no children.
            elif level == lastLevel and plusFlag:
                return False # last node has missing child.
            else:
                lastLevel = level
                plusFlag = newFlag
    return True
#@-node:ekr.20031218072017.3223:stringIs/stringsAreValidMoreFile
#@-node:ekr.20031218072017.3214:importFlattenedOutline & allies
#@+node:ekr.20031218072017.3224:importWebCommand & allies
#@+node:ekr.20031218072017.3225:createOutlineFromWeb
def createOutlineFromWeb (self,path,parent):

    c = self.c ; u = c.undoer
    junk,fileName = g.os_path_split(path)

    undoData = u.beforeInsertNode(parent)
    
    # Create the top-level headline.
    p = parent.insertAsLastChild()
    p.initHeadString(fileName)
    if self.webType=="cweb":
        c.setBodyString(p,"@ignore\n" + self.rootLine + "@language cweb")

    # Scan the file, creating one section for each function definition.
    self.scanWebFile(path,p)

    u.afterInsertNode(p,'Import',undoData)

    return p
#@-node:ekr.20031218072017.3225:createOutlineFromWeb
#@+node:ekr.20031218072017.3226:importWebCommand
def importWebCommand (self,files,webType):

    c = self.c ; current = c.currentVnode()
    if current == None: return
    if not files: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.webType = webType

    c.beginUpdate()
    try:
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutlineFromWeb(fileName,current)
            v.contract()
            v.setDirty()
            c.setChanged(True)
        c.selectVnode(current)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.3226:importWebCommand
#@+node:ekr.20031218072017.3227:findFunctionDef
def findFunctionDef (self,s,i):
    
    # Look at the next non-blank line for a function name.
    i = g.skip_ws_and_nl(s,i)
    k = g.skip_line(s,i)
    name = None
    while i < k:
        if g.is_c_id(s[i]):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
        elif s[i] == '(':
            if name: return name
            else: break
        else: i += 1
    return None
#@-node:ekr.20031218072017.3227:findFunctionDef
#@+node:ekr.20031218072017.3228:scanBodyForHeadline
@ This method returns the proper headline text.

1. If s contains a section def, return the section ref.
2. cweb only: if s contains @c, return the function name following the @c.
3. cweb only: if s contains @d name, returns @d name.
4. Otherwise, returns "@"
@c

def scanBodyForHeadline (self,s):
    
    if self.webType == "cweb":
        << scan cweb body for headline >>
    else:
        << scan noweb body for headline >>
    return "@" # default.
#@+node:ekr.20031218072017.3229:<< scan cweb body for headline >>
i = 0
while i < len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    # Allow constructs such as @ @c, or @ @<.
    if self.isDocStart(s,i):
        i += 2 ; i = g.skip_ws(s,i)
    if g.match(s,i,"@d") or g.match(s,i,"@f"):
        # Look for a macro name.
        directive = s[i:i+2]
        i = g.skip_ws(s,i+2) # skip the @d or @f
        if i < len(s) and g.is_c_id(s[i]):
            j = i ; g.skip_c_id(s,i) ; return s[j:i]
        else: return directive
    elif g.match(s,i,"@c") or g.match(s,i,"@p"):
        # Look for a function def.
        name = self.findFunctionDef(s,i+2)
        return g.choose(name,name,"outer function")
    elif g.match(s,i,"@<"):
        # Look for a section def.
        # A small bug: the section def must end on this line.
        j = i ; k = g.find_on_line(s,i,"@>")
        if k > -1 and (g.match(s,k+2,"+=") or g.match(s,k+2,"=")):
            return s[j:k+2] # return the section ref.
    i = g.skip_line(s,i)
#@-node:ekr.20031218072017.3229:<< scan cweb body for headline >>
#@+node:ekr.20031218072017.3230:<< scan noweb body for headline >>
i = 0
while i < len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if g.match(s,i,"<<"):
        k = g.find_on_line(s,i,">>=")
        if k > -1:
            ref = s[i:k+2]
            name = string.strip(s[i+2:k])
            if name != "@others":
                return ref
    else:
        name = self.findFunctionDef(s,i)
        if name:
            return name
    i = g.skip_line(s,i)
#@-node:ekr.20031218072017.3230:<< scan noweb body for headline >>
#@-node:ekr.20031218072017.3228:scanBodyForHeadline
#@+node:ekr.20031218072017.3231:scanWebFile (handles limbo)
def scanWebFile (self,fileName,parent):

    theType = self.webType
    lb = g.choose(theType=="cweb","@<","<<")
    rb = g.choose(theType=="cweb","@>",">>")

    try: # Read the file into s.
        f = open(fileName)
        s = f.read()
    except:
        g.es("Can not import " + fileName, color="blue")
        return

    << Create a symbol table of all section names >>
    << Create nodes for limbo text and the root section >>
    while i < len(s):
        outer_progress = i
        << Create a node for the next module >>
        assert(i > outer_progress)
#@nonl
#@+node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
i = 0 ; self.web_st = []

while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if self.isDocStart(s,i):
        if theType == "cweb": i += 2
        else: i = g.skip_line(s,i)
    elif theType == "cweb" and g.match(s,i,"@@"):
        i += 2
    elif g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k > -1: self.cstEnter(s[j:k])
    else: i += 1
    assert (i > progress)

# g.trace(self.cstDump())
#@-node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
#@+node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
i = 0
while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isModuleStart(s,i) or g.match(s,i,lb):
        break
    else: i = g.skip_line(s,i)
    assert(i > progress)
    
j = g.skip_ws(s,0)
if j < i:
    self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if g.match(s,i,lb):
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        else: i = g.skip_line(s,i)
        assert(i > progress)
    self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))
    
# g.trace(g.get_line(s,i))
#@-node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
#@+node:ekr.20031218072017.3234:<< Create a node for the next module >>
if theType=="cweb":
    assert(self.isModuleStart(s,i))
    start = i
    if self.isDocStart(s,i):
        i += 2
        while i < len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i): break
            else: i = g.skip_line(s,i)
            assert (i > progress)
    << Handle cweb @d, @f, @c and @p directives >>
else:
    assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
    start = i ; i = g.skip_line(s,i)
    while i < len(s):
        progress2 = i
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i): break
        else: i = g.skip_line(s,i)
        assert (i > progress)
    
body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)
#@+node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
if g.match(s,i,"@d") or g.match(s,i,"@f"):
    i += 2 ; i = g.skip_line(s,i)
    # Place all @d and @f directives in the same node.
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
        else: break
        assert (i > progress)
    i = g.skip_ws_and_nl(s,i)
    
while i < len(s) and not self.isModuleStart(s,i):
    progress = i
    i = g.skip_line(s,i)
    i = g.skip_ws_and_nl(s,i)
    assert (i > progress)

if g.match(s,i,"@c") or g.match(s,i,"@p"):
    i += 2
    while i < len(s):
        progress = i
        i = g.skip_line(s,i)
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        assert (i > progress)
#@-node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
#@-node:ekr.20031218072017.3234:<< Create a node for the next module >>
#@-node:ekr.20031218072017.3231:scanWebFile (handles limbo)
#@+node:ekr.20031218072017.3236:Symbol table
#@+node:ekr.20031218072017.3237:cstCanonicalize
# We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.

def cstCanonicalize (self,s,lower=True):
    
    if lower:
        s = string.lower(s)
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"\r","")
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
#@-node:ekr.20031218072017.3237:cstCanonicalize
#@+node:ekr.20031218072017.3238:cstDump
def cstDump (self):

    self.web_st.sort()
    s = "Web Symbol Table...\n\n"
    for name in self.web_st:
        s += name + "\n"
    return s
#@-node:ekr.20031218072017.3238:cstDump
#@+node:ekr.20031218072017.3239:cstEnter
# We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter (self,s):

    # Don't enter names that end in "..."
    s = string.rstrip(s)
    if s.endswith("..."): return
    
    # Put the section name in the symbol table, retaining capitalization.
    lower = self.cstCanonicalize(s,True)  # do lower
    upper = self.cstCanonicalize(s,False) # don't lower.
    for name in self.web_st:
        if string.lower(name) == lower:
            return
    self.web_st.append(upper)
#@-node:ekr.20031218072017.3239:cstEnter
#@+node:ekr.20031218072017.3240:cstLookup
# This method returns a string if the indicated string is a prefix of an entry in the web_st.

def cstLookup (self,target):
    
    # Do nothing if the ... convention is not used.
    target = string.strip(target)
    if not target.endswith("..."): return target
    # Canonicalize the target name, and remove the trailing "..."
    ctarget = target[:-3]
    ctarget = self.cstCanonicalize(ctarget)
    ctarget = string.strip(ctarget)
    found = False ; result = target
    for s in self.web_st:
        cs = self.cstCanonicalize(s)
        if cs[:len(ctarget)] == ctarget:
            if found:
                g.es("****** " + target + ": is also a prefix of: " + s)
            else:
                found = True ; result = s
                # g.es("replacing: " + target + " with: " + s)
    return result
#@-node:ekr.20031218072017.3240:cstLookup
#@-node:ekr.20031218072017.3236:Symbol table
#@-node:ekr.20031218072017.3224:importWebCommand & allies
#@+node:EKR.20040506075328.2:perfectImport
def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):
    
    __pychecker__ = 'maxlines=500'
    
    << about this algorithm >>
    c = self.c
    root = p.copy()
    at = c.atFileCommands
    if testing:
        << clear all dirty bits >>
    << Assign file indices >>
    << Write root's tree to to string s >>

    # Set up the data for the algorithm.
    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension(fileName)
    fat_lines = g.splitLines(s) # Keep the line endings.
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    j_lines = file(fileName).readlines()
    
    # Correct write_lines using the algorihm.
    if i_lines != j_lines:
        if verbose:
            g.es("Running Perfect Import",color="blue")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        if 1: # For testing.
            << put the corrected fat lines in a new node >>
        << correct root's tree using write_lines >>
    if verify:
        << verify that writing the tree would produce the original file >>
#@+node:ekr.20040717112739:<< about this algorithm >>
@nocolor
@

This algorithm corrects the result of an Import To @file command so that it is guaranteed that the result of writing the imported file will be identical to the original file except for any sentinels that have been inserted.

On entry, p points to the newly imported outline.

We correct the outline by applying Bernhard Mulder's algorithm.

1.  We use the atFile.write code to write the newly imported outline to a string s.  This string contains represents a thin derived file, so it can be used to recreate then entire outline structure without any other information.

Splitting s into lines creates the fat_lines argument to mu methods.

2. We make corrections to fat_lines using Mulder's algorithm.  The corrected fat_lines represents the corrected outline.  To do this, we set the arguments as follows:

- i_lines: fat_lines stripped of sentinels
- j_lines to the lines of the original imported file.

The algorithm updates fat_lines using diffs between i_lines and j_lines.

3. Mulder's algorithm doesn't specify which nodes have been changed.  In fact, it Mulder's algorithm doesn't really understand nodes at all.  Therefore, if we want to mark changed nodes we do so by comparing the original version of the imported outline with the corrected version of the outline.
#@-node:ekr.20040717112739:<< about this algorithm >>
#@+node:ekr.20040716065356:<< clear all dirty bits >>
for p2 in p.self_and_subtree_iter():
    p2.clearDirty()
#@-node:ekr.20040716065356:<< clear all dirty bits >>
#@+node:ekr.20040716064333:<< Assign file indices  >>
nodeIndices = g.app.nodeIndices

nodeIndices.setTimestamp()

for p2 in root.self_and_subtree_iter():
    try: # Will fail for None or any pre 4.1 file index.
        theId,time,n = p2.v.t.fileIndex
    except TypeError:
        p2.v.t.fileIndex = nodeIndices.getNewIndex()
#@-node:ekr.20040716064333:<< Assign file indices  >>
#@+node:ekr.20040716064333.1:<< Write root's tree to to string s >>
at.write(root,thinFile=True,toString=True)
s = at.stringOutput
if not s: return
#@-node:ekr.20040716064333.1:<< Write root's tree to to string s >>
#@+node:ekr.20040717132539:<< put the corrected fat lines in a new node >>
write_lines_node = root.insertAfter()
write_lines_node.initHeadString("write_lines")
s = ''.join(write_lines)
write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)
#@-node:ekr.20040717132539:<< put the corrected fat lines in a new node >>
#@+node:ekr.20040717113036:<< correct root's tree using write_lines >>
@ Notes:
1. This code must overwrite the newly-imported tree because the gnx's in
write_lines refer to those nodes.

2. The code in readEndNode now reports when nodes change during importing. This
code also marks changed nodes.
@c

try:
    at.correctedLines = 0
    at.targetFileName = "<perfectImport string-file>"
    at.inputFile = fo = g.fileLikeObject()
    at.file = fo # Strange, that this is needed.  Should be cleaned up.
    for line in write_lines:
        fo.write(line)
    firstLines,junk,junk = c.atFileCommands.scanHeader(fo,at.targetFileName)
    # To do: pass params to readEndNode.
    at.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
    n = at.correctedLines
    if verbose:
        g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
except:
    g.es("Exception in Perfect Import",color="red")
    g.es_exception()
    s = None
#@-node:ekr.20040717113036:<< correct root's tree using write_lines >>
#@+node:ekr.20040718035658:<< verify that writing the tree would produce the original file >>
try:
    # Read the original file into before_lines.
    before = file(fileName)
    before_lines = before.readlines()
    before.close()
    
    # Write the tree into after_lines.
    at.write(root,thinFile=True,toString=True)
    after_lines1 = g.splitLines(at.stringOutput)
    
    # Strip sentinels from after_lines and compare.
    after_lines = mu.removeSentinelsFromLines(after_lines1,delims)
    
    # A major kludge: Leo can not represent unindented blank lines in indented nodes!
    # We ignore the problem here by stripping whitespace from blank lines.
    # We shall need output options to handle such lines.
    if convertBlankLines:
        mu.stripWhitespaceFromBlankLines(before_lines)
        mu.stripWhitespaceFromBlankLines(after_lines)
    if before_lines == after_lines:
        if verbose:
            g.es("Perfect Import verified",color="blue")
    else:
        leoTest.fail()
        if verbose:
            g.es("Perfect Import failed verification test!",color="red")
            << dump the files >>
except IOError:
    g.es("Can not reopen %s!" % fileName,color="red")
    leoTest.fail()
#@+node:ekr.20040718045423:<< dump the files >>
print len(before_lines),len(after_lines)

if len(before_lines)==len(after_lines):
    for i in xrange(len(before_lines)):
        extra = 3
        if before_lines[i] != after_lines[i]:
            j = max(0,i-extra)
            print '-' * 20
            while j < i + extra + 1:
                leader = g.choose(i == j,"* ","  ")
                print "%s%3d" % (leader,j), repr(before_lines[j])
                print "%s%3d" % (leader,j), repr(after_lines[j])
                j += 1
else:
    for i in xrange(min(len(before_lines),len(after_lines))):
        if before_lines[i] != after_lines[i]:
            extra = 5
            print "first mismatch at line %d" % i
            print "printing %d lines after mismatch" % extra
            print "before..."
            for j in xrange(i+1+extra):
                print "%3d" % j, repr(before_lines[j])
            print
            print "after..."
            for k in xrange(1+extra):
                print "%3d" % (i+k), repr(after_lines[i+k])
            print
            print "with sentinels"
            j = 0 ; k = 0
            while k < i + 1 + extra:
                print "%3d" % k,repr(after_lines1[j])
                if not g.is_sentinel(after_lines1[j],delims):
                    k += 1
                j += 1
            break
#@-node:ekr.20040718045423:<< dump the files >>
#@-node:ekr.20040718035658:<< verify that writing the tree would produce the original file >>
#@-node:EKR.20040506075328.2:perfectImport
#@+node:ekr.20031218072017.3241:Scanners for createOutline
#@+node:ekr.20031218072017.2256:Python scanners & tests
#@+node:ekr.20031218072017.2257:scanPythonClass & helpers
def scanPythonClass (self,s,i,start,parent):

    """Creates a child node c of parent for the class, and children of c for each def in the class."""

    # g.trace(g.get_line(s,i))
    c = self.c
    class_indent = self.getLeadingIndent(s,i)
    << set class_name and headline >>
    if not class_name: return i
    i = g.skip_line(s,i) # Skip the class line.
    i,prefix,body = self.createClassNodeText(s,i,start)
    class_vnode = self.createHeadline(parent,prefix + body,headline)
    savedMethodName = self.methodName
    self.methodName = headline
    # Create a node for leading declarations of the class.
    i = self.scanPythonDecls(s,i,class_vnode,class_indent,indent_parent_ref_flag=True)
    start,i = self.scanPythonClassHelper(s,i,class_indent,class_name,class_vnode)
    s2 = s[start:i]
    if s2: c.appendStringToBody(class_vnode,s2)
    self.methodName = savedMethodName
    return i
#@+node:ekr.20031218072017.2258:<< set class_name and headline >>
# Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    class_name = s[j:i]
    headline = "class " + class_name
else:
    headline = ''
    class_name = ''
#@-node:ekr.20031218072017.2258:<< set class_name and headline >>
#@+node:ekr.20060626100102:scanPythonClassHelper
def scanPythonClassHelper(self,s,i,class_indent,class_name,class_vnode):
    
    indent =  self.getLeadingIndent(s,i)
    start = i = g.skip_blank_lines(s,i)
    parent_vnode = None
    while i < len(s):
        progress = i
        # New in Leo 4.4.1: ignore comment lines, whatever their indentation.
        if indent <= class_indent:
            j = g.skip_ws(s,i)
            if g.match(s,j,'#'):
                i = g.skip_to_end_of_line(s,j)
            else: break
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            j = g.skip_nl(s,i)
            if not backslashNewline:
                indent = self.getLeadingIndent(s,j)
                if indent > class_indent: i = j
                else: break
            else: i = j
        elif g.match_c_word(s,i,"def"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonDef(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif g.match_c_word(s,i,"class"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonClass(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
        elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
        else: i += 1
        assert(progress < i)
    return start,i
#@-node:ekr.20060626100102:scanPythonClassHelper
#@+node:ekr.20060626101103.1:createParentText
def createParentText (self,class_vnode,class_name):

    '''Insert the proper body text in the class_vnode.'''
    
    c = self.c
    
    # This must be done after the declaration reference is generated.
    if self.treeType == "@file":
        c.appendStringToBody(class_vnode,"\t@others\n")
    else:
        ref = g.angleBrackets(' class %s methods ' % (class_name))
        c.appendStringToBody(class_vnode,"\t" + ref + "\n\n")
#@-node:ekr.20060626101103.1:createParentText
#@+node:ekr.20060626103415:createClassNodeText
def createClassNodeText (self,s,i,start):
    
    # Create the section name using the old value of self.methodName.
    if  self.treeType == "@file":
        prefix = ""
    else:
        prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
        self.methodsSeen = True
    
    # i points just after the class line.
    
    # Add a docstring to the class node.
    docStringSeen = False
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j != len(s): # No scanning error.
            i = j ; docStringSeen = True
    
    body = s[start:i]
    body = self.undentBody(body)
    if docStringSeen: body = body + '\n'
    
    return i,prefix,body
#@-node:ekr.20060626103415:createClassNodeText
#@-node:ekr.20031218072017.2257:scanPythonClass & helpers
#@+node:ekr.20031218072017.2263:scanPythonDef
def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    << set headline or return i >>
    i = self.skipPythonDef(s,i,start)
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    << Create def node >>
    self.methodName = savedMethodName
    return i
#@+node:ekr.20031218072017.2264:<< set headline or return i >>
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i
#@-node:ekr.20031218072017.2264:<< set headline or return i >>
#@+node:ekr.20031218072017.2266:<< Create def node >>
# Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)
#@-node:ekr.20031218072017.2266:<< Create def node >>
#@-node:ekr.20031218072017.2263:scanPythonDef
#@+node:ekr.20031218072017.2267:scanPythonDecls
def scanPythonDecls (self,s,i,parent,indent,indent_parent_ref_flag=True):
    
    c = self.c
    done = False ; start = i
    while not done and i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n':
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            # 2/14/03: break on lesser indention.
            j = g.skip_ws(s,i)
            if not g.is_nl(s,j) and not g.match(s,j,"#") and not backslashNewline:
                lineIndent = self.getLeadingIndent(s,i)
                if lineIndent <= indent:
                    break
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << break on def or class >>
        else: i += 1
        assert(progress < i)
    j = g.skip_blank_lines(s,start)
    if g.is_nl(s,j): j = g.skip_nl(s,j)
    if j < i:
        << Create a child node for declarations >>
    return i
#@+node:ekr.20031218072017.2268:<< break on def or class >>
if g.match_c_word(s,i,"def") or g.match_c_word(s,i,"class"):
    i = g.find_line_start(s,i)
    done = True
    break
else:
    i = g.skip_c_id(s,i)
#@-node:ekr.20031218072017.2268:<< break on def or class >>
#@+node:ekr.20031218072017.2269:<< Create a child node for declarations >>
headline = ref = g.angleBrackets(" " + self.methodName + " declarations ")
leading_tab = g.choose(indent_parent_ref_flag,"\t","")

# Append the reference to the parent's body.
c.appendStringToBody(parent,leading_tab + ref + "\n") # 7/6/02

# Create the node for the decls.
body = self.undentBody(s[j:i])
if self.treeType == "@root":
    body = "@code\n\n" + body
self.createHeadline(parent,body,headline)
#@-node:ekr.20031218072017.2269:<< Create a child node for declarations >>
#@-node:ekr.20031218072017.2267:scanPythonDecls
#@+node:ekr.20031218072017.2270:scanPythonText
# See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    c = self.c
    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << handle possible Python function or class >>
        else: i += 1
        assert(progress < i)
    if not decls_seen: # 2/17/03
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
    << Append a reference to the methods of this file >>
    << Append any unused python text to the parent's body text >>
#@+node:ekr.20031218072017.2271:<< handle possible Python function or class >>
if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file":
            c.appendStringToBody(parent,"@others\n")
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)
#@-node:ekr.20031218072017.2271:<< handle possible Python function or class >>
#@+node:ekr.20031218072017.2272:<< Append a reference to the methods of this file >>
if self.treeType == "@root" and self.methodsSeen:
    c.appendStringToBody(parent,
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
#@-node:ekr.20031218072017.2272:<< Append a reference to the methods of this file >>
#@+node:ekr.20031218072017.2273:<< Append any unused python text to the parent's body text >>
# Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i < len(s):
    c.appendStringToBody(parent,s[start:])
#@-node:ekr.20031218072017.2273:<< Append any unused python text to the parent's body text >>
#@-node:ekr.20031218072017.2270:scanPythonText
#@+node:ekr.20060626083237.1:skipPythonDef
def skipPythonDef (self,s,i,start):
    
    # g.trace(g.get_line(s,i))

    # Set defIndent to the indentation of the def line.
    defIndent = self.getLeadingIndent(s,start)
    parenCount = 0
    << skip the entire signature >>
    indent = self.getLeadingIndent(s,i)
    while i < len(s): # and indent > defIndent
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            if not backslashNewline:
                # New in Leo 4.4.1: don't set indent for comment lines.
                j = g.skip_ws(s,i)
                if not g.match(s,j,'#'):
                    indent = self.getLeadingIndent(s,i)
                    if indent <= defIndent and parenCount == 0:
                        break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)
        
    return i
#@+node:ekr.20060627062652:<< skip the entire signature >>
# Now that we count parens, we must be careful to skip the entire signature.

j = s.find('(',i)
if j != -1:
    j = g.skip_matching_python_parens(s,j)

if j == -1 or not g.match(s,j+1,':'):
    g.es_print('Warning: improper signature: %s' % g.get_line(s,i))
    return i
else:
    i = g.skip_line(s,j) # Still not quite 100% correct.
#@-node:ekr.20060627062652:<< skip the entire signature >>
#@-node:ekr.20060626083237.1:skipPythonDef
#@+node:ekr.20060626083237.2:test_skipPythonDef
def test_skipPythonDef (self):

    global c # Get syntax warning if this is not first.
    if self: c = self.c             # Run from @test node: c not global
    else: self = c.importCommands   # Run from @suite: c *is* global

    d = g.scanDirectives(c)
    self.tab_width = d.get("tabwidth")
    verbose = False
    << define s >>
    start = 0
    i = self.skipPythonDef(s,i=0,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test1') and result.endswith('return 1'),'result:\n%s' % result
    start = i
    i = self.skipPythonDef(s,i=i,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test2') and result.endswith('pass'),'result:\n%s' % result
#@+node:ekr.20060626083725:<< define s >>
s = '''\
def test1():
    aList = (a,
b,c)
# underindented comment.
    return 1

def test2():
# underindented comment.
    pass
'''

s = g.adjustTripleString(s,self.tab_width)
#@-node:ekr.20060626083725:<< define s >>
#@-node:ekr.20060626083237.2:test_skipPythonDef
#@+node:ekr.20060627063313:test_skipPythonDef2
def test_skipPythonDef2 (self):
    
    '''Tests of long signature lines.'''

    global c # Get syntax warning if this is not first.
    if self: c = self.c             # Run from @test node: c not global
    else: self = c.importCommands   # Run from @suite: c *is* global

    d = g.scanDirectives(c)
    self.tab_width = d.get("tabwidth")
    verbose = False
    << define s >>
    start = 0
    i = self.skipPythonDef(s,i=0,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test1') and result.endswith('return 1'),'result:\n%s' % result
    start = i
    i = self.skipPythonDef(s,i=i,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test2') and result.endswith('return 2'),'result:\n%s' % result
#@+node:ekr.20060627063313.1:<< define s >>
s = '''\
def test1(
        a=2):
    return 1

def test2(
a=3):
    return 2
'''

s = g.adjustTripleString(s,self.tab_width)
#@-node:ekr.20060627063313.1:<< define s >>
#@-node:ekr.20060627063313:test_skipPythonDef2
#@+node:ekr.20060626100102.1:test_scanPythonClass
def test_scanPythonClass (self):
    
    # pychecker complains about c.

    global c # Get syntax warning if this is not first.
    if self: c = self.c             # Run from @test node: c not global
    else: self = c.importCommands   # Run from @suite: c *is* global

    d = g.scanDirectives(c)
    self.tab_width = d.get("tabwidth")
    verbose = False
    << define s >>
    start = 0
    i = self.skipPythonDef(s,i=0,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('class aClass') and result.endswith("'eggs'"),'result:\n%s' % result
    start = i
    i = self.skipPythonDef(s,i=i,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('class aClass2') and result.endswith("'twit'"),'result:\n%s' % result
#@+node:ekr.20060626100102.2:<< define s >>
s = '''\
class aClass:
    def spam():
        return 'spam'
# underindented comment line
    def eggs():
        return 'eggs'
        
class aClass2:
    def twit():
        return 'twit'
'''

s = g.adjustTripleString(s,self.tab_width)
#@-node:ekr.20060626100102.2:<< define s >>
#@-node:ekr.20060626100102.1:test_scanPythonClass
#@-node:ekr.20031218072017.2256:Python scanners & tests
#@+node:ekr.20031218072017.3250:scanCText
# Creates a child of parent for each C function definition seen.

def scanCText (self,s,parent):
    
    scanner = self.cScanner(self)
    scanner.scan(s,parent)
    
#@nonl
#@-node:ekr.20031218072017.3250:scanCText
#@+node:ekr.20031218072017.3265:scanElispText & allies
def scanElispText(self,s,p):

    c = self.c
    c.appendStringToBody(p,"@ignore\n@language elisp\n")
    i = 0 ; start = 0
    while i < len(s):
        progress = i
        ch = s[i] ; # g.trace(g.get_line(s,i))
        if ch == ';':
            i = g.skip_line(s,i)
        elif ch == '(':
            j = self.skipElispParens(s,i)
            k = g.skip_ws(s,i+1)
            if g.match_word(s,k,"defun") or g.match_word(s,k,"defconst") or g.match_word(s,k,"defvar"):
                data = s[start:i]
                if data.strip():
                    self.createElispDataNode(p,data)
                self.createElispFunction(p,s[i:j+1])
                start = j+1
            i = j
        else:
            i += 1
        assert(progress < i)
    data = s[start:len(s)]
    if data.strip():
        self.createElispDataNode(p,data)
#@+node:ekr.20031218072017.3266:skipElispParens
def skipElispParens (self,s,i):
    
    level = 0 ; n = len(s)
    assert(g.match(s,i,'('))
    
    while i < n:
        c = s[i]
        if c == '(':
            level += 1 ; i += 1
        elif c == ')':
            level -= 1
            if level <= 0:
                return i
            i += 1
        elif c == '"': i = g.skip_string(s,i) # Single-quotes are not strings.
        elif g.match(s,i,";"):  i = g.skip_line(s,i)
        else: i += 1
    return i
#@-node:ekr.20031218072017.3266:skipElispParens
#@+node:ekr.20031218072017.3267:skipElispId
def skipElispId (self,s,i):

    n = len(s)
    while i < n and g.isWordChar(s[i]):
        i += 1
    return i
#@-node:ekr.20031218072017.3267:skipElispId
#@+node:ekr.20031218072017.3268:createElispFunction
def createElispFunction (self,p,s):
    
    body = s
    i = 1 # Skip the '('
    i = g.skip_ws(s,i)

    # Set the prefix in the headline.
    assert(g.match(s,i,"defun") or g.match_word(s,i,"defconst") or g.match_word(s,i,"defvar"))
    if g.match_word(s,i,"defconst"):
        prefix = "const "
    elif g.match_word(s,i,"defvar"):
        prefix = "var "
    else:
        prefix = ""

    # Skip the "defun" or "defconst" or "defvar"
    i = self.skipElispId(s,i)
    
    # Get the following id.
    i = g.skip_ws(s,i)
    j = self.skipElispId(s,i)
    theId = prefix + s[i:j]

    self.createHeadline(p,body,theId)
#@-node:ekr.20031218072017.3268:createElispFunction
#@+node:ekr.20031218072017.3269:createElispDataNode
def createElispDataNode (self,p,s):
    
    data = s
    # g.trace(len(data))
    
    # Skip blank lines and comment lines.
    i = 0
    while i < len(s):
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,';'):
            i = g.skip_line(s,i)
        else: break

    # Find the next id, probably prefixed by an open paren.
    if g.match(s,i,"("):
        i = g.skip_ws(s,i+1)
    j = self.skipElispId(s,i)
    theId = s[i:j]
    if not theId:
        theId = "unnamed data"

    self.createHeadline(p,data,theId)
#@-node:ekr.20031218072017.3269:createElispDataNode
#@-node:ekr.20031218072017.3265:scanElispText & allies
#@+node:ekr.20041107094641:scanForthText
def scanForthText (self,s,parent):
    
    """Minimal forth scanner - leave it to user to create nodes as they see fit."""

    self.c.setBodyString(parent,"@ignore\n" + "@language forth\n" + self.rootLine + s)
#@-node:ekr.20041107094641:scanForthText
#@+node:ekr.20031218072017.3270:scanJavaText
# Creates a child of parent for each Java function definition seen.

def scanJavaText (self,s,parent,outerFlag): # True if at outer level.

    __pychecker__ = 'maxlines=500'

    << define scanJavaText vars >>
    # if not outerFlag: g.trace("inner:",s)
    while i < len(s):
        # g.trace(g.get_line(s,i))
        ch = s[i]
        # These cases skip tokens.
        if ch == '/':
            << handle possible Java comments >>
        elif ch == '"' or ch == '\'': i = g.skip_string(s,i)
        # These cases help determine where functions start.
        elif ch == '=':
            << handle equal sign in Java >>
        elif ch == '(':
            << handle open paren in Java >>
        elif ch == ';':
            << handle semicolon in Java >>
            class_seen = False
        # These cases can create child nodes.
        elif ch == '{':
            << handle open curly bracket in Java >>
        elif g.is_c_id(s[i]):
            << skip and remember the Java id >>
        else: i += 1
    << Append any unused text to the parent's body text >>
#@+node:ekr.20031218072017.3271:<< define scanJavaText vars >>
c = self.c
method_seen = False
class_seen = False # True: class keyword seen at outer level.
interface_seen = False # True: interface keyword seen at outer level.
lparen = None  # not None if '(' seen at outer level.
scan_start = 0
name = None
function_start = 0 # g.choose(outerFlag, None, 0)
i = 0
#@-node:ekr.20031218072017.3271:<< define scanJavaText vars >>
#@+node:ekr.20031218072017.3277:<< handle possible Java comments >>
if g.match(s,i,"//"):
    i = g.skip_line(s,i)
elif g.match(s,i,"/*"):
    i = g.skip_block_comment(s,i)
else:
    i += 1
#@-node:ekr.20031218072017.3277:<< handle possible Java comments >>
#@+node:ekr.20031218072017.3278:<< handle equal sign in Java >>
@ We can not be seeing a function definition when we find an equal sign at the top level. Equal signs inside parentheses are handled by the open paren logic.
@c

i += 1 # skip the '='
function_start = 0 # 3/23/03: (bug fix: was None) We can't be in a function.
lparen = None   # We have not seen an argument list yet.
if g.match(s,i,'='):
    i = g.skip_braces(s,i)
#@-node:ekr.20031218072017.3278:<< handle equal sign in Java >>
#@+node:ekr.20031218072017.3279:<< handle open paren in Java >>
lparen = i
# This will skip any equal signs inside the paren.
i = g.skip_parens(s,i)
if g.match(s,i,')'):
    i += 1
    i = g.skip_ws_and_nl(s,i)
    if g.match(s,i,';'):
        lparen = None # not a function definition.
else: lparen = None
#@-node:ekr.20031218072017.3279:<< handle open paren in Java >>
#@+node:ekr.20031218072017.3280:<< handle semicolon in Java >>
@ A semicolon signals the end of a declaration, thereby potentially starting the _next_ function defintion.   Declarations end a function definition unless we have already seen a parenthesis, in which case we are seeing an old-style function definition.
@c

i += 1 # skip the semicolon.
if lparen == None:
    function_start = i + 1 # The semicolon ends the declaration.
#@-node:ekr.20031218072017.3280:<< handle semicolon in Java >>
#@+node:ekr.20031218072017.3272:<< handle open curly bracket in Java >>
brace_ip1 = i
i = g.skip_braces(s,i) # Skip all inner blocks.
brace_ip2 = i

if not g.match (s,i,'}'):
    g.es("unmatched '{'")
elif not name:
    i += 1
elif (outerFlag and (class_seen or interface_seen)) or (not outerFlag and lparen):
    # g.trace("starting:",name)
    # g.trace("outerFlag:",outerFlag)
    # g.trace("lparen:",lparen)
    # g.trace("class_seen:",class_seen)
    # g.trace("scan_start:",g.get_line_after(s,scan_start))
    # g.trace("func_start:",g.get_line_after(s,function_start))
    # g.trace("s:",g.get_line(s,i))

    # Point i _after_ the last character of the method.
    i += 1
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
    function_end = i
    headline = name
    if outerFlag:
        leader = "" ; decl_leader = ""
        if class_seen:
            headline = "class " + headline
            methodKind = "classes"
        else:
            headline = "interface " + headline
            methodKind = "interfaces"
    else:
        leader = "\t" # Indent only inner references.
        decl_leader = "\n"  # Declaration leader for inner references.
        methodKind = "methods"
    if method_seen:
        # Include everything after the last fucntion.
        function_start = scan_start
    else:
        << create a Java declaration node >>
        << append Java method reference to parent node >>
    if outerFlag: # Create a class.
        # Backtrack so we remove leading whitespace.
        function_start = g.find_line_start(s,function_start)
        body = s[function_start:brace_ip1+1]
        body = self.massageBody(body,methodKind)
        v = self.createHeadline(parent,body,headline)
        << recursively scan the text >>
        # Append the brace to the parent.
        c.appendStringToBody(v,"}")
        i = brace_ip2 + 1 # Start after the closing brace.
    else: # Create a method.
        # Backtrack so we remove leading whitespace.
        function_start = g.find_line_start(s,function_start)
        body = s[function_start:function_end]
        body = self.massageBody(body,methodKind)
        self.createHeadline(parent,body,headline)
        i = function_end
    method_seen = True
    scan_start = function_start = i # Set the start of the _next_ function.
    lparen = None ; class_seen = False
else: i += 1
#@+node:ekr.20031218072017.3273:<< create a Java declaration node >>
save_ip = i
i = scan_start
while i < function_start and g.is_ws_or_nl(s,i):
    i += 1
    
if outerFlag:
    c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language java\n")

if i < function_start:
    decl_headline = g.angleBrackets(" " + self.methodName + " declarations ")

    # Append the headline to the parent's body.
    c.appendStringToBody(parent,decl_leader + leader + decl_headline + "\n")
    scan_start = g.find_line_start(s,scan_start) # Backtrack so we remove leading whitespace.
    decls = s[scan_start:function_start]
    decls = self.undentBody(decls)
    body = g.choose(self.treeType == "@file",decls,"@code\n\n" + decls)
    self.createHeadline(parent,body,decl_headline)

i = save_ip
scan_start = i
#@-node:ekr.20031218072017.3273:<< create a Java declaration node >>
#@+node:ekr.20031218072017.3274:<< append Java method reference to parent node >>
if self.treeType == "@file":
    if outerFlag:
        c.appendStringToBody(parent,"\n@others\n")
    else:
        c.appendStringToBody(parent,"\n\t@others\n")
else:
    kind = g.choose(outerFlag,"classes","methods")
    ref_name = g.angleBrackets(" " + self.methodName + " " + kind + " ")
    c.appendStringToBody(parent,leader + ref_name + "\n")
#@-node:ekr.20031218072017.3274:<< append Java method reference to parent node >>
#@+node:ekr.20031218072017.3275:<< recursively scan the text >>
# These mark the points in the present function.
# g.trace("recursive scan:",g.get_line(s,brace_ip1+ 1))
oldMethodName = self.methodName
self.methodName = headline
self.scanJavaText(s[brace_ip1+1:brace_ip2], # Don't include either brace.
    v,False) # inner level
self.methodName = oldMethodName
#@-node:ekr.20031218072017.3275:<< recursively scan the text >>
#@-node:ekr.20031218072017.3272:<< handle open curly bracket in Java >>
#@+node:ekr.20031218072017.3276:<< skip and remember the Java id >>
if g.match_c_word(s,i,"class") or g.match_c_word(s,i,"interface"):
    if g.match_c_word(s,i,"class"):
        class_seen = True
    else:
        interface_seen = True
    i = g.skip_c_id(s,i) # Skip the class or interface keyword.
    i = g.skip_ws_and_nl(s,i)
    if i < len(s) and g.is_c_id(s[i]):
        # Remember the class or interface name.
        j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
else:
    j = i ; i = g.skip_c_id(s,i)
    if not lparen and not class_seen:
        name = s[j:i] # Remember the name.
#@-node:ekr.20031218072017.3276:<< skip and remember the Java id >>
#@+node:ekr.20031218072017.3264:<< append any unused text to the parent's body text >>
# Used by the Java and Pascal scanners.

i = g.skip_ws_and_nl(s,scan_start)
if i < len(s):
    c.appendStringToBody(parent,s[scan_start:])
#@-node:ekr.20031218072017.3264:<< append any unused text to the parent's body text >>
#@-node:ekr.20031218072017.3270:scanJavaText
#@+node:ekr.20060328112327:scanLuaText
def scanLuaText (self,s,parent):
     
    """Minimal Lua scanner - leave it to user to create nodes as they see fit."""
 
    self.c.setBodyString(parent,"@ignore\n" + "@language lua\n" + self.rootLine + s)
#@-node:ekr.20060328112327:scanLuaText
#@+node:ekr.20031218072017.3281:scanPascalText
# Creates a child of parent for each Pascal function definition seen.

def scanPascalText (self,s,parent):

    c = self.c
    method_seen = False ; methodKind = "methods"
    scan_start = function_start = i = 0
    name = None
    while i < len(s):
        # line = g.get_line(s,i) ; g.trace(line)
        ch = s[i]
        if ch == '{': i = g.skip_pascal_braces(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_pascal_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.is_c_id(s[i]):
            << handle possible Pascal function >>
        else: i += 1
    << Append any unused text to the parent's body text >>
#@+node:ekr.20031218072017.3282:<< handle possible Pascal function >>
if g.match_c_word(s,i,"begin"):
    i = g.skip_pascal_begin_end(s,i)
    if g.match_c_word(s,i,"end"):
        i = g.skip_c_id(s,i)
elif (g.match_c_word(s,i,"function")  or g.match_c_word(s,i,"procedure") or
    g.match_c_word(s,i,"constructor") or g.match_c_word(s,i,"destructor")):

    # line = g.get_line(s,i) ; g.trace(line)
    
    start = i
    i = g.skip_c_id(s,i)
    i = g.skip_ws_and_nl(s,i)
    << remember the function name, or continue >>
    << skip the function definition, or continue >>
    if not method_seen:
        method_seen = True
        << create a child node for leading declarations >>
        << append noweb method reference to the parent node >>
        function_start = start
    else: function_start = scan_start
    << create a child node for the function >>
else: i = g.skip_c_id(s,i)
#@+node:ekr.20031218072017.3285:<< remember the function name, or continue >>
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    while i + 1 < len(s) and s[i] == '.' and g.is_c_id(s[i+1]):
        i += 1 ; j = i
        i = g.skip_c_id(s,i)
    name = s[j:i]
else: continue
#@-node:ekr.20031218072017.3285:<< remember the function name, or continue >>
#@+node:ekr.20031218072017.3286:<< skip the function definition, or continue >>
<< skip past the semicolon >>

if not g.match_c_word(s,i,"begin"):
    continue
# Skip to the matching end.
i = g.skip_pascal_begin_end(s,i)
if g.match_c_word(s,i,"end"):
    i = g.skip_c_id(s,i)
    i = g.skip_ws_and_nl(s,i)
    if g.match(s,i,';'):
        i += 1
    i = g.skip_ws(s,i)
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
else: continue
#@+node:ekr.20031218072017.3287:<< skip past the semicolon >>
while i < len(s) and s[i] != ';':
    # The paremeter list may contain "inner" semicolons.
    if s[i] == '(':
        i = g.skip_parens(s,i)
        if g.match(s,i,')'):
            i += 1
        else: break
    else: i += 1
if g.match(s,i,';'):
    i += 1
i = g.skip_ws_and_nl(s,i)

if g.match_c_word(s,i,"var"):
    # Skip to the next begin.
    i = g.skip_c_id(s,i)
    done = False
    while i < len(s) and not done:
        ch = s[i]
        if ch == '{': i = g.skip_pascal_braces(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.is_c_id(ch):
            if g.match_c_word(s,i,"begin"): done = True
            else: i = g.skip_c_id(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_pascal_string(s,i)
        else: i += 1
#@-node:ekr.20031218072017.3287:<< skip past the semicolon >>
#@-node:ekr.20031218072017.3286:<< skip the function definition, or continue >>
#@+node:ekr.20031218072017.3283:<< create a child node for leading declarations >>
save_ip = i
i = scan_start
while i < start and g.is_ws_or_nl(s,i):
    i += 1
if i < start:
    c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language pascal\n")
    headline = g.angleBrackets(self.methodName + " declarations ")
    # Append the headline to the parent's body.
    c.appendStringToBody(parent,headline + "\n")
    if self.treeType == "@file":
        body = s[scan_start:start]
    else:
        body = "@code\n\n" + s[scan_start:start]
    body = self.undentBody(body)
    self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i
#@-node:ekr.20031218072017.3283:<< create a child node for leading declarations >>
#@+node:ekr.20031218072017.3288:<< append noweb method reference to the parent node >>
# Append the headline to the parent's body.
if self.treeType == "@file":
    c.appendStringToBody(parent,"@others\n")
else:
    c.appendStringToBody(parent,
        g.angleBrackets(" " + self.methodName + " methods ") + "\n")
#@-node:ekr.20031218072017.3288:<< append noweb method reference to the parent node >>
#@+node:ekr.20031218072017.3284:<< create a child node for the function >>
# Point i _after_ the last character of the function.
i = g.skip_ws(s,i)
if g.is_nl(s,i):
    i = g.skip_nl(s,i)
function_end = i
headline = name
body = s[function_start:function_end]
body = self.massageBody(body,methodKind)
self.createHeadline(parent,body,headline)
scan_start = i
#@-node:ekr.20031218072017.3284:<< create a child node for the function >>
#@-node:ekr.20031218072017.3282:<< handle possible Pascal function >>
#@+node:ekr.20031218072017.3264:<< append any unused text to the parent's body text >>
# Used by the Java and Pascal scanners.

i = g.skip_ws_and_nl(s,scan_start)
if i < len(s):
    c.appendStringToBody(parent,s[scan_start:])
#@-node:ekr.20031218072017.3264:<< append any unused text to the parent's body text >>
#@-node:ekr.20031218072017.3281:scanPascalText
#@+node:ekr.20031218072017.3242:scanPHPText (Dave Hein)
# 08-SEP-2002 DTHEIN: Added for PHP import support.
#
# PHP uses both # and // as line comments, and /* */ as block comments

def scanPHPText (self,s,parent):

    __pychecker__ = 'maxlines=500'

    """Creates a child of parent for each class and function definition seen."""

    << define scanPHPText vars >>
    << Append file if not pure PHP >>
    
    # 14-SEP-2002 DTHEIN: Make leading <?php use the @first directive
    c.appendStringToBody(parent,"@first ")
    c.appendStringToBody(parent,s[:startOfCode])
    scan_start = i = startOfCode
    while i < endOfCode:
        # line = g.get_line(s,i) ; g.trace(line)
        ch = s[i]
        # These cases skip tokens.
        if ch == '/' or ch == '#':
            << handle possible PHP comments >>
        elif ch == '<':
            << handle possible heredoc string >>
        elif ch == '"' or ch == '\'':
            i = g.skip_string(s,i)
        # These cases help determine where functions start.
        # FIXME: probably want to capture 'var's as class member data
        elif ch == 'f' or ch =='c':
            << handle possible class or function >>
        elif class_start and (ch == '}'):
            << handle end of class >>
        else: i += 1
    << Append any unused text to the parent's body text >>
    # 14-SEP-2002 DTHEIN: Make leading <?php use the @first directive
    c.appendStringToBody(parent,"@last ")
    c.appendStringToBody(parent,s[endOfCode:])
#@+node:ekr.20031218072017.3244:<< define scanPHPText vars >>
c = self.c
scan_start = 0
class_start = 0
function_start = 0
i = 0
class_body = ""
class_node = ""
phpClassName = re.compile("class\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")
phpFunctionName = re.compile("function\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")

# 14-SEP-2002 DTHEIN: added these 2 variables to allow use of @first/last
startOfCode = s.find("\n") + 1 # this should be the line containing the initial <?php
endOfCode = s.rfind("?>") # this should be the line containing the last ?>
#@-node:ekr.20031218072017.3244:<< define scanPHPText vars >>
#@+node:ekr.20031218072017.3243:<< Append file if not pure PHP >>
# If the file does not begin with <?php or end with ?> then
# it is simply appended like a generic import would do.

s.strip() # Remove inadvertent whitespace.

if (
    not (
        s.startswith("<?P") or
        s.startswith("<?p") or
        s.startswith("<?=") or
        s.startswith("<?\n") or
        s.startswith("<?\r") or
        s.startswith("<? ") or
        s.startswith("<?\t")
    ) or not (
        s.endswith("?>\n") or
        s.endswith("?>\r") or
        s.endswith("?>\r\n")
    )
):
    g.es("File seems to be mixed HTML and PHP; importing as plain text file.")
    c.setBodyString(parent,"@ignore\n" + self.rootLine + s)
    return
#@-node:ekr.20031218072017.3243:<< Append file if not pure PHP >>
#@+node:ekr.20031218072017.3246:<< handle possible PHP comments >>
if g.match(s,i,"//"):
    i = g.skip_line(s,i)
elif g.match(s,i,"#"):
    i = g.skip_line(s,i)
elif g.match(s,i,"/*"):
    i = g.skip_block_comment(s,i)
else:
    i += 1
#@-node:ekr.20031218072017.3246:<< handle possible PHP comments >>
#@+node:ekr.20031218072017.3245:<< handle possible heredoc string >>
if g.match(s,i,"<<<"):
    i = g.skip_heredoc_string(s,i)
else:
    i += 1
#@-node:ekr.20031218072017.3245:<< handle possible heredoc string >>
#@+node:ekr.20031218072017.3247:<< handle possible class or function >>
@ In PHP, all functions are typeless and start with the keyword "function;  all classes start with the keyword class.

Functions can be nested, but we don't handle that right now (I don't think it is a common practice anyway).
@c
if g.match(s,i,"function "):
    #we want to make the function a subnode of either the @file node or a class node
    # 1. get the function name
    # 2. make a reference in the parent
    # 3. create the child node, and dump the function in it.
    function_start = i
    m = phpFunctionName.match(s[i:])
    if (None == m): # function keyword without function name
        i += len("function ")
    else:
        headline = g.angleBrackets(" function " + m.group(1) + " ")
        # find the end of the function
        openingBrace = s.find('{',i)
        function_end = g.skip_php_braces(s,openingBrace)
        function_end = g.skip_to_end_of_line(s,function_end - 1) + 1 # include the line end
        # Insert skipped text into parent's body.
        if class_start:
            class_body += s[scan_start:function_start]
        else:
            c.appendStringToBody(parent,s[scan_start:function_start])
        # Append the headline to the parent's body.
        if class_start:
            class_body += (headline + "\n")
        else:
            c.appendStringToBody(parent,headline + "\n")
        # Backup to capture leading whitespace (for undent purposes)
        while (function_start > 0) and (s[function_start - 1] in [" ", "\t"]):
            function_start -= 1
        # Get the body and undent it
        function_body = s[function_start:function_end]
        function_body = self.undentBody(function_body)
        if self.treeType != "@file":
            function_body = "@code\n\n" + function_body
        # Create the new node
        if class_start:
            self.createHeadline(class_node,function_body,headline)
        else:
            self.createHeadline(parent,function_body,headline)
        i = function_end
        scan_start = i
        function_end = 0
        function_start = 0 #done with this function
        function_body = ""
        
elif g.match(s,i,"class "):
    # we want to make the class a subnode of the @file node
    # 1. get the class name
    # 2. make a reference in the parent
    # 3. create the child node and dump the function in it
    class_start = i
    class_body = ""
    m = phpClassName.match(s[i:])
    if (None == m): # class keyword without class name
        i += len("class ")
    else:
        # Insert skipped text into parent's body.
        c.appendStringToBody(parent,s[scan_start:class_start])
        # create the headline name
        headline = g.angleBrackets(" class " + m.group(1) + " ")
        # find the place to start looking for methods (functions)
        openingBrace = s.find('{',i)
        # find the end of the class
        class_end = g.skip_php_braces(s,openingBrace)
        class_end = g.skip_to_end_of_line(s,class_end - 1) + 1 # include the line end
        # Append the headline to the parent's body.
        c.appendStringToBody(parent,headline + "\n")
        # Backup to capture leading whitespace (for undent purposes)
        while (class_start > 0) and (s[class_start - 1] in [" ", "\t"]):
            class_start -= 1
        scan_start = class_start
        # Create the new node
        class_node = self.createHeadline(parent,"",headline)
        i = openingBrace
    
else:
    i += 1
#@-node:ekr.20031218072017.3247:<< handle possible class or function >>
#@+node:ekr.20031218072017.3248:<< handle end of class >>
# Capture the rest of the body
class_body += s[scan_start:class_end]
# insert the class node's body
if self.treeType != "@file":
    class_body = "@code\n\n" + class_body
class_body = self.undentBody(class_body)
c.appendStringToBody(class_node,class_body)
# reset the indices
i = class_end
scan_start = i
class_end = 0
class_start = 0 #done with this class
class_body=""
#@-node:ekr.20031218072017.3248:<< handle end of class >>
#@+node:ekr.20031218072017.3249:<< Append any unused text to the parent's body text >>
c.appendStringToBody(parent,s[scan_start:endOfCode])
#@-node:ekr.20031218072017.3249:<< Append any unused text to the parent's body text >>
#@-node:ekr.20031218072017.3242:scanPHPText (Dave Hein)
#@+node:ekr.20070202105339.1:class cScanner
@
The C scanner uses an internal class as an organizational aid. This is far
superior, imo, to using a single huge scanCText function organized with noweb
section references. Indeed, the helper class creates a separate namespace for
use by the various helper functions.

At present only the C scanner uses this organization, and the utilities of the
cScanner class are identical to the utilites of the leoImportCommands class.
This duplication would go away if all the scanners derived from a baseScanner
class, but that is not likely any time soon, if ever.
@c

class cScanner:
    @others
#@nonl
#@+node:ekr.20070202105914:cScanner.ctor
def __init__ (self,importer):

    # Copy ivars.
    self.c = importer.c
    self.encoding = importer.encoding
    self.methodKind = g.choose(importer.fileType==".c","functions","methods")
    self.methodName = importer.methodName
    self.rootLine = importer.rootLine
    self.treeType = importer.treeType
    
    # Other ivars.
    self.function_start = 0
    self.name = None
    self.scan_start = 0
#@-node:ekr.20070202105914:cScanner.ctor
#@+node:ekr.20070202105914.1:scan & helpers
def scan (self,s,parent,init=True):
    
    c = self.c
    if init:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language c\n")
    else:
        saveData = self.name,self.function_start,self.scan_start

    self.name,self.function_start,self.scan_start = '',0,0
    i = 0
    while i < len(s):
        progress = i
        ch = s[i]
        # if i == 0 or ch == '\n': g.trace('line',repr(g.get_line(s,i)))
        # g.trace('ch',repr(ch))
        if ch == '/':         i = self.skipComments(s,i)
        elif ch in ('"',"'"): i = g.skip_string(s,i)
        elif ch == '(':     i = self.doOuterParen(s,i,parent) # Possible function/method definition.
        elif ch == ';':     i = self.doSemicolon(s,i) # Signals a possible start of a function.
        elif g.is_c_id(ch): i = self.doId(s,i,parent) # Possible class/namespace definition.
        else: i += 1
        assert i > progress
    self.appendUnusedText(s,i,parent)
    if init:
        if parent.hasChildren(): c.appendStringToBody(parent,'@others')
    else:
        self.name,self.function_start,self.scan_start = saveData
#@nonl
#@+node:ekr.20070202111549:appendUnusedText
def appendUnusedText (self,s,i,parent):
    
    c = self.c
    
    i = g.skip_ws_and_nl(s,self.scan_start)
    if i < len(s):
        s2 = s[self.scan_start:]
        # g.trace(repr(s2))
        c.appendStringToBody(parent,s2)
#@-node:ekr.20070202111549:appendUnusedText
#@+node:ekr.20031218072017.3257:doId
def doId (self,s,i,parent):
    
    j = i ; i = g.skip_c_id(s,i)
    name = s[j:i]
    if name in ('class','namespace'):
        i = self.doInner(s,j,parent,name)
    else:
        self.name = name
        while g.match(s,i,'::'):
            self.name = self.name + '::'
            i = g.skip_ws_and_nl(s,i+2)
            if g.match(s,i,'~'):
                i += 1
                self.name = self.name + '~'
            i = g.skip_ws_and_nl(s,i)
            j = i ; i = g.skip_c_id(s,i)
            name2 = s[j:i]
            self.name = self.name + name2
    return i
#@-node:ekr.20031218072017.3257:doId
#@+node:ekr.20070203153208:doInner
def doInner (self,s,i,parent,kind):
    
    '''Handle a namespace or class definition.'''

    c = self.c
    start = i
    i += len(kind)
    j = g.skip_ws_and_nl(s,i)
    i = g.skip_c_id(s,j)
    name = s[j:i].strip()
    if not name: return i
    i = g.skip_ws_and_nl(s,i)
    bracket = i
    if not g.match(s,i,'{'): return i
    i = g.skip_braces(s,i)
    if g.match(s,i,'}'):
        end = i
        i = g.skip_ws_and_nl(s,i+1)
        if g.match(s,i,';'): i += 1
        # Append previous text.
        prev = s[self.scan_start:start]
        c.appendStringToBody(parent,prev)
        self.scan_start = self.function_start = i
        preamble = s[start:bracket+1]
        # Create children.
        p = self.createHeadline(parent,headline='%s %s' % (kind,name),body=preamble)
        body = s[bracket+1:end]
        self.scan(body,p.copy(),init=False)
        # Finish the text.
        if p.hasChildren(): c.appendStringToBody(p,'\n\t@others')
        c.appendStringToBody(p,s[end:i])    
    else:
        g.trace('missing "}" following %s' % kind)
    return i
#@-node:ekr.20070203153208:doInner
#@+node:ekr.20031218072017.3262:doOuterParen
def doOuterParen (self,s,i,parent):
    
    '''Handle '(' at the top level.
    This begins a function/method if and only if the character after the matching ')' is '{'.'''
    
    # Skip the param list.  It may not be properly matched if there are #if's involved.
    c = self.c
    i = g.skip_parens(s,i)
    if not g.match(s,i,')'): return i
    i = g.skip_ws_and_nl(s,i+1)
    if g.match(s,i,';'):
        return self.doSemicolon(s,i)
    elif g.match(s,i,'='):
        # An initializer ends a declaration.
        i = g.skip_ws_and_nl(s,i+1)
        if g.match(s,i,'{'):
            i = g.skip_braces(s,i)
        self.function_start = i
        return i
    elif g.match(s,i,'{'):
        i = g.skip_braces(s,i)
        if g.match(s,i,'}'):
            i += 1
            # g.trace('function %s' % self.name)
            c.appendStringToBody(parent,s[self.scan_start:self.function_start])
            body = s[self.function_start:i]
            p = self.createHeadline(parent,headline=self.name,body=body)
        else:
            g.trace('no matching "}" in function/method definition')
        self.scan_start = self.function_start = i
        return i
    else:
        return i
#@-node:ekr.20031218072017.3262:doOuterParen
#@+node:ekr.20031218072017.3263:doSemicolon
def doSemicolon (self,s,i):

    self.function_start = i+1 # The semicolon ends the declaration.
    return i+1
#@-node:ekr.20031218072017.3263:doSemicolon
#@+node:ekr.20031218072017.3260:skipComments
def skipComments (self,s,i):

    if g.match(s,i,"//"):
        i = g.skip_line(s,i)
    elif g.match(s,i,"/*"):
        i = g.skip_block_comment(s,i)
    else:
        i += 1

    return i
#@-node:ekr.20031218072017.3260:skipComments
#@-node:ekr.20070202105914.1:scan & helpers
#@+node:ekr.20070203074709:Utilities (should be in base class)
#@+node:ekr.20070203074709.1:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace("parent,headline:",parent,headline)
    # Create the vnode.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)
    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070203074709.1:createHeadline
#@+node:ekr.20070203074709.2:error
def error (self,s): g.es(s)
#@-node:ekr.20070203074709.2:error
#@+node:ekr.20070203074709.3:getLeadingIndent
def getLeadingIndent (self,s,i):

    """Return the leading whitespace of a line, ignoring blank and comment lines."""

    i = g.find_line_start(s,i)
    while i < len(s):
        # g.trace(g.get_line(s,i))
        j = g.skip_ws(s,i) # Bug fix: 2/14/03
        if g.is_nl(s,j) or g.match(s,j,"#"): # Bug fix: 2/14/03
            i = g.skip_line(s,i) # ignore blank lines and comment lines.
        else:
            i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
            # g.trace("returns:",width)
            return width
    # g.trace("returns:0")
    return 0
#@-node:ekr.20070203074709.3:getLeadingIndent
#@+node:ekr.20070203074709.4:isDocStart and isModuleStart
# The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):
    
    if not g.match(s,i,"@"):
        return False

    j = g.skip_ws(s,i+1)
    if g.match(s,j,"%defs"):
        return False
    elif self.webType == "cweb" and g.match(s,i,"@*"):
        return True
    else:
        return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

def isModuleStart (self,s,i):

    if self.isDocStart(s,i):
        return True
    else:
        return self.webType == "cweb" and (
            g.match(s,i,"@c") or g.match(s,i,"@p") or
            g.match(s,i,"@d") or g.match(s,i,"@f"))
#@-node:ekr.20070203074709.4:isDocStart and isModuleStart
#@+node:ekr.20070203074709.6:massageComment
def massageComment (self,s):

    """Returns s with all runs of whitespace and newlines converted to a single blank.
    
    Also removes leading and trailing whitespace."""

    s = s.strip()
    s = s.replace("\n"," ")
    s = s.replace("\r"," ")
    s = s.replace("\t"," ")
    s = s.replace("  "," ")
    s = s.strip()
    return s
#@-node:ekr.20070203074709.6:massageComment
#@+node:ekr.20070203074709.10:setEncoding
def setEncoding (self):
    
    # scanDirectives checks the encoding: may return None.
    theDict = g.scanDirectives(self.c)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
#@-node:ekr.20070203074709.10:setEncoding
#@+node:ekr.20070203074709.11:skipLeadingComments
def skipLeadingComments (self,s):

    """Skips all leading comments in s, returning the remaining body text and the massaged comment text.

    Returns (body, comment)"""

    # g.trace(g.get_line(s,0))
    s_original = s
    s = s.lstrip()
    i = 0 ; comment = ""
    if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
        << scan for C-style comments >>
    elif self.fileType == ".lua":
        << scan for Lua comments >>
    elif self.fileType == ".pas":
        << scan for Pascal comments >>
    elif self.fileType == ".py":
        << scan for Python comments >>
    comment = string.strip(comment)
    if len(comment) == 0:
        return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
    elif self.treeType == "@file":
        return s[i:], "@ " + comment
    else:
        return s[i:], "@ " + comment + "\n"
#@+node:ekr.20070203074709.12:<< scan for C-style comments >>
while i < len(s):
    if g.match(s,i,"//"): # Handle a C++ comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,"/*"): # Handle a block C comment.
        j = i + 2 ; i = g.skip_block_comment (s,i)
        k = g.choose(g.match(s,i-2,"*/"),i-2,i)
        if self.fileType == ".java":
            # 8/2/02: a hack: add leading whitespace then remove it.
            comment = self.undentBody(comment)
            comment2 = ' ' * 2 + s[j:k]
            comment2 = self.undentBody(comment2)
            comment = comment + comment2 + "\n"
        else:
            comment = comment + self.massageComment(s[j:k]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20070203074709.12:<< scan for C-style comments >>
#@+node:ekr.20070203074709.13:<< scan for Lua comments >>
while i < len(s):
    if g.match(s,i,"--"): # Handle a Lua line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20070203074709.13:<< scan for Lua comments >>
#@+node:ekr.20070203074709.14:<< scan for Pascal comments >>
while i < len(s):
    if g.match(s,i,"//"): # Handle a Pascal line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,'(*'):
        j = i + 1 ; i = g.skip_pascal_block_comment(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20070203074709.14:<< scan for Pascal comments >>
#@+node:ekr.20070203074709.15:<< scan for Python comments >>
while i < len(s) and g.match(s,i,'#'):
    j = i + 1 ; i = g.skip_line(s,i)
    comment = self.undentBody(comment)
    comment = comment + self.massageComment(s[j:i]) + "\n"
    # 8/2/02: Preserve leading whitespace for undentBody
    i = g.skip_ws(s,i)
    i = g.skip_blank_lines(s,i)
#@-node:ekr.20070203074709.15:<< scan for Python comments >>
#@-node:ekr.20070203074709.11:skipLeadingComments
#@+node:ekr.20070203074709.16:undentBody
# We look at the first line to determine how much leading whitespace to delete.

def undentBody (self,s):

    """Removes extra leading indentation from all lines."""

    # g.trace(s)
    i = 0 ; result = ""
    # Copy an @code line as is.
    if g.match(s,i,"@code"):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]
    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i)
    if undent == 0: return s
    while i < len(s):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        line = s[j:i]
        # g.trace(line)
        line = g.removeLeadingWhitespace(line,undent,self.tab_width)
        result += line
    return result
#@-node:ekr.20070203074709.16:undentBody
#@-node:ekr.20070203074709:Utilities (should be in base class)
#@-node:ekr.20070202105339.1:class cScanner
#@-node:ekr.20031218072017.3241:Scanners for createOutline
#@-node:ekr.20031218072017.3209:Import
#@+node:ekr.20031218072017.3224:importWebCommand & allies
#@+node:ekr.20031218072017.3225:createOutlineFromWeb
def createOutlineFromWeb (self,path,parent):

    c = self.c ; u = c.undoer
    junk,fileName = g.os_path_split(path)

    undoData = u.beforeInsertNode(parent)
    
    # Create the top-level headline.
    p = parent.insertAsLastChild()
    p.initHeadString(fileName)
    if self.webType=="cweb":
        c.setBodyString(p,"@ignore\n" + self.rootLine + "@language cweb")

    # Scan the file, creating one section for each function definition.
    self.scanWebFile(path,p)

    u.afterInsertNode(p,'Import',undoData)

    return p
#@-node:ekr.20031218072017.3225:createOutlineFromWeb
#@+node:ekr.20031218072017.3226:importWebCommand
def importWebCommand (self,files,webType):

    c = self.c ; current = c.currentVnode()
    if current == None: return
    if not files: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.webType = webType

    c.beginUpdate()
    try:
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutlineFromWeb(fileName,current)
            v.contract()
            v.setDirty()
            c.setChanged(True)
        c.selectVnode(current)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.3226:importWebCommand
#@+node:ekr.20031218072017.3227:findFunctionDef
def findFunctionDef (self,s,i):
    
    # Look at the next non-blank line for a function name.
    i = g.skip_ws_and_nl(s,i)
    k = g.skip_line(s,i)
    name = None
    while i < k:
        if g.is_c_id(s[i]):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
        elif s[i] == '(':
            if name: return name
            else: break
        else: i += 1
    return None
#@-node:ekr.20031218072017.3227:findFunctionDef
#@+node:ekr.20031218072017.3228:scanBodyForHeadline
@ This method returns the proper headline text.

1. If s contains a section def, return the section ref.
2. cweb only: if s contains @c, return the function name following the @c.
3. cweb only: if s contains @d name, returns @d name.
4. Otherwise, returns "@"
@c

def scanBodyForHeadline (self,s):
    
    if self.webType == "cweb":
        << scan cweb body for headline >>
    else:
        << scan noweb body for headline >>
    return "@" # default.
#@+node:ekr.20031218072017.3229:<< scan cweb body for headline >>
i = 0
while i < len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    # Allow constructs such as @ @c, or @ @<.
    if self.isDocStart(s,i):
        i += 2 ; i = g.skip_ws(s,i)
    if g.match(s,i,"@d") or g.match(s,i,"@f"):
        # Look for a macro name.
        directive = s[i:i+2]
        i = g.skip_ws(s,i+2) # skip the @d or @f
        if i < len(s) and g.is_c_id(s[i]):
            j = i ; g.skip_c_id(s,i) ; return s[j:i]
        else: return directive
    elif g.match(s,i,"@c") or g.match(s,i,"@p"):
        # Look for a function def.
        name = self.findFunctionDef(s,i+2)
        return g.choose(name,name,"outer function")
    elif g.match(s,i,"@<"):
        # Look for a section def.
        # A small bug: the section def must end on this line.
        j = i ; k = g.find_on_line(s,i,"@>")
        if k > -1 and (g.match(s,k+2,"+=") or g.match(s,k+2,"=")):
            return s[j:k+2] # return the section ref.
    i = g.skip_line(s,i)
#@-node:ekr.20031218072017.3229:<< scan cweb body for headline >>
#@+node:ekr.20031218072017.3230:<< scan noweb body for headline >>
i = 0
while i < len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if g.match(s,i,"<<"):
        k = g.find_on_line(s,i,">>=")
        if k > -1:
            ref = s[i:k+2]
            name = string.strip(s[i+2:k])
            if name != "@others":
                return ref
    else:
        name = self.findFunctionDef(s,i)
        if name:
            return name
    i = g.skip_line(s,i)
#@-node:ekr.20031218072017.3230:<< scan noweb body for headline >>
#@-node:ekr.20031218072017.3228:scanBodyForHeadline
#@+node:ekr.20031218072017.3231:scanWebFile (handles limbo)
def scanWebFile (self,fileName,parent):

    theType = self.webType
    lb = g.choose(theType=="cweb","@<","<<")
    rb = g.choose(theType=="cweb","@>",">>")

    try: # Read the file into s.
        f = open(fileName)
        s = f.read()
    except:
        g.es("Can not import " + fileName, color="blue")
        return

    << Create a symbol table of all section names >>
    << Create nodes for limbo text and the root section >>
    while i < len(s):
        outer_progress = i
        << Create a node for the next module >>
        assert(i > outer_progress)
#@nonl
#@+node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
i = 0 ; self.web_st = []

while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if self.isDocStart(s,i):
        if theType == "cweb": i += 2
        else: i = g.skip_line(s,i)
    elif theType == "cweb" and g.match(s,i,"@@"):
        i += 2
    elif g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k > -1: self.cstEnter(s[j:k])
    else: i += 1
    assert (i > progress)

# g.trace(self.cstDump())
#@-node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
#@+node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
i = 0
while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isModuleStart(s,i) or g.match(s,i,lb):
        break
    else: i = g.skip_line(s,i)
    assert(i > progress)
    
j = g.skip_ws(s,0)
if j < i:
    self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if g.match(s,i,lb):
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        else: i = g.skip_line(s,i)
        assert(i > progress)
    self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))
    
# g.trace(g.get_line(s,i))
#@-node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
#@+node:ekr.20031218072017.3234:<< Create a node for the next module >>
if theType=="cweb":
    assert(self.isModuleStart(s,i))
    start = i
    if self.isDocStart(s,i):
        i += 2
        while i < len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i): break
            else: i = g.skip_line(s,i)
            assert (i > progress)
    << Handle cweb @d, @f, @c and @p directives >>
else:
    assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
    start = i ; i = g.skip_line(s,i)
    while i < len(s):
        progress2 = i
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i): break
        else: i = g.skip_line(s,i)
        assert (i > progress)
    
body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)
#@+node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
if g.match(s,i,"@d") or g.match(s,i,"@f"):
    i += 2 ; i = g.skip_line(s,i)
    # Place all @d and @f directives in the same node.
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
        else: break
        assert (i > progress)
    i = g.skip_ws_and_nl(s,i)
    
while i < len(s) and not self.isModuleStart(s,i):
    progress = i
    i = g.skip_line(s,i)
    i = g.skip_ws_and_nl(s,i)
    assert (i > progress)

if g.match(s,i,"@c") or g.match(s,i,"@p"):
    i += 2
    while i < len(s):
        progress = i
        i = g.skip_line(s,i)
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        assert (i > progress)
#@-node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
#@-node:ekr.20031218072017.3234:<< Create a node for the next module >>
#@-node:ekr.20031218072017.3231:scanWebFile (handles limbo)
#@+node:ekr.20031218072017.3236:Symbol table
#@+node:ekr.20031218072017.3237:cstCanonicalize
# We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.

def cstCanonicalize (self,s,lower=True):
    
    if lower:
        s = string.lower(s)
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"\r","")
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
#@-node:ekr.20031218072017.3237:cstCanonicalize
#@+node:ekr.20031218072017.3238:cstDump
def cstDump (self):

    self.web_st.sort()
    s = "Web Symbol Table...\n\n"
    for name in self.web_st:
        s += name + "\n"
    return s
#@-node:ekr.20031218072017.3238:cstDump
#@+node:ekr.20031218072017.3239:cstEnter
# We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter (self,s):

    # Don't enter names that end in "..."
    s = string.rstrip(s)
    if s.endswith("..."): return
    
    # Put the section name in the symbol table, retaining capitalization.
    lower = self.cstCanonicalize(s,True)  # do lower
    upper = self.cstCanonicalize(s,False) # don't lower.
    for name in self.web_st:
        if string.lower(name) == lower:
            return
    self.web_st.append(upper)
#@-node:ekr.20031218072017.3239:cstEnter
#@+node:ekr.20031218072017.3240:cstLookup
# This method returns a string if the indicated string is a prefix of an entry in the web_st.

def cstLookup (self,target):
    
    # Do nothing if the ... convention is not used.
    target = string.strip(target)
    if not target.endswith("..."): return target
    # Canonicalize the target name, and remove the trailing "..."
    ctarget = target[:-3]
    ctarget = self.cstCanonicalize(ctarget)
    ctarget = string.strip(ctarget)
    found = False ; result = target
    for s in self.web_st:
        cs = self.cstCanonicalize(s)
        if cs[:len(ctarget)] == ctarget:
            if found:
                g.es("****** " + target + ": is also a prefix of: " + s)
            else:
                found = True ; result = s
                # g.es("replacing: " + target + " with: " + s)
    return result
#@-node:ekr.20031218072017.3240:cstLookup
#@-node:ekr.20031218072017.3236:Symbol table
#@-node:ekr.20031218072017.3224:importWebCommand & allies
#@+node:ekr.20031218072017.3305:Utilities
#@+node:ekr.20031218072017.3306:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace("parent,headline:",parent,headline)
    # Create the vnode.
    v = parent.insertAsLastChild()
    v.initHeadString(headline,self.encoding)
    # Set the body.
    if len(body) > 0:
        self.c.setBodyString(v,body,self.encoding)
    return v
#@-node:ekr.20031218072017.3306:createHeadline
#@+node:ekr.20031218072017.3307:error
def error (self,s): g.es(s)
#@-node:ekr.20031218072017.3307:error
#@+node:ekr.20031218072017.3308:getLeadingIndent
def getLeadingIndent (self,s,i):

    """Return the leading whitespace of a line, ignoring blank and comment lines."""

    i = g.find_line_start(s,i)
    while i < len(s):
        # g.trace(g.get_line(s,i))
        j = g.skip_ws(s,i) # Bug fix: 2/14/03
        if g.is_nl(s,j) or g.match(s,j,"#"): # Bug fix: 2/14/03
            i = g.skip_line(s,i) # ignore blank lines and comment lines.
        else:
            i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
            # g.trace("returns:",width)
            return width
    # g.trace("returns:0")
    return 0
#@-node:ekr.20031218072017.3308:getLeadingIndent
#@+node:ekr.20031218072017.3309:isDocStart and isModuleStart
# The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):
    
    if not g.match(s,i,"@"):
        return False

    j = g.skip_ws(s,i+1)
    if g.match(s,j,"%defs"):
        return False
    elif self.webType == "cweb" and g.match(s,i,"@*"):
        return True
    else:
        return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

def isModuleStart (self,s,i):

    if self.isDocStart(s,i):
        return True
    else:
        return self.webType == "cweb" and (
            g.match(s,i,"@c") or g.match(s,i,"@p") or
            g.match(s,i,"@d") or g.match(s,i,"@f"))
#@-node:ekr.20031218072017.3309:isDocStart and isModuleStart
#@+node:ekr.20031218072017.3310:massageBody
def massageBody (self,s,methodKind):
    
    # g.trace(s)
    # g.trace(g.get_line(s,0))
    c = self.c
    if self.treeType == "@file":
        if self.fileType == ".py": # 7/31/02: was "py"
            return self.undentBody(s)
        else:
            newBody, comment = self.skipLeadingComments(s)
            newBody = self.undentBody(newBody)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            if len(comment) > 0:
                return comment + "\n@c" + newLine + newBody
            else:
                return newBody
    else:
        # Inserts < < self.methodName methodKind > > =
        cweb = self.fileType == "c" and not c.use_noweb_flag
        lb = g.choose(cweb,"@<","<<")
        rb = g.choose(cweb,"@>=",">>=")
        intro = lb + " " + self.methodName + " " + methodKind + " " + rb
        if self.fileType == ".py": # 7/31/02: was "py"
            newBody = self.undentBody(s)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            return intro + newLine + newBody
        else:
            newBody, comment = self.skipLeadingComments(s)
            newBody = self.undentBody(newBody)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            if len(comment) > 0:
                return comment + "\n" + intro + newLine + newBody
            else:
                return intro + newLine + newBody
#@-node:ekr.20031218072017.3310:massageBody
#@+node:ekr.20031218072017.3311:massageComment
def massageComment (self,s):

    """Returns s with all runs of whitespace and newlines converted to a single blank.
    
    Also removes leading and trailing whitespace."""

    # g.trace(g.get_line(s,0))
    s = string.strip(s)
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"\r"," ")
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
#@-node:ekr.20031218072017.3311:massageComment
#@+node:ekr.20031218072017.3312:massageWebBody
def massageWebBody (self,s):

    theType = self.webType
    lb = g.choose(theType=="cweb","@<","<<")
    rb = g.choose(theType=="cweb","@>",">>")
    << Remove most newlines from @space and @* sections >>
    << Replace abbreviated names with full names >>
    s = string.rstrip(s)
    return s
#@+node:ekr.20031218072017.3313:<< Remove most newlines from @space and @* sections >>
i = 0
while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isDocStart(s,i):
        # Scan to end of the doc part.
        if g.match(s,i,"@ %def"):
            # Don't remove the newline following %def
            i = g.skip_line(s,i) ; start = end = i
        else:
            start = end = i ; i += 2
        while i < len(s):
            progress2 = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i) or g.match(s,i,lb):
                end = i ; break
            elif theType == "cweb": i += 1
            else: i = g.skip_to_end_of_line(s,i)
            assert (i > progress2)
        # Remove newlines from start to end.
        doc = s[start:end]
        doc = string.replace(doc,"\n"," ")
        doc = string.replace(doc,"\r","")
        doc = string.strip(doc)
        if doc and len(doc) > 0:
            if doc == "@":
                doc = g.choose(self.webType=="cweb", "@ ","@\n")
            else:
                doc += "\n\n"
            # g.trace("new doc:",doc)
            s = s[:start] + doc + s[end:]
            i = start + len(doc)
    else: i = g.skip_line(s,i)
    assert (i > progress)
#@-node:ekr.20031218072017.3313:<< Remove most newlines from @space and @* sections >>
#@+node:ekr.20031218072017.3314:<< Replace abbreviated names with full names >>
i = 0
while i < len(s):
    progress = i
    # g.trace(g.get_line(s,i))
    if g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k > -1:
            name = s[j:k]
            name2 = self.cstLookup(name)
            if name != name2:
                # Replace name by name2 in s.
                # g.trace("replacing %s by %s" % (name,name2))
                s = s[:j] + name2 + s[k:]
                i = j + len(name2)
    i = g.skip_line(s,i)
    assert (i > progress)
#@-node:ekr.20031218072017.3314:<< Replace abbreviated names with full names >>
#@-node:ekr.20031218072017.3312:massageWebBody
#@+node:ekr.20031218072017.1463:setEncoding
def setEncoding (self):
    
    # scanDirectives checks the encoding: may return None.
    theDict = g.scanDirectives(self.c)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
#@-node:ekr.20031218072017.1463:setEncoding
#@+node:ekr.20031218072017.3315:skipLeadingComments
def skipLeadingComments (self,s):

    """Skips all leading comments in s, returning the remaining body text and the massaged comment text.

    Returns (body, comment)"""

    # g.trace(g.get_line(s,0))
    s_original = s
    s = s.lstrip()
    i = 0 ; comment = ""
    if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
        << scan for C-style comments >>
    elif self.fileType == ".lua":
        << scan for Lua comments >>
    elif self.fileType == ".pas":
        << scan for Pascal comments >>
    elif self.fileType == ".py":
        << scan for Python comments >>
    comment = string.strip(comment)
    if len(comment) == 0:
        return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
    elif self.treeType == "@file":
        return s[i:], "@ " + comment
    else:
        return s[i:], "@ " + comment + "\n"
#@+node:ekr.20031218072017.3316:<< scan for C-style comments >>
while i < len(s):
    if g.match(s,i,"//"): # Handle a C++ comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,"/*"): # Handle a block C comment.
        j = i + 2 ; i = g.skip_block_comment (s,i)
        k = g.choose(g.match(s,i-2,"*/"),i-2,i)
        if self.fileType == ".java":
            # 8/2/02: a hack: add leading whitespace then remove it.
            comment = self.undentBody(comment)
            comment2 = ' ' * 2 + s[j:k]
            comment2 = self.undentBody(comment2)
            comment = comment + comment2 + "\n"
        else:
            comment = comment + self.massageComment(s[j:k]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20031218072017.3316:<< scan for C-style comments >>
#@+node:ekr.20060328112327.1:<< scan for Lua comments >>
while i < len(s):
    if g.match(s,i,"--"): # Handle a Lua line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20060328112327.1:<< scan for Lua comments >>
#@+node:ekr.20031218072017.3317:<< scan for Pascal comments >>
while i < len(s):
    if g.match(s,i,"//"): # Handle a Pascal line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,'(*'):
        j = i + 1 ; i = g.skip_pascal_block_comment(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20031218072017.3317:<< scan for Pascal comments >>
#@+node:ekr.20031218072017.3318:<< scan for Python comments >>
while i < len(s) and g.match(s,i,'#'):
    j = i + 1 ; i = g.skip_line(s,i)
    comment = self.undentBody(comment)
    comment = comment + self.massageComment(s[j:i]) + "\n"
    # 8/2/02: Preserve leading whitespace for undentBody
    i = g.skip_ws(s,i)
    i = g.skip_blank_lines(s,i)
#@-node:ekr.20031218072017.3318:<< scan for Python comments >>
#@-node:ekr.20031218072017.3315:skipLeadingComments
#@+node:ekr.20031218072017.3319:undentBody
# We look at the first line to determine how much leading whitespace to delete.

def undentBody (self,s):

    """Removes extra leading indentation from all lines."""

    # g.trace(s)
    i = 0 ; result = ""
    # Copy an @code line as is.
    if g.match(s,i,"@code"):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]
    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i)
    if undent == 0: return s
    while i < len(s):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        line = s[j:i]
        # g.trace(line)
        line = g.removeLeadingWhitespace(line,undent,self.tab_width)
        result += line
    return result
#@-node:ekr.20031218072017.3319:undentBody
#@-node:ekr.20031218072017.3305:Utilities
#@+node:ekr.20031218072017.3187:skip_line, skip_to_start/end_of_line
@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    if i >= len(s): return len(s) # Bug fix: 2007/5/22
    if i < 0: i = 0
    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1
        
def skip_to_end_of_line (s,i):

    if i >= len(s): return len(s) # Bug fix: 2007/5/22
    if i < 0: i = 0
    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i

def skip_to_start_of_line (s,i):

    if i >= len(s): return len(s)
    if i <= 0:      return 0
    i = s.rfind('\n',0,i) # Don't find s[i], so it doesn't matter if s[i] is a newline.
    if i == -1: return 0
    else:       return i + 1
#@-node:ekr.20031218072017.3187:skip_line, skip_to_start/end_of_line
#@-node:ekr.20070518062728:Fix noweb problems
#@+node:ekr.20070514102229.1:Fix automatic directory creation
@nocolor
https://sourceforge.net/forum/message.php?msg_id=4301021
By: vransmayr

    I just performed a CVS-Update of Leo to ensure that I have the latest
version
of Leo.

When I try to create directories automatically (See also my initial question to
Leo Help Forum - "Feature or Bug?") I still receive an error. - The traceback
is:

<Log>

Leo Log Window...
Leo 4.4.3 alpha 2, build  1.147 , March 17, 2007
Python 2.4.3, Tk 8.4.7, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

redefining close-window in all to extend-to-word in all
redefining extend-to-word in all to kill-region-save in all
Can not import aspell from plugin leoEditCommands
leoID = vr20060903 (in C:\Dokumente und Einstellungen\VR)
global config dir: C:\CVS-Reps\leo\config
home dir: C:\Dokumente und Einstellungen\VR
reading settings in C:\CVS-Reps\leo\config\leoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\leoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\Desktop\Leo-20070507.leo
reading: C:\Dokumente und Einstellungen\VR\Desktop\Leo-20070507.leo
can not open: '@file C:\Dokumente und Einstellungen\VR\Desktop\a\test.py'
can not open: '@file C:\Dokumente und Einstellungen\VR\Desktop\a\b\test.py'
can not open: '@file C:\Dokumente und Einstellungen\VR\Desktop\a\b\c\test.py'
errors writing: C:\Dokumente und Einstellungen\VR\Desktop\a\test.py
path does not exist: C:\Dokumente und Einstellungen\VR\Desktop\a
errors writing: C:\Dokumente und Einstellungen\VR\Desktop\a\b\test.py
path does not exist: C:\Dokumente und Einstellungen\VR\Desktop\a\b
errors writing: C:\Dokumente und Einstellungen\VR\Desktop\a\b\c\test.py
path does not exist: C:\Dokumente und Einstellungen\VR\Desktop\a\b\c
Writing erroneous: @thin ./a/test.py
Writing erroneous: @thin ./a/b/test.py
Writing erroneous: @thin ./a/b/c/test.py
saved: Leo-20070507.leo

</Log>

Kind regards,

    Viktor
#@-node:ekr.20070514102229.1:Fix automatic directory creation
#@+node:ekr.20070514100340:Fix problem with update plugin
@nocolor

https://sourceforge.net/forum/message.php?msg_id=4309448
By: wgw

I downloaded leoupdate.py from tigris cvs. When I try to run it, I get: 


exception executing command
Traceback (most recent call last):
  File "/home/bill/download/leo-4-4-3-alpha-2/src/leoCommands.py", line 269,
in doCommand
    val = command(event)
  File "/home/bill/download/leo-4-4-3-alpha-2/plugins/plugins_menu.py", line
120, in callback
    p.hastoplevel(c)
  File "/usr/local/lib/leo/plugins/leoupdate.py", line 112, in topLevelMenu
    thePluginController.showManagerDialog()
  File "/usr/local/lib/leo/plugins/leoupdate.py", line 197, in
showManagerDialog
    dlg = HandlerDialog()
TypeError: __init__() takes at least 2 arguments (1 given)

I wouldn't be surprised if it was my installation (the Plugin update does not
work, for instance), but I thought I would let you know of the problem. I'm
running under Ubuntu.

Actually, I don't think it would work anyway; the cvs site in the code
is cvs.sourceforge.net/viewcvs.py/leo/leo/src, which, if I understand correctly,
is no longer active.
#@nonl
#@-node:ekr.20070514100340:Fix problem with update plugin
#@+node:ekr.20070426080015:Fix crasher in dynamic abbreviations
#@+node:ekr.20070506094429:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4255709

I have some questions about the usage of dynamic abbreviations in Leo. As an
Emacs user, I know how they work in Emacs: they expand partially entered words
using a dictionary of words from the currently open buffers.

- I found a thread in the SF Forums titled "dynamic-abbreviations increases
its scope", 07-20-2005. The functionality described in this thread seems to
be the functionality I am familiar with as an Emacs uses. Is this the functionality
accessed through the commands dabbrev-completion and dabbrev-expands ?
- What is the difference between dabbrev-completion and dabbrev-expands ? 
- I often get a TK exception when I use dabbrev-completion "TypeError: reduce()
of empty sequence with no initial value". What am I doing wrong ?

Can somebody answer these questions for me or point me to documentation that
describes Leo's support for dynamic abbreviations?

-----------
http://sourceforge.net/forum/message.php?msg_id=4260706
 
command completion is shell or readline functionality to automatically finish
what you've typed so far, thus "completing" the type-in of the command for you.

abbreviation expansion is actually going to put a bunch of characters in your
buffer where you only had to enter the abbreviation for it.

---------
http://sourceforge.net/forum/message.php?msg_id=4263851

Already solved a part of it. The exception is raised when the characters entered
cannot be completed to a previously typed word. In LeoPy.leo, Code-->Core
classes...-->@thin leoEditCommands.py-->editCommandsClass-->dynamic
abbreviation...-->dynamicExpansion2, no check is made that the call to
self.getDynamicList does not retrieve an empty list. I've added this check (locally)
and at least the exception is not raised anymore. Apparently I am the only one
using this functionality, otherwise taht person surely would have also encountered
the problem.

Unfortunately, when looking at the code it seems that only those words are completed
in the current node :( Is there another mechanism for completion (that also
considers other, e.g. previously viewed, nodes) or am I overlooking something ?
#@nonl
#@-node:ekr.20070506094429:Report
#@+node:ekr.20050920084036.13:abbrevCommandsClass (test)
@

type some text, set its abbreviation with Control-x a i g, type the text for abbreviation expansion
type Control-x a e ( or Alt-x expand-abbrev ) to expand abbreviation
type Alt-x abbrev-on to turn on automatic abbreviation expansion
Alt-x abbrev-on to turn it off

an example:
type:
frogs
after typing 's' type Control-x a i g.  This will turn the miniBuffer blue, type in your definition. For example: turtles.

Now in the buffer type:
frogs
after typing 's' type Control-x a e.  This will turn the 'frogs' into:
turtles
@c

class abbrevCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20050920084036.14: ctor & finishCreate
def __init__ (self,c):
    
    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    # Set local ivars.
    self.abbrevs ={}
    
def finishCreate(self):
    
    baseEditCommandsClass.finishCreate(self)
#@-node:ekr.20050920084036.14: ctor & finishCreate
#@+node:ekr.20050920084036.15: getPublicCommands & getStateCommands
def getPublicCommands (self):
    
    return {
        'abbrev-mode':                  self.toggleAbbrevMode,
        'add-global-abbrev':            self.addAbbreviation,
        # 'expand-abbrev':              self.expandAbbrev, # Not a command.
        'expand-region-abbrevs':        self.regionalExpandAbbrev,
        'inverse-add-global-abbrev':    self.addInverseAbbreviation,
        'kill-all-abbrevs':             self.killAllAbbrevs,
        'list-abbrevs':                 self.listAbbrevs,
        'read-abbrev-file':             self.readAbbreviations,
        'write-abbrev-file':            self.writeAbbreviations,
    }
#@-node:ekr.20050920084036.15: getPublicCommands & getStateCommands
#@+node:ekr.20050920084036.25:addAbbreviation
def addAbbreviation (self,event):
    
    '''Add an abbreviation:
    The selected text is the abbreviation;
    the minibuffer prompts you for the name of the abbreviation.
    Also sets abbreviations on.'''
            
    k = self.k ; state = k.getState('add-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Abbreviation: ',protect=True)
        k.getArg(event,'add-abbr',1,self.addAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        if k.arg.strip():
            self.abbrevs [k.arg] = word
            k.abbrevOn = True
            k.setLabelGrey(
                "Abbreviations are on.\nAbbreviation: '%s' = '%s'" % (
                k.arg,word))
#@-node:ekr.20050920084036.25:addAbbreviation
#@+node:ekr.20051004080550:addInverseAbbreviation
def addInverseAbbreviation (self,event):
    
    '''Add an inverse abbreviation:
    The selected text is the abbreviation name;
    the minibuffer prompts you for the value of the abbreviation.'''
    
    k = self.k ; state = k.getState('add-inverse-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Inverse Abbreviation: ',protect=True)
        k.getArg(event,'add-inverse-abbr',1,self.addInverseAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        if word:
            self.abbrevs [word] = k.arg
#@-node:ekr.20051004080550:addInverseAbbreviation
#@+node:ekr.20050920084036.27:expandAbbrev
def expandAbbrev (self,event):
    
    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.'''

    k = self.k ; c = self.c ; ch = event.char.strip()
    w = self.editWidget(event)
    if not w: return

    word = w.get('insert -1c wordstart','insert -1c wordend')
    g.trace('ch',repr(ch),'word',repr(word))
    if ch:
        # We must do this: expandAbbrev is called from Alt-x and Control-x,
        # we get two differnt types of data and w states.
        word = '%s%s'% (word,ch)
        
    val = self.abbrevs.get(word)
    if val is not None:
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        if i != j: w.delete(i,j)
        w.insert(i,val)
        c.frame.body.onBodyChanged(undoType='Typing')
        
    return val is not None
#@-node:ekr.20050920084036.27:expandAbbrev
#@+node:ekr.20050920084036.18:killAllAbbrevs
def killAllAbbrevs (self,event):
    
    '''Delete all abbreviations.'''

    self.abbrevs = {}
#@-node:ekr.20050920084036.18:killAllAbbrevs
#@+node:ekr.20050920084036.19:listAbbrevs
def listAbbrevs (self,event):
    
    '''List all abbreviations.'''

    k = self.k
    
    if self.abbrevs:
        for z in self.abbrevs:
            g.es('%s=%s' % (z,self.abbrevs[z]))
#@-node:ekr.20050920084036.19:listAbbrevs
#@+node:ekr.20050920084036.20:readAbbreviations
def readAbbreviations (self,event):
    
    '''Read abbreviations from a file.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Abbreviation File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return
        
    try:
        f = open(fileName)
        for x in f:
            a, b = x.split('=')
            b = b [:-1]
            self.abbrevs [a] = b
        f.close()
    except IOError:
        g.es('Can not open',fileName)
#@-node:ekr.20050920084036.20:readAbbreviations
#@+node:ekr.20050920084036.21:regionalExpandAbbrev (TK code)
def regionalExpandAbbrev (self,event):
    
    '''Exapand abbreviations throughout a region.'''

    k = self.k ; w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    i1,i2 = w.getSelectionRange()
    ins = w.getInsertPoint()
    << define a new generator searchXR >>

    # EKR: the 'result' of calling searchXR is a generator object.
    k.regx.iter = searchXR(i1,i2,ins,event)
    k.regx.iter.next() # Call it the first time.
#@nonl
#@+node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
@ This is a generator (it contains a yield).
To make this work we must define a new generator for each call to regionalExpandAbbrev.
@c
def searchXR (i1,i2,ins,event):
    k = self.k
    w = self.editWidget(event)
    if not w: return

    w.tag_add('sXR',i1,i2)
    while i1:
        tr = w.tag_ranges('sXR')
        if not tr: break
        i1 = w.search(r'\w',i1,stopindex=tr[1],regexp=True)
        if i1:
            word = w.get('%s wordstart' % i1,'%s wordend' % i1)
            w.tag_delete('found')
            w.tag_add('found','%s wordstart' % i1,'%s wordend' % i1)
            w.tag_config('found',background='yellow')
            if self.abbrevs.has_key(word):
                k.setLabel('Replace %s with %s? y/n' % (word,self.abbrevs[word]))
                yield None
                if k.regXKey == 'y':
                    ind = w.index('%s wordstart' % i1)
                    w.delete('%s wordstart' % i1,'%s wordend' % i1)
                    w.insert(ind,self.abbrevs[word])
            i1 = '%s wordend' % i1
    w.setInsertPoint(ins,ins,insert=ins)
    w.tag_delete('sXR')
    w.tag_delete('found')
    k.setLabelGrey('')
    self.k.regx = g.bunch(iter=None,key=None)
#@-node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
#@-node:ekr.20050920084036.21:regionalExpandAbbrev (TK code)
#@+node:ekr.20050920084036.23:toggleAbbrevMode
def toggleAbbrevMode (self,event):
    
    '''Toggle abbreviation mode.'''
 
    k = self.k
    k.abbrevOn = not k.abbrevOn
    k.keyboardQuit(event)
    k.setLabel('Abbreviations are ' + g.choose(k.abbrevOn,'On','Off'))
#@-node:ekr.20050920084036.23:toggleAbbrevMode
#@+node:ekr.20050920084036.24:writeAbbreviations
def writeAbbreviations (self,event):
    
    '''Write abbreviations to a file.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Write Abbreviations',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")
        
    if not fileName: return

    try:
        f = open(fileName,'w')
        for x in self.abbrevs:
            f.write('%s=%s\n' % (x,self.abbrevs[x]))
        f.close()
    except IOError:
        g.es('Can not create',fileName)
#@-node:ekr.20050920084036.24:writeAbbreviations
#@-node:ekr.20050920084036.13:abbrevCommandsClass (test)
#@+node:ekr.20050920084036.58:dynamic abbreviation...
#@+node:ekr.20050920084036.59:dynamicExpansion LATER
def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() not in ('null','tkinter'):
        return g.es('command not ready yet',color='blue')

    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if rlist:
            txt = rlist.pop()
            doDa(txt)
#@-node:ekr.20050920084036.59:dynamicExpansion LATER
#@+node:ekr.20050920084036.60:dynamicExpansion2 LATER
def dynamicExpansion2 (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    if rlist:
        dEstring = reduce(g.longestCommonPrefix,rlist)
        if dEstring:
            w.delete(i,i2)
            w.insert(i,dEstring)
#@-node:ekr.20050920084036.60:dynamicExpansion2 LATER
#@+node:ekr.20050920084036.61:getDynamicList (helper)
def getDynamicList (self,w,txt,rlist):

     ttext = w.getAllText()
     items = self.dynaregex.findall(ttext) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith(txt) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)
#@-node:ekr.20050920084036.61:getDynamicList (helper)
#@-node:ekr.20050920084036.58:dynamic abbreviation...
#@-node:ekr.20070426080015:Fix crasher in dynamic abbreviations
#@-node:ekr.20070522052905:Bugs 6
#@-node:ekr.20070515100356:To do: b2
#@-node:ekr.20060531161030:To do: 4.4.3
#@+node:ekr.20070325052041:To do: 4.4.4 (@auto)
#@+node:ekr.20070512162750:@url http://simpleparse.sourceforge.net/
#@-node:ekr.20070512162750:@url http://simpleparse.sourceforge.net/
#@+node:ekr.20061006165447:Let import commands decide what kind of import to do
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3940843
By: ktenney

>the distiction between importing 'foreign' text files and importing derived
files created by Leo.

Couldn't Leo make this distinction by looking at
the file being imported? If so, I think it should.

This could eliminate a lot of confusion IMO, if
I want to bring a file into a node, just
'import' it, and the right thing happens.

An emergency measure could be available in a 
'File Special' menu.
#@nonl
#@-node:ekr.20061006165447:Let import commands decide what kind of import to do
#@+node:ekr.20070324084040:Prototype of @auto
#@+node:ekr.20070324084040.1:NEWscanPythonText
def NEWscanPythonText (self,s,parent):
    
    scanner = self.pythonScanner(self,s,parent)
    
    scanner.parse()
        # Discover the node boundaries.
    scanner.checkWhitespace()
        # Check that whitespace passes TabNanny.
        # Check that whitespace is compatible with @tabwidth.
        # Check for underindented lines.
    scanner.generateNodes()
        # Generate a single node if there are errors,
        # otherwise generate the imported tree.
    scanner.checkImport()
        # Do trial write, verify that it would produce the original file.
        # Insert an @ignore directive in the root if there are errors.
#@nonl
#@-node:ekr.20070324084040.1:NEWscanPythonText
#@+node:ekr.20070324084040.13:class pythonScanner (not ready yet)
class pythonScanner:
    
    @others
    
    
#@nonl
#@+node:ekr.20070324084040.14:ctor (pythonScanner)
def __init__ (self,importer,s,parent):

    baseScannerClass.__init__(self,importer)
        # Init the base class.
        # Copies ivars from importer class to scanner class.

    # Other ivars.
    self.preamble_seen = False
    self.s = s
    self.className = None
    self.methodsSeen = False
    self.root = parent
    self.start = 0
#@-node:ekr.20070324084040.14:ctor (pythonScanner)
#@+node:ekr.20070324084040.15:scanPythonText
# See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    c = self.c
    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << handle possible Python function or class >>
        else: i += 1
        assert(progress < i)
    if not decls_seen: # 2/17/03
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
    << Append a reference to the methods of this file >>
    << Append any unused python text to the parent's body text >>
#@+node:ekr.20070324084040.16:<< Append a reference to the methods of this file >>
if self.treeType == "@root" and self.methodsSeen:
    c.appendStringToBody(parent,
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
#@-node:ekr.20070324084040.16:<< Append a reference to the methods of this file >>
#@+node:ekr.20070324084040.9:<< handle possible Python function or class >> (NOT USED)
if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file":
            c.appendStringToBody(parent,"@others\n")
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)
#@-node:ekr.20070324084040.9:<< handle possible Python function or class >> (NOT USED)
#@+node:ekr.20070324084040.17:<< Append any unused python text to the parent's body text >>
# Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i < len(s):
    c.appendStringToBody(parent,s[start:])
#@-node:ekr.20070324084040.17:<< Append any unused python text to the parent's body text >>
#@-node:ekr.20070324084040.15:scanPythonText
#@+node:ekr.20070324084040.18:doPythonClass & helpers
def doPythonClass (self,i,parent):
    
    c = self.c ; s = self.s
    
    if not self.preamble_seen:
        self.doPreamble(i)
    
    class_indent = self.getLeadingIndent(s,i)
    i,className,headline = self.getClassHeadline(i)
    if self.className:
        oldClassName = self.className
        self.className = className
        i = g.skip_line(s,i) # Skip the class line.
        i,prefix,body = self.createClassNodeText(s,i,start)
        class_vnode = self.createHeadline(parent,prefix + body,headline)
        start,i = self.scanPythonClass(i,class_indent,class_vnode)
        s2 = s[start:i]
        if s2: c.appendStringToBody(class_vnode,s2)
        self.className = oldClassName

    return i
#@nonl
#@+node:ekr.20070324084040.19:getClassHeadline
# Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    class_name = s[j:i]
    headline = "class " + class_name
else:
    headline = ''
    class_name = ''
#@-node:ekr.20070324084040.19:getClassHeadline
#@+node:ekr.20070324084040.20:createParentText
def createParentText (self,class_vnode,class_name):

    '''Insert the proper body text in the class_vnode.'''
    
    c = self.c
    
    # This must be done after the declaration reference is generated.
    if self.treeType == "@file":
        c.appendStringToBody(class_vnode,"\t@others\n")
    else:
        ref = g.angleBrackets(' class %s methods ' % (class_name))
        c.appendStringToBody(class_vnode,"\t" + ref + "\n\n")
#@-node:ekr.20070324084040.20:createParentText
#@+node:ekr.20070324084040.21:createClassNodeText
def createClassNodeText (self,s,i,start):
    
    # Create the section name using the old value of self.methodName.
    if  self.treeType == "@file":
        prefix = ""
    else:
        prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
        self.methodsSeen = True
    
    # i points just after the class line.
    
    # Add a docstring to the class node.
    docStringSeen = False
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j != len(s): # No scanning error.
            i = j ; docStringSeen = True
    
    body = s[start:i]
    body = self.undentBody(body)
    if docStringSeen: body = body + '\n'
    
    return i,prefix,body
#@-node:ekr.20070324084040.21:createClassNodeText
#@-node:ekr.20070324084040.18:doPythonClass & helpers
#@+node:ekr.20070324084040.22:doPythonDef
def doPythonDef (self,i,parent):
    
    if not self.preamble_seen:
        self.doPreamble(i)
    
    i = self.scanPythonDef(i,parent)
   
    return i
#@nonl
#@-node:ekr.20070324084040.22:doPythonDef
#@+node:ekr.20070324084040.23:doPreamble
def doPreamble (self,i):
    
    self.preamble_seen = True
    
    if i > 0:
        # Append the preamble to the root's body text.
        c.appendStringToBody(self.root,s[:i])

    if self.treeType == '@file':
        c.appendStringToBody(self.root,'@others\n')
#@-node:ekr.20070324084040.23:doPreamble
#@+node:ekr.20070324084040.24:scanPythonClass
def scanPythonClassHelper(self,s,i,class_indent,class_name,class_vnode):
    
    indent =  self.getLeadingIndent(s,i)
    start = i = g.skip_blank_lines(s,i)
    parent_vnode = None
    while i < len(s):
        progress = i
        # New in Leo 4.4.1: ignore comment lines, whatever their indentation.
        if indent <= class_indent:
            j = g.skip_ws(s,i)
            if g.match(s,j,'#'):
                i = g.skip_to_end_of_line(s,j)
            else: break
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            j = g.skip_nl(s,i)
            if not backslashNewline:
                indent = self.getLeadingIndent(s,j)
                if indent > class_indent: i = j
                else: break
            else: i = j
        elif g.match_c_word(s,i,"def"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonDef(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif g.match_c_word(s,i,"class"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonClass(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
        elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
        else: i += 1
        assert(progress < i)
    return start,i
#@-node:ekr.20070324084040.24:scanPythonClass
#@+node:ekr.20070324084040.25:scanPythonDef & helpers
def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    << set headline or return i >>
    i = self.skipPythonDef(s,i,start)
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    << Create def node >>
    self.methodName = savedMethodName
    return i
#@+node:ekr.20070324084040.26:createDefNode
# Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)
#@-node:ekr.20070324084040.26:createDefNode
#@+node:ekr.20070324084040.27:getDefHeadline
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i
#@-node:ekr.20070324084040.27:getDefHeadline
#@-node:ekr.20070324084040.25:scanPythonDef & helpers
#@+node:ekr.20070324084040.28:skipPythonDef
def skipPythonDef (self,s,i,start):
    
    # g.trace(g.get_line(s,i))

    # Set defIndent to the indentation of the def line.
    defIndent = self.getLeadingIndent(s,start)
    parenCount = 0
    << skip the entire signature >>
    indent = self.getLeadingIndent(s,i)
    while i < len(s): # and indent > defIndent
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            if not backslashNewline:
                # New in Leo 4.4.1: don't set indent for comment lines.
                j = g.skip_ws(s,i)
                if not g.match(s,j,'#'):
                    indent = self.getLeadingIndent(s,i)
                    if indent <= defIndent and parenCount == 0:
                        break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)
        
    return i
#@+node:ekr.20070324084040.29:<< skip the entire signature >>
# Now that we count parens, we must be careful to skip the entire signature.

j = s.find('(',i)
if j != -1:
    j = g.skip_matching_python_parens(s,j)

if j == -1 or not g.match(s,j+1,':'):
    g.es_print('Warning: improper signature: %s' % g.get_line(s,i))
    return i
else:
    i = g.skip_line(s,j) # Still not quite 100% correct.
#@-node:ekr.20070324084040.29:<< skip the entire signature >>
#@-node:ekr.20070324084040.28:skipPythonDef
#@-node:ekr.20070324084040.13:class pythonScanner (not ready yet)
#@-node:ekr.20070324084040:Prototype of @auto
#@+node:ekr.20051202094427:Resolve cvs conflicts
Investigate meld:  http://meld.sourceforge.net/
#@nonl
#@+node:ekr.20060601073503:Postings
@nocolor
#@nonl
#@+node:ekr.20031218072017.658:Stepen Schaefer 1
@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
#@-node:ekr.20031218072017.658:Stepen Schaefer 1
#@+node:ekr.20050501111900:Stephen Schaefer 2
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3125092
By: thyrsus

About a month ago, I posted a screed on how @thin was inadequate to address
my needs; that what I needed to collaborate on via version control was exactly
the essence of Leo's value: the multiple expressions of structure, which by
their nature must exist outside of @thin.  I said I was going to live the pain
to discover a modus vivendi.

Having done that, let me now say:

AAAAAAAAAAAAGGGGGGGGHHHHHHHHHH!

But the exercise has led me to a vision, which I will implement to the extent
my nonexistent spare time and paltry programming talents permit.

The essence of the pain is "conflicts", which become more  certain to occur
as the leo file encompases ever more related files.  As I work on a change to
the Linux configuration, my colleague works on a change to the Solaris configuration,
and one of us checks in our version of the leo file documenting the site
configuration first, and the other cannot check in his version of that file.
The conflict must be resolved by the human.  Using the "diff" tool on the .leo
XML is not an answer (though thank Heaven and Ed for gnxs).  The resolution
needs two levels of support: outline and node.

With the .leo file declared binary, in the event of a conflict CVS leaves you
with the most recent CVS version and your rejected version, and you're responsible
for performing a reconciliation and then resubmitting that.  Leo will recognize
the problem, and present both versions of the project, side by side, splitting
the outline pane.  The parallel trees will scroll/expand/contract in unison.
Outline branches present in CVS and not yours will display as blank space in
your version; nodes present in your version and not CVS will display as blank
space in the CVS version. The CVS version will be read only, your version editable.
The same node with differences in its text or in its children will be highlighted.
You will be able to drag nodes from the CVS version into your version. If the
text of a selected node has conflicts, the text area will split in two, showing
the CVS version and your version, with differences highlighted, both sides of
the pane scrolling in unison, the CVS side read-only, and you can copy from
that side to your side.  I intend to take as many ideas as I can from tkdiff
(http://sourceforge.net/projects/tkdiff/ - see also
http://freshmeat.net/screenshots/10602/ ).  (I have begun translating tkdiff
from from tcl to python - nearly 9000 lines and I'm still learning both languages,
so draw your own timeline.)  You edit your nodes, you edit your tree, you hit
the "reconcile" button, and your reconciliation of the conflict goes into CVS.
If, meanwhile, another one of your over-achieving colleages has again updated
CVS, the process repeats with the most current CVS version.  Or you can hit
the "abandon" button to give up on your changes.

As the Hebrews say at Passover: "Next year in Jerusalem."
#@nonl
#@-node:ekr.20050501111900:Stephen Schaefer 2
#@+node:ekr.20031218072017.659:Jonathon 1
@nocolor

http://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

In the .leo, if I edit <<bar>>, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@verbatim
#@+leo
#@verbatim
#@+node:0::@file foo.py
#@verbatim
#@+body
#@verbatim
#@+others
#@verbatim
#@+node:1::definition of a
#@verbatim
#@+body
print "a:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"bar"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:1::definition of a
#@verbatim
#@+node:2::definition of b
#@verbatim
#@+body
print "b:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation b"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:2::definition of b
#@verbatim
#@+node:3::definition of c
#@verbatim
#@+body
print "c:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation c"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:3::definition of c
#@verbatim
#@-others
#@verbatim
#@-body
#@verbatim
#@-node:0::@file foo.py
#@verbatim
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
#@-node:ekr.20031218072017.659:Jonathon 1
#@+node:ekr.20031218072017.660:Jonathan 2
@nocolor

By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

<<<<<<< 
blah blah blah? 
======= 
blah blah blah! 
>>>>>>> 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  
#@-node:ekr.20031218072017.660:Jonathan 2
#@+node:ekr.20031218072017.661:Gil 1
http://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
#@-node:ekr.20031218072017.661:Gil 1
#@+node:ekr.20031218072017.662:Gil 2
http://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?
#@nonl
#@-node:ekr.20031218072017.662:Gil 2
#@-node:ekr.20060601073503:Postings
#@-node:ekr.20051202094427:Resolve cvs conflicts
#@+node:ekr.20040919182750.1:Better handling of whitespace (cvs fiendly)
http://sourceforge.net/forum/message.php?msg_id=3578166
#@nonl
#@+node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
#@+node:ekr.20060808103849:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2674828
By: bwmulder

If I understand correctly, there are two different problems:

- Trailing whitespaces
- Left indented comments

1. Before commenting on these, a question:

If I write something like
    a=b
    if a:
        @others

[four spaces indentation]

I sometimes see tab characters before the lines inserted for '@others'.

It seems that Leo remembers 'two levels of indentation', and then
fabricates this indentation using tab characters.

I think it might be more robust if Leo remembered the actual
characters in front of @others and would use them for indentation.

I suspect that many indentation errors I had with Leo could have been
avoided had not Leo had its own ideas on how to do indentation.

Maybe Leo could use the exact sequence of characters in front of
@others for all inserted lines?

2. I do not care much about trailing whitespaces. Most of the time
they are invisible, but sometimes they are very misleading (trailing in python or C).

As far as I am concerned, Leo need never produce trailing whitespaces.

Maybe we need special machinery if sources have trailing whitespaces
and the sources are not under our control. 

Not sure if everybody would be happy if we essentially ban all trailing
whitespaces.

3. Unindented commentlines could be dealt with by using indentation to
indicate structure.

Of course, this might break the correspondance Leo structure / Python
structure, which is very ugly.

4. One possible alternative might be a new directive which indicates outindent:

@outindent <number>.

This would apply to the next comment block.

To me, 4. looks a little bit less ugly than 3.

5. As indicated in a different post, I suspect that Leo has a problem
if almost every node in an outline is changed. Profiling should point
to the culprit.

> 2. Have Leo strip whitespace from otherwise blank lines, and hope
that that solves all problems in Perfect Import. This is solving the
problem in the atFile code. The problem is that if we apply settings
in general we will get massive changes to derived files. In most
programming settings these changes might be welcome, but the problem
is actually making these changes. My first few attempts met with
abject failure.

Are you saying that you could not remove trailing blanks? What kind of
problems did you run into?

Summary:
- Use actual characters in front of @others or <<>> for indentation.
- Don't write trailing whitespaces
- Introduce directive for left-indendet comments.
- Profile to find out what slows Leo down if many nodes change.
#@nonl
#@-node:ekr.20060808103849:Report
#@+node:ekr.20041005105605.210:putIndent
def putIndent(self,n):
    
    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w > 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
#@-node:ekr.20041005105605.210:putIndent
#@-node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
#@+node:EKR.20040603092958.1:Add new options for handling newlines in body text
@nocolor

- "asis":
- "zero": no trailing newlines.
- "one": exactly one trailing newline.

Special case code is required so empty nodes stay empty with "one" option.
#@nonl
#@-node:EKR.20040603092958.1:Add new options for handling newlines in body text
#@-node:ekr.20040919182750.1:Better handling of whitespace (cvs fiendly)
#@-node:ekr.20070325052041:To do: 4.4.4 (@auto)
#@+node:ekr.20070105135713:To do: 4.5 (new positions)
#@+node:ekr.20061028070132:New positions
# None of this code is part of Leo's core yet: it is all highly experimental.

# Important: the new vnode class implies that the read code must be rewritten to be similar to the opml read code.
#@nonl
#@+node:ekr.20070512131018:Thoughts about positions 1
http://sourceforge.net/forum/message.php?msg_id=4308503

@nocolor

After more thought I am ready to back off my earlier post. Positions are perfectly reasonable things to support. Indeed, they can be, and probably should be, coequal with iterators. 
 
My 'revulsion' to positions stems from their present implementation--the 'optimization' of positions to avoid adding items to p.stack is certainly the worst optimization presently in Leo. It dates from the days when I was obsessing about reducing the amount of positions created. That was a valid concern then, but Leo now does an excellent job of not generating excess positions. Thus, there is no reason not to have p.stack contain all the parent vnodes at the present spot in a traversal. 
 
The idea of representing a position by a count in a traversal is cute, but of no practical importance. Indeed, why should Leo be forced to stupidly step through an entire traversal when a list of vnodes in p.stack would get to the proper spot in exponentially shorter time. Moreover, a list of vnodes in p.stack is great information to have, while a count N is almost exactly useless :-) 
 
Still, it is good to emphasize that *any* position, no matter how it is represented, makes sense *only* for a particular outline, that is, for a particular set of vnodes. In short, positions will stay, but will be reimplemented for the graph world. 
#@nonl
#@-node:ekr.20070512131018:Thoughts about positions 1
#@+node:ekr.20070512130855:Thoughts about positions 2
@nocolor

There will be some significant changes to the position and vnode classes for the graph world (Leo 4.5).  These changes will be common to both the graph and clone worlds:

Only vnode methods will be allowed to alter outline/graph data.  This would have been a good rule to following earlier, but up until now Leo has allowed 'confused' scripts--script that treat positions like vnodes.  This confusion will not be allowed in Leo 4.5.  The need for strict separation between vnodes and positions has become apparent in the recent chapters work.

It would be best to think of a position as a *path* to a particular vnode.  In the present (clone) world, the path is used exclusively by the tree drawing logic.  That logic tests whether the node being drawn matches (has the same position) as c.currentPosition.  In the graph world it probably makes sense to speak only of the current *vnode*, say v, so a position p is *a* current position if p.v == v.

The (renewed) focus on vnodes will be necessary.  For example, there will be no such things as p.back() or v._back in the graph world.  That is, a vnode v will have no *intrinsic* siblings.  Instead, siblings are relative to a parent: the order of vnodes in the parent.children links implicitly define sibling relationships, but a vnode v may have many 'parents', i.e. there may be many nodes that point to v.  We could speak of 'siblings with respect to a particular parent', but I suspect that will not be a particularly useful concept.  Rather, it will probably be more natural simply to define node relationships using iterators.  We shall see...
#@-node:ekr.20070512130855:Thoughts about positions 2
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.use_new_positions = False
    
    # New positions require the sax-based read code.
    self.use_sax = self.use_new_positions or c.config.getBool('use_sax_based_read')
    
    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5
    if self.use_sax:
        self.currentVnode = None
        self.rootVnode = None
    else:
        self.fileBuffer = None
        self.fileIndex = 0
        self.currentVnodeStack = [] # A stack of vnodes giving the current position.
        self.topVnodeStack     = [] # A stack of vnodes giving the top position.
        self.topPosition = None
    # For writing
    self.read_only = False
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@nonl
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061029093342.75:linkParentAndChildren (changed)
def linkParentAndChildren (self, parent_v, children):
    
    # if children: g.trace(parent_v,len(children))
    
    if self.use_new_positions:
        parent_v.t.links = children
    else:
        firstChild_v = children and children[0] or None
        parent_v.t._firstChild = firstChild_v
        for child in children:
            child._parent = parent_v
            
    v = parent_v
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
#@nonl
#@-node:ekr.20061029093342.75:linkParentAndChildren (changed)
#@+node:ekr.20061029093342.76:linkSiblings (changed)
def linkSiblings (self, sibs):
    
    '''Set the v._back and v._next links for all vnodes v in sibs.'''
    
    if self.use_new_positions:
        pass
    else:
        n = len(sibs)
        for i in xrange(n):
            v = sibs[i]
            v._back = (i-1 >= 0 and sibs[i-1]) or None
            v._next = (i+1 <  n and sibs[i+1]) or None
#@nonl
#@-node:ekr.20061029093342.76:linkSiblings (changed)
#@-node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.5:v.__cmp__ (not used)
if 0: # not used
    def __cmp__(self,other):
        
        g.trace(self,other)
        return not (self is other) # Must return 0, 1 or -1
#@-node:ekr.20061028211424.5:v.__cmp__ (not used)
#@+node:ekr.20061028211424.6:v.__init__
def __init__ (self,t):

    assert(t)
    
    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.unknownAttributes or any mutable vnode object changes.

    self.t = t # The tnode.
    self.statusBits = 0 # status bits
    
    # Structure links.
    #### self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20061028211424.6:v.__init__
#@+node:ekr.20061028211424.7:v.__repr__ & v.__str__
def __repr__ (self):
    
    if self.t:
        return "<vnode %d:'%s'>" % (id(self),self.cleanHeadString())
    else:
        return "<vnode %d:NULL tnode>" % (id(self))
        
__str__ = __repr__
#@-node:ekr.20061028211424.7:v.__repr__ & v.__str__
#@+node:ekr.20061028211424.8:v.dump (to be deleted)
def dumpLink (self,link):
    return g.choose(link,link,"<none>")

def dump (self,label=""):
    
    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)
    
    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v
#@-node:ekr.20061028211424.8:v.dump (to be deleted)
#@+node:ekr.20061028211424.9:v.__hash__ (only for zodb)
if use_zodb and ZODB:
    def __hash__(self):
        return self.t.__hash__()
#@nonl
#@-node:ekr.20061028211424.9:v.__hash__ (only for zodb)
#@-node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
def findAtFileName (self,names):
    
    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()
    
    if not g.match(h,0,'@'):
        return ""
    
    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
#@-node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
#@+node:ekr.20061028211424.12:anyAtFileNodeName
def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)
#@-node:ekr.20061028211424.12:anyAtFileNodeName
#@+node:ekr.20061028211424.13:at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)
    
def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)
    
def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)
    
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@-node:ekr.20061028211424.13:at...FileNodeName
#@+node:ekr.20061028211424.14:isAtAllNode
def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag
#@-node:ekr.20061028211424.14:isAtAllNode
#@+node:ekr.20061028211424.15:isAnyAtFileNode good
def isAnyAtFileNode (self):
    
    """Return True if v is any kind of @file or related node."""
    
    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
#@-node:ekr.20061028211424.15:isAnyAtFileNode good
#@+node:ekr.20061028211424.16:isAt...FileNode (vnode)
def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)
    
def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)
    
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@-node:ekr.20061028211424.16:isAt...FileNode (vnode)
#@+node:ekr.20061028211424.17:isAtIgnoreNode
def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag
#@-node:ekr.20061028211424.17:isAtIgnoreNode
#@+node:ekr.20061028211424.18:isAtOthersNode
def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag
#@-node:ekr.20061028211424.18:isAtOthersNode
#@+node:ekr.20061028211424.19:matchHeadline
def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""
    
    v = self
    
    h = g.toUnicode(v.headString(),'utf-8')
    h = h.lower().replace(' ','').replace('\t','')

    pattern = g.toUnicode(pattern,'utf-8')
    pattern = pattern.lower().replace(' ','').replace('\t','')
    
    return h.startswith(pattern)
#@-node:ekr.20061028211424.19:matchHeadline
#@-node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.22:v.back
# Compatibility routine for scripts

def back (self):

    return self._back
#@-node:ekr.20061028211424.22:v.back
#@+node:ekr.20061028211424.23:v.next
# Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next
#@-node:ekr.20061028211424.23:v.next
#@-node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.25:v.childIndex
def childIndex(self):
    
    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n
#@-node:ekr.20061028211424.25:v.childIndex
#@+node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
def firstChild (self):
    
    return self.t._firstChild
#@-node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
#@+node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
def hasChildren (self):
    
    v = self
    return v.firstChild()

hasFirstChild = hasChildren
#@-node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
#@+node:ekr.20061028211424.28:v.lastChild
def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child
#@-node:ekr.20061028211424.28:v.lastChild
#@+node:ekr.20061028211424.29:v.nthChild
# childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n > 0 and child:
        n -= 1
        child = child.next()
    return child
#@-node:ekr.20061028211424.29:v.nthChild
#@+node:ekr.20061028211424.30:v.numberOfChildren (n)
def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n += 1
        child = child.next()
    return n
#@-node:ekr.20061028211424.30:v.numberOfChildren (n)
#@-node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.32:v.isCloned (4.2)
def isCloned (self):
    
    return len(self.t.vnodeList) > 1
#@-node:ekr.20061028211424.32:v.isCloned (4.2)
#@+node:ekr.20061028211424.33:isDirty
def isDirty (self):

    return self.t.isDirty()
#@-node:ekr.20061028211424.33:isDirty
#@+node:ekr.20061028211424.34:isExpanded
def isExpanded (self):

    return ( self.statusBits & self.expandedBit ) != 0
#@-node:ekr.20061028211424.34:isExpanded
#@+node:ekr.20061028211424.35:isMarked
def isMarked (self):

    return ( self.statusBits & vnode.markedBit ) != 0
#@-node:ekr.20061028211424.35:isMarked
#@+node:ekr.20061028211424.36:isOrphan
def isOrphan (self):

    return ( self.statusBits & vnode.orphanBit ) != 0
#@-node:ekr.20061028211424.36:isOrphan
#@+node:ekr.20061028211424.37:isSelected
def isSelected (self):

    return ( self.statusBits & vnode.selectedBit ) != 0
#@-node:ekr.20061028211424.37:isSelected
#@+node:ekr.20061028211424.38:isTopBitSet
def isTopBitSet (self):

    return ( self.statusBits & self.topBit ) != 0
#@-node:ekr.20061028211424.38:isTopBitSet
#@+node:ekr.20061028211424.39:isVisited
def isVisited (self):

    return ( self.statusBits & vnode.visitedBit ) != 0
#@-node:ekr.20061028211424.39:isVisited
#@+node:ekr.20061028211424.40:status
def status (self):

    return self.statusBits
#@-node:ekr.20061028211424.40:status
#@-node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.41:v.bodyString
# Compatibility routine for scripts

def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.bodyString):
        s = "v.bodyString: Leo internal error: not unicode:" + repr(self.t.bodyString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
#@-node:ekr.20061028211424.41:v.bodyString
#@+node:ekr.20061028211424.42:v.headString & v.cleanHeadString
def headString (self):
    
    """Return the headline string."""
    
    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.headString):
        s = "Leo internal error: not unicode:" + repr(self.t.headString)
        g.es_print(s,color="red")
        
    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):
    
    s = self.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
#@-node:ekr.20061028211424.42:v.headString & v.cleanHeadString
#@+node:ekr.20061028211424.43:v.directParents (new method in 4.2)
def directParents (self):
    
    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.
    
    This is NOT the same as the list of ancestors of the vnode."""
    
    v = self
    
    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []
#@-node:ekr.20061028211424.43:v.directParents (new method in 4.2)
#@-node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
# These remain in 4.2: the file read logic calls these before creating positions.
#@+node:ekr.20061028211424.45:v.detach
def detach (self):
    
    '''Return a standalone copy of a vnode,
    detached from all other nodes and with a new tnode.'''
    
    v = self
    
    # Create a completely separate tnode.
    t2 = tnode(
        bodyString=v.bodyString(),
        headString=v.headString())
    
    return vnode(t2)
#@nonl
#@-node:ekr.20061028211424.45:v.detach
#@+node:ekr.20061028211424.46:v.insertAfter
def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAfter(self)

    return v
#@-node:ekr.20061028211424.46:v.insertAfter
#@+node:ekr.20061028211424.47:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAsNthChild(self,n)

    return v
#@-node:ekr.20061028211424.47:v.insertAsNthChild
#@+node:ekr.20061028211424.48:v.linkAfter
def linkAfter (self,v):

    """Link self after v."""
    
    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
#@-node:ekr.20061028211424.48:v.linkAfter
#@+node:ekr.20061028211424.49:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v
#@-node:ekr.20061028211424.49:v.linkAsNthChild
#@+node:ekr.20061028211424.50:v.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link a vnode as the root node and set the root _position_."""

    v = self

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v
#@nonl
#@-node:ekr.20061028211424.50:v.linkAsRoot
#@+node:ekr.20061028211424.51:v.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a vnode to the root position.
    
    Important: oldRoot must the previous root vnode if it exists.'''

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)
    
    return v
#@nonl
#@-node:ekr.20061028211424.51:v.moveToRoot
#@+node:ekr.20061028211424.52:v.unlink
def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []
#@nonl
#@-node:ekr.20061028211424.52:v.unlink
#@-node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
#@+node:ekr.20061028211424.53:Setters (no change)
#@+node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.55:clearClonedBit
def clearClonedBit (self):

    self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.55:clearClonedBit
#@+node:ekr.20061028211424.56:v.clearDirty (no change needed)
def clearDirty (self):

    v = self
    v.t.clearDirty()
#@nonl
#@-node:ekr.20061028211424.56:v.clearDirty (no change needed)
#@+node:ekr.20061028211424.57:v.clearMarked
def clearMarked (self):

    self.statusBits &= ~ self.markedBit
#@-node:ekr.20061028211424.57:v.clearMarked
#@+node:ekr.20061028211424.58:clearOrphan
def clearOrphan (self):

    self.statusBits &= ~ self.orphanBit
#@-node:ekr.20061028211424.58:clearOrphan
#@+node:ekr.20061028211424.59:clearVisited
def clearVisited (self):

    self.statusBits &= ~ self.visitedBit
#@-node:ekr.20061028211424.59:clearVisited
#@+node:ekr.20061028211424.60:contract & expand & initExpandedBit
def contract(self):

    self.statusBits &= ~ self.expandedBit
    
    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit
    
    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit
#@-node:ekr.20061028211424.60:contract & expand & initExpandedBit
#@+node:ekr.20061028211424.61:initStatus
def initStatus (self, status):

    self.statusBits = status
#@-node:ekr.20061028211424.61:initStatus
#@+node:ekr.20061028211424.62:setClonedBit & initClonedBit
def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.62:setClonedBit & initClonedBit
#@+node:ekr.20061028211424.63:v.setMarked & initMarkedBit
def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
#@-node:ekr.20061028211424.63:v.setMarked & initMarkedBit
#@+node:ekr.20061028211424.64:setOrphan
def setOrphan (self):

    self.statusBits |= self.orphanBit
#@-node:ekr.20061028211424.64:setOrphan
#@+node:ekr.20061028211424.65:setSelected (vnode)
# This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit
#@-node:ekr.20061028211424.65:setSelected (vnode)
#@+node:ekr.20061028211424.66:t.setVisited
# Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit
#@-node:ekr.20061028211424.66:t.setVisited
#@-node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.67:v.computeIcon & setIcon
def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val
    
def setIcon (self):

    pass # Compatibility routine for old scripts
#@-node:ekr.20061028211424.67:v.computeIcon & setIcon
#@+node:ekr.20061028211424.68:v.initHeadString
def initHeadString (self,s,encoding="utf-8"):
    
    v = self
    s = g.toUnicode(s,encoding,reportErrors=True)
    v.t.headString = s
    
    # g.trace(g.callers(5))
#@-node:ekr.20061028211424.68:v.initHeadString
#@+node:ekr.20061028211424.69:v.setSelection
def setSelection (self, start, length):

    self.t.setSelection ( start, length )
#@-node:ekr.20061028211424.69:v.setSelection
#@+node:ekr.20061028211424.70:v.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):
    
    return self.t.setTnodeText(s,encoding)
#@-node:ekr.20061028211424.70:v.setTnodeText
#@-node:ekr.20061028211424.53:Setters (no change)
#@-node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.1:position class
#@+node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.2:p.__cmp__ (changed)
def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self
    
    # g.trace(p1.headString(),p2 and p2.headString())

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal
    elif p1.v == p2.v and p2._childIndex == p2._childIndex and p1.stack == p2.stack:
        return 0 # equal
    else:
        return 1 # not equal

    # # Check entire stack quickly.
    # # The stack contains vnodes, so this is not a recursive call.
    # if p1.v != p2.v or p1.stack != p2.stack:
        # return 1 # notEqual
    # # This is slow: do this last!
    # if p1.childIndex() != p2.childIndex():
        # # Disambiguate clones having the same parents.
        # return 1 # notEqual
    # return 0 # equal
#@nonl
#@-node:ekr.20061028070057.2:p.__cmp__ (changed)
#@+node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                print "unknown position attribute:",attr
                import traceback ; traceback.print_stack()
            raise AttributeError,attr
#@nonl
#@-node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20061028070057.4:p.__init__
def __init__ (self,v,childIndex=0,stack=None):

    '''Create a new position.'''

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    self._childIndex = childIndex
    
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []
    
    g.app.positions += 1
    
    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20061028070057.4:p.__init__
#@+node:ekr.20061028070057.5:p.__nonzero__
@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

def __nonzero__ ( self):
    
    """Return True if a position is valid."""
    
    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None
#@-node:ekr.20061028070057.5:p.__nonzero__
#@+node:ekr.20061028070057.6:p.__str__ and p.__repr__
def __str__ (self):
    
    p = self
    
    if p.v:
        return "<pos %d lvl: %d [%d] %s>" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d        [%d] None>" % (id(p),len(p.stack))
        
__repr__ = __str__
#@-node:ekr.20061028070057.6:p.__str__ and p.__repr__
#@+node:ekr.20061028070057.7:p.archivedPosition
def archivedPosition (self):
    
    '''Return a representation of a position suitable for use in .leo files.'''
    
    p = self
    aList = [p2.v.childIndex() for p2 in p.self_and_parents_iter()]
    aList.reverse()
    return aList
#@nonl
#@-node:ekr.20061028070057.7:p.archivedPosition
#@+node:ekr.20061028070057.8:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""

    return position(self.v,self.stack)
#@-node:ekr.20061028070057.8:p.copy
#@+node:ekr.20061028070057.9:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):
    
    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label
        
def vnodeListIds (self):
    
    p = self
    return [id(v) for v in p.v.t.vnodeList]
#@-node:ekr.20061028070057.9:p.dump & p.vnodeListIds
#@+node:ekr.20061028070057.10:p.equal & isEqual (changed)
def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None.
    """

    p1 = self

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1._childIndex == p2._childIndex and
        p1.stack == p2.stack
    )
        
isEqual = equal
#@-node:ekr.20061028070057.10:p.equal & isEqual (changed)
#@+node:ekr.20061028070057.11:p.key
def key (self):
    
    p = self

    return '%s:%d.%s' % (
        id(p.v),
        p._childIndex,
        ','.join([str(id(v)) for v in p.stack])
    )
#@-node:ekr.20061028070057.11:p.key
#@-node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.12:p.moveToX (many changes)
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
#@+node:ekr.20061028070057.13:p.moveToBack (new)
def moveToBack (self):
    
    '''Move position p to its previous sibling.'''
    
    p = self
    if p.stack and p._childIndex > 0:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex -= 1
            p.v = links[p._childIndex]
        else:
            g.trace('Can not happen: no links')
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # p.v = p.v and p.v._back
    # return p
#@nonl
#@-node:ekr.20061028070057.13:p.moveToBack (new)
#@+node:ekr.20061028070057.14:p.moveToFirstChild (new)
def moveToFirstChild (self):

    '''Move a position to it's first child's position.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = 0
            p.v = links[0]
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # child = p.v.t._firstChild
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.14:p.moveToFirstChild (new)
#@+node:ekr.20061028070057.15:p.moveToLastChild (new)
def moveToLastChild (self):
    
    '''Move a position to it's last child's position.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = len(links)-1
            p.v = links[p._childIndex]
    else:
        p.v = None
    return p
    
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # child = p.v.lastChild()
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.15:p.moveToLastChild (new)
#@+node:ekr.20061028070057.16:p.moveToLastNode (no change)
def moveToLastNode (self):
    
    """Move a position to last node of its tree.
    
    N.B. Returns p if p has no children."""
    
    p = self
    while p.hasChildren():
        p.moveToLastChild()
    return p
#@-node:ekr.20061028070057.16:p.moveToLastNode (no change)
#@+node:ekr.20061028070057.17:p.moveToNext (new)
def moveToNext (self):

    '''Move position p to its next sibling.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if p._childIndex + 1 < len(links):
            p._childIndex += 1
            p.v = links[p._childIndex]
        else:
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # p.v = p.v and p.v._next
    # return p
#@-node:ekr.20061028070057.17:p.moveToNext (new)
#@+node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
def moveToNodeAfterTree (self):
    
    """Move a position to the node after the position's tree."""
    
    p = self
    
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
#@+node:ekr.20061028070057.19:p.moveToNthChild (new)
def moveToNthChild (self,n):
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links and n < len(links)
            p.v = links[n]
            p.childIndex = n
        else:
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # if p:
        # child = p.v.nthChild(n) # Must call vnode method here!
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.19:p.moveToNthChild (new)
#@+node:ekr.20061028070057.20:p.moveToParent (new)
def moveToParent (self):
    
    '''Move a position to its parent position.'''
    
    if p.stack:
        p.v,p._childIndex = p.stack.pop()
    else:
        p.v = None
    return p
    
    # p = self
    # if not p: return p
    # if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        # p.v = p.v._parent
    # elif p.stack:
        # p.v = p.stack.pop()
    # else:
        # p.v = None
    # return p
#@nonl
#@-node:ekr.20061028070057.20:p.moveToParent (new)
#@+node:ekr.20061028070057.21:p.moveToThreadBack (no change)
def moveToThreadBack (self):
    
    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.21:p.moveToThreadBack (no change)
#@+node:ekr.20061028070057.22:p.moveToThreadNext (little change)
def moveToThreadNext (self):
    '''Move a position to the next a position in threading order.'''
    p = self
    if p.hasChildren():
        p.moveToFirstChild()
    elif p.hasNext()
        p.moveToNext()
    else:
        p.moveToParent()
        while p:
            if p.hasNext():
                p.moveToNext()
                break #found
            p.moveToParent()
        # not found.
    return p

# def moveToThreadNext (self):
    # """Move a position to the next a position in threading order."""
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # p.moveToFirstChild()
        # elif p.v._next:
            # p.moveToNext()
        # else:
            # p.moveToParent()
            # while p:
                # if p.v._next:
                    # p.moveToNext()
                    # break #found
                # p.moveToParent()
            # # not found. 
    # return p
#@nonl
#@-node:ekr.20061028070057.22:p.moveToThreadNext (little change)
#@+node:ekr.20061028070057.23:p.moveToVisBack (no change)
def moveToVisBack (self):
    
    """Move a position to the position of the previous visible node."""

    p = self
    
    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p
#@-node:ekr.20061028070057.23:p.moveToVisBack (no change)
#@+node:ekr.20061028070057.24:p.moveToVisNext (no change)
def moveToVisNext (self):
    
    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()
            
    return p
#@-node:ekr.20061028070057.24:p.moveToVisNext (no change)
#@-node:ekr.20061028070057.12:p.moveToX (many changes)
#@+node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.27:p.Comparisons (no change)
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)
#@-node:ekr.20061028070057.27:p.Comparisons (no change)
#@+node:ekr.20061028070057.28:p.Headline & body strings (no change)
def bodyString (self):
    
    return self.v.bodyString()

def headString (self):
    
    return self.v.headString()
    
def cleanHeadString (self):
    
    return self.v.cleanHeadString()
#@-node:ekr.20061028070057.28:p.Headline & body strings (no change)
#@+node:ekr.20061028070057.29:p.Status bits (no change)
def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
#@-node:ekr.20061028070057.29:p.Status bits (no change)
#@+node:ekr.20061028070057.30:p.directParents (new, faster)
def directParents (self):
    
    p = self
    return p and p.stack or []

    # return self.v.directParents()
#@-node:ekr.20061028070057.30:p.directParents (new, faster)
#@+node:ekr.20061028070057.31:p.childIndex (new, much faster)
# This is time-critical code!

def childIndex(self):
    
    return p and p._childIndex or 0

    # p = self ; v = p.v
    # if not v or not v._back:
        # return 0
    # n = 0 ; v = v._back
    # while v:
        # n += 1
        # v = v._back
    # return n
#@nonl
#@-node:ekr.20061028070057.31:p.childIndex (new, much faster)
#@-node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.33:p.hasChildren (new)
def hasChildren(self):
    
    p = self
    
    if p.v and p.v.t:
        return len(p.v.t.links) > 0
    else:
        return False

    # return p.v and p.v.t and p.v.t._firstChild
#@-node:ekr.20061028070057.33:p.hasChildren (new)
#@+node:ekr.20061028070057.34:p.numberOfChildren (new)
def numberOfChildren (self):
    
    if p.v:
        return len(p.v.t.links)
    else:
        return 0
    
    # return self.v.numberOfChildren()
#@-node:ekr.20061028070057.34:p.numberOfChildren (new)
#@-node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@-node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
#@+node:ekr.20061028070057.36:p.hasX (new)
def hasBack(self):
    return self._childIndex > 0
    # return self.v and self.v._back

hasFirstChild = hasChildren
    
def hasNext(self):
    p = self
    if p.stack:
        parent_v,junk = self.stack[-1]
        links = parent_v.t.links
        return p._childIndex + 1 < len(parent.v.t.links)
    else:
        return False
    # return self.v and self.v._next
    
def hasParent(self):
    return len(self.stack) > 1 # The first item of each stack is the dummy parent.
    # return self.v and self.v._parent is not None
    
def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
    
hasVisBack = hasThreadBack
#@-node:ekr.20061028070057.36:p.hasX (new)
#@+node:ekr.20061028070057.37:hasThreadNext (big change)
def hasThreadNext(self):
    
    p = self ; v = p.v
    if not p.v: return False

    if p.hasChildren() or p.hasNext():
        return True
    else:
        # Simulate this code without copying p.
        # p2 = p.copy()
        # p2.moveToParent()
        # while p2:
            # if p2.hasNext():
                # return True
            # p2.moveToParent()
        # return False
        if not p.stack: return False
        n = len(p.stack)-1
        v,childIndex = p.stack[n]
        n -= 1
        while n >= 0:
            # v2,childIndex2 represent v's parent.
            v2,childIndex2 = parent.stack[n]
            links = v2.t.links
            if childIndex + 1 < len(links):
                return True
            # v.moveToParent
            v,childIndex = v2,childIndex2
            n -= 1
        return False

    # p = self ; v = p.v
    # if not p.v: return False
    # if v.t._firstChild or v._next:
        # return True
    # else:
        # n = len(p.stack)-1
        # v,n = p.vParentWithStack(v,p.stack,n)
        # while v:
            # if v._next:
                # return True
            # v,n = p.vParentWithStack(v,p.stack,n)
        # return False

hasVisNext = hasThreadNext
#@nonl
#@-node:ekr.20061028070057.37:hasThreadNext (big change)
#@+node:ekr.20061028070057.38:p.findRootPosition (unchanged)
def findRootPosition (self):
    
    p = self.copy()
    while p.hasParent():
        p.moveToParent()
    while p.hasBack():
        p.moveToBack()
    return p
#@nonl
#@-node:ekr.20061028070057.38:p.findRootPosition (unchanged)
#@+node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
def isAncestorOf (self, p2):
    
    p = self
    if not p.stack:
        return False
    elif p2 is None or not p2.stack:
        return False
    else:
        for v,junk in p2.stack:
            if v == p.v:
                return True
        else:
            return False
    
    # p = self
    # # Avoid calling p.copy() or copying the stack.
    # v2 = p2.v ; n = len(p2.stack)-1
        # # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # while v2:
        # if v2 == p.v:
            # return True
        # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # return False
#@nonl
#@-node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
#@+node:ekr.20061028070057.40:p.isCloned (unchanged)
def isCloned (self):
    
    return len(self.v.t.vnodeList) > 1
#@-node:ekr.20061028070057.40:p.isCloned (unchanged)
#@+node:ekr.20061028070057.41:p.isRoot (unchanged)
def isRoot (self):
    
    p = self

    return not p.hasParent() and not p.hasBack()
#@-node:ekr.20061028070057.41:p.isRoot (unchanged)
#@+node:ekr.20061028070057.42:p.isVisible (new)
def isVisible (self):
    
    """Return True if all of a position's parents are expanded."""
    
    p = self
    for v in p.stack:
        if not v.isExpanded():
            return False
    return True

    # p = self
    # v = p.v ; n = len(p.stack)-1
    # v,n = p.vParentWithStack(v,p.stack,n)
    # while v:
        # if not v.isExpanded():
            # return False
        # v,n = p.vParentWithStack(v,p.stack,n)
    # return True
#@nonl
#@-node:ekr.20061028070057.42:p.isVisible (new)
#@+node:ekr.20061028070057.43:p.level & simpleLevel (new)
def level(self):
    return len(self.stack)
    
simpleLevel = level

# def simpleLevel(self):
    # 
    # return len([p for p in self.parents_iter()])

# def level(self,verbose=False):
    # 
    # p = self ; level = 0
    # if not p: return level
        # 
    # # Avoid calling p.copy() or copying the stack.
    # v = p.v ; n = len(p.stack)-1
    # while 1:
        # assert(p)
        # v,n = p.vParentWithStack(v,p.stack,n)
        # if v:
            # level += 1
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        # else:
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # # if g.app.debug: assert(level==self.simpleLevel())
            # break
    # return level
#@-node:ekr.20061028070057.43:p.level & simpleLevel (new)
#@-node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n >= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
#@+node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)
#@-node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
#@-node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
#@+node:ekr.20061028070057.47:p.restoreLinksInTree
def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""
    
    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    for p in root.children_iter():
        p.restoreLinksInTree()
#@-node:ekr.20061028070057.47:p.restoreLinksInTree
#@+node:ekr.20061028070057.48:p.deleteLinksInTree & allies
def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()

    # for p in root.children_iter():
        # p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@+node:ekr.20061028070057.49:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20061028070057.49:p.deleteLinksInSubtree
#@+node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
#@-node:ekr.20061028070057.48:p.deleteLinksInTree & allies
#@-node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@+node:ekr.20061028070057.52:p.linkAfter
def linkAfter (self,after):

    """Link self after position 'after'."""
    
    p = self
    if not after.stack:
        g.trace('Can not happen: no dummy root.',after)
        return
    
    p.stack = after.stack[:]
    p._childIndex = after._childIndex + 1 #### New
    parent_v,junk = p.stack[-1] #### New
    links = parent_v.t.links #### New
    links.insert(p._childIndex,p.v) #### New
        
    #### p.v._parent = after.v._parent
    
    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.
    
    #### p.v._back = after.v
    #### p.v._next = after.v._next
    #### after.v._next = p.v
    #### if p.v._next:
        #### p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")
#@-node:ekr.20061028070057.52:p.linkAfter
#@+node:ekr.20061028070057.53:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of parent position 'parent'."""
    
    # g.trace(self,parent,n,parent.v)

    p = self
    links = parent.v.t.links
    if n <= len(links):
        links.insert(n,p.v)
    else:
        g.trace('Can not happen: n too large.',n,p)
        return
        
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # # Recreate the stack using the parent.
    # p.stack = parent.stack[:]
    # if parent.isCloned():
        # p.stack.append(parent.v)
    # p.v._parent = parent.v
    # # Add v to it's tnode's vnodeList.
    # if p.v not in p.v.t.vnodeList:
        # p.v.t.vnodeList.append(p.v)
        # p.v.t._p_changed = 1 # Support for tnode class.
    # if n == 0:
        # child1 = parent.v.t._firstChild
        # p.v._back = None
        # p.v._next = child1
        # if child1:
            # child1._back = p.v
        # parent.v.t._firstChild = p.v
    # else:
        # prev = parent.nthChild(n-1) # zero based
        # assert(prev)
        # p.v._back = prev.v
        # p.v._next = prev.v._next
        # prev.v._next = p.v
        # if p.v._next:
            # p.v._next._back = p.v
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.53:p.linkAsNthChild
#@+node:ekr.20061028070057.54:p.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    root_v,junk = p.stack[0]
    links = root_v.t.links
    p.stack = [root_v] # Clear the stack, except for the dummy root.
    links = [p.v]
    if oldRoot:
        links.append(oldRoot.v)
    
    # p.stack = [] # Clear the stack.
    # # Clear all links except the child link.
    # v._parent = None
    # v._back = None
    # v._next = oldRootVnode
    
    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    # if oldRoot:
        # oldRoot.v._back = v
    # p.dump(label="root")
#@nonl
#@-node:ekr.20061028070057.54:p.linkAsRoot
#@+node:ekr.20061028070057.55:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v.t.links does NOT change."""

    p = self ; v = p.v
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)
    
    if p.stack:
        parent,junk = p.stack[-1]
        links = parent.t.links
        if v in links:
            links.remove(v)
        else:
            g.trace("Can not happen: not its father's child.",p)
    else:
        g.trace('Can not happen: missing root.',p)
    
    # Reset the firstChild link in its direct father.
    # if p.v._parent:
        # if 0: # This can fail.  I have no idea why it was present.
            # assert(p.v and p.v._parent in p.v.directParents())
        # if p.v._parent.t._firstChild == v:
            # #g.trace('resetting _parent.v.t._firstChild to',v._next)
            # p.v._parent.t._firstChild = v._next
    # else:
        # parent = p.parent()
        # if parent:
            # if 0: # This can fail.  I have no idea why it was present.
                # assert(parent.v in p.v.directParents())
            # if parent.v.t._firstChild == v:
                # #g.trace('resetting parent().v.t._firstChild to',v._next)
                # parent.v.t._firstChild = v._next
    # # Do NOT delete the links in any child nodes.
    # # Clear the links in other nodes.
    # if v._back: v._back._next = v._next
    # if v._next: v._next._back = v._back
    # # Unlink _this_ node.
    # v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.55:p.unlink
#@-node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
#@-node:ekr.20061028211424.1:position class
#@-node:ekr.20061028070132:New positions
#@+node:ekr.20070105135851.1:Most important
#@+node:ekr.20061206060454:Improve import code
@nocolor

- Make the later munging unnecessary.
	- Don't generate @file or the full file names.
	- Don't add @ignore
	- Put @language python and @tabwidth -4 only in the root node.
- Put the docstring at the top.
- Make sure only imports go in the << imports >> section.
#@-node:ekr.20061206060454:Improve import code
#@+node:ekr.20061127170002.1:Allow multiple lines on the button bar
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3993176
By: rich_ries

How can the button bar be enlarged to take a second (or third!) row of icons? Or maybe the Scripting buttons can have
their own section, like the NodeBar plugin did/does?

add-new-icon-row command?
#@nonl
#@-node:ekr.20061127170002.1:Allow multiple lines on the button bar
#@-node:ekr.20070105135851.1:Most important
#@+node:ekr.20061028065955.4:New features
#@+node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061014050154.2:Binding to None clears all bindings
#@-node:ekr.20061014050154.2:Binding to None clears all bindings
#@+node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@-node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@+node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:new
def new (self,event=None):
    
    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)
    
    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):
    
    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
            
    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):
    
    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):
    
    '''Save a Leo outline to a file.'''

    c = self ; trace = False
    cc = c.config.getBool('use_chapters') and c.chapterController
    
    oldChapter = cc and cc.forceMainChapter()
    
    if trace and cc:
        g.trace('cc',cc)
        g.printEntireTree(c,'save:before')
        cc.printChaptersTree('save:before')

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
    
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""
        
    c.beginUpdate()
    try:
        if c.mFileName != "":
            # Calls c.setChanged(False) if no error.
            c.fileCommands.save(c.mFileName)
        else:
            fileName = g.app.gui.runSaveFileDialog(
                initialfile = c.mFileName,
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
            c.bringToFront()
    
            if fileName:
                # Don't change mFileName until the dialog has suceeded.
                c.mFileName = g.ensure_extension(fileName, ".leo")
                c.frame.title = c.mFileName
                c.frame.setTitle(g.computeWindowTitle(c.mFileName))
                c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
                c.fileCommands.save(c.mFileName)
                c.updateRecentFiles(c.mFileName)
                
        if cc:
            cc.restoreOldChapter(oldChapter)
    finally:
        c.endUpdate()
        
    if trace and cc:
        g.printEntireTree(c,'save:after')
        cc.printChaptersTree('save:after')
#@nonl
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):
    
    '''Save a Leo outline to a file with a new filename.'''
    
    c = self ; cc = c.config.getBool('use_chapters') and c.chapterController
    oldChapter = cc and cc.forceMainChapter()
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
        
    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""
    
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save As",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()
    
        if fileName:
            # 7/2/02: don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            # Calls c.setChanged(False) if no error.
            c.fileCommands.saveAs(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            
        if cc:
            cc.restoreOldChapter(oldChapter)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
def saveAsUnzipped (self,event=None):
    
    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)
    
def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)
    
def saveAsZippedHelper (self,isZipped):
    
    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
#@-node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):
    
    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''
    
    c = self ; cc = c.config.getBool('use_chapters') and c.chapterController
    oldChapter = cc and cc.forceMainChapter()
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
        
    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""
    
        # set local fileName, _not_ c.mFileName
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save To",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()
    
        if fileName:
            fileName = g.ensure_extension(fileName, ".leo")
            c.fileCommands.saveTo(fileName)
            c.updateRecentFiles(fileName)
            
        if cc:
            cc.restoreOldChapter(oldChapter)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):
    
    '''Revert the contents of a Leo outline to last saved contents.'''
    
    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return
        
    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@-node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@-node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@+node:ekr.20061024093525:Create settings menu
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3977681

How about having a menu Edit -> Settings with the submenu-items 'LeoSettings.leo',
'myLeoSettings.leo', 'this file's settings'?

The menu-items 'Open myLeoSettings.leo' and 'Open LeoSettings.leo' under the
Help-menu seem out-of-place.

#@-node:ekr.20061024093525:Create settings menu
#@+node:ekr.20061116054917.6:Remove blanks in calltips
#@-node:ekr.20061116054917.6:Remove blanks in calltips
#@+node:ekr.20061108100143:Create '*open-&test.leo' command that t.bat or test.leo
# This doesn't seem to work well on XP.
#@nonl
#@+node:ekr.20061209131102.1:openTest
def openTest (self, event=None):
    
    if 1: # Open in a new process.
        cmd = 'c:\Windows\System32\cmd.exe' # Hangs if used.
        python = sys.executable
        leo = g.os_path_abspath(g.os_path_join(g.app.loadDir,'leo.py'))
        test = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test'))
        
        os.system('%s %s %s %s' % (cmd, python,leo,test))
        # args = [python, leo, test]
        
        # if 1: # Use present environment.
            # os.spawnv(os.P_NOWAIT, sys.executable, args)
        # else: # Use a pristine environment.
            # os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
    else:
        c = self
        fileName = g.os_path_join(g.app.loadDir,'..','test','test.leo')
    
        ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es('not found: %s' % fileName)
#@-node:ekr.20061209131102.1:openTest
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):
    
    self.helpMenuTable = [
        # &: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&About Leo...',           'about-leo'),
        ('Online &Home Page',       'open-online-home'),
        '*open-online-&tutorial',
        '*open-&users-guide',
        '-',
        ('Open Leo&Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&Settings.leo',   'open-leoSettings-leo'),
        ('Open &myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&ipts.leo',       'open-scripts-leo'),
        # ('Open t&est.leo',          'open-test-leo'),
        '-',
        '*he&lp-for-minibuffer',
        '*help-for-&command',
        '-',
        '*&apropos-autocompletion',
        '*apropos-&bindings',
        '*apropos-&debugging-commands',
        '*apropos-&find-commands',
        '-',
        '*pri&nt-bindings',
        '*print-c&ommands',
    ]
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20061108100143:Create '*open-&test.leo' command that t.bat or test.leo
#@-node:ekr.20061028065955.4:New features
#@-node:ekr.20070105135713:To do: 4.5 (new positions)
#@+node:ekr.20060822174843:Most important projects
# Most of these projects will take a week or more.
#@nonl
#@+node:ekr.20070220082124:Make sure Leo can generate Latex
#@-node:ekr.20070220082124:Make sure Leo can generate Latex
#@+node:ekr.20070226075816.1:Update plugin manager to handle @enabled-plugins nodes
#@-node:ekr.20070226075816.1:Update plugin manager to handle @enabled-plugins nodes
#@+node:ekr.20070307082503:Make Leo an IPython notebook
#@+node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060603085719.1:Use IPython autocompleter?
#@-node:ekr.20060603085719.1:Use IPython autocompleter?
#@+node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@-node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@+node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@-node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@+node:ekr.20060603090445.9:Script button that saves environment between runs
This would allow IPython-like operation.
#@nonl
#@-node:ekr.20060603090445.9:Script button that saves environment between runs
#@-node:ekr.20060603090445.7:Ipython stuff
#@-node:ekr.20070307082503:Make Leo an IPython notebook
#@+node:ekr.20060629154112:Merge Leo & jyLeo
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3799470
By: leouser

I guess its hard to say what pieces must merge and what can stay different.
Id like it if the blasted nodes were the same.  I guess there is progress again
on a jython 2.2 being complete and work starting on 2.3.  So there is hope that
the nodes will be the same code, at least it will be possible.

At the top of my head the big differences outside of the position changes are:
1. Some modifications to the read/write code so that Chapters can work and also
Serialized positions.
2. Commander has some things different, it looks to the Chapters instance to
determine what is the curentPosition, top Position etc... instead of keeping
track of it itself.
3. GUI layers are very different.  Interesting tidbit here: the work I did to
get the JTree to use positions to determine if a node is expanded or not looks
like it has provided the outline for enhancing the JTree for Java itself to
be able to do this.  We will have to see, but maybe in Java 7 you can say: "Positions
lead to user controled tree expansion models".

There is a tremendous amount that is the same. Im sure you could make an interesting
evening out of comparing the codebases to see where things change.


#@+node:ekr.20070307082814:Create g.startupController class
#@-node:ekr.20070307082814:Create g.startupController class
#@-node:ekr.20060629154112:Merge Leo & jyLeo
#@+node:ekr.20060202231708.1:@menu nodes in leoSettings.leo
@nocolor

We could allow users to define Leo menus.
To do this, we must use minibuffer names for all menu entries

@color
#@nonl
#@-node:ekr.20060202231708.1:@menu nodes in leoSettings.leo
#@+node:ekr.20061207073104:Convert bottlenecks to pyrex code
# To do:  actually generate Leo's bottlenecks.
#@nonl
#@+node:ekr.20061207073104.1:gcc build docs
@nocolor

To build your module using GCC is a three step process on Unix. (I have know
idea how many steps it is on Windows™.)

Start by running the Pyrex compiler over your code as follows, where
mymodule.pyx is the name of the Pyrex module you are writing. python2.2 pyrexc
mymodule.pyx Next, compile the resulting C file into a .o file. The call to gcc
looks like this:

gcc -c -fPIC -I/usr/include/python2.2/ mymodule.c
The arguments to gcc are explained below.

-c 
Produces a .o file instead of an executable. 
-fPIC 
Produces position independent code, so we can dynamically link against it later. 
-I/usr/include/python2.2/ 
is the location of the Python 2.2 include file. The location of your Python include file may differ from /usr/include/python2.2/. 
mymodule.c 
is the name of the C file produced by Pyrex. 
Finally, link the .o into a .so: gcc -shared mymodule.o -lxosd -o mymodule.so
-shared 
produces a shared-object file, instead of an executable. 
mymodule.o 
is the name of the module you wish to compile. 
-lxosd 
links against a C-library, with the name of the library given as the argument. 
-o mymodule.so 
causes gcc to put the output into a file called mymodule.so 
The C library that you are wrapping will probably differ from mymodule. 
#@-node:ekr.20061207073104.1:gcc build docs
#@+node:ekr.20061207073104.2:pyrexc command-line options
@nocolor

The pyrexc command supports the following options:

  Short Long              Argument    Description
  -----------------------------------------------------------------------------
  -v    --version                     Display version number of pyrex compiler
  -l    --create-listing              Write error messages to a .lis file
  -I    --include-dir     <directory> Search for include files in named 
                                       directory (may be repeated)
  -o    --output-file     <filename>  Specify name of generated C file (only
                                       one source file allowed if this is used)

Anything else is taken as the name of a Pyrex source file and compiled
to a C source file. Multiple Pyrex source files can be specified
(unless -o is used), in which case each source file is treated as the
source of a distinct extension module and compiled separately to
produce its own C file.
#@-node:ekr.20061207073104.2:pyrexc command-line options
#@+node:ekr.20061207073104.3:@file myModule.pyx
def spam(int i, char *s):
    if 1:
        print i,s
#@nonl
#@-node:ekr.20061207073104.3:@file myModule.pyx
#@+node:ekr.20061207073104.4:Make myModule.c
# Use pyrexc to create myModule.c from myModule.pyx.
import os,sys
python = sys.executable
theFile = r'C:\prog\tigris-cvs\leo\test\myModule.pyx'
pyrexc = r'c:\prog\Pyrex-0.9.4.1\pyrexc.py'
os.system(r'%s %s %s' % (python,pyrexc,theFile))

if 0: # Build myModule library using distutils.
    from distutils.core import setup, Extension

    # Make the extension module ("mymodule") link against xosd
    xosdExtn = Extension("mymodule", ["mymodule.c"], libraries=["xosd"])
    
    # Compile the extension module
    setup(name="mymodule", ext_modules=[xosdExtn])
    
@ Save the above code in a file called setup.py and run the following code
to build and install your module.
    
    python setup.py build
    python setup.py install
#@nonl
#@-node:ekr.20061207073104.4:Make myModule.c
#@+node:ekr.20061207073104.5:Code to be optimized w/ pyrex
#@+node:ekr.20061207073104.6:Nodes...
#@-node:ekr.20061207073104.6:Nodes...
#@+node:ekr.20061207073104.216:Colorizer
#@-node:ekr.20061207073104.216:Colorizer
#@+node:ekr.20061207073104.268:File code
#@-node:ekr.20061207073104.268:File code
#@-node:ekr.20061207073104.5:Code to be optimized w/ pyrex
#@-node:ekr.20061207073104:Convert bottlenecks to pyrex code
#@+node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
@nocolor

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off.

@color
#@nonl
#@-node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
#@-node:ekr.20060530085844:Improve autocompletion
#@-node:ekr.20060822174843:Most important projects
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
