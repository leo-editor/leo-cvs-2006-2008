#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20051202094427:Urgent: Resolve cvs conflicts
Investigate meld:  http://meld.sourceforge.net/
#@nonl
#@+node:ekr.20060601073503:Postings
@nocolor
#@nonl
#@+node:ekr.20031218072017.658:Stepen Schaefer 1
@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
#@-node:ekr.20031218072017.658:Stepen Schaefer 1
#@+node:ekr.20050501111900:Stephen Schaefer 2
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3125092
By: thyrsus

About a month ago, I posted a screed on how @thin was inadequate to address
my needs; that what I needed to collaborate on via version control was exactly
the essence of Leo's value: the multiple expressions of structure, which by
their nature must exist outside of @thin.  I said I was going to live the pain
to discover a modus vivendi.

Having done that, let me now say:

AAAAAAAAAAAAGGGGGGGGHHHHHHHHHH!

But the exercise has led me to a vision, which I will implement to the extent
my nonexistent spare time and paltry programming talents permit.

The essence of the pain is "conflicts", which become more  certain to occur
as the leo file encompases ever more related files.  As I work on a change to
the Linux configuration, my colleague works on a change to the Solaris configuration,
and one of us checks in our version of the leo file documenting the site
configuration first, and the other cannot check in his version of that file.
The conflict must be resolved by the human.  Using the "diff" tool on the .leo
XML is not an answer (though thank Heaven and Ed for gnxs).  The resolution
needs two levels of support: outline and node.

With the .leo file declared binary, in the event of a conflict CVS leaves you
with the most recent CVS version and your rejected version, and you're responsible
for performing a reconciliation and then resubmitting that.  Leo will recognize
the problem, and present both versions of the project, side by side, splitting
the outline pane.  The parallel trees will scroll/expand/contract in unison.
Outline branches present in CVS and not yours will display as blank space in
your version; nodes present in your version and not CVS will display as blank
space in the CVS version. The CVS version will be read only, your version editable.
The same node with differences in its text or in its children will be highlighted.
You will be able to drag nodes from the CVS version into your version. If the
text of a selected node has conflicts, the text area will split in two, showing
the CVS version and your version, with differences highlighted, both sides of
the pane scrolling in unison, the CVS side read-only, and you can copy from
that side to your side.  I intend to take as many ideas as I can from tkdiff
(http://sourceforge.net/projects/tkdiff/ - see also
http://freshmeat.net/screenshots/10602/ ).  (I have begun translating tkdiff
from from tcl to python - nearly 9000 lines and I'm still learning both languages,
so draw your own timeline.)  You edit your nodes, you edit your tree, you hit
the "reconcile" button, and your reconciliation of the conflict goes into CVS.
If, meanwhile, another one of your over-achieving colleages has again updated
CVS, the process repeats with the most current CVS version.  Or you can hit
the "abandon" button to give up on your changes.

As the Hebrews say at Passover: "Next year in Jerusalem."
#@nonl
#@-node:ekr.20050501111900:Stephen Schaefer 2
#@+node:ekr.20031218072017.659:Jonathon 1
@nocolor

http://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

In the .leo, if I edit <<bar>>, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@verbatim
#@+leo
#@verbatim
#@+node:0::@file foo.py
#@verbatim
#@+body
#@verbatim
#@+others
#@verbatim
#@+node:1::definition of a
#@verbatim
#@+body
print "a:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"bar"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:1::definition of a
#@verbatim
#@+node:2::definition of b
#@verbatim
#@+body
print "b:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation b"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:2::definition of b
#@verbatim
#@+node:3::definition of c
#@verbatim
#@+body
print "c:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation c"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:3::definition of c
#@verbatim
#@-others
#@verbatim
#@-body
#@verbatim
#@-node:0::@file foo.py
#@verbatim
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
#@-node:ekr.20031218072017.659:Jonathon 1
#@+node:ekr.20031218072017.660:Jonathan 2
@nocolor

By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

<<<<<<< 
blah blah blah? 
======= 
blah blah blah! 
>>>>>>> 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  
#@-node:ekr.20031218072017.660:Jonathan 2
#@+node:ekr.20031218072017.661:Gil 1
http://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
#@-node:ekr.20031218072017.661:Gil 1
#@+node:ekr.20031218072017.662:Gil 2
http://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?
#@nonl
#@-node:ekr.20031218072017.662:Gil 2
#@-node:ekr.20060601073503:Postings
#@-node:ekr.20051202094427:Urgent: Resolve cvs conflicts
#@+node:ekr.20060531161030:To do: 4.4.1 beta 2 (1 week)
#@+node:ekr.20060602155519:calltips are broken for help(
#@-node:ekr.20060602155519:calltips are broken for help(
#@+node:ekr.20060602100638:backspace in file completion sometimes doesn't work well
#@-node:ekr.20060602100638:backspace in file completion sometimes doesn't work well
#@+node:ekr.20060602152600:silent modes and set/clear-silent-mode commands
#@-node:ekr.20060602152600:silent modes and set/clear-silent-mode commands
#@+node:ekr.20060211093935:Support for on-enter-mode in mode declarations
@nocolor

To do:
    
- keys are not handled properly in modes.

Oooops: For vim-like operation the focus must never go to the minibuffer!

Modes don't make sense the way they are being implemented: modes should not
affect the minibuffer at all: instead, they are simply temporary bindings.
    
@color
#@nonl
#@+node:ekr.20041117062717.2:ctor (configClass)
def __init__ (self):
    
    self.configsExist = False # True when we successfully open a setting file.
    self.defaultFont = None # Set in gui.getDefaultConfigFont.
    self.defaultFontFamily = None # Set in gui.getDefaultConfigFont.
    self.globalConfigFile = None # Set in initSettingsFiles
    self.homeFile = None # Set in initSettingsFiles
    self.inited = False
    self.modeCommandsDict = {} # For use by @mode logic. Keys are command names, values are g.Bunches.
    self.recentFilesFiles = [] # List of g.Bunches describing .leoRecentFiles.txt files.
    
    # Inited later...
    self.panes = None
    self.sc = None
    self.tree = None

    self.initDicts()
    self.initIvarsFromSettings()
    self.initSettingsFiles()
    self.initRecentFiles()
#@nonl
#@-node:ekr.20041117062717.2:ctor (configClass)
#@+node:ekr.20060531180657:Creating the mode
#@+node:ekr.20041119205148:parseHeadline
def parseHeadline (self,s):
    
    """Parse a headline of the form @kind:name=val
    Return (kind,name,val)."""

    kind = name = val = None

    if g.match(s,0,'@'):
        i = g.skip_id(s,1,chars='-')
        kind = s[1:i].strip()
        if kind:
            # name is everything up to '='
            j = s.find('=',i)
            if j == -1:
                name = s[i:].strip()
            else:
                name = s[i:j].strip()
                # val is everything after the '='
                val = s[j+1:].strip()

    # g.trace("%50s %10s %s" %(name,kind,val))
    return kind,name,val
#@nonl
#@-node:ekr.20041119205148:parseHeadline
#@+node:ekr.20060102103625.1:doMode
def doMode(self,p,kind,name,val):
    
    '''Parse an @mode node and create the enter-<name>-mode command.'''
    
    c = self.c ; k = c.k

    # Compute the mode name.
    name = name.strip().lower()
    j = name.find(' ')
    if j > -1: name = name[:j]
    if name.endswith('mode'):
        name = name[:-4].strip()
    if name.endswith('-'):
        name = name[:-1]
    name = name + '-mode'
    # g.trace('name',name)
    
    # Check for duplicate mode names.
    if g.app.config.modeCommandsDict.get(name):
        g.trace('Ignoring duplicate @mode setting: %s' % name)
        return
    
    # Call doShortcuts with a temp dict.
    d = self.shortcutsDict
    self.shortcutsDict = {}
    self.doShortcuts(p,kind,name,val)
    
    # Remember the mode dict.
    d2 = self.shortcutsDict
    
    # Restore the global dict.
    self.shortcutsDict = d
    
    # Change the pane of all entries to 'mode-name'.
    # This will disable warnings about duplicate bindings.
    for key in d2.keys():
        if key != '*entry-commands*':
            bunchList = d2.get(key,[])
            for bunch in bunchList:
                bunch.pane = name
                bunch.val = k.strokeFromSetting(bunch.val)
                # g.trace(name,bunch.val)
    
    # Create the command, but not any bindings to it.
    self.createModeCommand(name,d2)
#@nonl
#@-node:ekr.20060102103625.1:doMode
#@+node:ekr.20060102103625:createModeCommand
def createModeCommand (self,name,modeDict):

    commandName = 'enter-' + name
    commandName = commandName.replace(' ','-')
    # g.trace(name,commandName)
        
    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict
    
    # g.trace(modeDict.keys())

    if d.get(commandName):
        g.trace('Ignoring duplicate mode: %s' % commandName)
    else:
        d [commandName] = modeDict
#@nonl
#@-node:ekr.20060102103625:createModeCommand
#@+node:ekr.20041120112043:parseShortcutLine (g.app.config)
def parseShortcutLine (self,s):
    
    '''Parse a shortcut line.  Valid forms:
        
    --> entry-command
    settingName = shortcut
    settingName ! paneName = shortcut
    command-name -> mode-name = binding
    command-name -> same = binding
    '''
    
    name = val = nextMode = None ; nextMode = 'none'
    i = g.skip_ws(s,0)
   
    if g.match(s,i,'-->'): # New in 4.4.1 b1: allow mode-entry commands.
        j = g.skip_ws(s,i+3)
        i = g.skip_id(s,j,'-')
        entryCommandName = s[j:i]
        return None,g.Bunch(entryCommandName=entryCommandName)
    
    j = i
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None
    
    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'->'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]
        
    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]
           
    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i > 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(nextMode=nextMode,pane=pane,val=val)
#@nonl
#@-node:ekr.20041120112043:parseShortcutLine (g.app.config)
#@+node:ekr.20041120105609:doShortcuts
def doShortcuts(self,p,kind,name,val,s=None):
    
    __pychecker__ = '--no-argsused' # kind,val.
    
    # g.trace(self.c.fileName(),name)
    
    d = self.shortcutsDict # To detect duplicates.
    if s is None: s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if not name:
                # An entry command: put it in the special *entry-commands* key.
                aList = d.get('*entry-commands*',[])
                aList.append(bunch.entryCommandName)
                d ['*entry-commands*'] = aList
            elif bunch is not None:
                # A regular shortcut.
                # g.trace(name,bunch)
                # New in 4.4a5:
                bunchList = d.get(name,[])
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)
#@nonl
#@-node:ekr.20041120105609:doShortcuts
#@+node:ekr.20060104154937:addModeCommands (enterModeCallback)
def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        # g.trace('leoCommands %24s = %s' % (f.__name__,key))
#@nonl
#@-node:ekr.20060104154937:addModeCommands (enterModeCallback)
#@-node:ekr.20060531180657:Creating the mode
#@+node:ekr.20060531180657.1:Executed code
#@+node:ekr.20060102135349.2:enterNamedMode
def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    # g.trace(modeName)
    
    k.generalModeHandler(event,modeName=modeName)
#@-node:ekr.20060102135349.2:enterNamedMode
#@+node:ekr.20060119150624:createModeBindings
def createModeBindings (self,modeName,d):
    
    k = self ; c = k.c
    
    # Just do this once.
    d2 = k.masterBindingsDict.get(modeName,{})
    if d2: return

    for commandName in d.keys():
        if commandName == '*entry-commands*': continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('No such command: %s. Referenced from %s' % (
                commandName,modeName))
            continue
        bunchList = d.get(commandName,[])
        for bunch in bunchList:
            stroke = bunch.val
            # Important: bunch.val is a stroke returned from k.strokeFromSetting.
            # Do not call k.strokeFromSetting again here!
            if stroke and stroke not in ('None','none',None):
                if 0:
                    g.trace(
                        g.app.gui.widget_name(k.widget), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        bunch.nextMode)
                        
                # New in 4.4.1 b1: create an actual binding.
                def modeKeyCallback(event=None,k=k,stroke=stroke):
                    return k.masterKeyHandler(event,stroke)
            
                k.completeOneBindingForWidget (k.widget,stroke,modeKeyCallback)
               
                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.Bunch(
                    commandName=commandName,
                    func=func,
                    nextMode=bunch.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2
#@nonl
#@-node:ekr.20060119150624:createModeBindings
#@+node:ekr.20060104110233:generalModeHandler
def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = c.config.getBool('trace_modes')
    
    if trace: g.trace(modeName,'state',state)
   
    if state == 0:
        self.initMode(event,modeName)
        k.inputModeName = modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        if c.config.getBool('showHelpWhenEnteringModes'):
            k.modeHelp(event)
        else:
            c.frame.log.hideTab('Mode')
        if k.useTextWidget:
            c.minibufferWantsFocus()
        else:
            c.restoreRequestedFocus()
    elif not func:
        g.trace('No func: improper key binding')
        return 'break'
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            self.endMode(event)
            if c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.widget = k.modeWidget
            else:
                event = g.Bunch(widget = k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                self.reinitMode(modeName) # Re-enter this mode.
                k.setState(modeName,1,handler=k.generalModeHandler)
            else:
                self.initMode(event,nextMode) # Enter another mode.

    return 'break'
#@nonl
#@-node:ekr.20060104110233:generalModeHandler
#@+node:ekr.20060117202916.1:initMode
def initMode (self,event,modeName):

    k = self ; c = k.c

    if not modeName:
        g.trace('oops: no modeName')
        return

    d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    if not d:
        self.badMode(modeName)
        return
    else:
        k.modeBindingsDict = d
        
    k.inputModeName = modeName
    
    k.createModeBindings(modeName,d)

    entryCommands = d.get('*entry-commands*',[])
    if entryCommands:
        # g.trace('entryCommands',entryCommands)
        for commandName in entryCommands:
            g.trace('entry command:',commandName)
            k.simulateCommand(commandName)
   
    k.setLabelBlue(modeName+': ',protect=True)
    k.showStateAndMode()
    if k.useTextWidget:
        c.minibufferWantsFocus()
    else:
        pass # Do *not* change the focus here!
#@nonl
#@-node:ekr.20060117202916.1:initMode
#@+node:ekr.20060104125946:modeHelpHelper
def modeHelpHelper (self,d):
    
    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    keys = d.keys() ; keys.sort()

    data = [] ; n = 20
    for key in keys:
        if key != '*entry-commands*':
            bunchList = d.get(key)
            for bunch in bunchList:
                shortcut = bunch.val
                if shortcut not in (None,'None'):
                    s1 = key ; s2 = k.prettyPrintKey(shortcut)
                    n = max(n,len(s1))
                    data.append((s1,s2),)
                
    data.sort()
    
    # g.es('%s\n\n' % (k.inputModeName),tabName=tabName)
        
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s %s' % (n,s1,s2),tabName=tabName)
#@nonl
#@-node:ekr.20060104125946:modeHelpHelper
#@-node:ekr.20060531180657.1:Executed code
#@-node:ekr.20060211093935:Support for on-enter-mode in mode declarations
#@+node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@-node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@+node:ekr.20060531161030.1:Make body editors persistant
#@-node:ekr.20060531161030.1:Make body editors persistant
#@+node:ekr.20060531144607:Finish the new colorizer
#@-node:ekr.20060531144607:Finish the new colorizer
#@+node:ekr.20060531135634.1:Test and fix *important* Emacs commands
- Macros
- Lossage
- History
- Yank & Kill
- Insert newline (look up proper behavior).

** Put away the mouse and make sure everything works.
#@nonl
#@+node:ekr.20060413065803:Improve searches 4
#@+node:ekr.20060122183544:Improve isearch
@nocolor

- (done) Handle backspace for isearch: keep a stack of previous matches.
- (done) Allow cross-node isearches.

@color
#@nonl
#@+node:ekr.20051023132350:getLabel
def getLabel (self,ignorePrompt=False):
    
    k = self ; w = self.widget
    if not w: return ''
    
    if self.useTextWidget:
        w.update_idletasks()
        s = g.app.gui.getAllText(w)
    else:
        s = k.svar and k.svar.get()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
#@nonl
#@-node:ekr.20051023132350:getLabel
#@+node:ekr.20050920085536.38:updateLabel
def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    
    if ch and ch not in ('\n','\r'):
        if self.useTextWidget:
            c.widgetWantsFocusNow(w)
            i,j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            if ch == '\b':
                s = g.app.gui.getAllText(w)
                if len(s) > len(k.mb_prefix):
                    w.delete(i+'-1c')
            else:
                w.insert('insert',ch)
            # g.trace(k.mb_prefix)       
        else:
            # Just add the character.
            k.setLabel(k.getLabel() + ch)
#@nonl
#@-node:ekr.20050920085536.38:updateLabel
#@+node:ekr.20060127183752:masterKeyHandler & helper
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting

    val = self.masterKeyHandlerHelper(event,stroke,trace)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    if trace: g.trace('done:',repr(val))
    return val
#@nonl
#@+node:ekr.20060205221734:masterKeyHandlerHelper
def masterKeyHandlerHelper (self,event,stroke,trace):
    
    << define vars >>

    if keysym in special_keys:
        return None

    << do key traces >>

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    << handle per-pane bindings >>
#@+node:ekr.20060321105403:<< define vars >>
k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
#@nonl
#@-node:ekr.20060321105403:<< define vars >>
#@+node:ekr.20060321105403.1:<< do key traces >>
self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace('keysym',repr(event.keysym or ''),'stroke',repr(stroke),'state',state)
#@nonl
#@-node:ekr.20060321105403.1:<< do key traces >>
#@+node:ekr.20060321105403.2:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
        elif not k.handleMiniBindings(event,state,stroke):
            if trace: g.trace('calling modeHelp')
            k.modeHelp(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
    return 'break'
#@nonl
#@-node:ekr.20060321105403.2:<< handle mode bindings >>
#@+node:ekr.20060321105403.3:<< handle per-pane bindings >>
for key,name in (
    # Order here is similar to bindtags order.
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        name and w_name.startswith(name) or
        key == 'text' and g.app.gui.isTextWidget(w) or
        key == 'all'
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)

if k.ignore_unbound_non_ascii_keys and len(event.char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
else:
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@nonl
#@-node:ekr.20060321105403.3:<< handle per-pane bindings >>
#@-node:ekr.20060205221734:masterKeyHandlerHelper
#@+node:ekr.20060309065445:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return True
        
    return False
#@nonl
#@-node:ekr.20060309065445:handleMiniBindings
#@-node:ekr.20060127183752:masterKeyHandler & helper
#@+node:ekr.20060104110233:generalModeHandler
def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = c.config.getBool('trace_modes')
    
    if trace: g.trace(modeName,'state',state)
   
    if state == 0:
        self.initMode(event,modeName)
        k.inputModeName = modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        if c.config.getBool('showHelpWhenEnteringModes'):
            k.modeHelp(event)
        else:
            c.frame.log.hideTab('Mode')
        if k.useTextWidget:
            c.minibufferWantsFocus()
        else:
            c.restoreRequestedFocus()
    elif not func:
        g.trace('No func: improper key binding')
        return 'break'
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            self.endMode(event)
            if c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.widget = k.modeWidget
            else:
                event = g.Bunch(widget = k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                self.reinitMode(modeName) # Re-enter this mode.
                k.setState(modeName,1,handler=k.generalModeHandler)
            else:
                self.initMode(event,nextMode) # Enter another mode.

    return 'break'
#@nonl
#@-node:ekr.20060104110233:generalModeHandler
#@+node:ekr.20051023094009:Search classes
#@+node:ekr.20060123125256:class minibufferFind (the findHandler)
class minibufferFind:

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others
#@nonl
#@+node:ekr.20060123125317.2: ctor (minibufferFind)
def __init__(self,c,finder):

    self.c = c
    self.k = k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []
    
    commandName = 'replace-string'
    s = k.getShortcutForCommandName(commandName)
    s = k.prettyPrintKey(s)
    s = k.shortcutFromSetting(s)
    self.replaceStringShortcut = s
#@nonl
#@-node:ekr.20060123125317.2: ctor (minibufferFind)
#@+node:ekr.20060124140114: Options
#@+node:ekr.20060124123133:setFindScope
def setFindScope(self,where):
    
    '''Set the find-scope radio buttons.
    
    `where` must be in ('node-only','entire-outline','suboutline-only'). '''
    
    h = self.finder
    
    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.dict['radio-search-scope'].get()
        if var:
            h.dict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
#@nonl
#@-node:ekr.20060124123133:setFindScope
#@+node:ekr.20060124122844:setOption
def setOption (self, ivar, val):
    
    h = self.finder

    if ivar in h.intKeys:
        if val is not None:
            var = h.dict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
#@nonl
#@-node:ekr.20060124122844:setOption
#@+node:ekr.20060125082510:getOption
def getOption (self,ivar,verbose=False):
    
    h = self.finder
    
    var = h.dict.get(ivar)
    if var:
        val = var.get()
        verbose and g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
#@nonl
#@-node:ekr.20060125082510:getOption
#@+node:ekr.20060125074939:showFindOptions
def showFindOptions (self):
    
    '''Show the present find options in the status line.'''
    
    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')
    
    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )
        
    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
#@nonl
#@-node:ekr.20060125074939:showFindOptions
#@+node:ekr.20060124135401:toggleOption
def toggleOption (self, ivar):
    
    h = self.finder

    if ivar in h.intKeys:
        var = h.dict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
#@nonl
#@-node:ekr.20060124135401:toggleOption
#@+node:ekr.20060205105950:setupChangePattern
def setupChangePattern (self,pattern):
    
    h = self.finder ; t = h.change_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()
#@nonl
#@-node:ekr.20060205105950:setupChangePattern
#@+node:ekr.20060125091234:setupSearchPattern
def setupSearchPattern (self,pattern):
    
    h = self.finder ; t = h.find_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()
#@nonl
#@-node:ekr.20060125091234:setupSearchPattern
#@-node:ekr.20060124140114: Options
#@+node:ekr.20060210180352:addChangeStringToLabel
def addChangeStringToLabel (self,protect=True):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.change_ctrl
    
    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()
    
    s = t.get('1.0','end')

    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
#@-node:ekr.20060210180352:addChangeStringToLabel
#@+node:ekr.20060210164421:addFindStringToLabel
def addFindStringToLabel (self,protect=True):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.find_ctrl
    
    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = t.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
#@-node:ekr.20060210164421:addFindStringToLabel
#@+node:ekr.20060128080201:cloneFindAll
def cloneFindAll (self,event):

    k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
#@nonl
#@-node:ekr.20060128080201:cloneFindAll
#@+node:ekr.20060204120158:findAgain
def findAgain (self,event):

    f = self.finder
    
    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
        
#@nonl
#@-node:ekr.20060204120158:findAgain
#@+node:ekr.20060209064140:findAll
def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
#@nonl
#@-node:ekr.20060209064140:findAll
#@+node:ekr.20060205105950.1:generalChangeHelper
def generalChangeHelper (self,find_pattern,change_pattern):
    
    # g.trace(repr(change_pattern))
    
    c = self.c

    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()
#@nonl
#@-node:ekr.20060205105950.1:generalChangeHelper
#@+node:ekr.20060124181213.4:generalSearchHelper
def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):
    
    c = self.c
    
    self.setupSearchPattern(pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if findAll:
         self.finder.findAllCommand()
    elif cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@nonl
#@-node:ekr.20060124181213.4:generalSearchHelper
#@+node:ekr.20060210174441:lastStateHelper
def lastStateHelper (self):
    
    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
#@nonl
#@-node:ekr.20060210174441:lastStateHelper
#@+node:ekr.20050920084036.113:replaceString
def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
#@-node:ekr.20050920084036.113:replaceString
#@+node:ekr.20060124140224.3:reSearchBackward/Forward
def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.3:reSearchBackward/Forward
#@+node:ekr.20060124140224.1:seachForward/Backward
def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.1:seachForward/Backward
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20060124134356:setupArgs
def setupArgs (self,forward=False,regexp=False,word=False):
    
    h = self.finder ; k = self.k
    
    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)
            
    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
#@nonl
#@-node:ekr.20060124134356:setupArgs
#@+node:ekr.20060210173041:stateZeroHelper
def stateZeroHelper (self,event,tag,prefix,handler,escapes=[]):

    k = self.k
    self.w = event and event.widget
    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)
    
    # g.trace(escapes,g.callers())
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
#@nonl
#@-node:ekr.20060210173041:stateZeroHelper
#@+node:ekr.20060224171851:updateChange/FindList
def updateChangeList (self,s):

    if s not in self.changeTextList:
        self.changeTextList.append(s)
        
def updateFindList (self,s):

    if s not in self.findTextList:
        self.findTextList.append(s)
#@nonl
#@-node:ekr.20060224171851:updateChange/FindList
#@+node:ekr.20060124140224.2:wordSearchBackward/Forward
def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.2:wordSearchBackward/Forward
#@-node:ekr.20060123125256:class minibufferFind (the findHandler)
#@+node:ekr.20051020120306.6:class findTab (leoFind.leoFind)
class findTab (leoFind.leoFind):
    
    '''An adapter class that implements Leo's Find tab.'''

    @others
#@nonl
#@+node:ekr.20051020120306.10:Birth & death
#@+node:ekr.20051020120306.11:__init__
def __init__(self,c,parentFrame):
    
    # g.trace('findTab')

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    self.frame = self.outerFrame = self.top = None
    
    << create the tkinter intVars >>
    
    self.optionsOnly = c.config.getBool('show_only_find_tab_options')
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.
#@nonl
#@+node:ekr.20051020120306.12:<< create the tkinter intVars >>
self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()
#@nonl
#@-node:ekr.20051020120306.12:<< create the tkinter intVars >>
#@-node:ekr.20051020120306.11:__init__
#@+node:ekr.20051023181449:createBindings (findTab)
def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        return k.masterKeyHandler(event)
        
    def findButtonBindingCallback(event=None,self=self):
        self.findButton()
        return 'break'
        
    if 0: # No longer needed.
        def findTabClickCallback(event,self=self):
            c = self.c ; k = c.k ; w = event.widget
            k.keyboardQuit(event)
            w and c.widgetWantsFocusNow(w)
            return k.masterClickHandler(event)

    table = (
        ('<Button-1>',  k.masterClickHandler),
        ('<Double-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClickHandler),
        ('<Double-3>',  k.masterClickHandler),
        ('<Key>',       resetWrapCallback),
        ('<Return>',    findButtonBindingCallback),
        ("<Escape>",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)
#@nonl
#@-node:ekr.20051023181449:createBindings (findTab)
#@+node:ekr.20051020120306.13:createFrame (findTab)
def createFrame (self,parentFrame):
    
    c = self.c
    
    # g.trace('findTab')
    
    << Create the outer frames >>
    << Create the Find and Change panes >>
    << Create two columns of radio and checkboxes >>
    
    if  self.optionsOnly:
        buttons = []
    else:
        << Create two columns of buttons >>
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)
    
    if 0: # These dont work in the new binding scheme.  Use shortcuts or mode bindings instead.
        for w in buttons:
            w.bindHotKey(ftxt)
            w.bindHotKey(ctxt)
#@nonl
#@+node:ekr.20051020120306.14:<< Create the outer frames >>
configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)
#@nonl
#@-node:ekr.20051020120306.14:<< Create the outer frames >>
#@+node:ekr.20051020120306.15:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

if self.optionsOnly:
    # Use one-line boxes.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=1,width=25,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=1,width=25,name='change-text')
else:
    # Use bigger boxes for scripts.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
<< Bind Tab and control-tab >>

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")
        
if self.optionsOnly:
    flab.pack(side="left") ; ftxt.pack(side="left")
    clab.pack(side="left") ; ctxt.pack(side="left")
else:
    flab.pack(side="left") ; ftxt.pack(side="right", expand=1, fill="x")
    clab.pack(side="left") ; ctxt.pack(side="right", expand=1, fill="x")
#@nonl
#@+node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
def setFocus(w):
    c = self.c
    c.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("<Tab>",toChange)
ctxt.bind("<Tab>",toFind)
ftxt.bind("<Control-Tab>",insertFindTab)
ctxt.bind("<Control-Tab>",insertChangeTab)
#@nonl
#@-node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
#@-node:ekr.20051020120306.15:<< Create the Find and Change panes >>
#@+node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = []

checkLists[0] = [
    # ("Scrip&t Change",self.dict["script_change"]),
    ("Whole &Word", self.dict["whole_word"]),
    ("&Ignore Case",self.dict["ignore_case"]),
    ("Wrap &Around",self.dict["wrap"]),
    ("&Reverse",    self.dict["reverse"]),
    ('Rege&xp',     self.dict['pattern_match']),
    ("Mark &Finds", self.dict["mark_finds"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"&Entire Outline","entire-outline"),
    (self.dict["radio-search-scope"],"&Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&Node Only","node-only"),
]

checkLists[1] = [
    ("Search &Headline", self.dict["search_headline"]),
    ("Search &Body",     self.dict["search_body"]),
    ("Mark &Changes",    self.dict["mark_changes"]),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<Button-1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<Button-1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@nonl
#@-node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
#@+node:ekr.20051020120306.18:<< Create two columns of buttons >>
# Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    # ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)
#@nonl
#@-node:ekr.20051020120306.18:<< Create two columns of buttons >>
#@-node:ekr.20051020120306.13:createFrame (findTab)
#@+node:ekr.20051020120306.19:find.init
def init (self,c):
    
    # g.trace('Find Tab')

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20051020120306.20:<< set find/change widgets >>
self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@nonl
#@-node:ekr.20051020120306.20:<< set find/change widgets >>
#@+node:ekr.20051020120306.21:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outline")
#@nonl
#@-node:ekr.20051020120306.21:<< set radio buttons from ivars >>
#@-node:ekr.20051020120306.19:find.init
#@-node:ekr.20051020120306.10:Birth & death
#@+node:ekr.20051020120306.22:find.update_ivars
def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val)
        # g.trace(key,val)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)

    # The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@nonl
#@-node:ekr.20051020120306.22:find.update_ivars
#@+node:ekr.20060221074900:Callbacks
#@+node:ekr.20060221074900.1:findButtonCallback
def findButtonCallback(self,event=None):
    
    self.findButton()
    return 'break'
#@nonl
#@-node:ekr.20060221074900.1:findButtonCallback
#@+node:ekr.20051020120306.25:hideTab
def hideTab (self,event=None):
    
    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20051020120306.25:hideTab
#@-node:ekr.20060221074900:Callbacks
#@+node:ekr.20051024192602: Top level
#@+node:ekr.20060209064832:findAllCommand
def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()
#@nonl
#@-node:ekr.20060209064832:findAllCommand
#@+node:ekr.20060204120158.1:findAgainCommand
def findAgainCommand (self):
    
    s = g.app.gui.getAllText(self.find_ctrl)
    
    if s and s != '<find pattern here>':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
#@nonl
#@-node:ekr.20060204120158.1:findAgainCommand
#@+node:ekr.20060128075225:cloneFindAllCommand
def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
#@-node:ekr.20060128075225:cloneFindAllCommand
#@+node:ekr.20051024192642.2:findNext/PrefCommand
def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
#@nonl
#@-node:ekr.20051024192642.2:findNext/PrefCommand
#@+node:ekr.20051024192642.3:change/ThenFindCommand
def changeCommand (self,event=None):

    self.setup_command()
    self.change()
    
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
    
def changeThenFindCommand(self,event=None):
    
    self.setup_command()
    self.changeThenFind()
#@nonl
#@-node:ekr.20051024192642.3:change/ThenFindCommand
#@-node:ekr.20051024192602: Top level
#@+node:ekr.20051020120306.26:bringToFront
def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    c.widgetWantsFocus(t)
    g.app.gui.selectAllText(t)
    c.widgetWantsFocus(t)
#@nonl
#@-node:ekr.20051020120306.26:bringToFront
#@+node:ekr.20051020120306.27:selectAllFindText
def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # event

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        g.app.gui.setTextSelection(w,"1.0","end")

    return "break"
#@nonl
#@-node:ekr.20051020120306.27:selectAllFindText
#@+node:ekr.20051020120306.28:Tkinter wrappers
def init_s_ctrl (self,s):
    t = self.s_ctrl
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t
#@nonl
#@-node:ekr.20051020120306.28:Tkinter wrappers
#@+node:ekr.20051020120306.1:class underlinedTkButton
class underlinedTkButton:
    
    @others
#@nonl
#@+node:ekr.20051020120306.2:__init__
def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    << set self.hotKey if '&' is in the string >>

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces
#@nonl
#@+node:ekr.20051020120306.3:<< set self.hotKey if '&' is in the string >>
index = text.find('&')

if index > -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]
#@nonl
#@-node:ekr.20051020120306.3:<< set self.hotKey if '&' is in the string >>
#@-node:ekr.20051020120306.2:__init__
#@+node:ekr.20051020120306.4:bindHotKey
def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.buttonCallback)
#@nonl
#@-node:ekr.20051020120306.4:bindHotKey
#@+node:ekr.20051020120306.5:buttonCallback
# The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
#@-node:ekr.20051020120306.5:buttonCallback
#@-node:ekr.20051020120306.1:class underlinedTkButton
#@-node:ekr.20051020120306.6:class findTab (leoFind.leoFind)
#@+node:ekr.20050920084036.257:class searchCommandsClass
class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others
#@nonl
#@+node:ekr.20050920084036.258: ctor
def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    self.minibufferFindHandler = None
    self.stack = [] # A stack of previous matches.
    
    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None
#@nonl
#@-node:ekr.20050920084036.258: ctor
#@+node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
def getPublicCommands (self):
    
    return {
        'clone-find-all':                       self.cloneFindAll,
        'find-tab-find-all':                    self.findAll,
        
        # Thin wrappers on Find tab
        'find-tab-find':                        self.findTabFindNext,
        'find-tab-find-prev':                   self.findTabFindPrev,
        'find-tab-change':                      self.findTabChange,
        'find-tab-change-all':                  self.findTabChangeAll,
        'find-tab-change-then-find':            self.findTabChangeThenFind,
                    
        'hide-find-tab':                        self.hideFindTab,
            
        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
                    
        'open-find-tab':                        self.openFindTab,
    
        'replace-string':                       self.replaceString,
                    
        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.
        
        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,
        
        'show-find-options':                    self.showFindOptions,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,
        
        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
#@nonl
#@-node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
#@+node:ekr.20060123131421:Top-level methods
#@+node:ekr.20051020120306:openFindTab
def openFindTab (self,event=None,show=True):
    
    '''Open the Find tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Find'
    
    wasOpen = log.frameDict.get(tabName)

    if wasOpen:
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
#@nonl
#@-node:ekr.20051020120306:openFindTab
#@+node:ekr.20051022212004:Find Tab commands
# Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):
    '''Execute the 'Change' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()
        
def findTabChangeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeAllCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):
    '''Execute the 'Replace, Find' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()
        
def findTabFindAll(self,event=None):
    '''Execute the 'Find All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    '''Execute the 'Find Next' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    '''Execute the 'Find Previous' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    '''Hide the Find tab.'''
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')
#@nonl
#@-node:ekr.20051022212004:Find Tab commands
#@+node:ekr.20060124115801:getHandler
def getHandler(self,show=False):
    
    '''Return the minibuffer handler, creating it if necessary.'''
    
    c = self.c
    
    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.
    
    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler
#@nonl
#@-node:ekr.20060124115801:getHandler
#@+node:ekr.20060123115459:Find options wrappers
def setFindScopeEveryWhere (self, event):
    '''Set the 'Entire Outline' radio button in the Find tab.'''
    return self.setFindScope('entire-outline')

def setFindScopeNodeOnly  (self, event):
    '''Set the 'Node Only' radio button in the Find tab.'''
    return self.setFindScope('node-only')

def setFindScopeSuboutlineOnly (self, event):
    '''Set the 'Suboutline Only' radio button in the Find tab.'''
    return self.setFindScope('suboutline-only')
    
def showFindOptions (self,event):
    '''Show all Find options in the minibuffer label area.'''
    self.getHandler().showFindOptions()

def toggleIgnoreCaseOption     (self, event):
    '''Toggle the 'Ignore Case' checkbox in the Find tab.'''
    return self.toggleOption('ignore_case')

def toggleMarkChangesOption (self, event):
    '''Toggle the 'Mark Changes' checkbox in the Find tab.'''
    return self.toggleOption('mark_changes')
def toggleMarkFindsOption (self, event):
    '''Toggle the 'Mark Finds' checkbox in the Find tab.'''
    return self.toggleOption('mark_finds')
def toggleRegexOption (self, event):
    '''Toggle the 'Regexp' checkbox in the Find tab.'''
    return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event):
    '''Toggle the 'Reverse' checkbox in the Find tab.'''
    return self.toggleOption('reverse')

def toggleSearchBodyOption (self, event):
    '''Set the 'Search Body' checkbox in the Find tab.'''
    return self.toggleOption('search_body')

def toggleSearchHeadlineOption (self, event):
    '''Toggle the 'Search Headline' checkbox in the Find tab.'''
    return self.toggleOption('search_headline')

def toggleWholeWordOption (self, event):
    '''Toggle the 'Whole Word' checkbox in the Find tab.'''
    return self.toggleOption('whole_word')

def toggleWrapSearchOption (self, event):
    '''Toggle the 'Wrap Around' checkbox in the Find tab.'''
    return self.toggleOption('wrap')
    
def setFindScope (self, where):  self.getHandler().setFindScope(where)
def toggleOption (self, ivar):   self.getHandler().toggleOption(ivar)
#@nonl
#@-node:ekr.20060123115459:Find options wrappers
#@+node:ekr.20060124093828:Find wrappers
def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type <Return> to end the search string. The
    command will then prompt for the replacement string. Typing a second
    <Return> key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Set the 'Regexp' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Set the 'Regexp' checkbox to True, then do search-with-present-options.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Set the 'Word Search' checkbox to False and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Set the 'Word Search' checkbox to False, then do search-with-present-options.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Set the 'Word Search' checkbox to True, then do search-with-present-options.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Set the Word Search' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the <Return> key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)
#@nonl
#@-node:ekr.20060124093828:Find wrappers
#@+node:ekr.20060204120158.2:findAgain
def findAgain (self,event):

    '''The find-again command is the same as the find-tab-find command
    if the search pattern in the Find tab is not '<find pattern here>'
    Otherwise, the find-again is the same as the search-with-present-options command.'''
    
    h = self.getHandler()
    
    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to find-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)
#@nonl
#@-node:ekr.20060204120158.2:findAgain
#@-node:ekr.20060123131421:Top-level methods
#@+node:ekr.20050920084036.261:incremental search...
def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,forward=False,regexp=True)
#@nonl
#@+node:ekr.20050920084036.262:startIncremental
def startIncremental (self,event,forward,regexp):

    c = self.c ; k = self.k ; w = self.w
    
    self.forward = forward
    self.regexp = regexp
    
    old_i = w.index('insert')
    old_p = c.currentPosition()
    self.stack = [g.Bunch(insert=old_i,p=old_p)]

    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()
#@nonl
#@-node:ekr.20050920084036.262:startIncremental
#@+node:ekr.20060420144640:iSearchBackspace
def iSearchBackspace (self):
    
    c = self.c ; k = self.k ; w = self.w
    
    b = self.stack.pop()
    g.trace(b.insert)

    c.selectPosition(b.p)
    w.mark_set('insert',b.insert)
    w.see('insert')
    w.update_idletasks()
    
    if self.stack:
        self.scolorizer(event=None,pattern=b.pattern)
    else:
        self.stack.append(b)
        w.tag_delete('color','color1')
#@nonl
#@-node:ekr.20060420144640:iSearchBackspace
#@+node:ekr.20050920084036.264:iSearchStateHandler
# Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.bodyWantsFocus()
    
    # g.trace('keysym',keysym)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '<Control-s>':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '<Control-r>':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        s = self.searchString
        i = w.index('insert')
        j = w.index('insert +%sc' % len(s))
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
    elif keysym == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif ch:
        k.updateLabel(event)
        self.iSearchHelper(event)
        self.scolorizer(event)
#@nonl
#@-node:ekr.20050920084036.264:iSearchStateHandler
#@+node:ekr.20050920084036.265:scolorizer
def scolorizer (self,event,pattern=None):
    
    '''Colorizer for incremental searches.'''

    k = self.k ; w = self.w
    s = pattern or k.getLabel(ignorePrompt=True)
    # g.trace(repr(s))
    w.tag_delete('color','color1')
    if not s: return
    ind = '1.0'
    index = w.index('insert')
    index2 = w.index('%s+%dc' % (index,len(s)))
    # g.trace(index,index2)
    # Colorize in the forward direction, regardless of the kind of search.
    while ind:
        try:
            ind = w.search(s,ind,stopindex='end',regexp=self.regexp)
        except: break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(s))
            # g.trace(ind)
            if ind in (index,index2):
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
#@nonl
#@-node:ekr.20050920084036.265:scolorizer
#@+node:ekr.20050920084036.263:iSearchHelper
def iSearchHelper (self,event):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    c = self.c ; k = self.k ; w = self.w
    self.searchString = pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    stopindex = g.choose(self.forward,'end','1.0')
    startindex = g.choose(self.forward,'1.0','end')
    p1 = c.currentPosition() ; p = p1.copy() ; old_p = p.copy()
    old_ins = w.index('insert') # This must *not* be changed in the loop.
    w.mark_set('insert',startindex)
    while 1:
        try:
            i = w.search(pattern,old_ins,backwards=not self.forward,stopindex=stopindex,regexp=self.regexp)
            # Don't call endSearch here.  We'll do that when the user hits return.
            g.trace(repr(i))
            if not i.isspace():
                w.mark_set('insert',i)
                # if self.forward:
                    # w.mark_set('insert',i)
                # else:
                    # w.mark_set('insert',i+'-%dc'%(len(pattern)))
                w.see('insert')
                self.stack.append(g.Bunch(insert=old_ins,p=old_p,pattern=pattern[:-1]))
                # g.trace('found',old_ins,i)
                return   
        except: pass # g.es_exception()
        # old_p = p.copy()
        if self.forward: p.moveToThreadNext()
        else:            p.moveToThreadBack()
        if not p: break
        g.trace('searching',p.headString())
        c.selectPosition(p)
        w.mark_set('insert','1.0')
        w.update_idletasks()
        # if not self.forward:
            # w.mark_set('insert','end')
    c.selectPosition(p1)
#@nonl
#@-node:ekr.20050920084036.263:iSearchHelper
#@+node:ekr.20060203072636:endSearch
def endSearch (self,i,j):

    w = self.w
    w.tag_delete('color','color1')
    g.app.gui.setTextSelection (self.w,i,j,insert='sel.end')
    self.k.keyboardQuit(event=None)
#@nonl
#@-node:ekr.20060203072636:endSearch
#@-node:ekr.20050920084036.261:incremental search...
#@-node:ekr.20050920084036.257:class searchCommandsClass
#@-node:ekr.20051023094009:Search classes
#@-node:ekr.20060122183544:Improve isearch
#@+node:ekr.20060417194232:find (quick)
# To do: extend selection.
#@nonl
#@+node:ekr.20060417194232.1:findCharacter
def findCharacter (self,event):
    
    '''Put the cursor at the next occurance of a character on a line.'''

    k = self.k ; tag = 'find-char' ; state = k.getState(tag)
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Find character: ')
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True)
    else:
        ch = k.arg
        # g.trace(repr(ch))
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacter
#@+node:ekr.20060417194232.2:findWord
def findWord (self,event):
    
    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:
        ch = k.arg
        # g.trace(repr(ch))
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.2:findWord
#@-node:ekr.20060417194232:find (quick)
#@+node:ekr.20060122194643:isearch-headline (forward & backward)
#@-node:ekr.20060122194643:isearch-headline (forward & backward)
#@+node:ekr.20060123091352:Incremental search in switch-to-buffer
#@-node:ekr.20060123091352:Incremental search in switch-to-buffer
#@+node:ekr.20060206104205:Finish query-replace
#@-node:ekr.20060206104205:Finish query-replace
#@-node:ekr.20060413065803:Improve searches 4
#@-node:ekr.20060531135634.1:Test and fix *important* Emacs commands
#@+node:ekr.20060603073652:Rewrite commands chapter
Or at least list all the new commands.
#@nonl
#@-node:ekr.20060603073652:Rewrite commands chapter
#@-node:ekr.20060531161030:To do: 4.4.1 beta 2 (1 week)
#@+node:ekr.20060527164612:Important 1-2 day projects (1-2 weeks)
#@+node:ekr.20031218072017.801:Support .leo.gz or .leo.zip files
#@+node:ekr.20050428062312:Request 1
@nocolor

By: samcollett ( Sam Collett ) 
 Compressed LEO files   
2003-01-07 16:57


Would it be possible to have a new file format that was basically a compressed
version of LEO files? Maybe using the gzip compression method. You could then
save a lot of space when you do large files. Not being a professional
programmer myself (I mainly dabble in web design - HTML and Active Server
Pages) how difficult would this be to implement? You would just output using a
different file extension so users of the older versions can still use files
with the LEO extension.
#@-node:ekr.20050428062312:Request 1
#@+node:ekr.20040226092546:Request 2
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2442772
By: ejoy

I made an experiment last night. I replaced the call to open()in leofilecommand.py
with a call to gzip.open().

The LeoPy.leo file saved this way is only 600K! And there is no significant
speed down in saving.

I think it is a good idea to add compression support for load/save .leo files.
When reading or writing file with name ending with ".leo.gz", leo can call gzip
module to uncompress/compress the file, saving a lot of disk space.

What do you think of this?
#@nonl
#@-node:ekr.20040226092546:Request 2
#@+node:ekr.20031218072017.2297:open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    ok, ratio = self.getLeoFile(
        fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    # Delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.2297:open (leoFileCommands)
#@+node:ekr.20050428063105:newOpen (From chapters.py)
oldOpen = leoFileCommands.fileCommands.open

def newOpen( self,file,fileName,readAtFileNodesFlag=True,silent=False):

    global iscStringIO
    c = self.c
    
    if zipfile.is_zipfile( fileName ):
        iscStringIO = True
        chapters = openChaptersFile( fileName )
        g.es( str( len( chapters ) ) + " Chapters To Read", color = 'blue' )
        insertChapters( chapters, c.frame, c )
        g.es( "Finished Reading Chapters", color = 'blue' )
        iscStringIO = False
        return True

    return oldOpen(self,file,fileName,readAtFileNodesFlag,silent)
#@nonl
#@-node:ekr.20050428063105:newOpen (From chapters.py)
#@-node:ekr.20031218072017.801:Support .leo.gz or .leo.zip files
#@+node:ekr.20040919182750.1:Better handling of whitespace (cvs fiendly)
#@+node:ekr.20060227121512:Comments from Bernhard
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3578166
By: bwmulder

[quote]It turns out that munging whitespace can be extremely time consuming.
I once tried to do a user setting that would end all non-empty body text with
exactly one newline. That effectively hung Leo. I'm not sure if there was a
blunder in the code that caused this, but it may well have been that mass changes
like this are inherently expensive. So we should not assume that 'innocent'
whitespace changes are in fact easy to do.
[quote]

CVS stores files in the RCS format. The latest version is stored directly, the
other versions are stored as line differences (delete lines x-y, insert 3 lines
at z) relative to the latest version. If you change the empty line convention,
you might create lots of differences of the above form which might be expensive
to compute.

This should be a onetime cost, however, which, if you will, you could do one
file at a time.

I woudn't let a tool like CVS determine if I would  change the convention.

As for white space differences: TortoiseSVN (I have not used TortoiseCVS) allows
you to specify external programs. There should be some out there which allow
you to ignore white space differences when comparing files.

On a related note: I read that subversion is in Beta on SourceForge. You might
want to think about switching to subversion once it is officially supported.
One example of a project which has switched from CVS to subversion is the project
which maintains the Python sources itself (see, for example,
http://www.python.org/dev/devfaq.html#subversion-svn)
#@nonl
#@-node:ekr.20060227121512:Comments from Bernhard
#@+node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2674828
By: bwmulder

If I understand correctly, there are two different problems:

- Trailing whitespaces
- Left indented comments

1. Before commenting on these, a question:

If I write something like
    a=b
    if a:
        @others

[four spaces indentation]

I sometimes see tab characters before the lines inserted for '@others'.

It seems that Leo remembers 'two levels of indentation', and then
fabricates this indentation using tab characters.

I think it might be more robust if Leo remembered the actual
characters in front of @others and would use them for indentation.

I suspect that many indentation errors I had with Leo could have been
avoided had not Leo had its own ideas on how to do indentation.

Maybe Leo could use the exact sequence of characters in front of
@others for all inserted lines?

2. I do not care much about trailing whitespaces. Most of the time
they are invisible, but sometimes they are very misleading (trailing in python or C).

As far as I am concerned, Leo need never produce trailing whitespaces.

Maybe we need special machinerie if sources have trailing whitespaces
and the sources are not under our control. 

Not sure if everybody would be happy if we essentially ban all trailing
whitespaces.

3. Unindented commentlines could be dealt with by using indentation to
indicate structure.

Of course, this might break the correspondance Leo structure / Python
structure, which is very ugly.

4. One possible alternative might be a new directive which indicates outindent:

@outindent <number>.

This would apply to the next comment block.

To me, 4. looks a little bit less ugly than 3.

5. As indicated in a different post, I suspect that Leo has a problem
if almost every node in an outline is changed. Profiling should point
to the culprit.

> 2. Have Leo strip whitespace from otherwise blank lines, and hope
that that solves all problems in Perfect Import. This is solving the
problem in the atFile code. The problem is that if we apply settings
in general we will get massive changes to derived files. In most
programming settings these changes might be welcome, but the problem
is actually making these changes. My first few attempts met with
abject failure.

Are you saying that you could not remove trailing blanks? What kind of
problems did you run into?

Summary:
- Use actual characters in front of @others or <<>> for indentation.
- Don't write trailing whitespaces
- Introduce directive for left-indendet comments.
- Profile to find out what slows Leo down if many nodes change.
#@nonl
#@-node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
#@+node:ekr.20040930075920:Whitespace options
#@+node:ekr.20040720103642.1:Script to remove trailing body newlines VERY DANGEROUS
current = c.currentPosition()
count = 0

for p in c.all_positions_iter():
    s = p.bodyString().rstrip()
    if s:
        s = p.bodyString().rstrip() + '\n'
        if s != p.bodyString():
            # Do NOT set anything dirty here!
            ## p.v.t.setTnodeText(s)
            count += 1

print "%d nodes converted" % count
print "You MUST do Write All Nodes AND Save this file to complete the conversion"
#@nonl
#@-node:ekr.20040720103642.1:Script to remove trailing body newlines VERY DANGEROUS
#@+node:EKR.20040603092958.1:Add new options for handling newlines in body text
@nocolor

Alas, this really does not solve problems with Import.

- "asis":  ideal, maybe not possible?
- "zero": no trailing newlines.
- "one": exactly one trailing newline.

Special case code is required so empty nodes stay empty with "one" option.
#@nonl
#@+node:ekr.20040802063546.1:(Made sure body text changes reported properly)
# This may have to change when mass whitespace changes happen)
#@nonl
#@+node:ekr.20031218072017.1812:top_df.read
# The caller has enclosed this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False):
    
    """Common read logic for any derived file."""
    
    at = self ; c = at.c
    at.errors = 0
    importing = importFileName is not None
    << set fileName from root and importFileName >>
    << open file or return False >>
    g.es("reading: " + root.headString())
    firstLines,read_new,derivedFileIsThin = at.scanHeader(theFile,fileName)
    df = g.choose(read_new,at.new_df,at.old_df)
    # g.trace(g.choose(df==at.new_df,"new","old"))
    << copy ivars to df >>
    root.clearVisitedInTree()
    try:
        # 1/28/04: Don't set comment delims when importing.
        # 1/28/04: Call scanAllDirectives here, not in readOpenFile.
        importing = importFileName is not None
        df.scanAllDirectives(root,importing=importing,reading=True)
        df.readOpenFile(root,theFile,firstLines)
    except:
        at.error("Unexpected exception while reading derived file")
        g.es_exception()
    theFile.close()
    root.clearDirty() # May be set dirty below.
    after = root.nodeAfterTree()
    << warn about non-empty unvisited nodes >>
    if df.errors == 0:
        if not df.importing:
            << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return df.errors == 0
#@nonl
#@+node:ekr.20031218072017.1813:<< set fileName from root and importFileName >>
at.scanDefaultDirectory(root,importing=importing)
if at.errors: return

if importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@nonl
#@-node:ekr.20031218072017.1813:<< set fileName from root and importFileName >>
#@+node:ekr.20031218072017.1814:<< open file or return false >>
fn = g.os_path_join(at.default_directory,fileName)
fn = g.os_path_normpath(fn)

try:
    # 11/4/03: open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile = open(fn,'rb')
    if theFile:
        << warn on read-only file >>
    else: return False
except:
    at.error("Can not open: " + '"@file ' + fn + '"')
    root.setDirty()
    return False
#@nonl
#@+node:ekr.20031218072017.1815:<< warn on read-only file >>
try:
    read_only = not os.access(fn,os.W_OK)
    if read_only:
        g.es("read only: " + fn,color="red")
except:
    pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20031218072017.1815:<< warn on read-only file >>
#@-node:ekr.20031218072017.1814:<< open file or return false >>
#@+node:ekr.20031218072017.1816:<< copy ivars to df >>
# Telling what kind of file we are reading.
df.importing = importFileName != None
df.raw = False
if importing and df == at.new_df:
    thinFile = True
df.thinFile = thinFile

# Set by scanHeader.
df.encoding = at.encoding
df.endSentinelComment = at.endSentinelComment
df.startSentinelComment = at.startSentinelComment

# Set other common ivars.
df.errors = 0
df.file = theFile
df.importRootSeen = False
df.indent = 0
df.targetFileName = fileName
df.root = root
df.root_seen = False
df.perfectImportRoot = None # Set only in readOpenFile.
#@nonl
#@-node:ekr.20031218072017.1816:<< copy ivars to df >>
#@+node:ekr.20031218072017.1817:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file:" + p.headString())
        p.v.t.setVisited() # One message is enough.
#@nonl
#@-node:ekr.20031218072017.1817:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20031218072017.1818:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            p.setBodyStringOrPane(s) # Sets v and v.c dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@nonl
#@-node:ekr.20031218072017.1818:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20031218072017.1819:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@nonl
#@-node:ekr.20031218072017.1819:<< delete all tempBodyStrings >>
#@-node:ekr.20031218072017.1812:top_df.read
#@-node:ekr.20040802063546.1:(Made sure body text changes reported properly)
#@+node:ekr.20040930075920.1:Common to both options
#@+node:ekr.20031218072017.2404:<< define defaultsDict >>
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

# Defaults for ivars are specified in the ctor, _not_ here.

defaultsDict = {
    # compare options...
    "ignore_blank_lines" : 1,
    "limit_count" : 9,
    "print_mismatching_lines" : 1,
    "print_trailing_lines" : 1,
    # find/change options...
    "search_body" : 1,
    "whole_word" : 1,
    # Prefs panel.
    "default_target_language" : "Python",
    "tab_width" : -4,
    "page_width" : 132,
    "output_doc_chunks" : 1,
    "tangle_outputs_header" : 1,
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    "color_directives_in_plain_text" : 1,
    "underline_undefined_section_names" : 1,
    # Window options...
    "allow_clone_drags" : 1,
    "body_pane_wraps" : 1,
    "body_text_font_family" : "Courier",
    "body_text_font_size" : defaultBodyFontSize,
    "body_text_font_slant" : "roman",
    "body_text_font_weight" : "normal",
    "enable_drag_messages" : 1,
    "headline_text_font_size" : defaultTreeFontSize,
    "headline_text_font_slant" : "roman",
    "headline_text_font_weight" : "normal",
    "log_text_font_size" : defaultLogFontSize,
    "log_text_font_slant" : "roman",
    "log_text_font_weight" : "normal",
    "initial_window_height" : 600, # 7/24/03: In pixels.
    "initial_window_width" :  800, # 7/24/03: In pixels.
    "initial_window_left" : 10,
    "initial_window_top" : 10,
    "initial_splitter_orientation" : "vertical",
    "initial_vertical_ratio" : 0.5,
    "initial_horizontal_ratio" : 0.3,
    "initial_horizontal_secondary_ratio" : 0.5,
    "initial_vertical_secondary_ratio" : 0.7,
    "outline_pane_scrolls_horizontally" : 0,
    "split_bar_color" : "LightSteelBlue2",
    "split_bar_relief" : "groove",
    "split_bar_width" : 7 }
#@nonl
#@-node:ekr.20031218072017.2404:<< define defaultsDict >>
#@+node:ekr.20031218072017.3004:<< initialize ivars that may be set by config options >>
# Defaults for these ivaars are specified here, _not_ in defaultsDict.

self.at_root_bodies_start_in_doc_mode = True # For compatibility with previous versions.
self.config = None # The current instance of ConfigParser
self.config_encoding = "utf-8" # Encoding used for leoConfig.txt.
self.create_nonexistent_directories = False
self.default_derived_file_encoding = "utf-8"
self.new_leo_file_encoding = "UTF-8" # Upper case for compatibility with previous versions.
self.output_initial_comment = "" # "" or None for compatibility with previous versions.
self.output_newline = "nl"
self.read_only = True # Make sure we don't alter an illegal leoConfig.txt file!
self.redirect_execute_script_output_to_log_pane = False
self.relative_path_base_directory = "!"
self.remove_sentinels_extension = ".txt"
self.save_clears_undo_buffer = False
self.stylesheet = None
self.tkEncoding = None # Defaults to None so it doesn't override better defaults.
self.trailing_body_newlines = "asis"
self.use_plugins = False # Should never be True here!
self.use_psyco = False
self.undo_granularity = "word" # "char","word","line","node"
self.write_strips_blank_lines = False
#@nonl
#@-node:ekr.20031218072017.3004:<< initialize ivars that may be set by config options >>
#@+node:ekr.20031218072017.1421:<< get config options >>
@ Rewritten 10/11/02 as follows:

1. We call initConfigParam and initBooleanConfigParam to get the values.

The general purpose code will enter all these values into configDict.  This allows update() to write the configuration section without special case code.  configDict is not accessible by the user.  Rather, for greater speed the user access these values via the ivars of this class.

2. We pass the ivars themselves as params so that default initialization is done in the ctor, as would normally be expected.
@c

self.at_root_bodies_start_in_doc_mode = self.initBooleanConfigParam(
    "at_root_bodies_start_in_doc_mode",self.at_root_bodies_start_in_doc_mode)
    
encoding = self.initConfigParam(
    "config_encoding",self.config_encoding)
    
if g.isValidEncoding(encoding):
    self.config_encoding = encoding
else:
    g.es("bad config_encoding: " + encoding)
    
self.create_nonexistent_directories = self.initBooleanConfigParam(
    "create_nonexistent_directories",self.create_nonexistent_directories)
    
encoding = self.initConfigParam(
    "default_derived_file_encoding",self.default_derived_file_encoding)

if g.isValidEncoding(encoding):
    self.default_derived_file_encoding = encoding
else:
    g.es("bad default_derived_file_encoding: " + encoding)
    
encoding = self.initConfigParam(
    "new_leo_file_encoding",
    self.new_leo_file_encoding)

if g.isValidEncoding(encoding):
    self.new_leo_file_encoding = encoding
else:
    g.es("bad new_leo_file_encoding: " + encoding)

self.output_initial_comment = self.initConfigParam(
    "output_initial_comment",self.output_initial_comment)

self.output_newline = self.initConfigParam(
    "output_newline",self.output_newline)

self.read_only = self.initBooleanConfigParam(
    "read_only",self.read_only)

self.relative_path_base_directory = self.initConfigParam(
    "relative_path_base_directory",self.relative_path_base_directory)
    
self.redirect_execute_script_output_to_log_pane = self.initBooleanConfigParam(
    "redirect_execute_script_output_to_log_pane",
    self.redirect_execute_script_output_to_log_pane)
    
self.remove_sentinels_extension = self.initConfigParam(
    "remove_sentinels_extension",self.remove_sentinels_extension)

self.save_clears_undo_buffer = self.initBooleanConfigParam(
    "save_clears_undo_buffer",self.save_clears_undo_buffer)
    
self.stylesheet = self.initConfigParam(
    "stylesheet",self.stylesheet)
    
encoding = self.initConfigParam(
    "tk_encoding",self.tkEncoding)
    
if encoding and len(encoding) > 0: # May be None.
    if g.isValidEncoding(encoding):
        self.tkEncoding = encoding
    else:
        g.es("bad tk_encoding: " + encoding)
        
# New in 4.2
self.trailing_body_newlines = self.initConfigParam(
    "trailing_body_newlines",self.trailing_body_newlines)
    
self.use_plugins = self.initBooleanConfigParam(
    "use_plugins",self.use_plugins)

self.use_psyco = self.initBooleanConfigParam(
    "use_psyco",self.use_psyco)
    
self.undo_granularity = self.initConfigParam(
    "undo_granularity",self.undo_granularity)

# New in 4.2
self.write_strips_blank_lines = self.initBooleanConfigParam(
    "write_strips_blank_lines",self.write_strips_blank_lines)
    
#g.trace("write_strips_blank_lines",self.write_strips_blank_lines)
#g.trace("trailing_body_newlines",self.trailing_body_newlines)
#@nonl
#@-node:ekr.20031218072017.1421:<< get config options >>
#@-node:ekr.20040930075920.1:Common to both options
#@+node:ekr.20040718050922:(trailing_body_newlines option)
@color
#@nonl
#@+node:ekr.20040720105309:Notes
@killcolor

My first idea was to do this in the body text setters.  However, this converts everything when reading any .leo file, and that is _very_ slow.  It also appears to be very dangerous.
#@nonl
#@-node:ekr.20040720105309:Notes
#@-node:ekr.20040718050922:(trailing_body_newlines option)
#@+node:ekr.20040720075446.1:(write_strips_blank_lines option)
#@+node:ekr.20031218072017.2134:putCodeLine
def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # g.app.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
#@nonl
#@-node:ekr.20031218072017.2134:putCodeLine
#@-node:ekr.20040720075446.1:(write_strips_blank_lines option)
#@-node:EKR.20040603092958.1:Add new options for handling newlines in body text
#@-node:ekr.20040930075920:Whitespace options
#@+node:ekr.20041022083005.8:Script to catch mixed tab & space in derived files
import glob

@others

dir = c.frame.openDirectory
files = glob.glob('%s\*.py' % dir)

n = 0
for name in files:
    f = file(name)
    lines = f.readlines()
    # print '%5d %s' % (len(lines),name)
    f.close()
    check(name,lines)
    n += 1
print 'done.  checked %d files' % (n)
#@nonl
#@+node:ekr.20050917133402:check
def check(name,lines):
    
    n = 0
    for line in lines:
        n += 1
        i = g.skip_ws(line,0)
        lws = line[0:i]
        if lws:
            if lws.find(' ') > -1 and lws.find('\t') > -1:
                print '%20s %5d %s' % (name,n,repr(line))
#@nonl
#@-node:ekr.20050917133402:check
#@-node:ekr.20041022083005.8:Script to catch mixed tab & space in derived files
#@-node:ekr.20040919182750.1:Better handling of whitespace (cvs fiendly)
#@+node:ekr.20050419060645:Alternate lead-in characters
@nocolor

An @decorator setting might be good. This would be a list of all Python
decorators. Leo would create @verbatim sentinels for these.
#@nonl
#@-node:ekr.20050419060645:Alternate lead-in characters
#@+node:ekr.20060306194040:More screen shots or video tutorial on Leo's web site

@nocolor
http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/


http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.
#@+node:ekr.20060531134434:Tutorials
http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
#@nonl
#@-node:ekr.20060531134434:Tutorials
#@+node:ekr.20060531134434.1:Screencasts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3758303
By: ktenney

My sense is that documentation/screencasts has the
greatest potential for expanding Leo's mindshare.

I really like those produced by the good folks
at Dabo;
http://leafe.com/screencasts/
http://leafe.com/screencasts/populategrid.html

The TurboGears people have taken this to the extreme;
http://www.turbogears.org/ultimate.html

Leo is different enough that it warrants a 
demonstration of it's advantages.
#@nonl
#@-node:ekr.20060531134434.1:Screencasts
#@-node:ekr.20060306194040:More screen shots or video tutorial on Leo's web site
#@+node:ekr.20060530085844:Improve autocompletion
#@-node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20041022091645.4:Pymacs
#@+node:ekr.20040125121407:Postings
@nocolor
#@nonl
#@+node:ekr.20040125121407.1:randomandy
http://sourceforge.net/forum/message.php?msg_id=2389876
By: randomandy

Is it only me who sees this as a question on how to reinvent the wheel? (or
in the case of emacs, how to reinvent the <i>everything</i>.)

Leo and Python both seem so well suited as wonderful hierarchal glue programs.
And both are so elegant in the way their simple functionality brings such power
and order to the cause. It just seems it would be a shame to take something
so novel and unique and try to turn it into <i>yet another</i> huge text editor.

I'm with <A HREF="http://sourceforge.net/forum/message.php?msg_id=2345873">Danny
</A> on this one. The ideal solution is to find the most elegant and seamless
way to splice one's own beloved text editor (or multipurpose editor/OS) in with
the Leo paradigm. Have Leo hand off the text duties to the editor, or have the
editor deliver heirarchy commands to Leo.

I'm also quite curious if this makes a good tie in with SciTE. SciTE produces
stunningly readible language highlighting/formatting. Could it be employed for
basic cell text display, and then for heavier editing, a keystroke or button
could open the cell text in one's preferred weapons grade text editor?

Scintilla also has a similarly beautiful code-to-html and code-to-pdf capability
that seems very suited to the literary part of the Leo paradigm: publication.
It would be nice if that code could be exploited as well.

This Leo is really a marvelous work. It's transforming the way I think (i.e.
making it possible again). Nice work, Edward.
#@-node:ekr.20040125121407.1:randomandy
#@+node:ekr.20040125121407.2:dannyobrien
By: dannyobrien ( danny o'brien ) 
 RE: What would it take to turn Leo into Emacs   
2003-12-23 09:18  

 I agree with the embedding; I've used the vim plugin and it works well, but actually embedding the editor directly into the text field of leo (and allowing a range of keyboard shortcuts for eg headline editing) would be perfect.

There is some support for this in gvim, the GUI version of vim that comes as standard. This can be run so as its GUI is "embedded" in another GTK widget, using that library's GtkSocket/GtkPlug system. A quick demo of that (and how to do it in python) is here:

http://www.daa.com.au/pipermail/pygtk/2003-October/006185.html

To see this working with gvim, run the second (socket.py) program on that page then type

gvim --socketid <number generated by socket.py>

I'm not sure how you could do this in other widget libraries - I don't know much about X Windows, but I suppose it would need support in vim as well as the widget set.
 
#@-node:ekr.20040125121407.2:dannyobrien
#@+node:ekr.20040125121407.3:mdawson
http://sourceforge.net/forum/message.php?msg_id=2388448
By: mdawson

I use XEmacs as my text editor.  The first thing I did when
evaluating Leo was to set up "open with" to use XEmacs for editing
Leo body text.

My progress so far:

- my Open_With Plugin opens a Leo node as a foreground buffer in
XEmacs, or a background (invisible) buffer in XEmacs.

- my Open_Tree Plugin opens a sub-tree of Leo nodes as background
buffers in XEmacs.

- my filename modification plugin changes the temporary file names
used by Leo so that they can be spotted more easily in an XEmacs
buffer listing (e.g. ibuffer).

- an elisp function to kill all XEmacs Leo buffers at once.

- another elisp function to indent and unindent the Leo comments in
derived Python source, which improves the readability of code.

- my setup of the elisp Multiple-Major-Modes XEmacs package, so that
XEmacs is in text-mode in Leo @doc sections, and the correct
language mode in @code sections.

Any of these might be able to be adapted for your own use. They
should all work with Emacs as well as XEmacs, but I've not tested
that.

These are all outlined in Appendix "C. XEmacs Text Editor" of the
document at:
    http://devguide.leo.marshallresearch.ca

and the Leo outline that contains them is available at:
    http://leo.marshallresearch.ca


    ----------------------------------------
    Michael Dawson
#@nonl
#@-node:ekr.20040125121407.3:mdawson
#@-node:ekr.20040125121407:Postings
#@+node:ekr.20041022144159:Q: Pymacs bridge
I'm trying to use the Pymacs bridge to add a symbol completion facility to
Emacs's python-mode.  Neither the Python nor Emacs Lisp portions are all
that complex, but I'm having trouble passing a list of strings from Emacs
Lisp into Python.  On the Emacs Lisp side it looks like this:

    (pymacs-load "pycomplete")

    (defun py-complete ()
      (interactive)
      (pycomplete-pycomplete (py-symbol-near-point)
                             (py-find-global-imports)))

(py-find-global-imports) returns a (Lisp) list of strings, e.g.:

    ("import time", "import sys")

On the Python side I have this function:

    def pycomplete(s, imports=None):
        completions = get_all_completions(s, imports)
        dots = s.split(".")
        return os.path.commonprefix([k[len(dots[-1]):] for k in completions])

Unfortunately, the imports arg does not come across as a Python list of
strings (s does come across the bridge as a normal Python string).  Its
repr() prints out like this:

    lisp('("import time")')

What do I need to do to convert that object into a true Python list of
strings?  I'm afraid I don't quite understand the description of the lisp
object in the Pymacs docs.  I tried imports.value() but that just gave me

    (aref pymacs-lisp 0)

Any help appreciated...

Skip
#@nonl
#@-node:ekr.20041022144159:Q: Pymacs bridge
#@+node:ekr.20041022144159.1:A: pymacs-forget-mutability
"""
Proper Emacs Lisp lists, those for which the cdr of last cell is nil, are
normally transmitted opaquely to Python. If pymacs-forget-mutability is
set, or if Python later asks for these to be expanded, proper Emacs Lisp
lists get converted into Python lists, if we except the empty list, which
is always converted as Python None. In the other direction, Python lists
are always converted into proper Emacs Lisp lists.
"""

So, maybe try

    (defun py-complete ()
      (interactive)
      (let ((pymacs-forget-mutability t)) 
	(pycomplete-pycomplete (py-symbol-near-point)
                               (py-find-global-imports))))
#@-node:ekr.20041022144159.1:A: pymacs-forget-mutability
#@-node:ekr.20041022091645.4:Pymacs
#@-node:ekr.20060527164612:Important 1-2 day projects (1-2 weeks)
#@+node:ekr.20060527182117:Important 1-2 week projects (2-3 weeks)
#@+node:ekr.20041228084830.3:Finish wxWindows plugin
#@+node:ekr.20060529130339:Don't use body wrappers, use g.app.gui methods instead
#@-node:ekr.20060529130339:Don't use body wrappers, use g.app.gui methods instead
#@+node:ekr.20060527190832.1:Add gui index conversion methods
Add gui.toPythonIndex(s,index) and gui.toGuiIndex(s,index)
#@nonl
#@-node:ekr.20060527190832.1:Add gui index conversion methods
#@-node:ekr.20041228084830.3:Finish wxWindows plugin
#@+node:ekr.20041228084018.5:Finish zodb plugin
@ New notes:

- openFromZODB would be similar to openWithFileName, but gets root, current positions from zodb.

- Either we save positions in the zodb, or we figure out how to create root, current positions from vnodes.
    - Root positions is easy, but current position could be anywhere.

- Save commands would commit to zodb.  Revert would abort.
#@nonl
#@+node:ekr.20040226114127: Zope test
@color

import leoGlobals as g
import ZODB

d = dir(ZODB) ; d.sort()

g.trace(g.toString(d))

if 0:
    storage = ZODB.FileStorage.FileStorage(r"c:\prog\zopeTemp\leo.fs")
    g.trace(storage)
    if 0:
        db = ZODB.DB(storage)
        g.es(storage)
        g.es(db)
        db.close()
#@nonl
#@-node:ekr.20040226114127: Zope test
#@+node:ekr.20041002151816:ZODB docs
#@+node:ekr.20041002151816.1:What is the ZODB?
http://zope.org/Wikis/ZODB/FrontPage/guide/node2.html#SECTION000210000000000000000

1.1 What is the ZODB?

The ZODB is a persistence system for Python objects. Persistent programming
languages provide facilities that automatically write objects to disk and read
them in again when they're required by a running program. By installing the
ZODB, you add such facilities to Python.

#@-node:ekr.20041002151816.1:What is the ZODB?
#@+node:ekr.20041002151816.2:How ZODB Works
2.2 How ZODB Works

The ZODB is conceptually simple. Python classes subclass a persistent.Persistent
class to become ZODB-aware. Instances of persistent objects are brought in from
a permanent storage medium, such as a disk file, when the program needs them,
and remain cached in RAM. The ZODB traps modifications to objects, so that when
a statement such as obj.size = 1 is executed, the modified object is marked as
``dirty.'' On request, any dirty objects are written out to permanent storage;
this is called committing a transaction. Transactions can also be aborted or
rolled back, which results in any changes being discarded, dirty objects
reverting to their initial state before the transaction began.

#@-node:ekr.20041002151816.2:How ZODB Works
#@+node:ekr.20041002151816.3:Rules for Writing Persistent Classes
2.6 Rules for Writing Persistent Classes

Practically all persistent languages impose some restrictions on programming
style, warning against constructs they can't handle or adding subtle semantic
changes, and the ZODB is no exception. Happily, the ZODB's restrictions are
fairly simple to understand, and in practice it isn't too painful to work around
them.

The summary of rules is as follows:

* If you modify a mutable object that's the value of an object's attribute, the
ZODB can't catch that, and won't mark the object as dirty. The solution is to
either set the dirty bit yourself when you modify mutable objects, or use a
wrapper for Python's lists and dictionaries (PersistentList, PersistentMapping)
that will set the dirty bit properly.

* Recent versions of the ZODB allow writing a class with __setattr__ ,
__getattr__, or __delattr__ methods. (Older versions didn't support this at
all.) If you write such a __setattr__ or __delattr__ method, its code has to set
the dirty bit manually.

* A persistent class should not have an __del__ method. The database moves
objects freely between memory and storage. If an object has not been used in a
while, it may be released and its contents loaded from storage the next time it
is used. Since the Python interpreter is unaware of persistence, it would call
the __del__ each time the object was freed.
#@nonl
#@-node:ekr.20041002151816.3:Rules for Writing Persistent Classes
#@-node:ekr.20041002151816:ZODB docs
#@+node:ekr.20031218072017.406:Zop url's
#@+node:ekr.20031218072017.407:@url http://24.243.129.68:8080/members/sandbox
#@-node:ekr.20031218072017.407:@url http://24.243.129.68:8080/members/sandbox
#@+node:ekr.20031218072017.408:@url http://www.zopelabs.com/cookbook
#@-node:ekr.20031218072017.408:@url http://www.zopelabs.com/cookbook
#@+node:ekr.20031218072017.409:@url http://zwiki.org/FrontPage  Zope implementation of wiki
#@-node:ekr.20031218072017.409:@url http://zwiki.org/FrontPage  Zope implementation of wiki
#@-node:ekr.20031218072017.406:Zop url's
#@+node:ekr.20040107064101.5:Zope notes
#@+node:ekr.20031218072017.405:Kent Tenny Notes
@nocolor

Outlook: server for email, addresses & calendar.  Groupware.  Chandler similar.

Zope: back end is ZODB.  Zope like an OS: run Python code on Zope.

Zope: another way to access Leo files.  Maybe twisted is better?

Wiki anology: edit Leo files with browser.  Write through the web.

longrun.org

Wiki principles: 
	- Sharing is 90% of collaboration.
	- Zope: Subscribe to a wiki: email when page changes.
	- RSS: xml that defines piece of info(tile,url,abstract)
		- Client has a list of rss feeds: an xml file.
		- List of intesting people: notified when they say something.

Two goals:
	- publish Leo files
	- edit Leo files

Brother needs cvs.
Kent not so worried about cvs.
	-Leo file is a web site!
	- Helper layer between user and OS.
		- Look at aap project.  Author of vim. a-p.org
			- Replacement for make in Python.  Automating tool.
		- Expert prepares Leo file.  User uses it.
#@nonl
#@-node:ekr.20031218072017.405:Kent Tenny Notes
#@+node:ekr.20040107065006:posting
@nocolor

Yes he's absolutely right -- focus on the ZODB.

..stay alway from ZTP. ZPT, TPZ, CMF, Plone and all that other stuff for now.

I jsut came accross a handy slide show overview from last spring:
http://jace.seacrow.com/tech/zope/blug-zodb

BerkeyDB Storage is cool too and fits Leo well I think. plays nicely wiht ZODB
standalnioe and in Zope.
#@-node:ekr.20040107065006:posting
#@+node:ekr.20040107064854:example Code
from ZODG import FileStorage,DB
from Persistence import Persistent

# Connect to db.
# FileStorage is standard: entire db is stored in a single file.
storage = FileStorage.FileStorage("/tmp/test-filestorage.fs")
db = DB.(storage)
conn = db.open()

# Get the root of the db.
root = conn.root()

# Defining user classes.
class leoData(Persistent):
	pass
	
# Commit or revert.
get_transaction().commit()
get_transaction().abort()
#@nonl
#@-node:ekr.20040107064854:example Code
#@+node:ekr.20040107080609.1:Zshell
@nocolor

By: jasonic ( Jason Cunliffe )
ZShell  
2003-12-31 22:25

Hi, Just another friendly reminder to check out Jerome Alet's ZShell, one of Zope's best kept secrets:

http://www.librelogiciel.com/software/

ZShell : Manipulate the Zope Object DataBase with Unix shell like commands

and also

ZShellScripts : Unifies the Zope notion of Scripts and provides several Script interpreters : Python, Unix shell , Lisp, Perl, PHP, Ruby, and Zope ZShell

Not only for obvious usefullness, but also as a valuable study of Python access to the ZODB.

JAXML is cool too..
http://www.librelogiciel.com/software/jaxml/action_Presentation

- Jason
#@nonl
#@-node:ekr.20040107080609.1:Zshell
#@+node:ekr.20040107064854.1:@url http://zope.org/Products/StandaloneZODB
#@-node:ekr.20040107064854.1:@url http://zope.org/Products/StandaloneZODB
#@+node:ekr.20040107064854.2:@url http://jace.seacrow.com/tech/zope/blug-zodb
#@-node:ekr.20040107064854.2:@url http://jace.seacrow.com/tech/zope/blug-zodb
#@-node:ekr.20040107064101.5:Zope notes
#@+node:ekr.20031218072017.412:Zope postings
#@+node:ekr.20031218072017.413:From Rodrigo re: Zope.
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007586
By: rodrigo_b

z2.py,
>Supposing that that I did find this file, what would I be looking for? 

This is the Main script, the principal program, the code that startup all the
servers, the only python program that make run Zope, it the code called by start.py,
and it is the one to which you pass the command lines.

With the command line you can indicate which services to start up at which ports.
This is IMPORTANT. Also you can enable/disable the Debug mode.

python z2.py --help will give you some infos about what I'm talking about.

In linux the debug or not debug mode, enable the console or daemon mode (that
means 'background task mode').

In windows, I'm not sure that disabling the debug mode will be enough.
I know that at the install time you can setup Zope as a Windows Service, so
it will start automatically every time Windows Startup, and it will not open
a console window.

But first look at the debug mode.

Start.bat give some defaults command lines to z2.py

Webdav,
>What issues are involved in this choice, and why should I care today? 

from www.webdav.org

What is WebDAV? 
Briefly: WebDAV stands for "Web-based Distributed Authoring and Versioning".
It is a set of extensions to the HTTP protocol which allows users to collaboratively
edit and manage files on remote web servers.

For example that means that you can open you Windows Explorer (from your mail
I understand that you work on an MsWindows OS),
tip the url "localhost:%i"%(your webdav port) and you will be able to navigate,
view and edit the Zope Objects just as a normal file system (well, almost).

WebDav is a standard and there are Python implementations. WebDav is support
by  Oscom.

WebDav is cool.
WebDav is the 'highest level tool'.

ZODB,

>Does that mean that gnx's aren't needed with Zope? Could Leo nodes live in
the ZODB?

You have to thinks to ZODB just as what it is: a Persistent Object Database.
Most objects in Zope are Persistents, that mean that their instances do not
die when you shutdown the server.

The ZODB store his data in it own format.
I think that GNX should be keeped.
You have to basic ways to put nodes into Zope.

First: the hard way: create a new Product (Products are something like Zope
plugins) that is based on the Leo code, but were there is no node storage, instead
the node should be Persistents. Then add rendering code to this objects.

Leo node object + Persistence + ZClass + Rendering Code -> Leo Zope node.

Additionaly you should create an Folder like object that should be an 'Leo Outline
Zope Object',  actuating as an Leo nodes container.

This shema is similar to the Zwiki way, with a Zwiki Web and the Zwiki Pages.

Second: Use A zope folder just as Leo manage the @file nodes. Let have simple
DTMLDocuments, edited via WebDav, with <dtml-comments> , and stuff like that.
The Leo import/export that nodes.

RodrigoB.

#@-node:ekr.20031218072017.413:From Rodrigo re: Zope.
#@+node:ekr.20031218072017.414:Clarification from Kent Tenny
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2009081
By: ktenney

Edward,

I don't see ZLeo replacing Leo, rather a method of accessing
Leo files.

When I write, I almost always want it to be web accessable,
so that I can access it from any browser, and so that I can
share it easily. I would like myfile.leo to live
at http://longrun.org/leo/myfile.leo. It can be read and
written to from any browser (according to how permissions are
configured) The page describing how to configure Apache would
be found at http://longrun.org/leo/myfile.leo/Apache/configure
The only requirement to work with Leo files is a browser.

I wouldn't want to lose the capability to edit outside
the browser, using a standalone version of Leo or Zope's
ExternalEditor product. ExternalEditor allows me to click
an icon to open the page I'm viewing in any editor. I could
open it in Leo as a Leo file, or open just the page in
Vim (http://vim.sourceforge.net/index.php)

Zope is ponderous, I think of it as more of a platform
than an application. My understanding of how Zope works
grows slowly, in the mean time my focus is on _products_.
Installing a product in Zope is like installing an application
in Windows or Linux.

One of the most evolved products is Plone/CMF http://plone.org
which is basically a turnkey web site.

twisted http://twistedmatrix.com is a brilliant set of network
programming tools. That's all I know about it.

I'm not sure about Chandler (http://www.osafoundation.org/) 
(they did choose Python and ZODB http://www.osafoundation.org/technology.htm)

You might try subscribing to a Zope mailing list or two
http://www.zope.org/Resources/MailingLists
The community of users and developers is very important to Zope.

Thanks,
Kent
#@-node:ekr.20031218072017.414:Clarification from Kent Tenny
#@+node:ekr.20031218072017.415:From Rodrigo re: ip
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007817
By: rodrigo_b

If zope is running some server then this server will be accesible from your
network if and only if there is no firewall in the way.

The people can access to your services using (normally on internet you do not
have a domain name)

your_ip:the_service_port

Example:
zope http service on port 8080 on your machine.
When  you connect to internet your machine got an extra IP.
Then simple put on the web browser

http://your_conexion_ip:8080

and Tada you will see the root_zope/index_html object rendered intro HTML.

Most of the ISP give you a dinamic IP.
Some companies provides you dinamic IP Domain Name services, allowing to attach
a domain name to your machine dinamically (each time you reconect).

then you can have:

http://leo.edward.com:8080/

The 8080 stuff can be avoied if you setup zope to use the standard port 80 for
HTTP service.

With this in mind you can access ftp

ftp://your_ip_or_domain_name:8021

or webdav, or anything else.
#@-node:ekr.20031218072017.415:From Rodrigo re: ip
#@+node:ekr.20031218072017.416:Other servers
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007832
By: rodrigo_b

I would made a warning.

Zope IT IS NOT the only way to obtain an local HTTP server, pythonic and
flexible.

There is a lot of other way.

Also Zope IT IS NOT THE BEST pythonic http/ftp/webdav or anything server
aviable.

I think that we should define better 

What we want to do?

before choosing the tool.

As I said, I had already used Zope, I choosed it because of very specific features,
but nothing indicate that Zope is the best way to get Leo to the colaborative
network universe.

I think that we should at least consider:
- SimpleHTTPServer
- To take of the Medusa Server from Zope (that is use Zope code in the standard
Leo distribution, avoying dependences)
- Twisted matrix (I had no experience with it, but it looks much more
flexible/powerfull)

Zope provides you a specific framework, you have to match you application to
this framework, Zope (in my opinion) it is not a tool, it's an ambient.

It's seems that Edward it is new in the web oriented software, I think it has
a lot of potencialities and it will benefits Leo devellopment.

Please Edward, look at Zope as an example but not as THE options. Think about
what can be done, what should be done, and then we will take the best tool.

Anyway my opinion:
- SimpleHTTP server: usefull, it is in python, not very eficiente, just http
server	
- Medusa: usefull, very eficiente, just http server...
- Twisted Matrix: very powerfull, fresh comunity, confusing documentation, a
new paradigm, a devellopment tool.
- Zope: powerfull, eficient, comes with battery included, bad documentation,
to very paradigm oriented, the apps have to fit the paradigm, don't believe
all the promises, strong enthousiast comunity, poor web examples.


RodrigoB. 
#@-node:ekr.20031218072017.416:Other servers
#@+node:ekr.20031218072017.417:Is my ip public?
https://sourceforge.net/forum/message.php?msg_id=2007962
By: bwmulder

Since no one else answered this question, let me take a first take on the
question:

If you are connected to the internet, people can use your IP number to connect
to your computer. This IP number is often given dynamically, though some DSL
providers give you fixed IP numbers for an additional fee. If you did not ask
for fixed IP numbers, you probably have an dynamic IP number (I think).

An IP number consist of four digits. A connection to the (example) IP number
111.222.333.444 can by made via the request http://111.222.333.444

If you have a dynamic IP number, and your Internet provider provides you with
some space to publish HTML, you could, via a script, upload your current IP
number dynamically.

You might also consider buying a domain name. In this case, people can use the
domain name to connect to your computer instead of the IP number.

Another consideration are firewalls. Normally, you want a firewall isolating
your computer from attacks from the Internet. I firewall can be some additional
software. I am currently using a router, a piece of hardware, as a firewall.
Windows XP has firewall software build in. You might have to configure your
firewall to let requests for your server go through.

Finally, you might want to check the agreement you entered with your Internet
service provider, if you are allowed to run a server from your connection. It
might become a problem if your server becomes very popular.
#@-node:ekr.20031218072017.417:Is my ip public?
#@+node:ekr.20031218072017.418:Back ends for storing/retrieving nodes: Paul Paterson
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2009279
By: paulpaterson

What I see Zope offering is an alternative way of storing and retrieving nodes.
What you also get for "free" with Zope is concurrent access, security,
http/ftp/webdav access to the same node information etc. The hidden price you
pay is that Zope is big and many users will have other tools which can provide
these facilities also.

So, my thinking is that we can abstract the basic idea (alternative ways of
storing and retrieving node information) into Leo and then let the magic really
happen in the concrete implementation stage.

What does this mean? Well, we could change Leo so that whenever it goes to retrieve
Headline or Body it goes to a Node Server object to do that. The Node Server
object uses whatever method it wants to retrieve or set the information. The
Node server would also be responsible for telling Leo what child nodes an object
has and whether they are clones or not.

The cool part is that we could implement different kinds of Node server to talk
to different back-ends. These can then be thought of as drivers. So we might
have,

- a file system driver where all information is stored in files and directories
- a database driver where the DB stores all information
- an ftp driver
- a Zope driver
- the default Leo driver

People could write a driver to their own back end storage system. 

What is the advantage of this?

Well, the magic really happens in the back-end. If you choose a back end which
supports versioning, security, concurrent working, web access, etc etc then
Leo now supports them. If you choose a back-end which supports dynamic mark-up
or some other fancy stuff then Leo supports it. The key is that Leo doesn't
need to bind itself to any one system to achieve this - the end user can install
the relevant driver, configure the back-end and just go with it.

Paul
#@-node:ekr.20031218072017.418:Back ends for storing/retrieving nodes: Paul Paterson
#@+node:ekr.20031218072017.419:From Paul Paterson
Ok, I'll have a bash in a rough order or when things occurred...


1. Everything is web based. I had the same problem you did. I ran the
thing and said, "ok, so what did it do". Others have pointed you in the
right direction now with visiting http://localhost:8080 and
http://localhost:8080/manage to view the site and mange it respectively.

If you are running WinNT, 2000 or XP you can also run Zope as a service,
which is much more convenient as you don't need the console window open
all the time.


2. Everything in Zope is an object. Ok, you'll see this a lot. The best
thing to do is think "wow, cool" and then forget it again as you
probably wont really see how this helps at all until you get much deeper
into Zope. 


3. DTML allows you to construct web pages by piecing together bits much
like writing a program from functions. In fact you will find DTML is a
lot like tangling Leo's @root nodes. Here's a bit...

<!-- start html -->

<h>DTML allows you to assemble web pages much like Leo tangles
documents</h>

<p>For instance, have a look at how this page is constructed</p>

<dtml-var first_bit>
<dtml-var second_bit>
<dtml-var third_bit>

<!-- end html -->

The <dtml-var name> bit is like a < < name > > directive. It effectively
inserts the object (could be HTML, an image or something more complex)
in the current page. 

To see this snippet in action you can visit my server at
http://24.243.129.68:8080/members/sandbox/index_html

To see the code, visit http://24.243.129.68:8080/members/sandbox/manage
(username=edream, pwd=leo) and then click on the index_html to see the
main DTML. Feel free to mess around in here but please don't publish the
IP address as my ISP doesn't allow servers!


4. There is a lot of power in Zope products. Try going to www.zope.org
and seeing what is available. As an example I put a Wiki in the sandbox
area http://24.243.129.68:8080/members/sandbox/edswiki


5. If you are looking for a good book to begin with then steer clear of
"The Zope Book"! If you don't mind paying then "The book of Zope" is a
much better introduction. When you have read this then "The Zope Book"
will make some sense but really I found this book tremendously hard to
get through.


6. Web standards are very cool! Zope supports FTP. Point your favourite
FTP tool to,

ftp://24.243.129.68:8021/members/sandbox/

Or try using WebDav by creating a network place pointing to

http://24.243.129.68:8080/members/sandbox

You can then use windows explorer or an ftp tool to browse your objects.


7. Everything is an object! I can't do justice to the concept of
Acquisition here but by the time you have messed around with Zope a bit
you should start to see how acquisition starts to make things really
work like classes in Python. 


I realize this isn't very coherent - if I get a spare moment this
weekend I'll knock up a quick demo showing Leo interacting with Zope.

Regards,

Paul
#@-node:ekr.20031218072017.419:From Paul Paterson
#@+node:ekr.20040117092727.2:using zodb versions
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2379351
By: korakot

If leo use database storage (ZODB or otherwise)
it could scale much better. This will bring us some
possiblity to store all versions of changes to a node
or a tree.

Cloning will then point to a specific version. If there
is no conflict, it can update to a later version when
the primary clone change. If there is a conflict
we can deal with it wisely using 'diff information'
because we have 'all versions' stored.

#@-node:ekr.20040117092727.2:using zodb versions
#@+node:ekr.20031218072017.737:Leo & data bases
From: "Scott Chapman" <scott_list@mischko.com>
To: <edreamleo@charter.net>
Sent: Monday, November 10, 2003 11:05 AM
Subject: Enhancement request: Make Leo deal with a database

It would be Way Cool if Leo could deal with psycopg or other DataBase 
API compliant implementations and fetch and store database records.

Details of what I'd like to see:

I'm working on Python source code. I want Leo to pull a source code file 
from a database record built something like this:

filename: text
updated: datetimestamp
code: text

Leo would insert a new record, not update an existing one, each time a 
Save was done, with a more current time stamp.  

When a File Open was requested (i.e. a node on a existing Leo outline 
was being pulled from a database), Leo would fetch the most recent 
time-stamped version only.

I use this same technique for my wiki pages.  It's very easy to 
implement in SQL and works great.

Leo would also need the ability to save the same file to a regular 
python source code file on disk at a specific location, so you'd have 
to be able to put more than one save/load directive in a given node.

This would provide a nice version history and could lead to other Useful 
Things in Leo.

Scott
#@nonl
#@-node:ekr.20031218072017.737:Leo & data bases
#@-node:ekr.20031218072017.412:Zope postings
#@-node:ekr.20041228084018.5:Finish zodb plugin
#@+node:ekr.20050831131028:opml
#@+node:ekr.20050831131452:Original post
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3280949
By: billp9619

>>Making Leo a friendly part of the opml world has the potential to be very
important to Leo. <<

This is probably point 5. and covers the implementation of opml features as
exposed in Leo.

Because Leo is highly scripted there may be many requests... currently out on
the OPML list... that are solveable....such as how to see their outlines as
HTML without passing thru the OPML web server /host. BTW...all this new opml
stuff is only a week or two in production. The first message on
http://groups.yahoo.com/group/opml-newbies/
is July 25.

>> The question of whether to duplicate body text in <outline> elements
is minor<<

Good. 

Really, the opml tools are pretty much raw text/xml  and I was thinking the
default fallback is ... all clone text is "duplicate". If you want clones then
you will take care to only edit them in Leo. But if opml users all know and
use clones routinely in other editors,  then this is good news for opml
as technology.

>>more complicated than it needs to be<<

Well, both Leo and opml have only a few elements and each primarilly uses one
which recusively nests to make up the outline portion. I suppose body nodes
could be included more directly in headlines ... allowing un-numbered headlines
basically, ... but I am not sure that the current way is inferior
or complicated.

 A simpler (forgiving?) format might make it easier to create with external
apps and encourage transforming other xml to Leo via XSLT. It would have to
just "work".

(One thing about Leo's bias towards elements to contain markup, versus attributes,
is that ...you can cheat a little on escaping &quot; in vh or t nodes ?...which
makes code blocks smaller in the Leo xml.)

Your list above is pretty much how I see it as well.

regards,

bill p

#@-node:ekr.20050831131452:Original post
#@+node:ekr.20050831131452.1:opml attributes v elements
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3282460
By: billp9619

Looking at some discussion of outline formats there was a remark that because
opml places all text in attributes it is limited in not being able to contan
other elements. On xml-dev I also saw some advice about opml followed by the
comment that it is not a good format.

opml is crippled in this regard but  Leo only restricts itself as a choice in
order to  discern leo xml from content.(out of necessity we know).

Of course with xml you can mix vocabularies based on the use of namespaces.
By becoming namespace aware Leo could be adapted for non-escaped markup. The
purpose then is xml parsing of leo as a standard container of other xml. I do
not believe this is unthinkable  for some future capabilities... especially
if such nodes would contain exclusively xml from another namespace.

Just interesting that leo's format is more versatile than opml, 
but, ...by choice for its own purposes, ...
 is in this part "backward" compatible with opml. :)  

regards,

bill p
#@-node:ekr.20050831131452.1:opml attributes v elements
#@+node:ekr.20050912063133:@url http://sourceforge.net/forum/message.php?msg_id=3273977
#@-node:ekr.20050912063133:@url http://sourceforge.net/forum/message.php?msg_id=3273977
#@+node:ekr.20050912065811:@url http://sourceforge.net/forum/message.php?msg_id=3279900 (summary)
#@-node:ekr.20050912065811:@url http://sourceforge.net/forum/message.php?msg_id=3279900 (summary)
#@+node:ekr.20050915062404:My post
@nocolor

Hi,

I am the author of Leo http://webpages.charter.net/edreamleo/front.html an outline editor supporting clones http://webpages.charter.net/edreamleo/intro.html#clones-views.

I am interested in having Leo be able to read and write opml files.  My understanding is that applications are free to use attributes of <outline> elements as they please, but I am wondering whether there are guidelines or existing conventions for representing clones.  Have any namespaces been defined for that purpose?

Thanks.

Edward
#@-node:ekr.20050915062404:My post
#@-node:ekr.20050831131028:opml
#@+node:ekr.20060228072202:New undoer
#@+node:ekr.20060201161901.1:Postings re undo
#@+node:ekr.20060201161901.2:@url http://sourceforge.net/forum/message.php?msg_id=3332355
@nocolor

By: Edward K. Ream - edream 
   RE: Dividing The Undo: doing w/o v.uA 
2005-09-09 14:17  
> If we can open up how [Leo] reads xml, it may make it simpler to start developing a stash scheme. 
 
I agree that reading xml more properly would be A Good Thing (tm). As we shall see, however, it is not the main issue. 
 
> DOM seems like a good path to start out on. 
 
This is not the path I would have chosen. The new colorizer at in leoPlugins.leo at: 
 
Plugins-->Experimental/unfinished-->New colorizer-->@thin __jEdit_colorizer__.py 
 
uses sax. I like the light-weight approach. I would rather do a bit more work in the initial parsing and create the data structures myself then relying on DOM. 
 
But parsing is irrelevant. The problem is the design of *thin* derived files and the code that reads such files. Let us consider how we can "do without" v.unknownAttributes in thin derived files. I **shall not** change the format of thin derived files, so some trickery is required. The first step is read this section of Leo's new docs: 
 
http://webpages.charter.net/edreamleo/customizing.html#adding-extensible-attributes-to-nodes-and-leo-files  /> 
The key here is the so-called 'hidden machinery'. This is an essential feature of the code that reads and writes thin derived files and it **will not** change. **Note**: Leo has two sets of read code: the code that reads .leo files has no trouble whatever recreating vnodes. It is only vnodes in thin derived files that may not have attributes. 
 
**Important**: for @thin trees (in the outline) Leo saves *only* the <v> element corresponding to the @thin node itself. It is this <v> element that contains the 'hidden machinery'. Don't even think about having Leo write the whole tree of <v> elements: the 4.0 read code is made possible because these <v> elements do *not* exist. This eliminates all the error 'recovery' schemes that can not, if fact, be robust enough. 
 
So the only real alternative is to add uA's sufficient to recreate elements in the *reconstituted* vnodes that Leo creates in the leoAtFile read logic. Happily, we can do this as follows. When writing, a plugin (or an extended Leo) would 'piggyback' the vnode attributes in the corresponding **t**.unknownAttributes field. When reading, the plugin (or Leo) would put the vnode attributes "where they belong" in the appropriate vnode. We associate a 'vnode traversal index' with each vnode. This is simply how many previous "same" vnodes appeared in the traversal before getting to the desired vnode. Something like this:: 
 
vx = {} # traversal indices for vnodes. 
for p in c.allNodes_iter(): 
....n = vx.get(p.v.t,0) # n is the traversal index for vnode p.v. 
....vx[p.v.t] = n+1 # bump the index for the next v such that v.t == p.v.t 
 
We store attributes for vnode v in v.t.unknownAttributes, along with the traversal index. The read code uses the traversal index to copy vnode attributes from t.unknownAttributes to v.unknownAttrutes. Rather than forcing each plugin to do this, Leo should probably have support for this in the leoFileCommands read/write code. In short, the t.unknownAttributes machinery suffices in theory, and in practice a bit of support code would be good. 
 
Glad you asked :-) . I have been willing to live without v.uA's in thin derived files. I never thought much about this until you asked, but necessity is the mother... So this is good. A way exists to treat all vnodes as first-class citizens. 
 
Edward 
#@-node:ekr.20060201161901.2:@url http://sourceforge.net/forum/message.php?msg_id=3332355
#@-node:ekr.20060201161901.1:Postings re undo
#@+node:ekr.20060201152349:NodeUndoer.py
@ignore

<<imports>>
#commanders = util.WeakHashMap()
commanders = {}


class NodeUndoer:
    '''A class that manages NodeUndoerBase instances for tnodes'''
    
    undoers = {} #util.WeakHashMap()
    checksums = util.WeakHashMap()
    
    def __init__( self, c, umenu, rmenu, gtnu, gtnr, vunstack, clearundo ):
        '''c -> a commander
           umenu -> a JMenuItem that is the 'undo' action
           rmenu -> a JMenuItem that is the 'redo' action
           gtnu -> a JMenuItem that is the 'goto next undo' action
           gtnr -> a JMenuItem that is the 'goto next redo' action
           vunstack -> a JMenuItem that is the 'visualise undo stack' action
           clearundo -> a JMenuItem that is the 'clear undo stack' action
        '''
        
        self.c = c
        self.umenu = umenu
        umenu.actionPerformed = lambda event: self.undo()
        self.rmenu = rmenu
        rmenu.actionPerformed = lambda event: self.redo()
        self.gtnu = gtnu
        gtnu.actionPerformed = lambda event: self.gotoNextUndoSpot()
        self.gtnr = gtnr
        gtnr.actionPerformed = lambda event : self.gotoNextRedoSpot()
        self.umanager = None
        self.vunstack = vunstack
        vunstack.actionPerformed = lambda event: self.visualiseUndoStack()
        self.clearundo = clearundo
        clearundo.actionPerformed = lambda event: self.clearUndo()
        self.ignore = 0
        self.tnode = None
        self.compound = None 
        self.checksums_ok = 1
        self.checksum_violations = []
        wm1 = WeakMethod( self, "serializeForLeoFile" ); wm2 = WeakMethod( self, "unserializeFromLeoFile" )
        wm3 = WeakMethod( self, "checkSumViolation" )
        leoPlugins.registerHandler( "write-leo-file-data", wm1 )
        leoPlugins.registerHandler( "read-leo-file-data", wm2 )
        leoPlugins.registerHandler( "checksum-violation", wm3 )
    
    def undo( self ):
        
        if self.ignore: return
        self.ignore = 1
        self.umanager.undo()
        self.setMenu()
        self.ignore = 0
        return
        
    def redo( self ):
        
        if self.ignore: return
        self.ignore = 1
        self.umanager.redo()
        self.setMenu()
        self.ignore = 0
        return
        
    
    def setNode( self, p ):
        
        #print "SETTING NODE!!! %s" % t
        #print "FILEINDEX %s" % t.fileIndex
        #java.lang.Thread.dumpStack()
        v = p.v
        t = v.t
        #vid = v.vid
        
        if self.tnode:
            self.checksums[ self.tnode ] = md5.md5( self.tnode.bodyString ).hexdigest()
        
        #if self.undoers.containsKey( t ):
        if self.undoers.has_key( v ):
            #print "CONTAINTS %s" % t
            ua = self.undoers[ v ]
            print "--!!!!!!-- %s" % v
            print ua.__class__
            if ua.__class__ == leoSwingUndo.UndoBase:
                self.umanager = self.undoers[ v ]
                #if self.checksums.containsKey( v ):
                #    checksum = self.checksums[ v ]
                #    amd5 = md5.md5( t.bodyString )
                #    if amd5.hexdigest() != checksum:
                #        self.umanager.discardAllEdits()
                #        g.es( "Emptied undoer for %s:%s because of checksum mismatch" % ( t.headString, t ), color = "red" )
                #        #self.tnode = t
                #        #return
                #for z in self.umanager.undostack:
                #    commanders[ z ] = self.c
            else:
                print "UNPICKLING!!!!!"
                ua = cPickle.loads( ua )
                print "UNPICKLED Is now %s %s" % ( ua, len( ua.undostack ) )
                self.undoers[ v ] = ua
                self.umanager = ua
            if self.checksums.containsKey( t ):
                checksum = self.checksums[ t ]
                amd5 = md5.md5( t.bodyString )
                if amd5.hexdigest() != checksum:
                    self.umanager.discardAllEdits()
                    print "DISCARDED EDITSS!!!!"
                    g.es( "Emptied undoer for %s:%s because of checksum mismatch" % ( t.headString, t ), color = "red" )
                    #self.tnode = t
                    #return
            for z in self.umanager.undostack:
                commanders[ z ] = self.c
                                    
        else:
            print "V not in Undoers %s" % v
            #print v.vid
            self.umanager = leoSwingUndo.UndoBase()
            self.undoers[ v ] = self.umanager

        self.tnode = t
        self.setMenu()
        
    def __addUndo( self, undo ):
        #self.umanager.addEdit( undo )
        self.umanager.addUndo( undo )
        #upe = self.UndoableProxyEvent( undo, self.umanager, self, self.c )
        #self.c.undoer.addUndo( upe )
        #die_listeners[ undo ] = upe
        
        
    def addUndo( self, undo ):
        
        if not self.ignore:
            
            if self.compound:
                self.compound.addEdit( undo )
                return
            
            self.__addUndo( undo )                
    
        self.setMenu()
            
    def setMenu( self ):
        
        self.umenu.setText( self.umanager.getUndoPresentationName() )
        self.umenu.setEnabled( self.umanager.canUndo() )
        if self.umanager.canUndo():
            self.gtnu.setEnabled( 1 )
        else:
            self.gtnu.setEnabled( 0 )
        self.rmenu.setText( self.umanager.getRedoPresentationName() )    
        self.rmenu.setEnabled( self.umanager.canRedo() ) 
        if self.umanager.canRedo():
            self.gtnr.setEnabled( 1 )
        else:
            self.gtnr.setEnabled( 0 )
        
        self.c.undoer.setMenu()
               
    
    
    def getUStack( self, tnode ):
            
        if hasattr( tnode, 'unknownAttributes' ):
            uas = tnode.unknownAttributes
        else:
            tnode.unknownAttributes = uas = {}
        
        return uas
        

    def clearUndo( self ):
        
        self.umanager.discardAllEdits()
        self.setMenu()
        
    def gotoNextUndoSpot( self ):
        
        ua = self.umanager.editToBeUndone()
        if ua:
            spot = ua.spot
            self.c.frame.body._current_editor.setCaretPosition( spot )
            return
            
    def gotoNextRedoSpot( self ):
        ua = self.umanager.editToBeRedone()
        if ua:
            spot = ua.spot
            self.c.frame.body._current_editor.setCaretPosition( spot )
            return

    @others
    

                    
<<UndoableDocumentEvent>>
<<UndoableCompoundEvent>>




#@+node:ekr.20060201152349.1:<<imports>>
import java
import java.util as util
import javax.swing as swing
import javax.swing.undo as sundo
import javax.swing.event as sevent
import java.io as io
import jarray
import md5
import org.python.util as putil
import NodeUndoerBase
import LeoCompoundEdit
import leoGlobals as g
import zlib
import leoSwingUndo
import leoPlugins
import leoNodes
import base64
import pickle
import cPickle
from utilities.WeakMethod import WeakMethod
#@nonl
#@-node:ekr.20060201152349.1:<<imports>>
#@+node:ekr.20060201152349.2:visualiseUndoStack
def visualiseUndoStack( self ):
    
    umanager = self.umanager            
    table = swing.JTable( self.UneditableTableModel() )#( data, util.Vector( [ 'spot', 'data', 'action', 'redo/undo' ] ) )
    table.setSelectionMode( swing.ListSelectionModel.SINGLE_SELECTION )
    self.setDataForTable( table )

    
    jd = swing.JDialog()
    jd.setTitle( "Undo Stack" )
    cp = jd.getContentPane()
    cp.add( swing.JScrollPane( table ) )
    bholder = swing.JPanel()
    cp.add( bholder, java.awt.BorderLayout.SOUTH )
    uto = swing.JButton( "Undo To" )
    bholder.add( uto )
    <<_undoTo>>
    uto.actionPerformed = _undoTo
    
    rto = swing.JButton( "Redo To" )
    bholder.add( rto )
    <<_redoTo>>
    rto.actionPerformed = _redoTo
    
        
    jb = swing.JButton( "Close" )
    jb.actionPerformed = lambda event : jd.dispose()
    bholder.add( jb )
    jd.pack()
    g.app.gui.center_dialog( jd )
    jd.setModal( 1 )
    jd.show()
    
    
#@+node:ekr.20060201152349.3:<<_undoTo>>
def _undoTo( event ):
    sr = table.getSelectedRow()
    if sr == -1:
        swing.JOptionPane.showMessageDialog( None,
                                            "No Selected Row",
                                            "Select A Row Please",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
        return
    edits = umanager.getEdits()
    undo = edits.get( sr )
    if not undo.canUndo():
        swing.JOptionPane.showMessageDialog( None, 
                                            "Cant Undo To This Point", 
                                            "Illegal Undo Selection", 
                                            swing.JOptionPane.WARNING_MESSAGE )
        return
    self.ignore = 1
    umanager.undoTo( undo )
    self.ignore = 0
    self.setDataForTable( table )
#@-node:ekr.20060201152349.3:<<_undoTo>>
#@+node:ekr.20060201152349.4:<<_redoTo>>
def _redoTo( event ):
    sr = table.getSelectedRow()
    if sr == -1:
        swing.JOptionPane.showMessageDialog( None,
                                            "No Selected Row",
                                            "Select A Row Please",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
        return
    edits = umanager.getEdits()
    undo = edits.get( sr )
    if not undo.canRedo():
        swing.JOptionPane.showMessageDialog( None, 
                                            "Cant Redo To This Point", 
                                            "Illegal Redo Selection", 
                                            swing.JOptionPane.WARNING_MESSAGE )
        return
        
    self.ignore = 1
    umanager.redoTo( undo )
    self.ignore = 0
    self.setDataForTable( table )
    
#@-node:ekr.20060201152349.4:<<_redoTo>>
#@-node:ekr.20060201152349.2:visualiseUndoStack
#@+node:ekr.20060201152349.5:buildTableData
def buildTableData( self ):
    
    data = util.Vector()
    editu = self.umanager.editToBeUndone()
    editr = self.umanager.editToBeRedone()
    umanager = self.umanager
    cu = cr = -1
    edits = umanager.getEdits()
    for z in edits:
        if z.__class__ == LeoCompoundEdit:
            vec = java.util.Vector()
            edits2 = z.getEdits()
            spot = edits2[ 0 ].spot
            vec.add( spot )
            vec.add( "?" )
            vec.add( z.getPresentationName() )
            vec.add( "" )
        else:
            vec = z.getForTableModel()
            
        if z is editu:
            vec.set( 3, 'current undo' )
            cu = edits.indexOf( z )
        elif z.canUndo():
            vec.set( 3, 'undo' )
        if z is editr:
            vec.set( 3, 'current redo' )
            cr = edits.indexOf( z )
        elif z.canRedo():
            vec.set( 3, 'redo' )
        data.add( vec )
    
    return data, cu, cr


#@-node:ekr.20060201152349.5:buildTableData
#@+node:ekr.20060201152349.6:setDataForTable
def setDataForTable( self, table ):
    
    data, cu, cr = self.buildTableData()
    dm = table.getModel()
    dm.setDataVector( data, util.Vector( [ 'spot', 'data', 'action', 'redo/undo' ] ) )
    lsm = table.getSelectionModel()
    if cu != -1:
        lsm.setLeadSelectionIndex( cu )
    elif cr != -1:
        lsm.setLeadSelectionIndex( cr )
        
    
#@nonl
#@-node:ekr.20060201152349.6:setDataForTable
#@+node:ekr.20060201152349.7:pickle and unpickle
def serializeForLeoFile( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c:
        nwundoers = {}
        for z in self.undoers:
            if  self.undoers[ z ].__class__ == leoSwingUndo.UndoBase:
                nwundoers[ z.vid ] = cPickle.dumps( self.undoers[ z ] )
            else:
                nwundoers[ z.vid ] = self.undoers[ z ]
                
        store.addData( "tundoer", nwundoers ) #the storage class does the rest of the work for us
        

def unserializeFromLeoFile( self, tag, *args, **kwords ):

    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c and self.checksums_ok:
        try:
            udata = store.getData( "tundoer" )
            if udata:
                for z in udata:
                    if leoNodes.vid_vnode.has_key( z ):
                        #print "A connection %s %s" % ( z, leoNodes.vid_vnode[ z ] )
                        v = leoNodes.vid_vnode[ z ]
                        self.undoers[ v ] = udata[ z ]

        except:
            self.undostack = []
            self.undopointer = 0

    if not self.checksums_ok:
        self.checksums_ok = 1
        self.checksum_violations = []
        self.undostack = []
        self.undopointer = 0
        
#@-node:ekr.20060201152349.7:pickle and unpickle
#@+node:ekr.20060201152349.8:checkSumViolation
def checkSumViolation( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    filename = args[ 0 ][ 'filename' ]
    if c == self.c:
        self.checksums_ok = 0
        self.checksum_violations.append( filename )
#@nonl
#@-node:ekr.20060201152349.8:checkSumViolation
#@+node:ekr.20060201152349.9:startCompounding stopCompounding
def startCompounding( self, name ):
    self.compound = UndoableCompoundEvent( name )
    #self.compound = LeoCompoundEdit( name )
        
def stopCompounding( self ):
        
    compound = self.compound
    compound.end()
    self.compound = None
    #print "COMPOUND is %s" % compound
    self.__addUndo( compound )
    self.setMenu()
#@-node:ekr.20060201152349.9:startCompounding stopCompounding
#@+node:ekr.20060201152349.10:infrastructure
@others
#@nonl
#@+node:ekr.20060201152349.11:UneditableTableModel
class UneditableTableModel( swing.table.DefaultTableModel ):
    
    def __init__( self ):
        swing.table.DefaultTableModel.__init__( self )
        
    def isCellEditable( self, row, column ):
        return 0
        
#@-node:ekr.20060201152349.11:UneditableTableModel
#@+node:ekr.20060201152349.12:PickleProxy
class PickleProxy:
    '''This class exists to pickle the NodeUndoerBase instance into a form
       that can be safely stored in a Leo ua.'''
       
    def __init__( self, undoer, t ):
        self.undoer = undoer
        self.t = t
            
    def getPickleProxy( self ):
        
      
        try:
            #array = self.undoer.serializeSelf()
            data = pickle.dumps( self.undoer )
            ds = len( data )
            pp = zlib.compress( data, level = 9 )
            ps = len( pp )
            amd5 = md5.md5( self.t.bodyString )
            checksum = amd5.hexdigest()
            return pp, checksum 
        except Exception, x:
            return "", ""  
#@-node:ekr.20060201152349.12:PickleProxy
#@-node:ekr.20060201152349.10:infrastructure
#@+node:ekr.20060201152349.13:UndoableProxyEvent
class UndoableProxyEvent( sundo.UndoableEdit ):

       
    def __init__( self, event, owner, master , c):
        
        self.event = event
        self.owner = owner
        self.master = master
        self.c = c
        self.cp = c.currentPosition().copy()
        self._can_undo = event.canUndo()
        self._can_redo = event.canRedo()
        self.can_undo = self._can_undo
        self.can_redo = self._can_redo
        self.dieable = 0
        self.ignore = 0
        
    
    def __canRedo( self ):
        return self._can_redo == self.event.canRedo()
        
    def __canUndo( self ):
        return self._can_undo == self.event.canUndo()
            
            
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        #if self.__canUndo():
        return self.can_redo
        #else:
        #    return self.event.canRedo()
        
    def canUndo( self ):
        #if self.__canRedo():
        return self.can_undo
        #else:
        #    return self.event.canUndo()
        
    def isAlive( self ):
        return self.can_redo or self.can_undo
    
    def invalidate( self ):
        self.c.undoer.killFromEvent( self )
        
    def die( self ):    
        self.can_undo = self.can_redo = 0
        #edits = self.owner.getEdits()
        #spot = edits.indexOf( self.event )
        #self.owner.trimEdits( spot, edits.size() )
    
        
    def getPresentationName( self ):
        return self.event.getPresentationName()
        
    def getRedoPresentationName( self ):
        
        if self.__canRedo():
            return self.event.getRedoPresentationName()
        elif self.isAlive():
            return "Expended %s" % self.event.getRedoPresentationName()
        else:
            return "Dead %s" % self.event.getRedoPresentationName()
        
    def getUndoPresentationName( self ):
        
        if self.__canUndo():
            return self.event.getUndoPresentationName()
        elif self.isAlive():
            return "Expended %s" % self.event.getUndoPresentationName()
        else:
            return "Dead %s" % self.event.getUndoPresentationName()
        
        
    def isSignificant( self ):
        return 1
    
    def sync( self ):
        self._can_redo = self.event.canRedo()
        self._can_undo = self.event.canUndo()
        
    def redo( self ):
        
        self.c.selectPosition( self.cp.copy() )
        self.can_redo = 0
        self.can_undo = 1
        if self.__canRedo():
            self.master.ignore = 1
            if not self.ignore:
                self.owner.redo()
            self.master.ignore = 0
            self.master.setMenu()
            
        self.sync()
            
        
    def undo( self ):
        
        self.c.selectPosition( self.cp.copy() )
        self.can_undo = 0
        self.can_redo = 1
        if self.__canUndo():
            self.master.ignore = 1
            if not self.ignore:
                self.owner.undo()
            self.master.ignore = 0
            self.master.setMenu()
            
        self.sync()
        
    def replaceEdit( self, edit ):
        return 0
        

#@-node:ekr.20060201152349.13:UndoableProxyEvent
#@+node:ekr.20060201152349.14:<<UndoableDocumentEvent>>
class UndoableDocumentEvent3:#( sundo.UndoableEdit, io.Serializable ):
    '''A class that takes the current Editors document and does undo changes
       upon the data within the Editor.  It is assumed that the data in the document
       will be in sync with the changes represented within the UndoableDocumentEvent'''
       
    def __init__( self, c, event, txt = "" ):
        
        commanders[ self ] = c
        self.spot = event.getOffset()
        self.length = event.getLength()
        self.txt = txt

        self.can_undo = 1
        self.can_redo = 0
        if self.txt.isspace():
           name_txt = "%s whitespaces" % len( self.txt )
        else:
           name_txt = self.txt
        
        if event.getType() == sevent.DocumentEvent.EventType.INSERT:
            self.etype = "insert"
        elif event.getType() == sevent.DocumentEvent.EventType.REMOVE:
            self.etype = "remove"

            
            
        if self.etype == "insert":
            self.name = "insert %s" % name_txt  
        elif self.etype == "remove":
            self.name = "remove %s" % name_txt
    
    #def __getstate__( self ):
    #    dic = self.__dict__
    #    import copy
    #    rv = copy.copy( dic )
    #    #del rv[ c ]
    #    return rv        
            
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):    
        self.can_undo = self.can_redo = 0
        #if die_listeners.has_key( self ):
        #    dlistener = die_listeners[ self ]
        #    if dlistener.dieable:
        #        print "WHACKING %s" % dlistener
        #        dlistener.invalidate()
    
        
    def getPresentationName( self ):
        return self.name 
        
    def getRedoPresentationName( self ):
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        
    def redo( self ):
        
        self.can_redo = 0
        self.can_undo = 1
        self.redoEvent()
        
    def undo( self ):
        
        self.can_undo = 0
        self.can_redo = 1
        self.undoEvent()
        
    def replaceEdit( self, edit ):
        return 0
        
    def redoEvent( self ):
        
        c = commanders.get( self )
        doc = c.frame.body._current_editor.getDocument()
        if self.etype == "insert":
            doc.insertString( self.spot, self.txt, None )
            return       
        elif self.etype == "remove":            
            doc.remove( self.spot, self.length )
            return    
        
    def undoEvent( self ):
        

        c = commanders.get( self )                
        doc = c.frame.body._current_editor.getDocument()
        if self.etype == "insert":
            print 'undoing spot %s %s %s' % ( self.spot, self.length, self.txt )
            doc.remove( self.spot, self.length )
            print 'undone %s' % self
            return  
        elif self.etype == "remove":
            doc.insertString( self.spot, self.txt, None )
            return 

    def getForTableModel( self ):
        return util.Vector( [ self.spot, self.txt, self.name, '' ] )
        


#@-node:ekr.20060201152349.14:<<UndoableDocumentEvent>>
#@+node:ekr.20060201152349.15:<<UndoableCompoundEvent>>
class UndoableCompoundEvent3:
    
    def __init__( self, pname ):
        #self.ce = sundo.CompoundEdit()
        self.pname = pname
        self.undostack = []
        self.can_undo = 1
        self.can_redo = 0
        
    def getPresentationName( self ):
        return self.pname
        
    def getRedoPresentationName( self ):
        return "Redo %s" % self.pname
        
    def getUndoPresentationName( self ):
        return "Undo %s" % self.pname
        
    def canUndo( self ):
        return self.can_undo
        #return self.ce.canUndo()
        
    def canRedo( self ):
        return self.can_redo
        #return self.ce.canRedo()
        
    def undo( self ):
        for z in self.undostack:
            print z
            z.undo()
        self.can_undo = 0
        self.can_redo = 1
        
    def redo( self ):
        
        self.undostack.reverse()
        for z in self.undostack:
            print z
            z.redo()
        
        self.undostack.reverse()
        self.can_undo = 1
        self.can_redo = 0
        
    def isSignificant( self ):
        return 1
        #return self.ce.isSignificant()
        
    def addEdit( self, edit ):
        self.undostack.insert( 0, edit )
        

    
    def die( self ):
        pass
        #return self.ce.die()
        
    def end( self ):
        pass
        #return self.ce.end()
        
        

            
        

#@-node:ekr.20060201152349.15:<<UndoableCompoundEvent>>
#@-node:ekr.20060201152349:NodeUndoer.py
#@-node:ekr.20060228072202:New undoer
#@+node:ekr.20060531192407:IPython
#@-node:ekr.20060531192407:IPython
#@-node:ekr.20060527182117:Important 1-2 week projects (2-3 weeks)
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
