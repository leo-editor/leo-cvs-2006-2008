#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20060306194040:asap: Video and more screen shots on Leo's web site
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/


http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

Thanks,
Kent
#@nonl
#@+node:ekr.20060531134434:Tutorials
http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
#@nonl
#@-node:ekr.20060531134434:Tutorials
#@+node:ekr.20060531134434.1:Screencasts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3758303
By: ktenney

My sense is that documentation/screencasts has the
greatest potential for expanding Leo's mindshare.

I really like those produced by the good folks
at Dabo;
http://leafe.com/screencasts/
http://leafe.com/screencasts/populategrid.html

The TurboGears people have taken this to the extreme;
http://www.turbogears.org/ultimate.html

Leo is different enough that it warrants a 
demonstration of it's advantages.
#@nonl
#@-node:ekr.20060531134434.1:Screencasts
#@+node:ekr.20060829103523:Render Leo slideshows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3889246
By: terry_n_brown

Three packages that might be candidates for "rendering" slides authored in Leo:

MagicPoint: http://member.wide.ad.jp/wg/mgp/

  uses a text file format that leo could produce

Slidy: http://www.w3.org/Talks/Tools/Slidy/

  uses XHTML / canned Java script

S5: http://meyerweb.com/eric/tools/s5/

  Similar to Slidy I think, haven't looked at it
#@nonl
#@-node:ekr.20060829103523:Render Leo slideshows
#@-node:ekr.20060306194040:asap: Video and more screen shots on Leo's web site
#@+node:ekr.20060531161030:To do: 4.4.3
#@+node:ekr.20070505121642:Before b1
#@+node:ekr.20070506093903:Fix all unit tests on ubuntu
#@-node:ekr.20070506093903:Fix all unit tests on ubuntu
#@+node:ekr.20070506092941:Update release notes
#@-node:ekr.20070506092941:Update release notes
#@-node:ekr.20070505121642:Before b1
#@+node:ekr.20070505121642.1:Others
#@+node:ekr.20070426092031:Consider another way to compute home directory
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4281562
By: ktenney

I don't know if this is a resolved issue, here's another approach,
looks like a good one.

email link
http://murl.se/24201

python.org os.path doc
http://murl.se/24202

>>> import os
>>> lin_key, win_key = "home", "Documents"
>>> homedir = os.path.expanduser('~')
>>> if os.name == 'nt': os_key = win_key
>>> if os.name == 'posix': os_key = lin_key
>>> print homedir.find(os_key) > -1
True

#@-node:ekr.20070426092031:Consider another way to compute home directory
#@+node:ekr.20070325054325:Dist
#@+node:ekr.20070220082124.3:Make installing aspell easier
#@-node:ekr.20070220082124.3:Make installing aspell easier
#@+node:ekr.20070202080824:Enable more plugins by default
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4134565

I have been talking more and more people lately into giving Leo a try. These
are end-users, not programmer-type people. One of the problems I find is that
many features users expect as standard are plug-ins that are disabled at
startup.

From my experience, some of the plug-ins that people seem to want right away
are Cleo, Image, Maximize windows, Export to HTML, and Navibuttons.

Also, everyone seems to ask for spell checking, which I know is a separate install
(I haven't tried putting it in). Perhaps even that could be included?

I think it is a lot easier for power users to turn off things they don't like
than less sophisticated users to turn them on. However, I realize that each
additional plug-in means a longer load time and large memory footprint.

-------------------

From: Rich

These are the plugins that I use often:
Add directives & color markup
Cleo 3
Chapters 2 (unless Chapters works with newer releases, I will stick with Leo 4.4 final)
Group Operations
Nav_buttons
Open_with
RClick
Universal Scrolling

These are the plugins that I do not use too often:
New Buttons
UNL

The following are plugins I would like to use:
Edit Attributes
Conceptual Sort
Labels

"Labels" has a nice assortment of commands; however the labels are (1) not saved
between sessions, and (2) cannot be seen by "Edit Attributes."
I'd be more inclined to use "Edit Attributes" and "C-Sort" IF there was some
way to SEE the attributes (this goes for "Labels," as well).


---- Enable Aspell automatically if possible.

#@-node:ekr.20070202080824:Enable more plugins by default
#@+node:ekr.20061130084909:Improve What's special whitepaper
@nocolor

- Answer the question: how can Leo help me with programming?
#@nonl
#@-node:ekr.20061130084909:Improve What's special whitepaper
#@+node:ekr.20070215093739:Improve Leo's getting started page
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4159734
By: rogererens

Here are some issues with respect to installing Leo on Windows:

I think you should divide the "How to install Leo on Windows" into separate
sections: one section that describes the use of the installer and another one
that describes the use of the .zip-file. In the near future probably Vista deserves
its own section, too.

The notes warn about Python 2.4 and spaces in paths. The installer appears to
work properly with Python 2.5 though, and installing into a path that contains
spaces works fine too, AFAIK. Or are there any usability test cases to check
this?

Also, I would advice the person that is installing Leo to create an environment
variable (either a user variable or a system variable) called HOME with the
value "%USERPROFILE%\My Documents" when %HOME% does not yet exist (check in
a cmd-window by typing "echo %HOME%" without the quotes).
Then, after installing, a user should have the shortcut icon on his/her desktop;
change this by right-clicking and choosing properties to change the directory
where the application starts from the default "C:\Program Files\Leo\test\unittest"
into %HOME%.
I'm not sure if this could all be done automatically by the NSIS installer.

Finally, there's the issue that I installed Leo in the default Program Files
folder, while having the Administrator's role. After which I copied and adapted
the Leo shortcut to the desktop of a user with limited rights.
Unfortunately, when logged on as such a limited user, no plugins can be
enabled/disabled because of the restrictions on writing in program
files\leo\plugin.
(Even if the limited user _could_ write in that folder, it would be problematic:
his set of enabled plugins would overwrite the set of enabled plugins for the
administrator or another user).

Hope this helps to improve the installation experience for novices...
#@-node:ekr.20070215093739:Improve Leo's getting started page
#@+node:ekr.20070218143918:Improve Windows installation instructions
This section is way too confusing:
    
Users Guide-->Chapter 1: Installing Leo-->@rst html\install.html-->How to install Leo on Windows
#@nonl
#@-node:ekr.20070218143918:Improve Windows installation instructions
#@+node:ekr.20070307082503.1:Create Linux distribution
#@-node:ekr.20070307082503.1:Create Linux distribution
#@-node:ekr.20070325054325:Dist
#@+node:ekr.20070420080132:Better focus handling when clicking headline
# Tried and failed to improve things.  This logic is so tricky.
#@nonl
#@+node:ekr.20031218072017.2886:c.editHeadline
def editHeadline (self,event=None):
    
    '''Begin editing the headline of the selected node.'''
    
    c = self ; k = c.k ; tree = c.frame.tree
    
    if g.app.batchMode:
        c.notValidInBatchMode("Edit Headline")
        return
        
    if k:
        k.setDefaultUnboundKeyAction()
        k.showStateAndMode()

    tree.editLabel(c.currentPosition())
#@-node:ekr.20031218072017.2886:c.editHeadline
#@+node:ekr.20040803072955.127:tree.editLabel
def editLabel (self,p,selectAll=False):
    
    """Start editing p's headline."""

    c = self.c

    if p and p != self.editPosition():
        
        if self.trace_edit and not g.app.unitTesting:
            g.trace(p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(True)

    self.setEditPosition(p) # That is, self._editPosition = p
    
    #g.trace(c.edit_widget(p))
    
    if p and c.edit_widget(p):
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
#@-node:ekr.20040803072955.127:tree.editLabel
#@+node:ekr.20040803072955.87:onHeadlineClick
def onHeadlineClick (self,event,p=None):
    
    # g.trace('p',p)
    c = self.c ; w = event.widget
    
    if not p:
        try:
            p = w.leo_position
        except AttributeError:
            g.trace('*'*20,'oops')
    if not p: return 'break'
        
    # g.trace(g.app.gui.widget_name(w)) #p.headString())
    
    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal
#@-node:ekr.20040803072955.87:onHeadlineClick
#@+node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
def OnActivateHeadline (self,p,event=None):
    
    '''Handle common process when any part of a headline is clicked.'''
    
    # g.trace(p.headString())
    
    returnVal = 'break' # Default: do nothing more.

    try:
        c = self.c
        c.setLog()
        << activate this window >>
    except:
        g.es_event_exception("activate tree")
        
    return returnVal
#@+node:ekr.20040803072955.106:<< activate this window >>
if p == c.currentPosition():
    
    # The *second* click in the headline starts editing.
    if self.active:
        #g.trace("click 2")
        self.editLabel(p)
        returnVal = 'continue'
    else:
        #g.trace("click 1")
        # Set the focus immediately.  This is essential for proper editing.
        c.treeWantsFocusNow()
        returnVal = 'break'
else:
    #g.trace("not current")
    self.select(p,scroll=False)
    w  = c.frame.body.bodyCtrl
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        spot = p.v.t.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
    else:
        w.setInsertPoint(0)

    # if self.stayInTree:
        # c.treeWantsFocusNow()
    # else:
        # c.bodyWantsFocusNow()
    c.treeFocusHelper()
    returnVal = 'break'

# The next click *in the same headline* will start editing.
self.active = True
#@-node:ekr.20040803072955.106:<< activate this window >>
#@-node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
#@-node:ekr.20070420080132:Better focus handling when clicking headline
#@+node:ekr.20070506075357:Scroll commands are gui-dependent
#@+node:ekr.20060309060654:scrolling...
#@+node:ekr.20050920084036.116:scrollUp/Down/extendSelection
def scrollDown (self,event):
    '''Scroll the presently selected pane down one page.'''
    self.scrollHelper(event,'down',extend=False)

def scrollDownExtendSelection (self,event):
    '''Extend the text selection by scrolling the body text down one page.'''
    self.scrollHelper(event,'down',extend=True)

def scrollUp (self,event):
    '''Scroll the presently selected pane up one page.'''
    self.scrollHelper(event,'up',extend=False)

def scrollUpExtendSelection (self,event):
    '''Extend the text selection by scrolling the body text up one page.'''
    self.scrollHelper(event,'up',extend=True)
#@+node:ekr.20060113082917:scrollHelper
def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; gui = g.app.gui
    w = gui.eventWidget(event)
    if not w: return #  This does **not** require a text widget.

    if gui.isTextWidget(w):
        c.widgetWantsFocusNow(w)
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.getInsertPoint()
        s = w.getAllText()
        row,col = g.convertPythonIndexToRowCol(s,ins1)
        # Compute the spot.
        delta = self.measure(w)
        row1 = g.choose(direction=='down',row+delta,row-delta)
        row1 = max(0,row1)
        spot = g.convertRowColToPythonIndex(s,row1,col)
        # g.trace('spot',spot,'row1',row1)
        self.extendHelper(w,extend,spot)
        w.seeInsertPoint()
    elif gui.widget_name(w).startswith('canvas'):
        if direction=='down':
            self.scrollOutlineDownPage()
        else:
            self.scrollOutlineUpPage()
#@-node:ekr.20060113082917:scrollHelper
#@+node:ekr.20050920084036.147:measure
def measure (self,w):

    s = w.getAllText()
    ins = w.getInsertPoint()
    start, junk = g.convertPythonIndexToRowCol(s,ins)
    start += 1 ; delta = 0

    ustart = start - 1
    while ustart >= 1 and w.indexIsVisible('%s.0' % ustart):
        delta += 1 ; ustart -= 1

    ustart = start + 1
    while w.indexIsVisible('%s.0' % ustart):
        delta += 1 ; ustart += 1

    return delta
#@-node:ekr.20050920084036.147:measure
#@-node:ekr.20050920084036.116:scrollUp/Down/extendSelection
#@+node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
def scrollOutlineDownLine (self,event=None):
    '''Scroll the outline pane down one line.'''
    a,b = self.c.frame.canvas.leo_treeBar.get()
    if b < 1.0:
        self.c.frame.tree.canvas.yview_scroll(1,"unit")
    
def scrollOutlineDownPage (self,event=None):
    '''Scroll the outline pane down one page.'''
    a,b = self.c.frame.canvas.leo_treeBar.get()
    if b < 1.0:
        self.c.frame.tree.canvas.yview_scroll(1,"page")

def scrollOutlineUpLine (self,event=None):
    '''Scroll the outline pane up one line.'''
    a,b = self.c.frame.canvas.leo_treeBar.get()
    if a > 0.0:
        self.c.frame.tree.canvas.yview_scroll(-1,"unit")

def scrollOutlineUpPage (self,event=None):
    '''Scroll the outline pane up one page.'''
    a,b = self.c.frame.canvas.leo_treeBar.get()
    if a > 0.0:
        self.c.frame.tree.canvas.yview_scroll(-1,"page")
#@-node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
#@+node:ekr.20060726154531:scrollOutlineLeftRight
def scrollOutlineLeft (self,event=None):
    '''Scroll the outline left.'''
    self.c.frame.tree.canvas.xview_scroll(1,"unit")
    
def scrollOutlineRight (self,event=None):
    '''Scroll the outline left.'''
    self.c.frame.tree.canvas.xview_scroll(-1,"unit")
#@-node:ekr.20060726154531:scrollOutlineLeftRight
#@-node:ekr.20060309060654:scrolling...
#@-node:ekr.20070506075357:Scroll commands are gui-dependent
#@+node:ekr.20070427094150:Fix memory leaks
#@+node:ekr.20070505072655:To do: clear injected ivars (w.leo_xxx etc) when recycling widgets
#@-node:ekr.20070505072655:To do: clear injected ivars (w.leo_xxx etc) when recycling widgets
#@+node:ekr.20031218072017.3964:Destroying the tkFrame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body
    
    # g.printGcAll()

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    if c.chapterController:
        # New in Leo 4.4.3 b1.
        g.clearAllIvars(c.chapterController.tt) 
        g.clearAllIvars(c.chapterController)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.keyHandler) # New in Leo 4.4.3 b1.
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
   
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)
    
    
#@nonl
#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf (tkFrame)
def destroySelf (self):
    
    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c
    
    # Indicate that the commander is no longer valid.
    c.exists = False 
    
    # g.trace(self)

    # Important: this destroys all the objects of the commander too.
    self.destroyAllObjects()
    
    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()
#@-node:ekr.20031218072017.1974:destroySelf (tkFrame)
#@-node:ekr.20031218072017.3964:Destroying the tkFrame
#@+node:ekr.20070429092848.1:Interesting methods
#@+node:ekr.20031218072017.1329:onBodyChanged (leoBody)
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c
    bodyCtrl = w = body.bodyCtrl
    p = c.currentPosition()
    insert = w.getInsertPoint()
    ch = g.choose(insert==0,'',w.get(insert-1))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = w.getAllText() # Note: getAllText converts to unicode.
    # g.trace('newText',repr(newText),g.callers())
    newSel = w.getSelectionRange()
    if not oldText:
        oldText = p.bodyString() ; changed = True
    else:
        changed = oldText != newText
    # g.trace(repr(ch),'changed:',changed,'newText:',repr(newText))
    if not changed: return
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertPoint()
    << recolor the body >>
    if not c.changed: c.setChanged(True)
    self.updateEditors()
    << redraw the screen if necessary >>
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    # g.trace('new val:',val,'old val:',hasattr(p.v,'iconVal') and p.v.iconVal or '<None>')
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1329:onBodyChanged (leoBody)
#@+node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:EKR.20040602125018:enableIdleTimeHook
@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
#@-node:EKR.20040602125018:enableIdleTimeHook
#@+node:EKR.20040602125018.1:disableIdleTimeHook
# Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False
#@-node:EKR.20040602125018.1:disableIdleTimeHook
#@+node:EKR.20040602125018.2:idleTimeHookHandler
# An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args & keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for z in g.app.windowList:
                c = z.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for z in g.app.windowList:
        c = z.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
#@-node:EKR.20040602125018.2:idleTimeHookHandler
#@-node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:ekr.20031218072017.1596:g.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. c.hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError: # or (g.app.gui and g.app.gui.isNullGui):
        return None
        
    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag in ('open0','start1'):
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            g.es_print(s,color="blue")
        return None
         
    # Get the hook handler function.  Usually this is doPlugins.
    c = keywords.get("c")
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins
        
    try:
        # Pass the hook to the hook handler.
        # print 'doHook',f.__name__,keywords.get('c')
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
#@-node:ekr.20031218072017.1596:g.doHook
#@+node:ekr.20061031131434.105:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''
    
    k = self ; c = k.c ; gui = g.app.gui
    trace = False or k.traceMasterCommand
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
#@nonl
#@+node:ekr.20061031131434.106:<< define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@nonl
#@-node:ekr.20061031131434.106:<< define specialKeysyms >>
#@+node:ekr.20061031131434.107:<< add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
#@-node:ekr.20061031131434.107:<< add character to history >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.109:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)
    
    return func
#@-node:ekr.20061031131434.109:callKeystrokeFunction (not used)
#@+node:ekr.20061031131434.110:handleDefaultChar
def handleDefaultChar(self,event,stroke):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: pass # Ignore the key.
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@-node:ekr.20061031131434.110:handleDefaultChar
#@-node:ekr.20061031131434.105:masterCommand & helpers
#@+node:ekr.20061031131434.146:masterKeyHandler
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''

    << define vars >>
    if keysym in special_keys: return None
    
    trace = False or self.trace_masterKeyHandler and not g.app.unitTesting
    traceGC = False or self.trace_masterKeyHandlerGC and not g.app.unitTesting
    if traceGC: g.printNewObjects('masterKey 1')
    if trace:
        g.trace('stroke:',repr(stroke),'keysym:',repr(event.keysym),'ch:',repr(event.char),
            'state.kind:',k.state.kind,g.callers(4))
        # if (self.master_key_count % 100) == 0: g.printGcSummary()

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        # g.trace('special case')
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>
        
    if traceGC: g.printNewObjects('masterKey 2')
        
    << handle per-pane bindings >>
    << handle keys without bindings >>
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event: event = gui.leoKeyEvent(event,c)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.149:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            ok = k.handleMiniBindings(event,state,stroke)
            if ok:
                return 'break'
            elif stroke and len(stroke) == 1:
                # if trace: g.trace('calling modeHelp')
                k.modeHelp(event)
                return 'break'
            else:
                # End the mode and fall through to the pane bindings!
                k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@-node:ekr.20061031131434.149:<< handle mode bindings >>
#@+node:ekr.20061031131434.150:<< handle per-pane bindings >>
keyStatesTuple = ('command','insert','overwrite')
isPlain =  k.isPlainKey(stroke)

# g.trace('w_name',w_name,'w',w,'isTextWidget(w)',g.app.gui.isTextWidget(w))
# g.trace('button',k.masterBindingsDict.get('button'))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d.keys())
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20061031131434.150:<< handle per-pane bindings >>
#@+node:ekr.20061031131434.151:<< handle keys without bindings >>
if traceGC: g.printNewObjects('masterKey 5')

modesTuple = ('insert','overwrite')

if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
    # insert/overwrite normal character.  <Return> is *not* a normal character.
    if trace: g.trace('plain key in insert mode',repr(stroke))
    if traceGC: g.printNewObjects('masterKey 4')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
    
elif keysym.find('Escape') != -1:
    # Never insert escape characters.
    return 'break'

else:
    if trace: g.trace(repr(stroke),'no func')
    if traceGC: g.printNewObjects('masterKey 6')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20061031131434.151:<< handle keys without bindings >>
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = False or self.trace_masterKeyHandler and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                if not k.silentMode:
                    c.minibufferWantsFocus()
                return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@-node:ekr.20061031131434.146:masterKeyHandler
#@+node:ekr.20061031131434.76: ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    # g.trace('base keyHandler',g.callers())
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    
    # These must be defined here to avoid memory leaks.
    self.enable_autocompleter           = c.config.getBool('enable_autocompleter_initially')
    self.enable_calltips                = c.config.getBool('enable_calltips_initially')
    self.ignore_caps_lock               = c.config.getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = c.config.getBool('ignore_unbound_non_ascii_keys')
    self.swap_mac_keys                  = c.config.getBool('swap_mac_keys')
    self.trace_bind_key_exceptions      = c.config.getBool('trace_bind_key_exceptions')
    self.traceMasterCommand             = c.config.getBool('trace_masterCommand')
    self.trace_masterKeyHandler         = c.config.getBool('trace_masterKeyHandler')
    self.trace_masterKeyHandlerGC       = c.config.getBool('trace_masterKeyHandlerGC')
    self.trace_key_event                = c.config.getBool('trace_key_event')
    self.trace_minibuffer               = c.config.getBool('trace_minibuffer')
    self.warn_about_redefined_shortcuts = c.config.getBool('warn_about_redefined_shortcuts')
    << define externally visible ivars >>
    << define internal ivars >>
    
    self.defineTkNames()
    self.defineSpecialKeys()
    self.autoCompleter = autoCompleterClass(self)
    self.setDefaultUnboundKeyAction()
#@+node:ekr.20061031131434.78:<< define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.previousSelection = None # A hack for middle-button paste: set by masterClickHandler, used by pasteText.
self.state = g.bunch(kind=None,n=None,handler=None)
#@-node:ekr.20061031131434.78:<< define externally visible ivars >>
#@+node:ekr.20061031131434.79:<< define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
#@-node:ekr.20061031131434.79:<< define internal ivars >>
#@-node:ekr.20061031131434.76: ctor (keyHandler)
#@-node:ekr.20070429092848.1:Interesting methods
#@+node:ekr.20031218072017.1588:Garbage Collection
# debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

@others
#@+node:ekr.20031218072017.1589:clearAllIvars
def clearAllIvars (o):
    
    """Clear all ivars of o, a member of some class."""
    
    if o:
        o.__dict__.clear()
#@-node:ekr.20031218072017.1589:clearAllIvars
#@+node:ekr.20031218072017.1590:collectGarbage
def collectGarbage():

    try:
        if not g.app.trace_gc_inited:
            g.enable_gc_debug()

        if g.app.trace_gc_verbose or g.app.trace_gc_calls:
            # print('Collecting garbage',g.callers())
            print 'collectGarbage:'

        gc.collect()
    except Exception:
        pass
        
    # Only init once, regardless of what happens.
    g.app.trace_gc_inited = True
#@-node:ekr.20031218072017.1590:collectGarbage
#@+node:ekr.20060127162818:enable_gc_debug
no_gc_message = False

def enable_gc_debug(event=None):
    
    if gc:
        if g.app.trace_gc_verbose:
            gc.set_debug(
                gc.DEBUG_STATS | # prints statistics.
                gc.DEBUG_LEAK | # Same as all below.
                gc.DEBUG_COLLECTABLE |
                gc.DEBUG_UNCOLLECTABLE |
                gc.DEBUG_INSTANCES |
                gc.DEBUG_OBJECTS |
                gc.DEBUG_SAVEALL
            )
        # else:
            # gc.set_debug(gc.DEBUG_STATS)
    elif not g.no_gc_message:
        g.no_gc_message = True
        g.es('Can not import gc module',color='blue')
#@-node:ekr.20060127162818:enable_gc_debug
#@+node:ekr.20031218072017.1592:printGc
# Formerly called from unit tests.

def printGc(tag=None):
    
    if not g.app.trace_gc: return None
    
    tag = tag or g._callerName(n=2)
        
    printGcObjects(tag=tag)
    printGcRefs(tag=tag)
    
    if g.app.trace_gc_verbose:
        printGcVerbose(tag=tag)
#@+node:ekr.20031218072017.1593:printGcRefs
def printGcRefs (tag=''):

    refs = gc.get_referrers(app.windowList[0])
    print('-' * 30,tag)

    if g.app.trace_gc_verbose:
        print("refs of", app.windowList[0])
        for ref in refs:
            print(type(ref))
    else:
        print("%d referers" % len(refs))
#@-node:ekr.20031218072017.1593:printGcRefs
#@-node:ekr.20031218072017.1592:printGc
#@+node:ekr.20060202161935:printGcAll
def printGcAll (tag=''):

    # Suppress warning about keywords arg not supported in sort.
    
    tag = tag or g._callerName(n=2)
    d = {} ; objects = gc.get_objects()
    print('-' * 30)
    print('%s: %d objects' % (tag,len(objects)))

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except: pass
        # if type(obj) == type(()):
            # print id(obj),repr(obj)
        d[t] = d.get(t,0) + 1
        
    if 1: # Sort by n
        items = d.items()
        try:
            # Support for keword args to sort function exists in Python 2.4.
            # Support for None as an alternative to omitting cmp exists in Python 2.3.
            items.sort(key=lambda x: x[1],reverse=True)
        except: pass
        for z in items:
            print '%40s %7d' % (z[0],z[1])
    else: # Sort by type
        keys = d.keys() ; keys.sort()
        for t in keys:
            print '%40s %7d' % (t,d.get(t))
#@-node:ekr.20060202161935:printGcAll
#@+node:ekr.20060127164729.1:printGcObjects   (printNewObjects=pno)
def printGcObjects(tag=''):
    
    '''Print newly allocated objects.'''
    
    tag = tag or g._callerName(n=2)
    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount
        if delta == 0: return
        lastObjectCount = n2
        
        << print number of each type of object >>
        if 0:
            << print added functions >>

    except Exception:
        traceback.print_exc()
        
printNewObjects = pno = printGcObjects

#@+node:ekr.20040703054646:<< print number of each type of object >>
global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    t = type(obj)
    if t == 'instance' and t not in types.StringTypes:
        try: t = obj.__class__
        except: pass
    if t != types.FrameType:
        r = repr(t) # was type(obj) instead of repr(t)
        n = typesDict.get(r,0) 
        typesDict[r] = n + 1
    
# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)
           
empty = True
for key in keys:
    n3 = lastTypesDict.get(key,0)
    n4 = typesDict.get(key,0)
    delta2 = n4-n3
    if delta2 != 0:
        empty = False
        break

if not empty:
    # keys = [repr(key) for key in keys]
    keys.sort()
    print '-' * 30
    print "%s: garbage: %d, objects: %d, delta: %d" % (tag,n,n2,delta)
    
    if 0:
        for key in keys:
            n1 = lastTypesDict.get(key,0)
            n2 = typesDict.get(key,0)
            delta2 = n2-n1
            if delta2 != 0:
                print("%+6d =%7d %s" % (delta2,n2,key))

lastTypesDict = typesDict
typesDict = {}
#@-node:ekr.20040703054646:<< print number of each type of object >>
#@+node:ekr.20040703065638:<< print added functions >>
# import types
import inspect

global lastFunctionsDict

funcDict = {}

# Don't print more than 50 objects.
n = 0
for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        n += 1

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if n < 50 and not lastFunctionsDict.has_key(key):
            print(obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            print("args", args)
            if varargs: print("varargs",varargs)
            if varkw: print("varkw",varkw)
            if defaults:
                print("defaults...")
                for s in defaults: print(s)

lastFunctionsDict = funcDict
funcDict = {}
#@-node:ekr.20040703065638:<< print added functions >>
#@-node:ekr.20060127164729.1:printGcObjects   (printNewObjects=pno)
#@+node:ekr.20060205043324.1:printGcSummary
def printGcSummary (tag=''):
    
    tag = tag or g._callerName(n=2)

    g.enable_gc_debug()

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = '%s: printGCSummary: garbage: %d, objects: %d' % (tag,n,n2)
        print s
    except:
        traceback.print_exc()
#@-node:ekr.20060205043324.1:printGcSummary
#@+node:ekr.20060127165509:printGcVerbose
# WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(tag=''):
    
    tag = tag or g._callerName(n=2)
    global lastObjectsDict
    objects = gc.get_objects()
    newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]
    
    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o
        
    dicts = 0 ; seqs = 0
    
    i = 0 ; n = len(newObjects)
    while i < 100 and i < n:
        o = newObjects[i]
        if type(o) == type({}): dicts += 1
        elif type(o) in (type(()),type([])):
            #print id(o),repr(o)
            seqs += 1
        #else:
        #    print(o)
        i += 1
    print('=' * 40)
    print('dicts: %d, sequences: %d' % (dicts,seqs))
    print("%s: %d new, %d total objects" % (tag,len(newObjects),len(objects)))
    print('-' * 40)
#@-node:ekr.20060127165509:printGcVerbose
#@-node:ekr.20031218072017.1588:Garbage Collection
#@-node:ekr.20070427094150:Fix memory leaks
#@+node:ekr.20070426080015:Fix crasher in dynamic abbreviations
#@+node:ekr.20070506094429:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4255709

I have some questions about the usage of dynamic abbreviations in Leo. As an
Emacs user, I know how they work in Emacs: they expand partially entered words
using a dictionary of words from the currently open buffers.

- I found a thread in the SF Forums titled "dynamic-abbreviations increases
its scope", 07-20-2005. The functionality described in this thread seems to
be the functionality I am familiar with as an Emacs uses. Is this the functionality
accessed through the commands dabbrev-completion and dabbrev-expands ?
- What is the difference between dabbrev-completion and dabbrev-expands ? 
- I often get a TK exception when I use dabbrev-completion "TypeError: reduce()
of empty sequence with no initial value". What am I doing wrong ?

Can somebody answer these questions for me or point me to documentation that
describes Leo's support for dynamic abbreviations?

-----------
http://sourceforge.net/forum/message.php?msg_id=4260706
 
command completion is shell or readline functionality to automatically finish
what you've typed so far, thus "completing" the type-in of the command for you.

abbreviation expansion is actually going to put a bunch of characters in your
buffer where you only had to enter the abbreviation for it.

---------
http://sourceforge.net/forum/message.php?msg_id=4263851

Already solved a part of it. The exception is raised when the characters entered
cannot be completed to a previously typed word. In LeoPy.leo, Code-->Core
classes...-->@thin leoEditCommands.py-->editCommandsClass-->dynamic
abbreviation...-->dynamicExpansion2, no check is made that the call to
self.getDynamicList does not retrieve an empty list. I've added this check (locally)
and at least the exception is not raised anymore. Apparently I am the only one
using this functionality, otherwise taht person surely would have also encountered
the problem.

Unfortunately, when looking at the code it seems that only those words are completed
in the current node :( Is there another mechanism for completion (that also
considers other, e.g. previously viewed, nodes) or am I overlooking something ?
#@nonl
#@-node:ekr.20070506094429:Report
#@+node:ekr.20050920084036.13:abbrevCommandsClass (test)
@

type some text, set its abbreviation with Control-x a i g, type the text for abbreviation expansion
type Control-x a e ( or Alt-x expand-abbrev ) to expand abbreviation
type Alt-x abbrev-on to turn on automatic abbreviation expansion
Alt-x abbrev-on to turn it off

an example:
type:
frogs
after typing 's' type Control-x a i g.  This will turn the miniBuffer blue, type in your definition. For example: turtles.

Now in the buffer type:
frogs
after typing 's' type Control-x a e.  This will turn the 'frogs' into:
turtles
@c

class abbrevCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20050920084036.14: ctor & finishCreate
def __init__ (self,c):
    
    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    # Set local ivars.
    self.abbrevs ={}
    
def finishCreate(self):
    
    baseEditCommandsClass.finishCreate(self)
#@-node:ekr.20050920084036.14: ctor & finishCreate
#@+node:ekr.20050920084036.15: getPublicCommands & getStateCommands
def getPublicCommands (self):
    
    return {
        'abbrev-mode':                  self.toggleAbbrevMode,
        'add-global-abbrev':            self.addAbbreviation,
        # 'expand-abbrev':              self.expandAbbrev, # Not a command.
        'expand-region-abbrevs':        self.regionalExpandAbbrev,
        'inverse-add-global-abbrev':    self.addInverseAbbreviation,
        'kill-all-abbrevs':             self.killAllAbbrevs,
        'list-abbrevs':                 self.listAbbrevs,
        'read-abbrev-file':             self.readAbbreviations,
        'write-abbrev-file':            self.writeAbbreviations,
    }
#@-node:ekr.20050920084036.15: getPublicCommands & getStateCommands
#@+node:ekr.20050920084036.25:addAbbreviation
def addAbbreviation (self,event):
    
    '''Add an abbreviation:
    The selected text is the abbreviation;
    the minibuffer prompts you for the name of the abbreviation.
    Also sets abbreviations on.'''
            
    k = self.k ; state = k.getState('add-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Abbreviation: ',protect=True)
        k.getArg(event,'add-abbr',1,self.addAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        if k.arg.strip():
            self.abbrevs [k.arg] = word
            k.abbrevOn = True
            k.setLabelGrey(
                "Abbreviations are on.\nAbbreviation: '%s' = '%s'" % (
                k.arg,word))
#@-node:ekr.20050920084036.25:addAbbreviation
#@+node:ekr.20051004080550:addInverseAbbreviation
def addInverseAbbreviation (self,event):
    
    '''Add an inverse abbreviation:
    The selected text is the abbreviation name;
    the minibuffer prompts you for the value of the abbreviation.'''
    
    k = self.k ; state = k.getState('add-inverse-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Inverse Abbreviation: ',protect=True)
        k.getArg(event,'add-inverse-abbr',1,self.addInverseAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        if word:
            self.abbrevs [word] = k.arg
#@-node:ekr.20051004080550:addInverseAbbreviation
#@+node:ekr.20050920084036.27:expandAbbrev
def expandAbbrev (self,event):
    
    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.'''

    k = self.k ; c = self.c ; ch = event.char.strip()
    w = self.editWidget(event)
    if not w: return

    word = w.get('insert -1c wordstart','insert -1c wordend')
    g.trace('ch',repr(ch),'word',repr(word))
    if ch:
        # We must do this: expandAbbrev is called from Alt-x and Control-x,
        # we get two differnt types of data and w states.
        word = '%s%s'% (word,ch)
        
    val = self.abbrevs.get(word)
    if val is not None:
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        if i != j: w.delete(i,j)
        w.insert(i,val)
        c.frame.body.onBodyChanged(undoType='Typing')
        
    return val is not None
#@-node:ekr.20050920084036.27:expandAbbrev
#@+node:ekr.20050920084036.18:killAllAbbrevs
def killAllAbbrevs (self,event):
    
    '''Delete all abbreviations.'''

    self.abbrevs = {}
#@-node:ekr.20050920084036.18:killAllAbbrevs
#@+node:ekr.20050920084036.19:listAbbrevs
def listAbbrevs (self,event):
    
    '''List all abbreviations.'''

    k = self.k
    
    if self.abbrevs:
        for z in self.abbrevs:
            g.es('%s=%s' % (z,self.abbrevs[z]))
#@-node:ekr.20050920084036.19:listAbbrevs
#@+node:ekr.20050920084036.20:readAbbreviations
def readAbbreviations (self,event):
    
    '''Read abbreviations from a file.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Abbreviation File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return
        
    try:
        f = open(fileName)
        for x in f:
            a, b = x.split('=')
            b = b [:-1]
            self.abbrevs [a] = b
        f.close()
    except IOError:
        g.es('Can not open',fileName)
#@-node:ekr.20050920084036.20:readAbbreviations
#@+node:ekr.20050920084036.21:regionalExpandAbbrev (TK code)
def regionalExpandAbbrev (self,event):
    
    '''Exapand abbreviations throughout a region.'''

    k = self.k ; w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    i1,i2 = w.getSelectionRange()
    ins = w.getInsertPoint()
    << define a new generator searchXR >>

    # EKR: the 'result' of calling searchXR is a generator object.
    k.regx.iter = searchXR(i1,i2,ins,event)
    k.regx.iter.next() # Call it the first time.
#@nonl
#@+node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
@ This is a generator (it contains a yield).
To make this work we must define a new generator for each call to regionalExpandAbbrev.
@c
def searchXR (i1,i2,ins,event):
    k = self.k
    w = self.editWidget(event)
    if not w: return

    w.tag_add('sXR',i1,i2)
    while i1:
        tr = w.tag_ranges('sXR')
        if not tr: break
        i1 = w.search(r'\w',i1,stopindex=tr[1],regexp=True)
        if i1:
            word = w.get('%s wordstart' % i1,'%s wordend' % i1)
            w.tag_delete('found')
            w.tag_add('found','%s wordstart' % i1,'%s wordend' % i1)
            w.tag_config('found',background='yellow')
            if self.abbrevs.has_key(word):
                k.setLabel('Replace %s with %s? y/n' % (word,self.abbrevs[word]))
                yield None
                if k.regXKey == 'y':
                    ind = w.index('%s wordstart' % i1)
                    w.delete('%s wordstart' % i1,'%s wordend' % i1)
                    w.insert(ind,self.abbrevs[word])
            i1 = '%s wordend' % i1
    w.setInsertPoint(ins,ins,insert=ins)
    w.tag_delete('sXR')
    w.tag_delete('found')
    k.setLabelGrey('')
    self.k.regx = g.bunch(iter=None,key=None)
#@-node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
#@-node:ekr.20050920084036.21:regionalExpandAbbrev (TK code)
#@+node:ekr.20050920084036.23:toggleAbbrevMode
def toggleAbbrevMode (self,event):
    
    '''Toggle abbreviation mode.'''
 
    k = self.k
    k.abbrevOn = not k.abbrevOn
    k.keyboardQuit(event)
    k.setLabel('Abbreviations are ' + g.choose(k.abbrevOn,'On','Off'))
#@-node:ekr.20050920084036.23:toggleAbbrevMode
#@+node:ekr.20050920084036.24:writeAbbreviations
def writeAbbreviations (self,event):
    
    '''Write abbreviations to a file.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Write Abbreviations',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")
        
    if not fileName: return

    try:
        f = open(fileName,'w')
        for x in self.abbrevs:
            f.write('%s=%s\n' % (x,self.abbrevs[x]))
        f.close()
    except IOError:
        g.es('Can not create',fileName)
#@-node:ekr.20050920084036.24:writeAbbreviations
#@-node:ekr.20050920084036.13:abbrevCommandsClass (test)
#@+node:ekr.20050920084036.58:dynamic abbreviation...
#@+node:ekr.20050920084036.59:dynamicExpansion LATER
def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() not in ('null','tkinter'):
        return g.es('command not ready yet',color='blue')

    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if rlist:
            txt = rlist.pop()
            doDa(txt)
#@-node:ekr.20050920084036.59:dynamicExpansion LATER
#@+node:ekr.20050920084036.60:dynamicExpansion2 LATER
def dynamicExpansion2 (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    if rlist:
        dEstring = reduce(g.longestCommonPrefix,rlist)
        if dEstring:
            w.delete(i,i2)
            w.insert(i,dEstring)
#@-node:ekr.20050920084036.60:dynamicExpansion2 LATER
#@+node:ekr.20050920084036.61:getDynamicList (helper)
def getDynamicList (self,w,txt,rlist):

     ttext = w.getAllText()
     items = self.dynaregex.findall(ttext) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith(txt) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)
#@-node:ekr.20050920084036.61:getDynamicList (helper)
#@-node:ekr.20050920084036.58:dynamic abbreviation...
#@-node:ekr.20070426080015:Fix crasher in dynamic abbreviations
#@-node:ekr.20070505121642.1:Others
#@-node:ekr.20060531161030:To do: 4.4.3
#@+node:ekr.20070325052041:To do: 4.4.4 (@auto)
#@+node:ekr.20070512162750:@url http://simpleparse.sourceforge.net/
#@-node:ekr.20070512162750:@url http://simpleparse.sourceforge.net/
#@+node:ekr.20061006165447:Let import commands decide what kind of import to do
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3940843
By: ktenney

>the distiction between importing 'foreign' text files and importing derived
files created by Leo.

Couldn't Leo make this distinction by looking at
the file being imported? If so, I think it should.

This could eliminate a lot of confusion IMO, if
I want to bring a file into a node, just
'import' it, and the right thing happens.

An emergency measure could be available in a 
'File Special' menu.
#@nonl
#@-node:ekr.20061006165447:Let import commands decide what kind of import to do
#@+node:ekr.20070324084040:Prototype of @auto
#@+node:ekr.20070324084040.1:NEWscanPythonText
def NEWscanPythonText (self,s,parent):
    
    scanner = self.pythonScanner(self,s,parent)
    
    scanner.parse()
        # Discover the node boundaries.
    scanner.checkWhitespace()
        # Check that whitespace passes TabNanny.
        # Check that whitespace is compatible with @tabwidth.
        # Check for underindented lines.
    scanner.generateNodes()
        # Generate a single node if there are errors,
        # otherwise generate the imported tree.
    scanner.checkImport()
        # Do trial write, verify that it would produce the original file.
        # Insert an @ignore directive in the root if there are errors.
#@nonl
#@-node:ekr.20070324084040.1:NEWscanPythonText
#@+node:ekr.20070324084040.13:class pythonScanner (not ready yet)
class pythonScanner:
    
    @others
    
    
#@nonl
#@+node:ekr.20070324084040.14:ctor (pythonScanner)
def __init__ (self,importer,s,parent):

    baseScannerClass.__init__(self,importer)
        # Init the base class.
        # Copies ivars from importer class to scanner class.

    # Other ivars.
    self.preamble_seen = False
    self.s = s
    self.className = None
    self.methodsSeen = False
    self.root = parent
    self.start = 0
#@-node:ekr.20070324084040.14:ctor (pythonScanner)
#@+node:ekr.20070324084040.15:scanPythonText
# See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    c = self.c
    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << handle possible Python function or class >>
        else: i += 1
        assert(progress < i)
    if not decls_seen: # 2/17/03
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
    << Append a reference to the methods of this file >>
    << Append any unused python text to the parent's body text >>
#@+node:ekr.20070324084040.16:<< Append a reference to the methods of this file >>
if self.treeType == "@root" and self.methodsSeen:
    c.appendStringToBody(parent,
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
#@-node:ekr.20070324084040.16:<< Append a reference to the methods of this file >>
#@+node:ekr.20070324084040.9:<< handle possible Python function or class >> (NOT USED)
if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file":
            c.appendStringToBody(parent,"@others\n")
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)
#@-node:ekr.20070324084040.9:<< handle possible Python function or class >> (NOT USED)
#@+node:ekr.20070324084040.17:<< Append any unused python text to the parent's body text >>
# Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i < len(s):
    c.appendStringToBody(parent,s[start:])
#@-node:ekr.20070324084040.17:<< Append any unused python text to the parent's body text >>
#@-node:ekr.20070324084040.15:scanPythonText
#@+node:ekr.20070324084040.18:doPythonClass & helpers
def doPythonClass (self,i,parent):
    
    c = self.c ; s = self.s
    
    if not self.preamble_seen:
        self.doPreamble(i)
    
    class_indent = self.getLeadingIndent(s,i)
    i,className,headline = self.getClassHeadline(i)
    if self.className:
        oldClassName = self.className
        self.className = className
        i = g.skip_line(s,i) # Skip the class line.
        i,prefix,body = self.createClassNodeText(s,i,start)
        class_vnode = self.createHeadline(parent,prefix + body,headline)
        start,i = self.scanPythonClass(i,class_indent,class_vnode)
        s2 = s[start:i]
        if s2: c.appendStringToBody(class_vnode,s2)
        self.className = oldClassName

    return i
#@nonl
#@+node:ekr.20070324084040.19:getClassHeadline
# Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    class_name = s[j:i]
    headline = "class " + class_name
else:
    headline = ''
    class_name = ''
#@-node:ekr.20070324084040.19:getClassHeadline
#@+node:ekr.20070324084040.20:createParentText
def createParentText (self,class_vnode,class_name):

    '''Insert the proper body text in the class_vnode.'''
    
    c = self.c
    
    # This must be done after the declaration reference is generated.
    if self.treeType == "@file":
        c.appendStringToBody(class_vnode,"\t@others\n")
    else:
        ref = g.angleBrackets(' class %s methods ' % (class_name))
        c.appendStringToBody(class_vnode,"\t" + ref + "\n\n")
#@-node:ekr.20070324084040.20:createParentText
#@+node:ekr.20070324084040.21:createClassNodeText
def createClassNodeText (self,s,i,start):
    
    # Create the section name using the old value of self.methodName.
    if  self.treeType == "@file":
        prefix = ""
    else:
        prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
        self.methodsSeen = True
    
    # i points just after the class line.
    
    # Add a docstring to the class node.
    docStringSeen = False
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j != len(s): # No scanning error.
            i = j ; docStringSeen = True
    
    body = s[start:i]
    body = self.undentBody(body)
    if docStringSeen: body = body + '\n'
    
    return i,prefix,body
#@-node:ekr.20070324084040.21:createClassNodeText
#@-node:ekr.20070324084040.18:doPythonClass & helpers
#@+node:ekr.20070324084040.22:doPythonDef
def doPythonDef (self,i,parent):
    
    if not self.preamble_seen:
        self.doPreamble(i)
    
    i = self.scanPythonDef(i,parent)
   
    return i
#@nonl
#@-node:ekr.20070324084040.22:doPythonDef
#@+node:ekr.20070324084040.23:doPreamble
def doPreamble (self,i):
    
    self.preamble_seen = True
    
    if i > 0:
        # Append the preamble to the root's body text.
        c.appendStringToBody(self.root,s[:i])

    if self.treeType == '@file':
        c.appendStringToBody(self.root,'@others\n')
#@-node:ekr.20070324084040.23:doPreamble
#@+node:ekr.20070324084040.24:scanPythonClass
def scanPythonClassHelper(self,s,i,class_indent,class_name,class_vnode):
    
    indent =  self.getLeadingIndent(s,i)
    start = i = g.skip_blank_lines(s,i)
    parent_vnode = None
    while i < len(s):
        progress = i
        # New in Leo 4.4.1: ignore comment lines, whatever their indentation.
        if indent <= class_indent:
            j = g.skip_ws(s,i)
            if g.match(s,j,'#'):
                i = g.skip_to_end_of_line(s,j)
            else: break
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            j = g.skip_nl(s,i)
            if not backslashNewline:
                indent = self.getLeadingIndent(s,j)
                if indent > class_indent: i = j
                else: break
            else: i = j
        elif g.match_c_word(s,i,"def"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonDef(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif g.match_c_word(s,i,"class"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonClass(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
        elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
        else: i += 1
        assert(progress < i)
    return start,i
#@-node:ekr.20070324084040.24:scanPythonClass
#@+node:ekr.20070324084040.25:scanPythonDef & helpers
def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    << set headline or return i >>
    i = self.skipPythonDef(s,i,start)
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    << Create def node >>
    self.methodName = savedMethodName
    return i
#@+node:ekr.20070324084040.26:createDefNode
# Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)
#@-node:ekr.20070324084040.26:createDefNode
#@+node:ekr.20070324084040.27:getDefHeadline
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i
#@-node:ekr.20070324084040.27:getDefHeadline
#@-node:ekr.20070324084040.25:scanPythonDef & helpers
#@+node:ekr.20070324084040.28:skipPythonDef
def skipPythonDef (self,s,i,start):
    
    # g.trace(g.get_line(s,i))

    # Set defIndent to the indentation of the def line.
    defIndent = self.getLeadingIndent(s,start)
    parenCount = 0
    << skip the entire signature >>
    indent = self.getLeadingIndent(s,i)
    while i < len(s): # and indent > defIndent
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            if not backslashNewline:
                # New in Leo 4.4.1: don't set indent for comment lines.
                j = g.skip_ws(s,i)
                if not g.match(s,j,'#'):
                    indent = self.getLeadingIndent(s,i)
                    if indent <= defIndent and parenCount == 0:
                        break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)
        
    return i
#@+node:ekr.20070324084040.29:<< skip the entire signature >>
# Now that we count parens, we must be careful to skip the entire signature.

j = s.find('(',i)
if j != -1:
    j = g.skip_matching_python_parens(s,j)

if j == -1 or not g.match(s,j+1,':'):
    g.es_print('Warning: improper signature: %s' % g.get_line(s,i))
    return i
else:
    i = g.skip_line(s,j) # Still not quite 100% correct.
#@-node:ekr.20070324084040.29:<< skip the entire signature >>
#@-node:ekr.20070324084040.28:skipPythonDef
#@-node:ekr.20070324084040.13:class pythonScanner (not ready yet)
#@-node:ekr.20070324084040:Prototype of @auto
#@+node:ekr.20051202094427:Resolve cvs conflicts
Investigate meld:  http://meld.sourceforge.net/
#@nonl
#@+node:ekr.20060601073503:Postings
@nocolor
#@nonl
#@+node:ekr.20031218072017.658:Stepen Schaefer 1
@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
#@-node:ekr.20031218072017.658:Stepen Schaefer 1
#@+node:ekr.20050501111900:Stephen Schaefer 2
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3125092
By: thyrsus

About a month ago, I posted a screed on how @thin was inadequate to address
my needs; that what I needed to collaborate on via version control was exactly
the essence of Leo's value: the multiple expressions of structure, which by
their nature must exist outside of @thin.  I said I was going to live the pain
to discover a modus vivendi.

Having done that, let me now say:

AAAAAAAAAAAAGGGGGGGGHHHHHHHHHH!

But the exercise has led me to a vision, which I will implement to the extent
my nonexistent spare time and paltry programming talents permit.

The essence of the pain is "conflicts", which become more  certain to occur
as the leo file encompases ever more related files.  As I work on a change to
the Linux configuration, my colleague works on a change to the Solaris configuration,
and one of us checks in our version of the leo file documenting the site
configuration first, and the other cannot check in his version of that file.
The conflict must be resolved by the human.  Using the "diff" tool on the .leo
XML is not an answer (though thank Heaven and Ed for gnxs).  The resolution
needs two levels of support: outline and node.

With the .leo file declared binary, in the event of a conflict CVS leaves you
with the most recent CVS version and your rejected version, and you're responsible
for performing a reconciliation and then resubmitting that.  Leo will recognize
the problem, and present both versions of the project, side by side, splitting
the outline pane.  The parallel trees will scroll/expand/contract in unison.
Outline branches present in CVS and not yours will display as blank space in
your version; nodes present in your version and not CVS will display as blank
space in the CVS version. The CVS version will be read only, your version editable.
The same node with differences in its text or in its children will be highlighted.
You will be able to drag nodes from the CVS version into your version. If the
text of a selected node has conflicts, the text area will split in two, showing
the CVS version and your version, with differences highlighted, both sides of
the pane scrolling in unison, the CVS side read-only, and you can copy from
that side to your side.  I intend to take as many ideas as I can from tkdiff
(http://sourceforge.net/projects/tkdiff/ - see also
http://freshmeat.net/screenshots/10602/ ).  (I have begun translating tkdiff
from from tcl to python - nearly 9000 lines and I'm still learning both languages,
so draw your own timeline.)  You edit your nodes, you edit your tree, you hit
the "reconcile" button, and your reconciliation of the conflict goes into CVS.
If, meanwhile, another one of your over-achieving colleages has again updated
CVS, the process repeats with the most current CVS version.  Or you can hit
the "abandon" button to give up on your changes.

As the Hebrews say at Passover: "Next year in Jerusalem."
#@nonl
#@-node:ekr.20050501111900:Stephen Schaefer 2
#@+node:ekr.20031218072017.659:Jonathon 1
@nocolor

http://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

In the .leo, if I edit <<bar>>, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@verbatim
#@+leo
#@verbatim
#@+node:0::@file foo.py
#@verbatim
#@+body
#@verbatim
#@+others
#@verbatim
#@+node:1::definition of a
#@verbatim
#@+body
print "a:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"bar"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:1::definition of a
#@verbatim
#@+node:2::definition of b
#@verbatim
#@+body
print "b:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation b"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:2::definition of b
#@verbatim
#@+node:3::definition of c
#@verbatim
#@+body
print "c:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation c"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:3::definition of c
#@verbatim
#@-others
#@verbatim
#@-body
#@verbatim
#@-node:0::@file foo.py
#@verbatim
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
#@-node:ekr.20031218072017.659:Jonathon 1
#@+node:ekr.20031218072017.660:Jonathan 2
@nocolor

By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

<<<<<<< 
blah blah blah? 
======= 
blah blah blah! 
>>>>>>> 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  
#@-node:ekr.20031218072017.660:Jonathan 2
#@+node:ekr.20031218072017.661:Gil 1
http://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
#@-node:ekr.20031218072017.661:Gil 1
#@+node:ekr.20031218072017.662:Gil 2
http://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?
#@nonl
#@-node:ekr.20031218072017.662:Gil 2
#@-node:ekr.20060601073503:Postings
#@-node:ekr.20051202094427:Resolve cvs conflicts
#@+node:ekr.20040919182750.1:Better handling of whitespace (cvs fiendly)
http://sourceforge.net/forum/message.php?msg_id=3578166
#@nonl
#@+node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
#@+node:ekr.20060808103849:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2674828
By: bwmulder

If I understand correctly, there are two different problems:

- Trailing whitespaces
- Left indented comments

1. Before commenting on these, a question:

If I write something like
    a=b
    if a:
        @others

[four spaces indentation]

I sometimes see tab characters before the lines inserted for '@others'.

It seems that Leo remembers 'two levels of indentation', and then
fabricates this indentation using tab characters.

I think it might be more robust if Leo remembered the actual
characters in front of @others and would use them for indentation.

I suspect that many indentation errors I had with Leo could have been
avoided had not Leo had its own ideas on how to do indentation.

Maybe Leo could use the exact sequence of characters in front of
@others for all inserted lines?

2. I do not care much about trailing whitespaces. Most of the time
they are invisible, but sometimes they are very misleading (trailing in python or C).

As far as I am concerned, Leo need never produce trailing whitespaces.

Maybe we need special machinery if sources have trailing whitespaces
and the sources are not under our control. 

Not sure if everybody would be happy if we essentially ban all trailing
whitespaces.

3. Unindented commentlines could be dealt with by using indentation to
indicate structure.

Of course, this might break the correspondance Leo structure / Python
structure, which is very ugly.

4. One possible alternative might be a new directive which indicates outindent:

@outindent <number>.

This would apply to the next comment block.

To me, 4. looks a little bit less ugly than 3.

5. As indicated in a different post, I suspect that Leo has a problem
if almost every node in an outline is changed. Profiling should point
to the culprit.

> 2. Have Leo strip whitespace from otherwise blank lines, and hope
that that solves all problems in Perfect Import. This is solving the
problem in the atFile code. The problem is that if we apply settings
in general we will get massive changes to derived files. In most
programming settings these changes might be welcome, but the problem
is actually making these changes. My first few attempts met with
abject failure.

Are you saying that you could not remove trailing blanks? What kind of
problems did you run into?

Summary:
- Use actual characters in front of @others or <<>> for indentation.
- Don't write trailing whitespaces
- Introduce directive for left-indendet comments.
- Profile to find out what slows Leo down if many nodes change.
#@nonl
#@-node:ekr.20060808103849:Report
#@+node:ekr.20041005105605.210:putIndent
def putIndent(self,n):
    
    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w > 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
#@-node:ekr.20041005105605.210:putIndent
#@-node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
#@+node:EKR.20040603092958.1:Add new options for handling newlines in body text
@nocolor

- "asis":
- "zero": no trailing newlines.
- "one": exactly one trailing newline.

Special case code is required so empty nodes stay empty with "one" option.
#@nonl
#@-node:EKR.20040603092958.1:Add new options for handling newlines in body text
#@-node:ekr.20040919182750.1:Better handling of whitespace (cvs fiendly)
#@-node:ekr.20070325052041:To do: 4.4.4 (@auto)
#@+node:ekr.20070105135713:To do: 4.5 (new positions)
#@+node:ekr.20061028070132:New positions
# None of this code is part of Leo's core yet: it is all highly experimental.

# Important: the new vnode class implies that the read code must be rewritten to be similar to the opml read code.
#@nonl
#@+node:ekr.20070512131018:Thoughts about positions 1
http://sourceforge.net/forum/message.php?msg_id=4308503

@nocolor

After more thought I am ready to back off my earlier post. Positions are perfectly reasonable things to support. Indeed, they can be, and probably should be, coequal with iterators. 
 
My 'revulsion' to positions stems from their present implementation--the 'optimization' of positions to avoid adding items to p.stack is certainly the worst optimization presently in Leo. It dates from the days when I was obsessing about reducing the amount of positions created. That was a valid concern then, but Leo now does an excellent job of not generating excess positions. Thus, there is no reason not to have p.stack contain all the parent vnodes at the present spot in a traversal. 
 
The idea of representing a position by a count in a traversal is cute, but of no practical importance. Indeed, why should Leo be forced to stupidly step through an entire traversal when a list of vnodes in p.stack would get to the proper spot in exponentially shorter time. Moreover, a list of vnodes in p.stack is great information to have, while a count N is almost exactly useless :-) 
 
Still, it is good to emphasize that *any* position, no matter how it is represented, makes sense *only* for a particular outline, that is, for a particular set of vnodes. In short, positions will stay, but will be reimplemented for the graph world. 
#@nonl
#@-node:ekr.20070512131018:Thoughts about positions 1
#@+node:ekr.20070512130855:Thoughts about positions 2
@nocolor

There will be some significant changes to the position and vnode classes for the graph world (Leo 4.5).  These changes will be common to both the graph and clone worlds:

Only vnode methods will be allowed to alter outline/graph data.  This would have been a good rule to following earlier, but up until now Leo has allowed 'confused' scripts--script that treat positions like vnodes.  This confusion will not be allowed in Leo 4.5.  The need for strict separation between vnodes and positions has become apparent in the recent chapters work.

It would be best to think of a position as a *path* to a particular vnode.  In the present (clone) world, the path is used exclusively by the tree drawing logic.  That logic tests whether the node being drawn matches (has the same position) as c.currentPosition.  In the graph world it probably makes sense to speak only of the current *vnode*, say v, so a position p is *a* current position if p.v == v.

The (renewed) focus on vnodes will be necessary.  For example, there will be no such things as p.back() or v._back in the graph world.  That is, a vnode v will have no *intrinsic* siblings.  Instead, siblings are relative to a parent: the order of vnodes in the parent.children links implicitly define sibling relationships, but a vnode v may have many 'parents', i.e. there may be many nodes that point to v.  We could speak of 'siblings with respect to a particular parent', but I suspect that will not be a particularly useful concept.  Rather, it will probably be more natural simply to define node relationships using iterators.  We shall see...
#@-node:ekr.20070512130855:Thoughts about positions 2
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.use_new_positions = False
    
    # New positions require the sax-based read code.
    self.use_sax = self.use_new_positions or c.config.getBool('use_sax_based_read')
    
    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5
    if self.use_sax:
        self.currentVnode = None
        self.rootVnode = None
    else:
        self.fileBuffer = None
        self.fileIndex = 0
        self.currentVnodeStack = [] # A stack of vnodes giving the current position.
        self.topVnodeStack     = [] # A stack of vnodes giving the top position.
        self.topPosition = None
    # For writing
    self.read_only = False
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@nonl
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061029093342.75:linkParentAndChildren (changed)
def linkParentAndChildren (self, parent_v, children):
    
    # if children: g.trace(parent_v,len(children))
    
    if self.use_new_positions:
        parent_v.t.links = children
    else:
        firstChild_v = children and children[0] or None
        parent_v.t._firstChild = firstChild_v
        for child in children:
            child._parent = parent_v
            
    v = parent_v
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
#@nonl
#@-node:ekr.20061029093342.75:linkParentAndChildren (changed)
#@+node:ekr.20061029093342.76:linkSiblings (changed)
def linkSiblings (self, sibs):
    
    '''Set the v._back and v._next links for all vnodes v in sibs.'''
    
    if self.use_new_positions:
        pass
    else:
        n = len(sibs)
        for i in xrange(n):
            v = sibs[i]
            v._back = (i-1 >= 0 and sibs[i-1]) or None
            v._next = (i+1 <  n and sibs[i+1]) or None
#@nonl
#@-node:ekr.20061029093342.76:linkSiblings (changed)
#@-node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.5:v.__cmp__ (not used)
if 0: # not used
    def __cmp__(self,other):
        
        g.trace(self,other)
        return not (self is other) # Must return 0, 1 or -1
#@-node:ekr.20061028211424.5:v.__cmp__ (not used)
#@+node:ekr.20061028211424.6:v.__init__
def __init__ (self,t):

    assert(t)
    
    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.unknownAttributes or any mutable vnode object changes.

    self.t = t # The tnode.
    self.statusBits = 0 # status bits
    
    # Structure links.
    #### self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20061028211424.6:v.__init__
#@+node:ekr.20061028211424.7:v.__repr__ & v.__str__
def __repr__ (self):
    
    if self.t:
        return "<vnode %d:'%s'>" % (id(self),self.cleanHeadString())
    else:
        return "<vnode %d:NULL tnode>" % (id(self))
        
__str__ = __repr__
#@-node:ekr.20061028211424.7:v.__repr__ & v.__str__
#@+node:ekr.20061028211424.8:v.dump (to be deleted)
def dumpLink (self,link):
    return g.choose(link,link,"<none>")

def dump (self,label=""):
    
    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)
    
    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v
#@-node:ekr.20061028211424.8:v.dump (to be deleted)
#@+node:ekr.20061028211424.9:v.__hash__ (only for zodb)
if use_zodb and ZODB:
    def __hash__(self):
        return self.t.__hash__()
#@nonl
#@-node:ekr.20061028211424.9:v.__hash__ (only for zodb)
#@-node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
def findAtFileName (self,names):
    
    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()
    
    if not g.match(h,0,'@'):
        return ""
    
    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
#@-node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
#@+node:ekr.20061028211424.12:anyAtFileNodeName
def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)
#@-node:ekr.20061028211424.12:anyAtFileNodeName
#@+node:ekr.20061028211424.13:at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)
    
def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)
    
def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)
    
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@-node:ekr.20061028211424.13:at...FileNodeName
#@+node:ekr.20061028211424.14:isAtAllNode
def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag
#@-node:ekr.20061028211424.14:isAtAllNode
#@+node:ekr.20061028211424.15:isAnyAtFileNode good
def isAnyAtFileNode (self):
    
    """Return True if v is any kind of @file or related node."""
    
    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
#@-node:ekr.20061028211424.15:isAnyAtFileNode good
#@+node:ekr.20061028211424.16:isAt...FileNode (vnode)
def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)
    
def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)
    
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@-node:ekr.20061028211424.16:isAt...FileNode (vnode)
#@+node:ekr.20061028211424.17:isAtIgnoreNode
def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag
#@-node:ekr.20061028211424.17:isAtIgnoreNode
#@+node:ekr.20061028211424.18:isAtOthersNode
def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag
#@-node:ekr.20061028211424.18:isAtOthersNode
#@+node:ekr.20061028211424.19:matchHeadline
def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""
    
    v = self
    
    h = g.toUnicode(v.headString(),'utf-8')
    h = h.lower().replace(' ','').replace('\t','')

    pattern = g.toUnicode(pattern,'utf-8')
    pattern = pattern.lower().replace(' ','').replace('\t','')
    
    return h.startswith(pattern)
#@-node:ekr.20061028211424.19:matchHeadline
#@-node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.22:v.back
# Compatibility routine for scripts

def back (self):

    return self._back
#@-node:ekr.20061028211424.22:v.back
#@+node:ekr.20061028211424.23:v.next
# Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next
#@-node:ekr.20061028211424.23:v.next
#@-node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.25:v.childIndex
def childIndex(self):
    
    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n
#@-node:ekr.20061028211424.25:v.childIndex
#@+node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
def firstChild (self):
    
    return self.t._firstChild
#@-node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
#@+node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
def hasChildren (self):
    
    v = self
    return v.firstChild()

hasFirstChild = hasChildren
#@-node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
#@+node:ekr.20061028211424.28:v.lastChild
def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child
#@-node:ekr.20061028211424.28:v.lastChild
#@+node:ekr.20061028211424.29:v.nthChild
# childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n > 0 and child:
        n -= 1
        child = child.next()
    return child
#@-node:ekr.20061028211424.29:v.nthChild
#@+node:ekr.20061028211424.30:v.numberOfChildren (n)
def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n += 1
        child = child.next()
    return n
#@-node:ekr.20061028211424.30:v.numberOfChildren (n)
#@-node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.32:v.isCloned (4.2)
def isCloned (self):
    
    return len(self.t.vnodeList) > 1
#@-node:ekr.20061028211424.32:v.isCloned (4.2)
#@+node:ekr.20061028211424.33:isDirty
def isDirty (self):

    return self.t.isDirty()
#@-node:ekr.20061028211424.33:isDirty
#@+node:ekr.20061028211424.34:isExpanded
def isExpanded (self):

    return ( self.statusBits & self.expandedBit ) != 0
#@-node:ekr.20061028211424.34:isExpanded
#@+node:ekr.20061028211424.35:isMarked
def isMarked (self):

    return ( self.statusBits & vnode.markedBit ) != 0
#@-node:ekr.20061028211424.35:isMarked
#@+node:ekr.20061028211424.36:isOrphan
def isOrphan (self):

    return ( self.statusBits & vnode.orphanBit ) != 0
#@-node:ekr.20061028211424.36:isOrphan
#@+node:ekr.20061028211424.37:isSelected
def isSelected (self):

    return ( self.statusBits & vnode.selectedBit ) != 0
#@-node:ekr.20061028211424.37:isSelected
#@+node:ekr.20061028211424.38:isTopBitSet
def isTopBitSet (self):

    return ( self.statusBits & self.topBit ) != 0
#@-node:ekr.20061028211424.38:isTopBitSet
#@+node:ekr.20061028211424.39:isVisited
def isVisited (self):

    return ( self.statusBits & vnode.visitedBit ) != 0
#@-node:ekr.20061028211424.39:isVisited
#@+node:ekr.20061028211424.40:status
def status (self):

    return self.statusBits
#@-node:ekr.20061028211424.40:status
#@-node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.41:v.bodyString
# Compatibility routine for scripts

def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.bodyString):
        s = "v.bodyString: Leo internal error: not unicode:" + repr(self.t.bodyString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
#@-node:ekr.20061028211424.41:v.bodyString
#@+node:ekr.20061028211424.42:v.headString & v.cleanHeadString
def headString (self):
    
    """Return the headline string."""
    
    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.headString):
        s = "Leo internal error: not unicode:" + repr(self.t.headString)
        g.es_print(s,color="red")
        
    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):
    
    s = self.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
#@-node:ekr.20061028211424.42:v.headString & v.cleanHeadString
#@+node:ekr.20061028211424.43:v.directParents (new method in 4.2)
def directParents (self):
    
    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.
    
    This is NOT the same as the list of ancestors of the vnode."""
    
    v = self
    
    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []
#@-node:ekr.20061028211424.43:v.directParents (new method in 4.2)
#@-node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
# These remain in 4.2: the file read logic calls these before creating positions.
#@+node:ekr.20061028211424.45:v.detach
def detach (self):
    
    '''Return a standalone copy of a vnode,
    detached from all other nodes and with a new tnode.'''
    
    v = self
    
    # Create a completely separate tnode.
    t2 = tnode(
        bodyString=v.bodyString(),
        headString=v.headString())
    
    return vnode(t2)
#@nonl
#@-node:ekr.20061028211424.45:v.detach
#@+node:ekr.20061028211424.46:v.insertAfter
def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAfter(self)

    return v
#@-node:ekr.20061028211424.46:v.insertAfter
#@+node:ekr.20061028211424.47:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAsNthChild(self,n)

    return v
#@-node:ekr.20061028211424.47:v.insertAsNthChild
#@+node:ekr.20061028211424.48:v.linkAfter
def linkAfter (self,v):

    """Link self after v."""
    
    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
#@-node:ekr.20061028211424.48:v.linkAfter
#@+node:ekr.20061028211424.49:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v
#@-node:ekr.20061028211424.49:v.linkAsNthChild
#@+node:ekr.20061028211424.50:v.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link a vnode as the root node and set the root _position_."""

    v = self

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v
#@nonl
#@-node:ekr.20061028211424.50:v.linkAsRoot
#@+node:ekr.20061028211424.51:v.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a vnode to the root position.
    
    Important: oldRoot must the previous root vnode if it exists.'''

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)
    
    return v
#@nonl
#@-node:ekr.20061028211424.51:v.moveToRoot
#@+node:ekr.20061028211424.52:v.unlink
def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []
#@nonl
#@-node:ekr.20061028211424.52:v.unlink
#@-node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
#@+node:ekr.20061028211424.53:Setters (no change)
#@+node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.55:clearClonedBit
def clearClonedBit (self):

    self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.55:clearClonedBit
#@+node:ekr.20061028211424.56:v.clearDirty (no change needed)
def clearDirty (self):

    v = self
    v.t.clearDirty()
#@nonl
#@-node:ekr.20061028211424.56:v.clearDirty (no change needed)
#@+node:ekr.20061028211424.57:v.clearMarked
def clearMarked (self):

    self.statusBits &= ~ self.markedBit
#@-node:ekr.20061028211424.57:v.clearMarked
#@+node:ekr.20061028211424.58:clearOrphan
def clearOrphan (self):

    self.statusBits &= ~ self.orphanBit
#@-node:ekr.20061028211424.58:clearOrphan
#@+node:ekr.20061028211424.59:clearVisited
def clearVisited (self):

    self.statusBits &= ~ self.visitedBit
#@-node:ekr.20061028211424.59:clearVisited
#@+node:ekr.20061028211424.60:contract & expand & initExpandedBit
def contract(self):

    self.statusBits &= ~ self.expandedBit
    
    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit
    
    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit
#@-node:ekr.20061028211424.60:contract & expand & initExpandedBit
#@+node:ekr.20061028211424.61:initStatus
def initStatus (self, status):

    self.statusBits = status
#@-node:ekr.20061028211424.61:initStatus
#@+node:ekr.20061028211424.62:setClonedBit & initClonedBit
def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.62:setClonedBit & initClonedBit
#@+node:ekr.20061028211424.63:v.setMarked & initMarkedBit
def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
#@-node:ekr.20061028211424.63:v.setMarked & initMarkedBit
#@+node:ekr.20061028211424.64:setOrphan
def setOrphan (self):

    self.statusBits |= self.orphanBit
#@-node:ekr.20061028211424.64:setOrphan
#@+node:ekr.20061028211424.65:setSelected (vnode)
# This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit
#@-node:ekr.20061028211424.65:setSelected (vnode)
#@+node:ekr.20061028211424.66:t.setVisited
# Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit
#@-node:ekr.20061028211424.66:t.setVisited
#@-node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.67:v.computeIcon & setIcon
def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val
    
def setIcon (self):

    pass # Compatibility routine for old scripts
#@-node:ekr.20061028211424.67:v.computeIcon & setIcon
#@+node:ekr.20061028211424.68:v.initHeadString
def initHeadString (self,s,encoding="utf-8"):
    
    v = self
    s = g.toUnicode(s,encoding,reportErrors=True)
    v.t.headString = s
    
    # g.trace(g.callers(5))
#@-node:ekr.20061028211424.68:v.initHeadString
#@+node:ekr.20061028211424.69:v.setSelection
def setSelection (self, start, length):

    self.t.setSelection ( start, length )
#@-node:ekr.20061028211424.69:v.setSelection
#@+node:ekr.20061028211424.70:v.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):
    
    return self.t.setTnodeText(s,encoding)
#@-node:ekr.20061028211424.70:v.setTnodeText
#@-node:ekr.20061028211424.53:Setters (no change)
#@-node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.1:position class
#@+node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.2:p.__cmp__ (changed)
def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self
    
    # g.trace(p1.headString(),p2 and p2.headString())

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal
    elif p1.v == p2.v and p2._childIndex == p2._childIndex and p1.stack == p2.stack:
        return 0 # equal
    else:
        return 1 # not equal

    # # Check entire stack quickly.
    # # The stack contains vnodes, so this is not a recursive call.
    # if p1.v != p2.v or p1.stack != p2.stack:
        # return 1 # notEqual
    # # This is slow: do this last!
    # if p1.childIndex() != p2.childIndex():
        # # Disambiguate clones having the same parents.
        # return 1 # notEqual
    # return 0 # equal
#@nonl
#@-node:ekr.20061028070057.2:p.__cmp__ (changed)
#@+node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                print "unknown position attribute:",attr
                import traceback ; traceback.print_stack()
            raise AttributeError,attr
#@nonl
#@-node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20061028070057.4:p.__init__
def __init__ (self,v,childIndex=0,stack=None):

    '''Create a new position.'''

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    self._childIndex = childIndex
    
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []
    
    g.app.positions += 1
    
    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20061028070057.4:p.__init__
#@+node:ekr.20061028070057.5:p.__nonzero__
@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

def __nonzero__ ( self):
    
    """Return True if a position is valid."""
    
    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None
#@-node:ekr.20061028070057.5:p.__nonzero__
#@+node:ekr.20061028070057.6:p.__str__ and p.__repr__
def __str__ (self):
    
    p = self
    
    if p.v:
        return "<pos %d lvl: %d [%d] %s>" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d        [%d] None>" % (id(p),len(p.stack))
        
__repr__ = __str__
#@-node:ekr.20061028070057.6:p.__str__ and p.__repr__
#@+node:ekr.20061028070057.7:p.archivedPosition
def archivedPosition (self):
    
    '''Return a representation of a position suitable for use in .leo files.'''
    
    p = self
    aList = [p2.v.childIndex() for p2 in p.self_and_parents_iter()]
    aList.reverse()
    return aList
#@nonl
#@-node:ekr.20061028070057.7:p.archivedPosition
#@+node:ekr.20061028070057.8:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""

    return position(self.v,self.stack)
#@-node:ekr.20061028070057.8:p.copy
#@+node:ekr.20061028070057.9:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):
    
    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label
        
def vnodeListIds (self):
    
    p = self
    return [id(v) for v in p.v.t.vnodeList]
#@-node:ekr.20061028070057.9:p.dump & p.vnodeListIds
#@+node:ekr.20061028070057.10:p.equal & isEqual (changed)
def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None.
    """

    p1 = self

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1._childIndex == p2._childIndex and
        p1.stack == p2.stack
    )
        
isEqual = equal
#@-node:ekr.20061028070057.10:p.equal & isEqual (changed)
#@+node:ekr.20061028070057.11:p.key
def key (self):
    
    p = self

    return '%s:%d.%s' % (
        id(p.v),
        p._childIndex,
        ','.join([str(id(v)) for v in p.stack])
    )
#@-node:ekr.20061028070057.11:p.key
#@-node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.12:p.moveToX (many changes)
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
#@+node:ekr.20061028070057.13:p.moveToBack (new)
def moveToBack (self):
    
    '''Move position p to its previous sibling.'''
    
    p = self
    if p.stack and p._childIndex > 0:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex -= 1
            p.v = links[p._childIndex]
        else:
            g.trace('Can not happen: no links')
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # p.v = p.v and p.v._back
    # return p
#@nonl
#@-node:ekr.20061028070057.13:p.moveToBack (new)
#@+node:ekr.20061028070057.14:p.moveToFirstChild (new)
def moveToFirstChild (self):

    '''Move a position to it's first child's position.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = 0
            p.v = links[0]
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # child = p.v.t._firstChild
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.14:p.moveToFirstChild (new)
#@+node:ekr.20061028070057.15:p.moveToLastChild (new)
def moveToLastChild (self):
    
    '''Move a position to it's last child's position.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = len(links)-1
            p.v = links[p._childIndex]
    else:
        p.v = None
    return p
    
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # child = p.v.lastChild()
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.15:p.moveToLastChild (new)
#@+node:ekr.20061028070057.16:p.moveToLastNode (no change)
def moveToLastNode (self):
    
    """Move a position to last node of its tree.
    
    N.B. Returns p if p has no children."""
    
    p = self
    while p.hasChildren():
        p.moveToLastChild()
    return p
#@-node:ekr.20061028070057.16:p.moveToLastNode (no change)
#@+node:ekr.20061028070057.17:p.moveToNext (new)
def moveToNext (self):

    '''Move position p to its next sibling.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if p._childIndex + 1 < len(links):
            p._childIndex += 1
            p.v = links[p._childIndex]
        else:
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # p.v = p.v and p.v._next
    # return p
#@-node:ekr.20061028070057.17:p.moveToNext (new)
#@+node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
def moveToNodeAfterTree (self):
    
    """Move a position to the node after the position's tree."""
    
    p = self
    
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
#@+node:ekr.20061028070057.19:p.moveToNthChild (new)
def moveToNthChild (self,n):
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links and n < len(links)
            p.v = links[n]
            p.childIndex = n
        else:
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # if p:
        # child = p.v.nthChild(n) # Must call vnode method here!
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.19:p.moveToNthChild (new)
#@+node:ekr.20061028070057.20:p.moveToParent (new)
def moveToParent (self):
    
    '''Move a position to its parent position.'''
    
    if p.stack:
        p.v,p._childIndex = p.stack.pop()
    else:
        p.v = None
    return p
    
    # p = self
    # if not p: return p
    # if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        # p.v = p.v._parent
    # elif p.stack:
        # p.v = p.stack.pop()
    # else:
        # p.v = None
    # return p
#@nonl
#@-node:ekr.20061028070057.20:p.moveToParent (new)
#@+node:ekr.20061028070057.21:p.moveToThreadBack (no change)
def moveToThreadBack (self):
    
    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.21:p.moveToThreadBack (no change)
#@+node:ekr.20061028070057.22:p.moveToThreadNext (little change)
def moveToThreadNext (self):
    '''Move a position to the next a position in threading order.'''
    p = self
    if p.hasChildren():
        p.moveToFirstChild()
    elif p.hasNext()
        p.moveToNext()
    else:
        p.moveToParent()
        while p:
            if p.hasNext():
                p.moveToNext()
                break #found
            p.moveToParent()
        # not found.
    return p

# def moveToThreadNext (self):
    # """Move a position to the next a position in threading order."""
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # p.moveToFirstChild()
        # elif p.v._next:
            # p.moveToNext()
        # else:
            # p.moveToParent()
            # while p:
                # if p.v._next:
                    # p.moveToNext()
                    # break #found
                # p.moveToParent()
            # # not found. 
    # return p
#@nonl
#@-node:ekr.20061028070057.22:p.moveToThreadNext (little change)
#@+node:ekr.20061028070057.23:p.moveToVisBack (no change)
def moveToVisBack (self):
    
    """Move a position to the position of the previous visible node."""

    p = self
    
    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p
#@-node:ekr.20061028070057.23:p.moveToVisBack (no change)
#@+node:ekr.20061028070057.24:p.moveToVisNext (no change)
def moveToVisNext (self):
    
    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()
            
    return p
#@-node:ekr.20061028070057.24:p.moveToVisNext (no change)
#@-node:ekr.20061028070057.12:p.moveToX (many changes)
#@+node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.27:p.Comparisons (no change)
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)
#@-node:ekr.20061028070057.27:p.Comparisons (no change)
#@+node:ekr.20061028070057.28:p.Headline & body strings (no change)
def bodyString (self):
    
    return self.v.bodyString()

def headString (self):
    
    return self.v.headString()
    
def cleanHeadString (self):
    
    return self.v.cleanHeadString()
#@-node:ekr.20061028070057.28:p.Headline & body strings (no change)
#@+node:ekr.20061028070057.29:p.Status bits (no change)
def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
#@-node:ekr.20061028070057.29:p.Status bits (no change)
#@+node:ekr.20061028070057.30:p.directParents (new, faster)
def directParents (self):
    
    p = self
    return p and p.stack or []

    # return self.v.directParents()
#@-node:ekr.20061028070057.30:p.directParents (new, faster)
#@+node:ekr.20061028070057.31:p.childIndex (new, much faster)
# This is time-critical code!

def childIndex(self):
    
    return p and p._childIndex or 0

    # p = self ; v = p.v
    # if not v or not v._back:
        # return 0
    # n = 0 ; v = v._back
    # while v:
        # n += 1
        # v = v._back
    # return n
#@nonl
#@-node:ekr.20061028070057.31:p.childIndex (new, much faster)
#@-node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.33:p.hasChildren (new)
def hasChildren(self):
    
    p = self
    
    if p.v and p.v.t:
        return len(p.v.t.links) > 0
    else:
        return False

    # return p.v and p.v.t and p.v.t._firstChild
#@-node:ekr.20061028070057.33:p.hasChildren (new)
#@+node:ekr.20061028070057.34:p.numberOfChildren (new)
def numberOfChildren (self):
    
    if p.v:
        return len(p.v.t.links)
    else:
        return 0
    
    # return self.v.numberOfChildren()
#@-node:ekr.20061028070057.34:p.numberOfChildren (new)
#@-node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@-node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
#@+node:ekr.20061028070057.36:p.hasX (new)
def hasBack(self):
    return self._childIndex > 0
    # return self.v and self.v._back

hasFirstChild = hasChildren
    
def hasNext(self):
    p = self
    if p.stack:
        parent_v,junk = self.stack[-1]
        links = parent_v.t.links
        return p._childIndex + 1 < len(parent.v.t.links)
    else:
        return False
    # return self.v and self.v._next
    
def hasParent(self):
    return len(self.stack) > 1 # The first item of each stack is the dummy parent.
    # return self.v and self.v._parent is not None
    
def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
    
hasVisBack = hasThreadBack
#@-node:ekr.20061028070057.36:p.hasX (new)
#@+node:ekr.20061028070057.37:hasThreadNext (big change)
def hasThreadNext(self):
    
    p = self ; v = p.v
    if not p.v: return False

    if p.hasChildren() or p.hasNext():
        return True
    else:
        # Simulate this code without copying p.
        # p2 = p.copy()
        # p2.moveToParent()
        # while p2:
            # if p2.hasNext():
                # return True
            # p2.moveToParent()
        # return False
        if not p.stack: return False
        n = len(p.stack)-1
        v,childIndex = p.stack[n]
        n -= 1
        while n >= 0:
            # v2,childIndex2 represent v's parent.
            v2,childIndex2 = parent.stack[n]
            links = v2.t.links
            if childIndex + 1 < len(links):
                return True
            # v.moveToParent
            v,childIndex = v2,childIndex2
            n -= 1
        return False

    # p = self ; v = p.v
    # if not p.v: return False
    # if v.t._firstChild or v._next:
        # return True
    # else:
        # n = len(p.stack)-1
        # v,n = p.vParentWithStack(v,p.stack,n)
        # while v:
            # if v._next:
                # return True
            # v,n = p.vParentWithStack(v,p.stack,n)
        # return False

hasVisNext = hasThreadNext
#@nonl
#@-node:ekr.20061028070057.37:hasThreadNext (big change)
#@+node:ekr.20061028070057.38:p.findRootPosition (unchanged)
def findRootPosition (self):
    
    p = self.copy()
    while p.hasParent():
        p.moveToParent()
    while p.hasBack():
        p.moveToBack()
    return p
#@nonl
#@-node:ekr.20061028070057.38:p.findRootPosition (unchanged)
#@+node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
def isAncestorOf (self, p2):
    
    p = self
    if not p.stack:
        return False
    elif p2 is None or not p2.stack:
        return False
    else:
        for v,junk in p2.stack:
            if v == p.v:
                return True
        else:
            return False
    
    # p = self
    # # Avoid calling p.copy() or copying the stack.
    # v2 = p2.v ; n = len(p2.stack)-1
        # # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # while v2:
        # if v2 == p.v:
            # return True
        # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # return False
#@nonl
#@-node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
#@+node:ekr.20061028070057.40:p.isCloned (unchanged)
def isCloned (self):
    
    return len(self.v.t.vnodeList) > 1
#@-node:ekr.20061028070057.40:p.isCloned (unchanged)
#@+node:ekr.20061028070057.41:p.isRoot (unchanged)
def isRoot (self):
    
    p = self

    return not p.hasParent() and not p.hasBack()
#@-node:ekr.20061028070057.41:p.isRoot (unchanged)
#@+node:ekr.20061028070057.42:p.isVisible (new)
def isVisible (self):
    
    """Return True if all of a position's parents are expanded."""
    
    p = self
    for v in p.stack:
        if not v.isExpanded():
            return False
    return True

    # p = self
    # v = p.v ; n = len(p.stack)-1
    # v,n = p.vParentWithStack(v,p.stack,n)
    # while v:
        # if not v.isExpanded():
            # return False
        # v,n = p.vParentWithStack(v,p.stack,n)
    # return True
#@nonl
#@-node:ekr.20061028070057.42:p.isVisible (new)
#@+node:ekr.20061028070057.43:p.level & simpleLevel (new)
def level(self):
    return len(self.stack)
    
simpleLevel = level

# def simpleLevel(self):
    # 
    # return len([p for p in self.parents_iter()])

# def level(self,verbose=False):
    # 
    # p = self ; level = 0
    # if not p: return level
        # 
    # # Avoid calling p.copy() or copying the stack.
    # v = p.v ; n = len(p.stack)-1
    # while 1:
        # assert(p)
        # v,n = p.vParentWithStack(v,p.stack,n)
        # if v:
            # level += 1
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        # else:
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # # if g.app.debug: assert(level==self.simpleLevel())
            # break
    # return level
#@-node:ekr.20061028070057.43:p.level & simpleLevel (new)
#@-node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n >= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
#@+node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)
#@-node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
#@-node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
#@+node:ekr.20061028070057.47:p.restoreLinksInTree
def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""
    
    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    for p in root.children_iter():
        p.restoreLinksInTree()
#@-node:ekr.20061028070057.47:p.restoreLinksInTree
#@+node:ekr.20061028070057.48:p.deleteLinksInTree & allies
def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()

    # for p in root.children_iter():
        # p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@+node:ekr.20061028070057.49:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20061028070057.49:p.deleteLinksInSubtree
#@+node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
#@-node:ekr.20061028070057.48:p.deleteLinksInTree & allies
#@-node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@+node:ekr.20061028070057.52:p.linkAfter
def linkAfter (self,after):

    """Link self after position 'after'."""
    
    p = self
    if not after.stack:
        g.trace('Can not happen: no dummy root.',after)
        return
    
    p.stack = after.stack[:]
    p._childIndex = after._childIndex + 1 #### New
    parent_v,junk = p.stack[-1] #### New
    links = parent_v.t.links #### New
    links.insert(p._childIndex,p.v) #### New
        
    #### p.v._parent = after.v._parent
    
    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.
    
    #### p.v._back = after.v
    #### p.v._next = after.v._next
    #### after.v._next = p.v
    #### if p.v._next:
        #### p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")
#@-node:ekr.20061028070057.52:p.linkAfter
#@+node:ekr.20061028070057.53:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of parent position 'parent'."""
    
    # g.trace(self,parent,n,parent.v)

    p = self
    links = parent.v.t.links
    if n <= len(links):
        links.insert(n,p.v)
    else:
        g.trace('Can not happen: n too large.',n,p)
        return
        
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # # Recreate the stack using the parent.
    # p.stack = parent.stack[:]
    # if parent.isCloned():
        # p.stack.append(parent.v)
    # p.v._parent = parent.v
    # # Add v to it's tnode's vnodeList.
    # if p.v not in p.v.t.vnodeList:
        # p.v.t.vnodeList.append(p.v)
        # p.v.t._p_changed = 1 # Support for tnode class.
    # if n == 0:
        # child1 = parent.v.t._firstChild
        # p.v._back = None
        # p.v._next = child1
        # if child1:
            # child1._back = p.v
        # parent.v.t._firstChild = p.v
    # else:
        # prev = parent.nthChild(n-1) # zero based
        # assert(prev)
        # p.v._back = prev.v
        # p.v._next = prev.v._next
        # prev.v._next = p.v
        # if p.v._next:
            # p.v._next._back = p.v
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.53:p.linkAsNthChild
#@+node:ekr.20061028070057.54:p.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    root_v,junk = p.stack[0]
    links = root_v.t.links
    p.stack = [root_v] # Clear the stack, except for the dummy root.
    links = [p.v]
    if oldRoot:
        links.append(oldRoot.v)
    
    # p.stack = [] # Clear the stack.
    # # Clear all links except the child link.
    # v._parent = None
    # v._back = None
    # v._next = oldRootVnode
    
    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    # if oldRoot:
        # oldRoot.v._back = v
    # p.dump(label="root")
#@nonl
#@-node:ekr.20061028070057.54:p.linkAsRoot
#@+node:ekr.20061028070057.55:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v.t.links does NOT change."""

    p = self ; v = p.v
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)
    
    if p.stack:
        parent,junk = p.stack[-1]
        links = parent.t.links
        if v in links:
            links.remove(v)
        else:
            g.trace("Can not happen: not its father's child.",p)
    else:
        g.trace('Can not happen: missing root.',p)
    
    # Reset the firstChild link in its direct father.
    # if p.v._parent:
        # if 0: # This can fail.  I have no idea why it was present.
            # assert(p.v and p.v._parent in p.v.directParents())
        # if p.v._parent.t._firstChild == v:
            # #g.trace('resetting _parent.v.t._firstChild to',v._next)
            # p.v._parent.t._firstChild = v._next
    # else:
        # parent = p.parent()
        # if parent:
            # if 0: # This can fail.  I have no idea why it was present.
                # assert(parent.v in p.v.directParents())
            # if parent.v.t._firstChild == v:
                # #g.trace('resetting parent().v.t._firstChild to',v._next)
                # parent.v.t._firstChild = v._next
    # # Do NOT delete the links in any child nodes.
    # # Clear the links in other nodes.
    # if v._back: v._back._next = v._next
    # if v._next: v._next._back = v._back
    # # Unlink _this_ node.
    # v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.55:p.unlink
#@-node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
#@-node:ekr.20061028211424.1:position class
#@-node:ekr.20061028070132:New positions
#@+node:ekr.20070105135851.1:Most important
#@+node:ekr.20061206060454:Improve import code
@nocolor

- Make the later munging unnecessary.
	- Don't generate @file or the full file names.
	- Don't add @ignore
	- Put @language python and @tabwidth -4 only in the root node.
- Put the docstring at the top.
- Make sure only imports go in the << imports >> section.
#@-node:ekr.20061206060454:Improve import code
#@+node:ekr.20061127170002.1:Allow multiple lines on the button bar
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3993176
By: rich_ries

How can the button bar be enlarged to take a second (or third!) row of icons? Or maybe the Scripting buttons can have
their own section, like the NodeBar plugin did/does?

add-new-icon-row command?
#@nonl
#@-node:ekr.20061127170002.1:Allow multiple lines on the button bar
#@-node:ekr.20070105135851.1:Most important
#@+node:ekr.20061028065955.4:New features
#@+node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061014050154.2:Binding to None clears all bindings
#@-node:ekr.20061014050154.2:Binding to None clears all bindings
#@+node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@-node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@+node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:new
def new (self,event=None):
    
    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)
    
    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):
    
    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
            
    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):
    
    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):
    
    '''Save a Leo outline to a file.'''

    c = self ; trace = False
    cc = c.config.getBool('use_chapters') and c.chapterController
    
    oldChapter = cc and cc.forceMainChapter()
    
    if trace and cc:
        g.trace('cc',cc)
        g.printEntireTree(c,'save:before')
        cc.printChaptersTree('save:before')

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
    
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""
        
    c.beginUpdate()
    try:
        if c.mFileName != "":
            # Calls c.setChanged(False) if no error.
            c.fileCommands.save(c.mFileName)
        else:
            fileName = g.app.gui.runSaveFileDialog(
                initialfile = c.mFileName,
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
            c.bringToFront()
    
            if fileName:
                # Don't change mFileName until the dialog has suceeded.
                c.mFileName = g.ensure_extension(fileName, ".leo")
                c.frame.title = c.mFileName
                c.frame.setTitle(g.computeWindowTitle(c.mFileName))
                c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
                c.fileCommands.save(c.mFileName)
                c.updateRecentFiles(c.mFileName)
                
        if cc:
            cc.restoreOldChapter(oldChapter)
    finally:
        c.endUpdate()
        
    if trace and cc:
        g.printEntireTree(c,'save:after')
        cc.printChaptersTree('save:after')
#@nonl
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):
    
    '''Save a Leo outline to a file with a new filename.'''
    
    c = self ; cc = c.config.getBool('use_chapters') and c.chapterController
    oldChapter = cc and cc.forceMainChapter()
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
        
    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""
    
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save As",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()
    
        if fileName:
            # 7/2/02: don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            # Calls c.setChanged(False) if no error.
            c.fileCommands.saveAs(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            
        if cc:
            cc.restoreOldChapter(oldChapter)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
def saveAsUnzipped (self,event=None):
    
    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)
    
def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)
    
def saveAsZippedHelper (self,isZipped):
    
    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
#@-node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):
    
    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''
    
    c = self ; cc = c.config.getBool('use_chapters') and c.chapterController
    oldChapter = cc and cc.forceMainChapter()
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
        
    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""
    
        # set local fileName, _not_ c.mFileName
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save To",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()
    
        if fileName:
            fileName = g.ensure_extension(fileName, ".leo")
            c.fileCommands.saveTo(fileName)
            c.updateRecentFiles(fileName)
            
        if cc:
            cc.restoreOldChapter(oldChapter)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):
    
    '''Revert the contents of a Leo outline to last saved contents.'''
    
    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return
        
    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@-node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@-node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@+node:ekr.20061024093525:Create settings menu
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3977681

How about having a menu Edit -> Settings with the submenu-items 'LeoSettings.leo',
'myLeoSettings.leo', 'this file's settings'?

The menu-items 'Open myLeoSettings.leo' and 'Open LeoSettings.leo' under the
Help-menu seem out-of-place.

#@-node:ekr.20061024093525:Create settings menu
#@+node:ekr.20061116054917.6:Remove blanks in calltips
#@-node:ekr.20061116054917.6:Remove blanks in calltips
#@+node:ekr.20061108100143:Create '*open-&test.leo' command that t.bat or test.leo
# This doesn't seem to work well on XP.
#@nonl
#@+node:ekr.20061209131102.1:openTest
def openTest (self, event=None):
    
    if 1: # Open in a new process.
        cmd = 'c:\Windows\System32\cmd.exe' # Hangs if used.
        python = sys.executable
        leo = g.os_path_abspath(g.os_path_join(g.app.loadDir,'leo.py'))
        test = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test'))
        
        os.system('%s %s %s %s' % (cmd, python,leo,test))
        # args = [python, leo, test]
        
        # if 1: # Use present environment.
            # os.spawnv(os.P_NOWAIT, sys.executable, args)
        # else: # Use a pristine environment.
            # os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
    else:
        c = self
        fileName = g.os_path_join(g.app.loadDir,'..','test','test.leo')
    
        ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es('not found: %s' % fileName)
#@-node:ekr.20061209131102.1:openTest
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):
    
    self.helpMenuTable = [
        # &: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&About Leo...',           'about-leo'),
        ('Online &Home Page',       'open-online-home'),
        '*open-online-&tutorial',
        '*open-&users-guide',
        '-',
        ('Open Leo&Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&Settings.leo',   'open-leoSettings-leo'),
        ('Open &myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&ipts.leo',       'open-scripts-leo'),
        # ('Open t&est.leo',          'open-test-leo'),
        '-',
        '*he&lp-for-minibuffer',
        '*help-for-&command',
        '-',
        '*&apropos-autocompletion',
        '*apropos-&bindings',
        '*apropos-&debugging-commands',
        '*apropos-&find-commands',
        '-',
        '*pri&nt-bindings',
        '*print-c&ommands',
    ]
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20061108100143:Create '*open-&test.leo' command that t.bat or test.leo
#@-node:ekr.20061028065955.4:New features
#@-node:ekr.20070105135713:To do: 4.5 (new positions)
#@+node:ekr.20060822174843:Most important projects
# Most of these projects will take a week or more.
#@nonl
#@+node:ekr.20070220082124:Make sure Leo can generate Latex
#@-node:ekr.20070220082124:Make sure Leo can generate Latex
#@+node:ekr.20070226075816.1:Update plugin manager to handle @enabled-plugins nodes
#@-node:ekr.20070226075816.1:Update plugin manager to handle @enabled-plugins nodes
#@+node:ekr.20070307082503:Make Leo an IPython notebook
#@+node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060603085719.1:Use IPython autocompleter?
#@-node:ekr.20060603085719.1:Use IPython autocompleter?
#@+node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@-node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@+node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@-node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@+node:ekr.20060603090445.9:Script button that saves environment between runs
This would allow IPython-like operation.
#@nonl
#@-node:ekr.20060603090445.9:Script button that saves environment between runs
#@-node:ekr.20060603090445.7:Ipython stuff
#@-node:ekr.20070307082503:Make Leo an IPython notebook
#@+node:ekr.20060629154112:Merge Leo & jyLeo
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3799470
By: leouser

I guess its hard to say what pieces must merge and what can stay different.
Id like it if the blasted nodes were the same.  I guess there is progress again
on a jython 2.2 being complete and work starting on 2.3.  So there is hope that
the nodes will be the same code, at least it will be possible.

At the top of my head the big differences outside of the position changes are:
1. Some modifications to the read/write code so that Chapters can work and also
Serialized positions.
2. Commander has some things different, it looks to the Chapters instance to
determine what is the curentPosition, top Position etc... instead of keeping
track of it itself.
3. GUI layers are very different.  Interesting tidbit here: the work I did to
get the JTree to use positions to determine if a node is expanded or not looks
like it has provided the outline for enhancing the JTree for Java itself to
be able to do this.  We will have to see, but maybe in Java 7 you can say: "Positions
lead to user controled tree expansion models".

There is a tremendous amount that is the same. Im sure you could make an interesting
evening out of comparing the codebases to see where things change.


#@+node:ekr.20070307082814:Create g.startupController class
#@-node:ekr.20070307082814:Create g.startupController class
#@-node:ekr.20060629154112:Merge Leo & jyLeo
#@+node:ekr.20060202231708.1:@menu nodes in leoSettings.leo
@nocolor

We could allow users to define Leo menus.
To do this, we must use minibuffer names for all menu entries

@color
#@nonl
#@-node:ekr.20060202231708.1:@menu nodes in leoSettings.leo
#@+node:ekr.20061207073104:Convert bottlenecks to pyrex code
# To do:  actually generate Leo's bottlenecks.
#@nonl
#@+node:ekr.20061207073104.1:gcc build docs
@nocolor

To build your module using GCC is a three step process on Unix. (I have know
idea how many steps it is on Windows™.)

Start by running the Pyrex compiler over your code as follows, where
mymodule.pyx is the name of the Pyrex module you are writing. python2.2 pyrexc
mymodule.pyx Next, compile the resulting C file into a .o file. The call to gcc
looks like this:

gcc -c -fPIC -I/usr/include/python2.2/ mymodule.c
The arguments to gcc are explained below.

-c 
Produces a .o file instead of an executable. 
-fPIC 
Produces position independent code, so we can dynamically link against it later. 
-I/usr/include/python2.2/ 
is the location of the Python 2.2 include file. The location of your Python include file may differ from /usr/include/python2.2/. 
mymodule.c 
is the name of the C file produced by Pyrex. 
Finally, link the .o into a .so: gcc -shared mymodule.o -lxosd -o mymodule.so
-shared 
produces a shared-object file, instead of an executable. 
mymodule.o 
is the name of the module you wish to compile. 
-lxosd 
links against a C-library, with the name of the library given as the argument. 
-o mymodule.so 
causes gcc to put the output into a file called mymodule.so 
The C library that you are wrapping will probably differ from mymodule. 
#@-node:ekr.20061207073104.1:gcc build docs
#@+node:ekr.20061207073104.2:pyrexc command-line options
@nocolor

The pyrexc command supports the following options:

  Short Long              Argument    Description
  -----------------------------------------------------------------------------
  -v    --version                     Display version number of pyrex compiler
  -l    --create-listing              Write error messages to a .lis file
  -I    --include-dir     <directory> Search for include files in named 
                                       directory (may be repeated)
  -o    --output-file     <filename>  Specify name of generated C file (only
                                       one source file allowed if this is used)

Anything else is taken as the name of a Pyrex source file and compiled
to a C source file. Multiple Pyrex source files can be specified
(unless -o is used), in which case each source file is treated as the
source of a distinct extension module and compiled separately to
produce its own C file.
#@-node:ekr.20061207073104.2:pyrexc command-line options
#@+node:ekr.20061207073104.3:@file myModule.pyx
def spam(int i, char *s):
    if 1:
        print i,s
#@nonl
#@-node:ekr.20061207073104.3:@file myModule.pyx
#@+node:ekr.20061207073104.4:Make myModule.c
# Use pyrexc to create myModule.c from myModule.pyx.
import os,sys
python = sys.executable
theFile = r'C:\prog\tigris-cvs\leo\test\myModule.pyx'
pyrexc = r'c:\prog\Pyrex-0.9.4.1\pyrexc.py'
os.system(r'%s %s %s' % (python,pyrexc,theFile))

if 0: # Build myModule library using distutils.
    from distutils.core import setup, Extension

    # Make the extension module ("mymodule") link against xosd
    xosdExtn = Extension("mymodule", ["mymodule.c"], libraries=["xosd"])
    
    # Compile the extension module
    setup(name="mymodule", ext_modules=[xosdExtn])
    
@ Save the above code in a file called setup.py and run the following code
to build and install your module.
    
    python setup.py build
    python setup.py install
#@nonl
#@-node:ekr.20061207073104.4:Make myModule.c
#@+node:ekr.20061207073104.5:Code to be optimized w/ pyrex
#@+node:ekr.20061207073104.6:Nodes...
#@-node:ekr.20061207073104.6:Nodes...
#@+node:ekr.20061207073104.216:Colorizer
#@-node:ekr.20061207073104.216:Colorizer
#@+node:ekr.20061207073104.268:File code
#@-node:ekr.20061207073104.268:File code
#@-node:ekr.20061207073104.5:Code to be optimized w/ pyrex
#@-node:ekr.20061207073104:Convert bottlenecks to pyrex code
#@+node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
@nocolor

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off.

@color
#@nonl
#@-node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
#@-node:ekr.20060530085844:Improve autocompletion
#@-node:ekr.20060822174843:Most important projects
#@+node:ekr.20070414090051:Study
@nocolor

- launchpad http://launchpad.net 

- bazaar (bzr)
#@nonl
#@-node:ekr.20070414090051:Study
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
