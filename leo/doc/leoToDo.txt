#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20070703111455:To do: 4.4.5 Useful odds & ends
# Leo 4.4.5 will complete several projects that are long overdue.

#@+node:ekr.20070814070312:First
#@+node:ekr.20071106135136:Add option: warn if plugins fail to load
#@-node:ekr.20071106135136:Add option: warn if plugins fail to load
#@+node:ekr.20070814144804:Incorrect conversion of paths to absolute paths
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4464649
By: terry_n_brown

An argument I'm always having with leo has to do with its conversion of file
paths to 'absolute' forms.

In the file browser I select '/home/tbrown/misc/foo.leo'.
Leo reinterprets this as '/media/hda2/usr1/home/tbrown/misc/foo.leo'

Then I switch machines, and while
'/home/tbrown/misc/foo.leo' would still be valid,
'/media/hda2/usr1/home/tbrown/misc/foo.leo' isn't - on the other machine it
would be '/media/hdb1/home/tbrown/misc/foo.leo'.

I end up with the two entries in recent files, having to identify the right one.

If the Tk dialog is returning '/home/tbrown/misc/foo.leo', which I assume it is
because that's what it's displaying, I wish leo would use and store that.

@color
#@nonl
#@-node:ekr.20070814144804:Incorrect conversion of paths to absolute paths
#@+node:ekr.20070803115653:Support @path and other directives in headlines
#@-node:ekr.20070803115653:Support @path and other directives in headlines
#@+node:ekr.20071105145643:Clean up config mess
#@-node:ekr.20071105145643:Clean up config mess
#@+node:ekr.20071031113657:Remove Leo's hand-written parser: use sax or lxml
# Are there proper unit tests?
# Do global settings and find-panel settings get set properly.
#@nonl
#@+node:ekr.20071003104917:Make http://edreamleo.org/namespaces/leo-python-editor/1.1 Leo's official namespace
#@-node:ekr.20071003104917:Make http://edreamleo.org/namespaces/leo-python-editor/1.1 Leo's official namespace
#@-node:ekr.20071031113657:Remove Leo's hand-written parser: use sax or lxml
#@-node:ekr.20070814070312:First
#@+node:ekr.20071105155631:High impact
#@+node:ekr.20071025160653.2:Commands to add/remove icons
#@+node:ekr.20071026092640:To do
@nocolor

To do:

* Define standard event handlers:
    - on-left-click (deletes icon)
    - on-click

* Adjust location depending on icon size.

- Define standard icons in a subfolder of Icons folder?

insert-icon
append-icon
delete-first-icon
delete-nth-icon
delete-all-node-icons
delete-all-icons-in-tree
#@-node:ekr.20071026092640:To do
#@+node:ekr.20040803072955.46:drawUserIcons & helper
def drawUserIcons(self,p,where,x,y):

    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""

    h,w = 0,0 ; t = p.v.t

    if not hasattr(t,"unknownAttributes"):
        return h,w

    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w

    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()

    # g.trace(where,h,w)

    return h,w
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):

    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # if self.trace_gc: g.printNewObjects(tag='userIcon 1')

    # g.trace(where,x,y,theDict)

    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            << draw the icon in string s >>
    elif theType == "file":
        theFile = theDict.get("file")
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>

    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    # if self.trace_gc: g.printNewObjects(tag='userIcon 2')

    return h,w
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.49:<< draw the icon in string s >>
pass
#@-node:ekr.20040803072955.49:<< draw the icon in string s >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
fullname = g.os_path_normpath(fullname)

# Bug fix: the key must include distinguish nodes.
key = (fullname,p.v.t)
image = self.iconimages.get(key)

if not image:
    try:
        from PIL import Image, ImageTk
        image1 = Image.open(fullname)
        image = ImageTk.PhotoImage(image1)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if not image:
    try:
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p.copy()
    # g.trace('id',theId,p.headString(),theFile,image)

    # assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad
#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@-node:ekr.20040803072955.46:drawUserIcons & helper
#@+node:ekr.20040803072955.12:recycleWidgets
def recycleWidgets (self):

    canvas = self.canvas

    for theId in self.visibleBoxes:
        if theId not in self.freeBoxes:
            self.freeBoxes.append(theId)
        canvas.coords(theId,-100,-100)
    self.visibleBoxes = []

    for theId in self.visibleClickBoxes:
        if theId not in self.freeClickBoxes:
            self.freeClickBoxes.append(theId)
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleClickBoxes = []

    for theId in self.visibleIcons:
        if theId not in self.freeIcons:
            self.freeIcons.append(theId)
        canvas.coords(theId,-100,-100)
    self.visibleIcons = []

    for theId in self.visibleLines:
        if theId not in self.freeLines:
            self.freeLines.append(theId)
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleLines = []

    aList = self.visibleText.values()
    for data in aList:
        w,theId = data
        # assert theId == w.leo_window_id
        canvas.coords(theId,-100,-100)
        w.leo_position = None # Allow the position to be freed.
        if data not in self.freeText:
            self.freeText.append(data)
    self.visibleText = {}

    # g.trace('deleting visible user icons!')
    for theId in self.visibleUserIcons:
        # The present code does not recycle user Icons.
        self.canvas.delete(theId)
    self.visibleUserIcons = []
#@-node:ekr.20040803072955.12:recycleWidgets
#@-node:ekr.20071025160653.2:Commands to add/remove icons
#@+node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@-node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@+node:ekr.20071024090626:Support @bool diagnose-aspell-installation
#@-node:ekr.20071024090626:Support @bool diagnose-aspell-installation
#@+node:ekr.20071105160956:*** auto-change panes
@nocolor

The idea: if a key binding is only in effect for one pane, and we get the
binding, maybe we should change to the pane first!

Examples:

copy-node: auto-select tree pane.
copy_text (when not editing a headline): auto-select body text.
#@nonl
#@-node:ekr.20071105160956:*** auto-change panes
#@-node:ekr.20071105155631:High impact
#@+node:ekr.20070703111455.1:Most important
#@+node:ekr.20071025160653.1:Support @command nodes in @buttons tree
#@-node:ekr.20071025160653.1:Support @command nodes in @buttons tree
#@+node:ekr.20070623144302:vim-like bindings
#@+node:ekr.20070824094005:Requests
@nocolor

> Some of the features I've grown to like with VIM are search-and-replace within the current selection, easy keyboard navigation, and to some extent macro recording and running.

Thanks for these comments.  I'll keep them in mind as I design the vim-like code.

Edward
#@nonl
#@-node:ekr.20070824094005:Requests
#@+node:ekr.20070814083528.1:Design post
@nocolor

http://sourceforge.net/forum/forum.php?thread_id=1800079&forum_id=10226

Recent posts have discussed @menu trees and resolving cvs conflicts. The third of my recent ruminations concerns adding support for vim-like key bindings. 

Earlier work involving input modes (@mode nodes in settings file) probably is not completely sufficient to implement plain-key key bindings in a way that would truly be vim-like. 

Most of the issues are implementation issues: Leo's key-handling code is very complicated. The trick is to handle both vim and emacs styles compatibly. 

The user must be able to specify vim-like key bindings without using @mode nodes. That is, top-level vim key bindings must always be available. Vim has an enormous number of key bindings: the user must be able to specify which are in effect. 

My strategy will be as follows: 

1. Create enter-vim-mode and exit-vim-mode commands, and create the setting: 

@bool vim-mode-by-default = False 

This will allow the user to specify vim mode as the default mode if desired. 

2. Create **vim-edit** commands as needed in order to handler user interaction. For example, dd deletes the present line while d5 deletes 5 lines. Rather than trying to simulate this effect using the present mechanisms, the vim-delete command will prompt for the number of characters or lines to delete. 

Give the complex nature of vims c and d commands (and others) it will probably be necessary to create a vim-edit class in leoEditCommands.py. This class will handle all the ways of specifying a range of characters to which the various commands will apply. It's not clear exactly how much work will be needed, but my guess is that it will, in fact, be easiest to handle vim-like interactions with new code. 

3. Vim's ':' command will simply invoke Leo's minibuffer. This isn't precisely the same as Vim's status line: it is significantly better. Otoh, we will want a way to simulate the actual spelling of vim's ':' commands. Possible @abbreviation nodes can be pressed into service. 

4. Internally, it will be quite a trick to allow top-level vim-like plain-key bindings in all text widgets. I'm not sure how to do this, but it is essential. 

I am quite eager to get something truly vim-like working. It promises to increase my editing speed substantially. It also should appeal strongly to present vim users. 
#@nonl
#@-node:ekr.20070814083528.1:Design post
#@+node:ekr.20071026140857:Posting re vim bindings
@nocolor

> I'm looking forward to this.

Excellent.  You can help with the testing :-)

Leo looks like a perfect match for the vim approach.  Indeed, vim typically uses a 1 or 2 level concatenation scheme (preceded by a repeat count).  This is kinda like a utf-8 encoding :-)  That is, it is a variable-length encoding of the command.

This is a very powerful approach, one that vim doesn't really exploit (because it doesn't need to). But Leo absolutely needs this power of some extra levels.  Something like this:

i input mode

f focus commands
..fb focus to body
..fo focus to outline
..fl focus to log
..ft toggle body pane focus

o outline commands
..om outline move, i.e., actually move the nodes.
..og outline go, i.e., select nodes without changing the outline
..od outline delete
..oh outline edit headline

s search commands
..so search options
...soi toggle ignore-case checkbox
...sow toggle word checkbox
...etc!
..st search using search tab
..sf forward incremental search
..sb backward incremental search

x minibuffer commands

w file commands
..ws save outline
..wq quit

escape: universal escape, like ctrl-g now.

Do you see?  Just one extra level allows 10+ times the number of key bindings.  This is a perfect match for Leo's complex environment.

Naturally, Leo will allow the user to specify these bindings using nodes in the @settings tree. Indeed, this is truly an exciting prospect.

Edward

P.S.  I've glossed over the details of which single characters (like d for delete character) should be reserved for common editing and cursor-movement commands.  That's the beauty of creating these bindings with user settings: no need to argue :-)  And that's the beauty of arbitrarily deep key binding trees: there are plenty of keys to go around.

EKR
#@-node:ekr.20071026140857:Posting re vim bindings
#@-node:ekr.20070623144302:vim-like bindings
#@+node:ekr.20070625091423:Add translation services
@nocolor

*Many* calls to g.es and g.es_print have a mix of translated and untranslated items.
Untranslated items should include file names, directories, gnx's, leo_id's etc.

**Don't bother to do clone-find-all: there are 666 many matches!**

Regardless of the chosen scheme:

- g.translate will do the actual translation.

- Some simple string, like tr, will be an abbreviation for g.translate.
  The typical import will be::

    import leoGlobals as g ; tr = g.translate

The easiest scheme seems to be:

- g.es and g.es_print translate all arguments.
- g.esx and g.es_printx do no translation.

g.esx and g.es_printx allow a mix on translated and untranslated arguments::

    g.esx(tr('abc'),fileName)
#@-node:ekr.20070625091423:Add translation services
#@+node:ekr.20071001052501:Versioning for nodes
@nocolor

One feature I have not seen in SCS system is something which might be called
"history compression": I might be interested in having both version 5 and 6
in my source tree, when the current version is 7, but I am not really interested
in the 2000 steps which transformed 5 into 6 (just suggested this feature to
the bazaar people). This happens actually quite often to me, since I use the
SCS as a back-up system, saving many (uninteresting) intermediate steps while
implementing a new feature.
#@nonl
#@-node:ekr.20071001052501:Versioning for nodes
#@+node:ekr.20060530085844:Improve autocompletion
# Study rope:  http://rope.sourceforge.net/
#@nonl
#@+node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
@nocolor

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off.

@color
#@nonl
#@-node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
#@+node:ekr.20071106083149:Recent posts
@killcolor

I'm a little confused about the intended behaviour of autocomplete. I tried to test it using: 

@language python  

s = [1,2] 

I expected s. to yield a list of methods one might apply to a list (like append
etc...) instead it seems to give me a list of methods for a string. If one
replaces s with l, you don't get much of anything.

My responses 

The present autocompletion code is mostly a hack for working on Leo's own source
code. If your var is called s, the autocompleter assumes s is a string.

For the conventions used, see this node in leoPy.leo:

Code-->Gui Base classes-->@thin leoKeys.py-->class autoCompleterClass--> ctor
(autocompleter)-->defineObjectDict

Clearly, this is not good in general. I may generalize the code this week. Leo
will scan an @file tree (in a separate thread?) the first time you asked for
autocompletion in that tree.

-----

The issues involving autocompletion are coming back to my memory. In general,
this is a tricky problem. Consider:

- There may be no 'clean' version of the source code that you want to
auto-complete: you may be creating a new node, or a new file, and the source
code, being incomplete, will not parse correctly.

- Except in special circumstances, there is no 'real' object corresponding to s,
so there is no way to use Python's inspect module on s. Modules are an
exception: the autocompleter can handle existing modules fairly well. Try "os."
or "os.path." for example.

So I was a bit hasty in condemning the present approach. If your var is called
aList instead of s, Leo will suggest autocompletions for a list. Similarly for
s, s2 for strings, d, d1 and d2 for dictionaries, etc.

I'll look at the pyxides project for discussion of autocompleter code that might
be useful, but there are no guarantees that something better is coming soon.

-----

Scanning the pyxides thread about autocompletion, it seems the most promising tool is called rope: http://rope.sourceforge.net/ 

But to repeat: autocompletion is not easy. I have some long-delayed bugs to fix before turning my attention to an improved autocompleter. So probably not this week... 

----- 

1. It might be possible to generalize c.k.defineObjectDict so that the user
could specify autocompleter conventions, say in an @autocompleter node in an
@settings tree.

However, Python is not lisp, to actually specifying the object to use as the
base of the completion may not be trivial. See the code for
c.k.defineObjectDict.

2. Brian (LeoUser) used another kind of autocompleter scheme in his now-defunct
emacs plugin. When an outline was opened a scan (in a separate thread) found all
pairs x.y in the code. Typing x. would then give you all the y's associated with
x. It's clever, but it has obvious problems: it does not suggest completions
that are not in the file, and it suggests too much for 'self.'.

BTW, I actually did a lot of work on autocompletion that is not presently
active. In particular, leoKeys.py contains a 'forgiving' parser that attempts to
understand what 'self' means. Iirc, I disabled this code because it was too slow.
#@-node:ekr.20071106083149:Recent posts
#@+node:ekr.20071106135937:Study the pydev code in c:\prog\pydev
#@-node:ekr.20071106135937:Study the pydev code in c:\prog\pydev
#@+node:ekr.20071106135937.1:Study the rope code in c:\prog\rope
#@-node:ekr.20071106135937.1:Study the rope code in c:\prog\rope
#@-node:ekr.20060530085844:Improve autocompletion
#@-node:ekr.20070703111455.1:Most important
#@+node:ekr.20071105155631.1:Plugins
#@+node:ekr.20071021125124:Revise plugins manager plugin
Remove all references to pluginsManager.txt.
#@nonl
#@-node:ekr.20071021125124:Revise plugins manager plugin
#@+node:ekr.20071010162003:Add @rclick-menus trees to specify rclick popup menus
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4562648
By: rogererens

Maybe I may use this thread to make another suggestion for Leo 4.4.5, related
to @menus: have the menu-options for right-clicking in the various panes also
in the @settings-tree.

Regards, Roger
#@nonl
#@-node:ekr.20071010162003:Add @rclick-menus trees to specify rclick popup menus
#@+node:ekr.20071026052111:Fix cursesGui  plugin
#@+node:ekr.20071026051956:crash in cursesGui.py
reading settings in C:\prog\tigris-cvs\leo\config\leoSettings.leo
reading settings in C:\Documents and Settings\HP_Administrator\My Documents\Edward\myLeoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\test\test.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leoRecentFiles.txt
reading C:\prog\tigris-cvs\leo\config\.leoRecentFiles.txt
@enabled-plugins found in test.leo
textGui oops <module>,run,createFrame,openWithFileName,newLeoCommanderAndFrame,finishCreate,createKeyHandlerClass should be implem
ented
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 401, in <module>
    run(fileName)
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 144, in run
    c,frame = createFrame(fileName)
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 213, in createFrame
    ok, frame = g.openWithFileName(fileName,None)
  File "C:\prog\tigris-cvs\leo\src\leoGlobals.py", line 1908, in openWithFileName
    c,frame = app.newLeoCommanderAndFrame(fileName=fileName,gui=gui)
  File "C:\prog\tigris-cvs\leo\src\leoApp.py", line 577, in newLeoCommanderAndFrame
    c.finishCreate(initEditCommanders)
  File "c:\prog\tigris-cvs\leo\src\leoCommands.py", line 216, in finishCreate
    c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 247, in finishCreateEditCommanders
    d2 = theInstance.getPublicCommands()
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 1022, in getPublicCommands
    'keyboard-quit':                k.keyboardQuit,
AttributeError: 'NoneType' object has no attribute 'keyboardQuit'
>>>
#@nonl
#@-node:ekr.20071026051956:crash in cursesGui.py
#@-node:ekr.20071026052111:Fix cursesGui  plugin
#@+node:ekr.20071105155631.2:Fix script_io_to_body plugin
#@-node:ekr.20071105155631.2:Fix script_io_to_body plugin
#@-node:ekr.20071105155631.1:Plugins
#@+node:ekr.20071105155631.3:Testing
#@+node:ekr.20071014110905:Test pickled uA's to make sure they can be unpicled
@nocolor

From email from Terry Brown

python /home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leo.py /home/tbrown/.tnb.leo

(should be all on one line, i.e. run and open /home/tbrown/.tnb.leo)

gives the traceback below.  Opening the file from within Leo works fine.

Bah - I just now looked at it closely enough to realize it's the evil
pickled Tk classes in cleo uAs.  So I don't know whether you want to
fix that or not, it makes sense Leo would read the file specified on
the command line before Tk is initialized - if it's just scanning for
settings maybe it could catch and ignore failed uA reads at that time?

At some point I want to take pickled Tk vars out of cleo, I was
thinking when that guy was working on the wx gui would be a good time,
too bad he got sick.

Cheers -Terry

reading settings in /mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/config/leoSettings.leo
reading settings in /home/tbrown/leoSettings.leo
reading settings in /home/tbrown/myLeoSettings.leo
reading settings in /home/tbrown/.tnb.leo
Traceback (most recent call last):
  File "/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leo.py", line 398, in <module>
    run(fileName)
  File "/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leo.py", line 118, in run
    g.app.config.readSettingsFiles(fileName,verbose)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoConfig.py", line 1649, in readSettingsFiles
    c = self.openSettingsFile(path)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoConfig.py", line 1674, in openSettingsFile
    theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 892, in open
    silent=silent)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 779, in getLeoFile
    self.getAllLeoElements(fileName,silent)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1317, in getAllLeoElements
    self.getVnodes()
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1898, in getVnodes
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1738, in getVnode
    attr,val = self.getUa("vnode")
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1658, in getUa
    val2 = pickle.loads(binString)
  File "/usr/lib/python2.5/pickle.py", line 1374, in loads
    return Unpickler(file).load()
  File "/usr/lib/python2.5/pickle.py", line 858, in load
    dispatch[key](self)
  File "/usr/lib/python2.5/pickle.py", line 1217, in load_build
    setstate(state)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/plugins/cleo.py", line 130, in __setstate__
    Tk.Variable.__init__(self)
  File "/usr/lib/python2.5/lib-tk/Tkinter.py", line 188, in __init__
    self._tk = master.tk
AttributeError: 'NoneType' object has no attribute 'tk'
Exception exceptions.AttributeError: "TkPickleVar instance has no attribute '_tk'" in <bound method TkPickleVar.__del__ of <cleo.TkPickleVar instance at 0xb73a876c>> ignored
#@-node:ekr.20071014110905:Test pickled uA's to make sure they can be unpicled
#@+node:ekr.20071024172428:Failed unit tests when running externally
#@+node:ekr.20071024184325:4 leoEditCommands tests fail when run externally
creating: dynamicUnitTest.leo
FF.F...F.........
======================================================================
FAIL: @test c.editCommands.capitalizeHelper

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 14, in <module>
AssertionError: Expected Targetword, got: u''

======================================================================
FAIL: @test findWord

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 15, in <module>
AssertionError: got:

======================================================================
FAIL: @test selfInsertCommand-2 (replacing tabs)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 13, in <module>
AssertionError: last line:u'    '

======================================================================
FAIL: @test setMoveCol

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 12, in <module>
AssertionError

----------------------------------------------------------------------
Ran 17 tests in 0.047s

FAILED (failures=4)
#@+node:ekr.20051015114221.1:capitalizeHelper & test
def capitalizeHelper (self,event,which,undoType):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getWord(s,ins)
    word = s[i:j]
    # g.trace('word',repr(word))
    if not word.strip(): return

    self.beginCommand(undoType=undoType)

    if   which == 'cap':  word2 = word.capitalize()
    elif which == 'low':  word2 = word.lower()
    elif which == 'up':   word2 = word.upper()
    else: g.trace('can not happen: which = %s' %s (which))

    changed = word != word2
    # g.trace('changed',changed,'word2',repr(word2))

    if changed:
        w.delete(i,j)
        w.insert(i,word2)
        w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand(changed=changed,setLabel=True)
#@+node:ekr.20070627082044.268:@test c.editCommands.capitalizeHelper
# TARGETWORD
if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl

        for (which,result) in (('cap','Targetword'),('low','targetword'),('up','TARGETWORD')):
            w.setInsertPoint(5)
            c.editCommands.capitalizeHelper(event=None,which=which,undoType=None)
            s = w.getAllText()
            word = s[2:12]
            assert word == result, 'Expected %s, got: %s' % (result,repr(word))
            i = w.getInsertPoint()
            assert i == 5, 'Expected 5, got: %d' % i
    finally:
        c.endUpdate(False)
#@-node:ekr.20070627082044.268:@test c.editCommands.capitalizeHelper
#@-node:ekr.20051015114221.1:capitalizeHelper & test
#@+node:ekr.20060417194232.2:findWord & test
def findWord (self,event):

    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord)
    else:        
        word = k.arg ; w = self.w ; c = k.c
        if word:
            i = w.getInsertPoint()
            s = w.getAllText()
            j = s.find('\n',i) # Limit to this line.
            if j > -1: s = s[:j]
            while i < len(s):
                if g.match_word(s,i,word) and (i == 0 or not g.isWordChar(s[i-1])):
                    w.setSelectionRange(i,i+len(word))
                    break
                else:
                    i += 1
        k.resetLabel()
        k.clearState()
#@+node:ekr.20070627082044.270:@test findWord
# targetWord
if g.unitTesting:
    c.beginUpdate()
    try:
        k = c.k ; w = c.frame.body.bodyCtrl
        w.setInsertPoint(0)
        k.arg = 'targetWord'
        k.setState('find-word-on-line',1)
        f = c.editCommands.findWord(event=None)
        i,j = w.getSelectionRange()
        s = w.getAllText()
        word = s[i:j]
        assert word == 'targetWord', 'got: %s' % word
    finally:
        c.endUpdate(False)
#@-node:ekr.20070627082044.270:@test findWord
#@-node:ekr.20060417194232.2:findWord & test
#@+node:ekr.20051125080855:selfInsertCommand, helpers & tests
def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    #g.trace('ch',repr(ch))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:

            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    # g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if keysym == 'Tab': # Support for wx_alt_gui plugin.
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch and ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
#@nonl
#@-node:ekr.20051026171121:insertNewlineHelper
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'

    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = g.scanDirectives(c,p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.scanColorDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        w.delete(i,j)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]

        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        # g.trace('n',n)
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@+node:ekr.20070627082044.274:@test selfInsertCommand-1
if g.unitTesting:
    c.beginUpdate()
    try:
        ec = c.editCommands ; w = c.frame.body.bodyCtrl
        s = w.getAllText()

        # This strings tests unicode, paren matching, and auto-indentation.
        u = u'(a\u00c9\u03a9B\u3045\u4e7cz):\n' # '(aÉΩBぅ乼cz):\n'
        u = u'(pdq):\n'
        w.setInsertPoint(len(s))
        for char in u:
            event = g.Bunch(widget=w,char=char,keysym=None)
            ec.selfInsertCommand(event)
        result = w.getAllText()
        #g.trace('result',repr(result))
        assert result.endswith('    '),'result:%s' % repr(result) # Test of autocompleter.
    finally:
        w.setAllText(s)
        p.v.t.bodyString = s
        # g.trace(repr(s))
        c.recolor()
        c.endUpdate(False)

# end:
#@-node:ekr.20070627082044.274:@test selfInsertCommand-1
#@+node:ekr.20070627082044.275:@test selfInsertCommand-2 (replacing tabs)
if g.unitTesting:
    c.beginUpdate()
    try:
        ec = c.editCommands ; w = c.frame.body.bodyCtrl
        s = w.getAllText()
        w.setSelectionRange(len(s)-9,len(s)-6)
        event = g.Bunch(widget=w,char='\t',keysym=None)
        ec.selfInsertCommand(event)
        result = w.getAllText()
        # g.trace('result',repr(result))
        assert result.endswith('\n    abcdef'),'last line:%s' % repr(result.split('\n')[-1])
    finally:
        w.setAllText(s)
        p.v.t.bodyString = s
        # g.trace(repr(s))
        c.recolor()
        c.endUpdate(False)
###abcdef
#@nonl
#@-node:ekr.20070627082044.275:@test selfInsertCommand-2 (replacing tabs)
#@-node:ekr.20051125080855:selfInsertCommand, helpers & tests
#@+node:ekr.20060209095101:setMoveCol & test
def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t
#@nonl
#@+node:ekr.20070627082044.276:@test setMoveCol
if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl
        ec = c.editCommands

        for spot,result in (('1.0',0),(5,5)):
            ec.setMoveCol(w,spot)
            assert ec.moveSpot == result
            assert ec.moveCol == result
    finally:
        c.endUpdate(False)
#@-node:ekr.20070627082044.276:@test setMoveCol
#@-node:ekr.20060209095101:setMoveCol & test
#@-node:ekr.20071024184325:4 leoEditCommands tests fail when run externally
#@+node:ekr.20071024184907:2 gui Base class tests fail when run externally
creating: dynamicUnitTest.leo
...F.F.........
======================================================================
FAIL: @test leoBody.getInsertLines

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 13, in <module>
AssertionError: Got u''

======================================================================
FAIL: @test pasteText

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 14, in <module>
AssertionError

----------------------------------------------------------------------
Ran 15 tests in 0.063s

FAILED (failures=2)
#@+node:ekr.20031218072017.4030:getInsertLines & test (changed)
def getInsertLines (self):

    """Return before,after where:

    before is all the lines before the line containing the insert point.
    sel is the line containing the insert point.
    after is all the lines after the line containing the insert point.

    All lines end in a newline, except possibly the last line."""

    body = self ; w = body.bodyCtrl
    s = w.getAllText()
    insert = w.getInsertPoint()
    i,j = g.getLine(s,insert)
    before = s[0:i]
    ins = s[i:j]
    after = s[j:]

    before = g.toUnicode(before,g.app.tkEncoding)
    ins    = g.toUnicode(ins,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)

    return before,ins,after
#@+node:ekr.20070627082044.920:@test leoBody.getInsertLines
# line 1
# line 2
# line 3
if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl
        index = 11 # in the second line.
        w.setInsertPoint(index)
        before,ins,after = c.frame.body.getInsertLines()
        assert before == '# line 1\n','Got %s' % repr(before)
        assert ins    == '# line 2\n','Got %s' % repr(ins)
        assert after.startswith('# line 3\n')
        assert after.endswith('# end.')
    finally:
        c.endUpdate(False)
# end.
#@nonl
#@-node:ekr.20070627082044.920:@test leoBody.getInsertLines
#@-node:ekr.20031218072017.4030:getInsertLines & test (changed)
#@+node:ekr.20070130115927.7:leoFrame.pasteText & test
def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    # g.trace('isText',g.app.gui.isTextWidget(w),w)
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()

    # print 'pasteText',i,j,middleButton,wname,repr(c.k.previousSelection)

    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()

    singleLine = wname.startswith('head') or wname.startswith('minibuffer')

    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)

        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.getAllText()
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                width = f.tree.headWidth(p=None,s=s)
                w.setWidth(width)
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.

    return 'break' # Essential

OnPasteFromMenu = pasteText
#@+node:ekr.20070627082044.842:@test pasteText
# target
if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl
        # print (w)
        s2 = p.bodyString()
        s = w.getAllText()
        assert s == s2, 'w.getAllText() != p.bodyString(): len(w)=%d, len(p)=%d' % (len(s),len(s2))
        w.setInsertPoint(len(s))
        c.k.previousSelection = 2,8
        event = g.Bunch(widget=w)
        c.frame.pasteText(event=event,middleButton=True)
        s2 = w.getAllText()
        assert len(s2) == len(s) + len('target')
    finally:
        w.setAllText(s)
        p.v.t.bodyString = s2
        # g.trace(repr(s))
        c.recolor()
        c.endUpdate(False)
# end5targettargettarget
#@nonl
#@-node:ekr.20070627082044.842:@test pasteText
#@-node:ekr.20070130115927.7:leoFrame.pasteText & test
#@-node:ekr.20071024184907:2 gui Base class tests fail when run externally
#@+node:ekr.20071024185136:27 unitTest.txt tests fail when run externally
creating: dynamicUnitTest.leo

found  3 doctests for leoGlobals
found  1 doctests for leoTest
....FcompareOutlines failed
p1 <pos 24603600 lvl: 6 [0] tempNode> <vnode 23763024:'tempNode'>
p2 <pos 24604304 lvl: 7 [0] after> <vnode 23763312:'after'>
p1.body
u'# after'
p2.body
u'@language python\n\ndef addCommentTest():\n\n    # if 1:\n        # a = 2\n        # b = 3\n\n    pass'
FcompareOutlines failed
p1 <pos 52311152 lvl: 6 [0] tempNode> <vnode 23763024:'tempNode'>
p2 <pos 24604304 lvl: 7 [0] after> <vnode 23763696:'after'>
p1.body
u'@tabwidth -4\n\nline 1\n    line 2\n      line 3\nline4'
p2.body
u'@tabwidth -4\n\nline 1\n\tline 2\n\t  line 3\nline4'
FcompareOutlines failed
p1 <pos 52311312 lvl: 6 [0] tempNode> <vnode 23763024:'tempNode'>
p2 <pos 24603600 lvl: 7 [0] after> <vnode 23764080:'after'>
p1.body
u'@tabwidth -4\n\nline 1\n\tline 2\n\t  line 3\nline4'
p2.body
u'@tabwidth -4\n\nline 1\n    line 2\n      line 3\nline4'
FcompareOutlines failed
p1 <pos 25266416 lvl: 6 [0] tempNode> <vnode 23763024:'tempNode'>
p2 <pos 24604304 lvl: 7 [0] after> <vnode 23764464:'after'>
p1.body
u'@tabwidth -4\n\nline 1\n    line 2\n      line 3\nline4'
p2.body
u'@tabwidth -4\n\nline 1\n\tline 2\n\t  line 3\nline4'
FcompareOutlines failed
p1 <pos 24603600 lvl: 6 [0] tempNode> <vnode 23763024:'tempNode'>
p2 <pos 24604304 lvl: 7 [0] after> <vnode 23764848:'after'>
p1.body
u'@tabwidth -4\n\nline 1\n\tline 2\n\t  line 3\nline4'
p2.body
u'@tabwidth -4\n\nline 1\n    line 2\n      line 3\nline4'
FcompareOutlines failed
p1 <pos 24604304 lvl: 6 [0] tempNode> <vnode 23763024:'tempNode'>
p2 <pos 25266416 lvl: 7 [0] after> <vnode 23781648:'after'>
p1.body
u'line 1\n    line 2\n    line 3\nline 4'
p2.body
u'line 1\nline 2\nline 3\nline 4'
FcompareOutlines failed
p1 <pos 25266416 lvl: 6 [0] tempNode> <vnode 23763024:'tempNode'>
p2 <pos 24603600 lvl: 7 [0] after> <vnode 23782032:'after'>
p1.body
u'after'
p2.body
u'@language python\n\ndef deleteCommentTest():\n\n    if 1:\n        a = 2\n        b = 3\n\n    pass'
FcompareOutlines failed
p1 <pos 52311344 lvl: 6 [0] tempNode> <vnode 23763024:'tempNode'>
p2 <pos 25266416 lvl: 7 [0] after> <vnode 23782416:'after'>
p1.numberOfChildren()=0, p2.numberOfChildren()=1
p1.body
u'before\n    << section >>\n    sec line 1\n        sec line 2 indented\nsec line 3\nafter'
p2.body
u'before\nafter'
F.Selected text should start with a section name
compareOutlines failed
p1 <pos 24603600 lvl: 6 [0] tempNode> <vnode 23763024:'tempNode'>
p2 <pos 25266416 lvl: 7 [0] after> <vnode 23783280:'after'>
p1.numberOfChildren()=0, p2.numberOfChildren()=1
p1.body
u'before\n    << section >>\n    sec line 1\n        sec line 2 indented\nsec line 3\nafter'
p2.body
u'before\n    << section >>\nafter'
FSelected text should start with a section name
...............................................................................................................F..F.......
End of unit tests for typing
.FFFFFFFFFFFFFFcolorizer <threading_colorizer.nullColorizer instance at 0x0168B0A8>
................................................................................................................................................................
..........
End of doctests
...............F...
End of other unit tests
.............
======================================================================
FAIL: @test p.setBodyStringOrPane

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 15, in <module>
AssertionError: c.setBodyString failed: u'', 'after'

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1268, in runTest
    self.editBody()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1257, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: addComments: before undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1268, in runTest
    self.editBody()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1257, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: convertAllBlanks: before undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1268, in runTest
    self.editBody()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1257, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: convertAllTabs: before undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1268, in runTest
    self.editBody()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1257, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: convertBlanks: before undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1268, in runTest
    self.editBody()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1257, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: convertTabs: before undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1268, in runTest
    self.editBody()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1257, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: dedentBody: before undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1268, in runTest
    self.editBody()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1257, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: deleteComments: before undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1268, in runTest
    self.editBody()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1257, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: extract: before undo1

======================================================================
FAIL: runTest (leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1268, in runTest
    self.editBody()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1257, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: extractSection: before undo1

======================================================================
FAIL: @test paste from menu into headline sticks

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 24, in <module>
AssertionError: oops1: expected: Test headline abcABC, got Test headline abc

======================================================================
FAIL: @test selecting new node retains paste in headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 21, in <module>
AssertionError

======================================================================
FAIL: @test noTrailingNewline (pass)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 7, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1058, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1067, in runTest
    self.checkText()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 948, in checkText
    + "\n  Actual text: " + `newLines[i]`
AssertionError: Mismatch on line 0.
Expected text: u'This line is over forty characters long,\n'
  Actual text: u'This line is over forty characters long, at least it seems to be.'

======================================================================
FAIL: @test trailingNewline (pass)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 8, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1058, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1067, in runTest
    self.checkText()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 948, in checkText
    + "\n  Actual text: " + `newLines[i]`
AssertionError: Mismatch on line 0.
Expected text: u'This line is over forty characters long,\n'
  Actual text: u'This line is over forty characters long, at least it seems to be.\n'

======================================================================
FAIL: @test mixedLineLengths

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 7, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1058, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1067, in runTest
    self.checkText()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 948, in checkText
    + "\n  Actual text: " + `newLines[i]`
AssertionError: Mismatch on line 0.
Expected text: u'This line is over forty characters long,\n'
  Actual text: u'This line is over forty characters long, at least it seems to be.\n'

======================================================================
FAIL: @test mixedLinesWithLeadingWS

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 7, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1058, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1067, in runTest
    self.checkText()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 948, in checkText
    + "\n  Actual text: " + `newLines[i]`
AssertionError: Mismatch on line 0.
Expected text: u'This line is over forty characters long,\n'
  Actual text: u'This line is over forty characters long, at least it seems to be.\n'

======================================================================
FAIL: @test noChangeRequired

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 7, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1058, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1068, in runTest
    self.checkPosition(self.finalRow,self.finalCol)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 931, in checkPosition
    assert expCol == col, "Got column %d.  Expected %d" % (col,expCol)
AssertionError: Got column 0.  Expected 28

======================================================================
FAIL: @test honorLeadingWS

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 7, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1058, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1067, in runTest
    self.checkText()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 948, in checkText
    + "\n  Actual text: " + `newLines[i]`
AssertionError: Mismatch on line 0.
Expected text: u'   This line is over forty characters\n'
  Actual text: u'   This line is over forty characters long, at least it seems to be.\n'

======================================================================
FAIL: @test honorLeadingWSVar1

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 7, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1058, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1067, in runTest
    self.checkText()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 948, in checkText
    + "\n  Actual text: " + `newLines[i]`
AssertionError: Mismatch on line 0.
Expected text: u'   This line is over forty characters\n'
  Actual text: u'   This line is over forty characters long, at least it seems to be.\n'

======================================================================
FAIL: @test simpleHangingIndent

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 7, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1058, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1067, in runTest
    self.checkText()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 948, in checkText
    + "\n  Actual text: " + `newLines[i]`
AssertionError: Mismatch on line 0.
Expected text: u'Honor this line that has a hanging\n'
  Actual text: u'Honor this line that has a hanging indentation, please.  Hanging\n'

======================================================================
FAIL: @test testSimpleHangingIndentVar1

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 7, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1058, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1067, in runTest
    self.checkText()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 948, in checkText
    + "\n  Actual text: " + `newLines[i]`
AssertionError: Mismatch on line 0.
Expected text: u'Honor this line that has a hanging\n'
  Actual text: u'Honor this line that has\n'

======================================================================
FAIL: @test simpleHangingIndentVar2

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 7, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1058, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1067, in runTest
    self.checkText()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 948, in checkText
    + "\n  Actual text: " + `newLines[i]`
AssertionError: Mismatch on line 0.
Expected text: u'Honor this line that has a hanging\n'
  Actual text: u'Honor this line that \n'

======================================================================
FAIL: @test multiParagraphTest

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 7, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1080, in runTest
    self.checkPosition(13,0)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 933, in checkPosition
    assert expRow == row, "Got row %d.  Expected %d" % (row,expRow)
AssertionError: Got row 1.  Expected 13

======================================================================
FAIL: @test multiParagraphWithListTest

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 8, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1102, in runTest
    self.checkPosition(4,0)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 933, in checkPosition
    assert expRow == row, "Got row %d.  Expected %d" % (row,expRow)
AssertionError: Got row 1.  Expected 4

======================================================================
FAIL: @test leadingWSOnEmptyLinesTest

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 18, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1128, in runTest
    self.checkPosition(4,0)
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 933, in checkPosition
    assert expRow == row, "Got row %d.  Expected %d" % (row,expRow)
AssertionError: Got row 1.  Expected 4

======================================================================
FAIL: @test directiveBreaksParagraphTest

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 5, in <module>
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 915, in __init__
    self.go()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 922, in go
    self.runTest()
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 1154, in runTest
    self.checkPosition(13,0) # at next paragraph
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 933, in checkPosition
    assert expRow == row, "Got row %d.  Expected %d" % (row,expRow)
AssertionError: Got row 1.  Expected 13

======================================================================
FAIL: @test openURL

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoTest.py", line 162, in runTest
    exec script + '\n' in d
  File "<string>", line 9, in <module>
AssertionError: Got:None

----------------------------------------------------------------------
Ran 354 tests in 33.531s

FAILED (failures=27)
#@-node:ekr.20071024185136:27 unitTest.txt tests fail when run externally
#@+node:ekr.20071025143956:Posting: document unit test bug & describe coming new scheme
@nocolor

The new scheme:

- Run tests externally from leoPy.leo to test recent changes.
- Run tests locally from leoPy.leo for more 'accurate' tests.
    - External tests use null gui.  This can distort the tests.
    - Several tests fail because of problems in the nullGui (like select)

- Put general unit tests in unitTest.leo.
- Put most unit tests in leoPy.leo, near the code they test.
- Run @test nodes in leoPy.leo **from unitTest.leo**.
#@nonl
#@-node:ekr.20071025143956:Posting: document unit test bug & describe coming new scheme
#@-node:ekr.20071024172428:Failed unit tests when running externally
#@+node:ekr.20070220082124:Make sure Leo can generate Latex
#@-node:ekr.20070220082124:Make sure Leo can generate Latex
#@-node:ekr.20071105155631.3:Testing
#@+node:ekr.20070630143345:Other
#@+node:ekr.20070521105645:Improve api docs with epidoc?
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319363
By: ktenney

I think there is room for improvement in documenting Leo's
API, making it easier to write these kind of scripts.
I'm not sure of the best way to do that.

Epydoc seems to be the most active project in this realm.
http://epydoc.sourceforge.net/epydoc.html
#@-node:ekr.20070521105645:Improve api docs with epidoc?
#@+node:ekr.20070629070639:Add command: toggle-collapse_nodes_during_finds
val = c.config.getBool('collapse_nodes_during_finds')
c.config.set(p,'collapse_nodes_during_finds',not val)
g.es_print('collapse_nodes_during_finds',c.config.getBool('collapse_nodes_during_finds'))
#@nonl
#@-node:ekr.20070629070639:Add command: toggle-collapse_nodes_during_finds
#@+node:ekr.20061116054917.6:Remove blanks in calltips
#@-node:ekr.20061116054917.6:Remove blanks in calltips
#@+node:ekr.20070627151457:--runCommand option
@ --runCommand "leo-command-name" runs the command at idle-time after loading the file.
#@nonl
#@-node:ekr.20070627151457:--runCommand option
#@+node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """

    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"

if ext[0] != ".":
    ext = "."+ext

# print "ext",ext
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None

body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed

if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):

    """Return the path to the temp file corresponding to p and ext."""

    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)

        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)

        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)

        name = g.toUnicode(name,g.app.tkEncoding)

        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))

        path = g.os_path_join(td,name)

        return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    c.beginUpdate()
    try:
        if c.mFileName != "":
            # Calls c.setChanged(False) if no error.
            c.fileCommands.save(c.mFileName)
        else:
            fileName = g.app.gui.runSaveFileDialog(
                initialfile = c.mFileName,
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
            c.bringToFront()

            if fileName:
                # Don't change mFileName until the dialog has suceeded.
                c.mFileName = g.ensure_extension(fileName, ".leo")
                c.frame.title = c.mFileName
                c.frame.setTitle(g.computeWindowTitle(c.mFileName))
                c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
                c.fileCommands.save(c.mFileName)
                c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save As",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # 7/2/02: don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            # Calls c.setChanged(False) if no error.
            c.fileCommands.saveAs(c.mFileName)
            c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
#@-node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        # set local fileName, _not_ c.mFileName
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save To",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            fileName = g.ensure_extension(fileName, ".leo")
            c.fileCommands.saveTo(fileName)
            c.updateRecentFiles(fileName)

    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@-node:ekr.20061002093442:Add opml support to new,open, save commands
#@-node:ekr.20070630143345:Other
#@+node:ekr.20070703111455.3:Maybe
# some of these can wait till much later.
#@nonl
#@+node:ekr.20071027121956:Fix javaScript scanner
# Javascript syntax is truly bizarre.
#@nonl
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setTnodeText('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".js":
        self.scanJavaScriptText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20070713075450:Unit tests
# atAuto must be False for unit tests: otherwise the test gets wiped out.

def cUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest(p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.c')

def cSharpUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest(p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.c#')

def elispUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.el')

def htmlUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.htm')

def javaUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.java')

def javaScriptUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.js')

def pascalUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.pas')

def phpUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.php')

def pythonUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.py')

def textUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.txt')

def defaultImporterUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,ext='.xxx')
#@+node:ekr.20070713082220:scannerUnitTest
def scannerUnitTest (self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):

    '''Run a unit test of an import scanner,
    i.e., create a tree from string s at location p.'''

    c = self.c ; h = p.headString() ; old_root = p.copy()
    oldChanged = c.changed
    c.beginUpdate()
    try:
        d = g.app.unitTestDict
        expectedErrors = d.get('expectedErrors')
        expectedErrorMessage = d.get('expectedErrorMessage')
        expectedMismatchLine = d.get('expectedMismatchLine')
        g.app.unitTestDict = {
            'expectedErrors':expectedErrors,
            'expectedErrorMessage':expectedErrorMessage,
            'expectedMismatchLine':expectedMismatchLine,
        }
        if not fileName: fileName = p.headString()
        if not s: s = self.removeSentinelsCommand([fileName],toString=True)
        title = g.choose(h.startswith('@test'),h[5:],h)
        self.createOutline(title.strip(),p.copy(),atAuto=atAuto,s=s,ext=ext)
        d = g.app.unitTestDict
        ok = ((d.get('result') and expectedErrors in (None,0)) or
            (
                # checkTrialWrite returns *True* if the following match.
                # d.get('result') == False and
                d.get('actualErrors') == d.get('expectedErrors') and
                d.get('actualMismatchLine') == d.get('expectedMismatchLine') and
                (expectedErrorMessage is None or d.get('actualErrorMessage') == d.get('expectedErrorMessage'))
            ))
        if not ok:
            g.trace('result',d.get('result'),
                'actualErrors',d.get('actualErrors'),
                'expectedErrors',d.get('expectedErrors'),
                'actualMismatchLine',d.get('actualMismatchLine'),
                'expectedMismatchLine', d.get('expectedMismatchLine'),
                '\nactualErrorMessage  ',d.get('actualErrorMessage'),
                '\nexpectedErrorMessage',d.get('expectedErrorMessage'),
            )
        if not showTree and ok:
            while old_root.hasChildren():
                old_root.firstChild().doDelete()
            c.setChanged(oldChanged)

    finally:
        c.selectPosition(old_root)
        c.endUpdate()

    if g.app.unitTesting:
        assert ok

    return ok
#@-node:ekr.20070713082220:scannerUnitTest
#@-node:ekr.20070713075450:Unit tests
#@+node:ekr.20031218072017.3241:Scanners for createOutline
#@+node:ekr.20070703122141.65: class baseScannerClass
class baseScannerClass:

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
#@+node:ekr.20070703122141.66:baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.language = language
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.mismatchWarningGiven = False
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = None # Set in run: the tab width in effect in the c.currentPosition.
    self.tab_ws = '' # Set in run: the whitespace equivalent to one tab.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'  

    # Compute language ivars.
    delim1,delim2,delim3 = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # May be overridden in subclasses.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.classTags = ['class',] # tags that start a tag.
    self.functionTags = []
    self.hasClasses = True
    self.hasFunctions = True
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
#@-node:ekr.20070703122141.66:baseScannerClass.__init__
#@+node:ekr.20070808115837:Checking
#@+node:ekr.20070703122141.102:check
def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070703122141.104:checkTrialWrite & tests
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@+node:ekr.20070816103348:@test checkTriailWrite
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()

    g.app.unitTestDict ['expectedErrors'] = 1
    g.app.unitTestDict ['expectedMismatchLine'] = 2

    s1 = g.toUnicode('line1 Ä, ڱ,  궯, 奠\nline2\n',encoding='utf-8')
    s2 = g.toUnicode('line1 Ä, ڱ,  궯, 奠\nline2a\n',encoding='utf-8')
    runner.checkTrialWrite(s1=s1,s2=s2)
#@-node:ekr.20070816103348:@test checkTriailWrite
#@-node:ekr.20070703122141.104:checkTrialWrite & tests
#@+node:ekr.20070730093735:compareHelper & tests
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

    if i >= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print(repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]
    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif (not strict and not g.unitTesting) and line1.lstrip() == line2.lstrip():
        if not self.mismatchWarningGiven:
            self.mismatchWarningGiven = True
            g.es_print('Warning: leading whitespace does not match')
            g.es_print('First mismatched line at line %d % (i+1)')
            g.es_print('original line:  %s' % line1)
            g.es_print('generated line: %s' % line2)
        return True # A match excluding leading whitespace.
    else:
        if not g.app.unitTesting or i+1 != expectedMismatch:
            # g.es_print('compareHelper')
            g.es_print('*** first mismatch at line %d' % (i+1))
            g.es_print('original line:  %s' % line1)
            g.es_print('generated line: %s' % line2)
        d ['actualMismatchLine'] = i+1
        # g.trace('lines 1...\n',repr(lines1),'\nlines2...\n',repr(lines2))
        return False
#@+node:ekr.20070816101019:@test compareHelper
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    i = 0
    lines1 = ['abc',]
    lines2 = ['xyz',]

    g.app.unitTestDict ['expectedErrors'] = 1
    g.app.unitTestDict ['expectedMismatchLine'] = 1

    runner.compareHelper(lines1,lines2,i,strict=True)
#@-node:ekr.20070816101019:@test compareHelper
#@+node:ekr.20071030115446.1:@test compareHelper-warning
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='java')
    i = 0
    lines1 = ['abc',]
    lines2 = [' abc',]

    g.unitTesting = False # force the warning.

    g.app.unitTestDict ['expectedErrors'] = 0
    g.app.unitTestDict ['expectedMismatchLine'] = 0

    runner.compareHelper(lines1,lines2,i,strict=False)
#@-node:ekr.20071030115446.1:@test compareHelper-warning
#@-node:ekr.20070730093735:compareHelper & tests
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import the file perfectly\nfirst mismatched line: %d\n%s' % (
            kind,bad_i,repr(lines2[bad_i-1])))

    if len(lines1) < 100:
        pr('input...')
        for i in xrange(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in xrange(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
#@+node:ekr.20070913084008:minitest of pr
if False: # Don't clutter the unit tests.

    def pr(*args,**keys): # reportMismatch test
        g.es_print(color='blue',*args,**keys)

    pr('input...')
    pr('newline=False:',newline=False)
    pr('after')
    pr('done')
#@-node:ekr.20070913084008:minitest of pr
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20070808115837:Checking
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    # g.trace(parent.headString())

    if self.treeType == '@file':
        c.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20070705144309:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20070705144309:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent.headString(),headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.c.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070703122141.81:massageComment
def massageComment (self,s):

    '''Return s with leading and trailing whitespace removed and all other
    runs of whitespace and newlines converted to a single blank.'''

    s = s.strip()
    s = s.replace('\n',' ')
    s = s.replace('\r',' ')
    s = s.replace('\t',' ')
    s = s.replace('  ',' ')
    s = s.strip()
    return s
#@-node:ekr.20070703122141.81:massageComment
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,i,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.classLines = []
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    # Remember the indentation of the class line.
    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,bodyIndent,classDelim,decls,trailing = self.putClassHelper(s,i,codeEnd,class_name,class_node)
    # g.trace('bodyIndent',bodyIndent,'undentVal',undentVal)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name) or ''

    # Give ref the same indentation as the body of the class.
    if ref:
        bodyWs = g.computeLeadingWhitespace (bodyIndent,self.tab_width)
        ref = '%s%s' % (bodyWs,ref)

    # Remove the leading whitespace.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        self.undentBy(decls,undentVal) +
        self.undentBy(ref,undentVal) +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070703122141.106:getClassNodeRef
def getClassNodeRef (self,class_name):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    return '%s\n' % (s)
#@-node:ekr.20070703122141.106:getClassNodeRef
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    j = i ; i = self.skipDecls(s,i,end,inClass=True)
    decls = s[j:i]

    # Set the body indent if there are real decls.
    bodyIndent = decls.strip() and self.getIndent(s,i) or None

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,bodyIndent2 = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,bodyIndent2 = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    if bodyIndent is None: bodyIndent = bodyIndent2

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,bodyIndent,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and self.trace

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body1 = s[start:sigStart]
    # Bug fix: 2007/20/31: adjust start backwards to get a better undent.
    if body1.strip():
        while start > 0 and s[start-1] in (' ','\t'):
            start -= 1

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if trace: g.trace('body\n%s' % body)

    if not body.endswith('\n'):
        self.error(
            'function %s does not end with a newline; one will be added\n%s' % (
                self.sigId,g.get_line(s,codeEnd)))
        g.trace(g.callers())

    self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
#@-node:ekr.20070707082432:putFunction
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    c.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20070703122141.88:undentBody & undentBy
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    # Copy an @code line as is.
    # i = 0
    # if g.match(s,i,'@code'):
        # j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        # result += s[j:i]

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        # result = ''.join([
            # g.removeLeadingWhitespace(line,undent,self.tab_width)
                # for line in g.splitLines(s)])
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result

def undentBy (self,s,undentVal):
    return ''.join(
        [g.removeLeadingWhitespace(line,undentVal,self.tab_width)
            for line in g.splitLines(s)])
#@-node:ekr.20070703122141.88:undentBody & undentBy
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    self.error(
        'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@+node:ekr.20070703122141.78:error & oops
def error (self,s):

    self.errors += 1
    self.importCommands.errors += 1
    if g.app.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict['actualErrorMessage'] = s
        g.app.unitTestDict['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.trace(g.callers())
            g.es_print(s,color='red')
    else:
        g.es_print(s,color='red')

def oops (self):
    print 'baseScannerClass oops: %s must be overridden in subclass' % g.callers()
#@-node:ekr.20070703122141.78:error & oops
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20071017132056:getIndent
def getIndent (self,s,i):

    j,j2 = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    # g.trace('%d %s' % (indent,s[j:j2]))
    return indent
#@nonl
#@-node:ekr.20071017132056:getIndent
#@+node:ekr.20070706101600:scan & scanHelper
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start < len(s):
        self.c.appendStringToBody(parent,s[start:]) 
#@+node:ekr.20071018084830:scanHelper
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    # g.trace(g.callers())
    # g.trace('i',i,g.get_line(s,i))
    assert kind in ('class','outer')
    start = i ; putRef = False ; bodyIndent = None
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = start = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else: i += 1

        # if progress == i: g.pdb()
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,bodyIndent
#@-node:ekr.20071018084830:scanHelper
#@-node:ekr.20070706101600:scan & scanHelper
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level <= 0:
                if trace: g.trace('returns\n',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    self.error('no block')
    if 1:
        i,j = g.getLine(s,start)
        g.trace(s[max(0,i-20):i+20])
    if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls
def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.

    The decls *must* end in a newline.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    if trace: g.trace(g.callers())
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            break
        elif self.startsFunction(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            break
        else:
            i += 1 ;  prefix = None
        # if progress == i: g.pdb()
        assert(progress < i)

    if prefix is not None:
        i = g.find_line_start(s,prefix) # i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
#@-node:ekr.20070707080042:skipDecls
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i < len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i >= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasClasses and self.startsHelper(s,i,kind='class',tags=self.classTags)
    return val

def startsFunction (self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasFunctions and self.startsHelper(s,i,kind='function',tags=self.functionTags)
    return val
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    # if not tags: return False

    trace = self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
        return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if 0: ### wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    # __pychecker__ = '--no-argsused' # tags not used in the base class.

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i < len(s) and s[i],ids,classId)
    return i, ids, classId
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@+node:ekr.20070711134534:skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
#@-node:ekr.20070711134534:skipSigId
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1))
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    c = self.c
    self.root = root = parent.copy()
    self.file_s = s
    self.tab_width = self.importCommands.getTabWidth(p=root)
    # g.trace('tab_width',self.tab_width)
    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    self.mismatchWarningGiven = False
    changed = c.isChanged()

    # Regularize leading whitespace for strict languages only.
    if self.strict:
        s = self.regularizeWhitespace(s)

    # Generate the nodes, including directive and section references.
    self.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and self.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: self.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@-node:ekr.20070707072749:run (baseScannerClass)
#@-node:ekr.20070703122141.65: class baseScannerClass
#@+node:edreamleo.20070710110114.1:C scanner
#@+node:edreamleo.20070710110153:scanCText
def scanCText (self,s,parent,atAuto=False):

    scanner = self.cScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:edreamleo.20070710110153:scanCText
#@+node:edreamleo.20070710093042:class cScanner (baseScannerClass)
class cScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = '#' # A hack: treat preprocess directives as comments(!)
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.sigHeadExtraTokens = ['*']
        self.sigFailTokens = [';','=']
#@-node:edreamleo.20070710093042:class cScanner (baseScannerClass)
#@-node:edreamleo.20070710110114.1:C scanner
#@+node:ekr.20071008130845:C# scanner
#@+node:ekr.20071008130845.1:scanCSharpText
def scanCSharpText (self,s,parent,atAuto=False):

    scanner = self.cSharpScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20071008130845.1:scanCSharpText
#@+node:ekr.20071008130845.2:class cSharpScanner (baseScannerClass)
class cSharpScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class','interface','namespace',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = None
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.sigHeadExtraTokens = []
        self.sigFailTokens = [';','='] # Just like C.
#@-node:ekr.20071008130845.2:class cSharpScanner (baseScannerClass)
#@-node:ekr.20071008130845:C# scanner
#@+node:ekr.20070711060107:Elisp scanner
#@+node:ekr.20070711060107.1:scanElispText
def scanElispText (self,s,parent,atAuto=False):

    scanner = self.elispScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20070711060107.1:scanElispText
#@+node:ekr.20070711060113:class elispScanner (baseScannerClass)
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False
    end = self.skipBlock(s,i)
    if not g.match(s,end,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len(key)
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = g.skip_id(s,i)
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner (baseScannerClass)
#@-node:ekr.20070711060107:Elisp scanner
#@+node:edreamleo.20070710110114:Java scanner
#@+node:edreamleo.20070710110114.2:scanJavaText
def scanJavaText (self,s,parent,atAuto=False):

    scanner = self.javaScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:edreamleo.20070710110114.2:scanJavaText
#@+node:edreamleo.20070710085115:class javaScanner (baseScannerClass)
class javaScanner (baseScannerClass):

    @others
#@+node:ekr.20071019171430:javaScanner.__init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = '{'
    self.classTags = ['class','interface']
    self.functionTags = []
    self.sigFailTokens = [';','='] # Just like c.
#@-node:ekr.20071019171430:javaScanner.__init__
#@+node:ekr.20071019170943:javaScanner.skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    # Remove 'public' and 'private'
    ids2 = [z for z in ids if z not in ('public','private','final',)]

    # Remove 'extends' and everything after it.
    ids = []
    for z in ids2:
        if z == 'extends': break
        ids.append(z)

    return i, ids and ids[-1]
#@-node:ekr.20071019170943:javaScanner.skipSigId
#@-node:edreamleo.20070710085115:class javaScanner (baseScannerClass)
#@-node:edreamleo.20070710110114:Java scanner
#@+node:ekr.20071027111225:JavaScript scanner (not ready yet)
# The syntax for patterns causes all kinds of problems...
#@nonl
#@+node:ekr.20071027111225.1:scanJavaScriptText
def scanJavaScriptText (self,s,parent,atAuto=False):

    scanner = self.javaScriptScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20071027111225.1:scanJavaScriptText
#@+node:ekr.20071027111225.2:class javaScriptScanner (baseScannerClass)
class javaScriptScanner (baseScannerClass):

    @others
#@+node:ekr.20071027111225.3:javaScriptScanner.__init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java') # Used to set comment delims.

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.hasClasses = False
    self.hasFunctions = True
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None # For now, ignore outer blocks.
    self.outerBlockDelim2 = None
    self.classTags = []
    self.functionTags = ['function']
    self.sigFailTokens = [';',] # ','=',] # Just like Java.
#@-node:ekr.20071027111225.3:javaScriptScanner.__init__
#@+node:ekr.20071102150937:startsString
def startsString(self,s,i):

    if g.match(s,i,'"') or g.match(s,i,"'"):
        # Count the number of preceding backslashes:
        n = 0 ; j = i-1
        while j >= 0 and s[j] == '\\':
            n += 1
            j -= 1
        return (n % 2) == 0
    # elif g.match(s,i,'/'):
        # return i == 0 or s[i-1] != '/'
    else:
        return False
#@-node:ekr.20071102150937:startsString
#@+node:ekr.20071102161115:skipString
# Not ready: '/' is also the division operator!


# def skipString (self,s,i):

    # # Returns len(s) on unterminated string.
    # if s[i] in ('"',"'"):
        # return g.skip_string(s,i,verbose=False)
    # else:
        # # Match a pattern.
        # delim = '/'
        # g.pdb()
        # assert(s[i] == delim)
        # i += 1
        # n = len(s)
        # while i < n:
            # if s[i] == delim and s[i-1] != '\\':
                # return i + 1
            # else:
                # i += 1
        # return i
#@nonl
#@-node:ekr.20071102161115:skipString
#@-node:ekr.20071027111225.2:class javaScriptScanner (baseScannerClass)
#@-node:ekr.20071027111225:JavaScript scanner (not ready yet)
#@+node:ekr.20070711104241:Pascal scanner
#@+node:ekr.20070711104241.2:scanPascalText
def scanPascalText (self,s,parent,atAuto=False):

    scanner = self.pascalScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@nonl
#@-node:ekr.20070711104241.2:scanPascalText
#@+node:ekr.20070711104241.3:class pascalScanner (baseScannerClass)
class pascalScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='pascal')

        # Set the parser delims.
        self.blockCommentDelim1 = '(*'
        self.blockCommentDelim2 = '*)'
        self.lineCommentDelim = '//'
        self.blockDelim1 = 'begin'
        self.blockDelim2 = 'end'
        self.classTags = []
        self.functionTags = ['function','procedure','constructor','destructor',]
#@-node:ekr.20070711104241.3:class pascalScanner (baseScannerClass)
#@-node:ekr.20070711104241:Pascal scanner
#@+node:ekr.20070711090052:PHP scanner
#@+node:ekr.20070711090122:scanPHPText
def scanPHPText (self,s,parent,atAuto=False):

    scanner = self.phpScanner(importCommands=self,atAuto=atAuto)

    if scanner.isPurePHP(s):
        scanner.run(s,parent)
    else:
        fileName = scanner.fileName
        if not atAuto:
            g.es_print('%s seems to be mixed HTML and PHP.' % fileName)
        scanner.createHeadline(
            parent,body=s,headline=fileName)
#@-node:ekr.20070711090122:scanPHPText
#@+node:ekr.20070711090052.1:class phpScanner (baseScannerClass)
class phpScanner (baseScannerClass):

    @others
#@+node:ekr.20070711090052.2: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
#@-node:ekr.20070711090052.2: __init__
#@+node:ekr.20070711094850:isPurePHP
def isPurePHP (self,s):

    '''Return True if the file begins with <?php or ends with ?>'''

    s = s.strip()

    return (
        s.startswith('<?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?>'))

#@-node:ekr.20070711094850:isPurePHP
#@+node:ekr.20070711090052.3:Overrides
# Does not create @first/@last nodes
#@+node:ekr.20070711090807:startsString skipString
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'<<<')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return self.skipString()
    else:
        return g.skip_heredoc_string(s,i)
#@-node:ekr.20070711090807:startsString skipString
#@-node:ekr.20070711090052.3:Overrides
#@-node:ekr.20070711090052.1:class phpScanner (baseScannerClass)
#@-node:ekr.20070711090052:PHP scanner
#@+node:ekr.20070703123334.2:Python scanner
#@+node:ekr.20070703122141.99:scanPythonText
def scanPythonText (self,s,parent,atAuto=False):

    scanner = self.pythonScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20070703122141.99:scanPythonText
#@+node:ekr.20070703122141.100:class pythonScanner (baseScannerClass)
class pythonScanner (baseScannerClass):

    @others
#@+node:ekr.20070703122141.101: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='python')

    # Set the parser delims.
    self.lineCommentDelim = '#'
    self.classTags = ['class',]
    self.functionTags = ['def',]
    self.blockDelim1 = self.blockDelim2 = None
        # Suppress the check for the block delim.
        # The check is done in skipSigTail.
    self.strict = True

#@-node:ekr.20070703122141.101: __init__
#@+node:ekr.20070707113839:extendSignature
def extendSignature(self,s,i):

    '''Extend the text to be added to the class node following the signature.

    The text *must* end with a newline.'''

    # Add a docstring to the class node,
    # And everything on the line following it
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j < len(s): # No scanning error.
            # Return the docstring only if nothing but whitespace follows.
            j = g.skip_ws(s,j)
            if g.is_nl(s,j):
                return j + 1

    return i
#@-node:ekr.20070707113839:extendSignature
#@+node:ekr.20070707073627.4:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_python_string(s,i,verbose=False)
#@-node:ekr.20070707073627.4:skipString
#@+node:ekr.20070712090019.1:skipCodeBlock (python) & helper
def skipCodeBlock (self,s,i,kind):

    trace = False ; verbose = False
    # if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i < len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            i = g.skip_nl(s,i)
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                pass # We have already made progress.
            else:
                if trace and verbose: g.trace(g.get_line(s,i))
                backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
                if not backslashNewline:
                    i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                        s,i,parenCount,startIndent,underIndentedStart)
                    if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 < i < len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
        return i,False
    if (trace or self.trace) and s[start:i].strip():
        g.trace('%s returns\n' % (kind) + s[start:i])
    return i,True
#@+node:ekr.20070801080447:pythonNewlineHelper
def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if trace: g.trace('startIndent',startIndent,'indent',indent,'line',repr(g.get_line(s,j)))
    if indent <= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent <= startIndent:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedComment(line)
            underIndentedStart = None
    if trace: g.trace('returns',i,'underIndentedStart',underIndentedStart)
    return i,underIndentedStart,breakFlag
#@-node:ekr.20070801080447:pythonNewlineHelper
#@-node:ekr.20070712090019.1:skipCodeBlock (python) & helper
#@+node:ekr.20070803101619:skipSigTail
# This must be overridden in order to handle newlines properly.

def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    while i < len(s):
        ch = s[i]
        if ch == '\n':
            break
        elif ch in (' ','\t',):
            i += 1
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        else:
            break

    return i,g.match(s,i,':')
#@-node:ekr.20070803101619:skipSigTail
#@-node:ekr.20070703122141.100:class pythonScanner (baseScannerClass)
#@-node:ekr.20070703123334.2:Python scanner
#@+node:ekr.20070713075352:Default scanner
def scanUnknownFileType (self,s,p,ext,atAuto=False):

    c = self.c
    changed = c.isChanged()
    body = g.choose(atAuto,'','@ignore\n')
    if ext in ('.html','.htm'): body += '@language html\n'
    if ext in ('.txt','.text'): body += '@nocolor\n'
    c.setBodyString(p,body + self.rootLine + s)
    if atAuto:
        for p in p.self_and_subtree_iter():
            p.clearDirty()
        if not changed:
            c.setChanged(False)

    g.app.unitTestDict = {'result':True}
#@-node:ekr.20070713075352:Default scanner
#@-node:ekr.20031218072017.3241:Scanners for createOutline
#@+node:ekr.20071027111225:JavaScript scanner (not ready yet)
# The syntax for patterns causes all kinds of problems...
#@nonl
#@+node:ekr.20071027111225.1:scanJavaScriptText
def scanJavaScriptText (self,s,parent,atAuto=False):

    scanner = self.javaScriptScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20071027111225.1:scanJavaScriptText
#@+node:ekr.20071027111225.2:class javaScriptScanner (baseScannerClass)
class javaScriptScanner (baseScannerClass):

    @others
#@+node:ekr.20071027111225.3:javaScriptScanner.__init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java') # Used to set comment delims.

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.hasClasses = False
    self.hasFunctions = True
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None # For now, ignore outer blocks.
    self.outerBlockDelim2 = None
    self.classTags = []
    self.functionTags = ['function']
    self.sigFailTokens = [';',] # ','=',] # Just like Java.
#@-node:ekr.20071027111225.3:javaScriptScanner.__init__
#@+node:ekr.20071102150937:startsString
def startsString(self,s,i):

    if g.match(s,i,'"') or g.match(s,i,"'"):
        # Count the number of preceding backslashes:
        n = 0 ; j = i-1
        while j >= 0 and s[j] == '\\':
            n += 1
            j -= 1
        return (n % 2) == 0
    # elif g.match(s,i,'/'):
        # return i == 0 or s[i-1] != '/'
    else:
        return False
#@-node:ekr.20071102150937:startsString
#@+node:ekr.20071102161115:skipString
# Not ready: '/' is also the division operator!


# def skipString (self,s,i):

    # # Returns len(s) on unterminated string.
    # if s[i] in ('"',"'"):
        # return g.skip_string(s,i,verbose=False)
    # else:
        # # Match a pattern.
        # delim = '/'
        # g.pdb()
        # assert(s[i] == delim)
        # i += 1
        # n = len(s)
        # while i < n:
            # if s[i] == delim and s[i-1] != '\\':
                # return i + 1
            # else:
                # i += 1
        # return i
#@nonl
#@-node:ekr.20071102161115:skipString
#@-node:ekr.20071027111225.2:class javaScriptScanner (baseScannerClass)
#@-node:ekr.20071027111225:JavaScript scanner (not ready yet)
#@-node:ekr.20071027121956:Fix javaScript scanner
#@+node:ekr.20071004120359.2:Do expand-region-abbrevs from
#@+node:ekr.20050920084036.21:regionalExpandAbbrev (TK code)
# def regionalExpandAbbrev (self,event):

    # '''Exapand abbreviations throughout a region.'''

    # k = self.k ; w = self.editWidget(event)
    # if not w or not self._chckSel(event): return

    # i1,i2 = w.getSelectionRange()
    # ins = w.getInsertPoint()
    # << define a new generator searchXR >>

    # # EKR: the 'result' of calling searchXR is a generator object.
    # k.regx.iter = searchXR(i1,i2,ins,event)
    # k.regx.iter.next() # Call it the first time.
#@nonl
#@+node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
# @ This is a generator (it contains a yield).
# To make this work we must define a new generator for each call to regionalExpandAbbrev.
# @c
# def searchXR (i1,i2,ins,event):
    # k = self.k
    # w = self.editWidget(event)
    # if not w: return

    # w.tag_add('sXR',i1,i2)
    # while i1:
        # tr = w.tag_ranges('sXR')
        # if not tr: break
        # i1 = w.search(r'\w',i1,stopindex=tr[1],regexp=True)
        # if i1:
            # word = w.get('%s wordstart' % i1,'%s wordend' % i1)
            # w.tag_delete('found')
            # w.tag_add('found','%s wordstart' % i1,'%s wordend' % i1)
            # w.tag_config('found',background='yellow')
            # if self.abbrevs.has_key(word):
                # k.setLabel('Replace %s with %s? y/n' % (word,self.abbrevs[word]))
                # yield None
                # if k.regXKey == 'y':
                    # ind = w.index('%s wordstart' % i1)
                    # w.delete('%s wordstart' % i1,'%s wordend' % i1)
                    # w.insert(ind,self.abbrevs[word])
            # i1 = '%s wordend' % i1
    # w.setInsertPoint(ins,ins,insert=ins)
    # w.tag_delete('sXR')
    # w.tag_delete('found')
    # k.setLabelGrey('')
    # self.k.regx = g.bunch(iter=None,key=None)
#@-node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
#@-node:ekr.20050920084036.21:regionalExpandAbbrev (TK code)
#@-node:ekr.20071004120359.2:Do expand-region-abbrevs from
#@+node:ekr.20070905072809.1:Mulder post re svn
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4484641
By: bwmulder

Actually we are talking about two plugins here: a bazaar plugin, and a
Leo plugin.

The bazaar plugin would do special things for Leo files during checkout, status
and checkin. After checkout, for example, it would delete the sentinels in the
user visible files.

The Leo plugin would know to go to the repository for reading (and writing?).

One open question is to where to store new sentinels: can they be hidden away
in the Source Control System (SCS) directories?

Another open question: Could Leo sentinels be used as an identity marker, which
unambiguously identifies a piece of text? With that, the SCS system might have
enough information to make statements like:

Lines 10-100 where in file x where moved from file y, in other words: the SCS
could track code at the function level.

The whole process could then work like this:

1. You check out your sources.
2. After checkout, the bazaar plugin would delete all sentinels from the checked-out
files.
3. If you start Leo, Leo would read the (full) file from the SCS.
4. If you make modifications, the full file would be hidden in SCS directories,
and the disk file would (again) show no sentinels.
5. I don't know how the bazaar status command works. We must make sure that
status works correctly for Leo files as it does for any other files.
6. For checkin, the SCS system would have to use the information hidden in step
4.

Open questions:

1. Can the Leo sentinels be used as a permanent identity markers for text? If
they can't be right now, would Edward be willing to modify them so that they
can?
2. Can / should we make the full files available somehow (probably)
2. How would conflict resolution work? Can / should we hide the sentinels even
then? (probably not)

So the answer to your question is: yes, I am thinking about such plugins, though
I am not (yet) thinking of writing such plugins myself.

______________________________________________________________________
You are receiving this email because you elected to monitor this forum.
To stop monitoring this forum, login to SourceForge.net and visit:
https://sourceforge.net/forum/unmonitor.php?forum_id=10226
#@-node:ekr.20070905072809.1:Mulder post re svn
#@+node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061014050154.2:Binding to None clears all bindings
#@-node:ekr.20061014050154.2:Binding to None clears all bindings
#@+node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@-node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@+node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20070605114358:Improve how recent files works?
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4347116
By: terry_n_brown

This is just a nit I guess, but I move between two machines all the time, and
Leo keeps changing the paths I open from /home/tbrown/project/project.leo to
/media/hda8/project/project.leo, so that when I switch to the other machine,
where /home/tbrown/project/project.leo is actually /media/hdb2/project/project.leo,
the recent files link is wrong.

If it would be trivial for Leo to not do this, I'd like that feature.  If it's
a big deal, then not to worry, I can always navigate to the file of course.
#@-node:ekr.20070605114358:Improve how recent files works?
#@+node:ekr.20070619161413:Finish support for hidden windows
@

*** Important ***

The new code is just barely enough to open a window with a nullGui for @button dynamic-tests.
**However**, it is just the start of what would be required to open a window and execute most operations on it.
In particular, throughout leoEditCommands.py we should substitute c.frame.gui (or self.gui) for g.app.gui.
But it's way too late in the Leo 4.4.3 release cycle to do that.
#@nonl
#@+node:ekr.20031218072017.3679:  leoFrame.__init__
def __init__ (self,gui):

    self.c = None # Must be created by subclasses.
    self.title = None # Must be created by subclasses.
    self.gui = gui

    # Objects attached to this frame.
    self.colorPanel = None 
    self.comparePanel = None
    self.findPanel = None
    self.fontPanel = None
    self.iconBar = None
    self.isNullFrame = False
    self.keys = None
    self.menu = None
    self.miniBufferWidget = None # New in 4.4.
    self.prefsPanel = None
    self.statusLine = None
    self.useMiniBufferWidget = False # New in 4.4

    # Gui-independent data
    self.componentsDict = {} # Keys are names, values are componentClass instances.
    self.es_newlines = 0 # newline count for this log stream
    self.openDirectory = ""
    self.requestRecolorFlag = False
    self.saved=False # True if ever saved
    self.splitVerticalFlag,self.ratio, self.secondary_ratio = True,0.5,0.5 # Set by initialRatios later.
    self.startupWindow=False # True if initially opened window
    self.stylesheet = None # The contents of <?xml-stylesheet...?> line.
    self.tab_width = 0 # The tab width in effect in this pane.

#@+node:ekr.20061109120726:leoFrame.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (

    'initialRatios',
    'longFileName',
    'oops',
    'promptForSave',
    'scanForTabWidth',
    'shortFileName',

    # Headline editing.
    'abortEditLabelCommand',
    'endEditLabelCommand',
    'insertHeadlineTime',

    # Cut/Copy/Paste.
    'OnPaste',
    'OnPasteFromMenu',
    'copyText',
    'cutText',
    'pasteText',

    # Icon bar convenience methods.    
    'addIconButton',
    'clearIconBar',
    'createIconBar',
    'getIconBar',
    'getIconBarObject',
    'hideIconBar',

    # Status line convenience methods.
    'createStatusLine',
    'clearStatusLine',
    'disableStatusLine',
    'enableStatusLine',
    'getStatusLine',
    'getStatusObject',
    'putStatusLine',
    'setFocusStatusLine',
    'statusLineIsEnabled',
    'updateStatusLine',
)
#@nonl
#@-node:ekr.20061109120726:leoFrame.mustBeDefinedOnlyInBaseClass
#@+node:ekr.20061109120704:leoFrame.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    #Gui-dependent commands.
    'cascade',
    'contractBodyPane',
    'contractLogPane',
    'contractOutlinePane',
    'contractPane',
    'equalSizedPanes',
    'expandLogPane',
    'expandPane',
    'fullyExpandBodyPane',
    'fullyExpandLogPane',
    'fullyExpandOutlinePane',
    'fullyExpandPane',
    'hideBodyPane',
    'hideLogPane',
    'hideLogWindow',
    'hideOutlinePane',
    'hidePane',
    'leoHelp',
    'minimizeAll',
    'resizeToScreen',
    'toggleActivePane',
    'toggleSplitDirection',
    # Windowutilities...
    'bringToFront',
    'deiconify',
    'get_window_info',
    'lift',
    'update',
    # Config...
    'resizePanesToRatio',
    'setInitialWindowGeometry',
    'setTopGeometry',
)
#@nonl
#@-node:ekr.20061109120704:leoFrame.mustBeDefinedInSubclasses
#@-node:ekr.20031218072017.3679:  leoFrame.__init__
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(fileName=fileName,gui=gui)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        k and k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,fileName=None,gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leoCommands

    if not fileName: fileName = ""
    if not gui: gui = g.app.gui
    << compute the window title >>

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    if updateRecentFiles:
        c.updateRecentFiles(fileName)

    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@+node:ekr.20031218072017.1623:new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20070302095121:createTextWidget
def createTextWidget (self,parentFrame=None):

    self.logNumber += 1

    c = self.c

    gui = c and c.frame and c.frame.gui or g.app.gui

    log = gui.plainTextWidget(
        c = self.c,
        name="log-%d" % self.logNumber,
    )

    return log
#@-node:ekr.20070302095121:createTextWidget
#@+node:ekr.20070302171509.2: nullStatusLineClass.ctor
def __init__ (self,c,parentFrame):

    self.c = c
    self.enabled = False
    self.parentFrame = parentFrame

    gui = c and c.frame and c.frame.gui or g.app.gui

    self.textWidget = w = gui.plainTextWidget(c,name='status-line')

    # Set the official ivars.
    c.frame.statusFrame = None
    c.frame.statusLabel = None
    c.frame.statusText  = self.textWidget
#@-node:ekr.20070302171509.2: nullStatusLineClass.ctor
#@-node:ekr.20070619161413:Finish support for hidden windows
#@+node:ekr.20070613103409:Improve marks/recent buttons
- Arrow keys must move up/down.
- Should be commands to show the marks/recent dialogs.
#@nonl
#@-node:ekr.20070613103409:Improve marks/recent buttons
#@+node:ekr.20070613181147:(maybe) Improve key handling
# The idea is to use a single <Key binding> and
# use w.event_generate(key) to create a table
# that associates Tk key numbers with bindings:

    if event.char:
        if 0:
            import Tkinter as Tk
            w = Tk.Text()
            def foo (event):
                g.trace(event)
            w.bind('<Key>',foo)
            for prefix in ('Alt-Key-','Shift-Key-'):
                key = '<%s%s>' % (prefix,event.char.strip())
                g.trace(key)
                w.event_generate('a')
        if 0:
            for z in ('char','keysym','keycode','keysym_num','state',):
                a = getattr(event,z)
                print z,repr(a)
#@-node:ekr.20070613181147:(maybe) Improve key handling
#@+node:ekr.20070624135822:Templates for common code fragments
#@-node:ekr.20070624135822:Templates for common code fragments
#@+node:ekr.20061127170002.1:Allow multiple lines on the button bar
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3993176
By: rich_ries

How can the button bar be enlarged to take a second (or third!) row of icons? Or maybe the Scripting buttons can have
their own section, like the NodeBar plugin did/does?

add-new-icon-row command?
#@nonl
#@-node:ekr.20061127170002.1:Allow multiple lines on the button bar
#@-node:ekr.20070703111455.3:Maybe
#@-node:ekr.20070703111455:To do: 4.4.5 Useful odds & ends
#@+node:ekr.20070923103337:Not associated with any release
#@+node:ekr.20060306194040:Video and more screen shots on Leo's web site
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/


http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

Thanks,
Kent
#@nonl
#@+node:ekr.20060531134434:Tutorials
http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
#@nonl
#@-node:ekr.20060531134434:Tutorials
#@+node:ekr.20060531134434.1:Screencasts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3758303
By: ktenney

My sense is that documentation/screencasts has the
greatest potential for expanding Leo's mindshare.

I really like those produced by the good folks
at Dabo;
http://leafe.com/screencasts/
http://leafe.com/screencasts/populategrid.html

The TurboGears people have taken this to the extreme;
http://www.turbogears.org/ultimate.html

Leo is different enough that it warrants a 
demonstration of it's advantages.

-------------------

https://sourceforge.net/forum/message.php?msg_id=4396251
By: ktenney

2 good screencasts on making screencasts;

http://murl.se/26296
#@-node:ekr.20060531134434.1:Screencasts
#@+node:ekr.20060829103523:Render Leo slideshows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3889246
By: terry_n_brown

Three packages that might be candidates for "rendering" slides authored in Leo:

MagicPoint: http://member.wide.ad.jp/wg/mgp/

  uses a text file format that leo could produce

Slidy: http://www.w3.org/Talks/Tools/Slidy/

  uses XHTML / canned Java script

S5: http://meyerweb.com/eric/tools/s5/

  Similar to Slidy I think, haven't looked at it
#@nonl
#@-node:ekr.20060829103523:Render Leo slideshows
#@-node:ekr.20060306194040:Video and more screen shots on Leo's web site
#@+node:ekr.20071029082025:Improve distribution
* Convert to svn  (use py_svn)
* Enable sax option.
* Proper xml namespace in .leo files.  Is this Leo 5.0??
#@nonl
#@+node:ekr.20070929125944:Emulate Orange's download philosophy
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4543089
By: billp9619

from the download page:

If it's the first time you hear about Python, this is the installation for you.
The packages includes complete Orange, Python, Windows Extensions for Python
(PythonWin), Numeric Python, Qt 2.2 non-commercial, PyQt, PyQwt and GraphViz.

Leo should copy this download philosophy.



#@-node:ekr.20070929125944:Emulate Orange's download philosophy
#@+node:ekr.20070615063616.1:Create Debian package
#@-node:ekr.20070615063616.1:Create Debian package
#@-node:ekr.20071029082025:Improve distribution
#@+node:ekr.20071102191642:Other guis
#@+node:ekr.20071030191227:Emacs/Pymacs gui
#@-node:ekr.20071030191227:Emacs/Pymacs gui
#@+node:ekr.20070824093611:Improve wxGui plugin
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4480477
By: plumloco

Sorry to here about your injury, Edward. Hope its not RSI from working too hard
on Leo.  Get well soon.

When your fit and well again you might like to have a look at this.

I have been playing with custom tree widgets for leo, first with pyGTK then
with wxPython.  I had thought about doing a  pyGTK plugin until I realized how
much work was involved :)

I have adapted the __wx_gui.py plugin to work with my custom widget and called
it __wx_alt_gui.py. You, or anyone else who is interested, can download the
plugin from http://plumloco.co.uk/scratch/__wx_alt_gui.py.gz.

The great benefit of using this custom widget is that it has no secondary data
structures to keep in synch, this makes it faster and more efficient in terms
of resources. It also eliminates the problem of complicated glue code.

All that is needed is to call update whenever a change is made and the widget
will get all its data directly from the leo outline itself.  A good test for
the widget is to load a large outline and do an expand-all-nodes on it (try
the same with __wx_gui and tkLeo).

The widget still needs a lot of work but it works well enough for its usefulness
and viability to be tested.

I would be interested to know your intentions towards wxLeo.  My impression
is that you do not plan on being very active in its development, seeing as how
you are talking about doing a java swing version.

If you have no objections, I would like to do some work on wxLeo myself, partly
for its own sake and partly to gain experience for a possible pyGTK port.  Obviously
I do not want to be treading on your toes, so please tell me if I am intruding.


#@-node:ekr.20070824093611:Improve wxGui plugin
#@+node:ekr.20070703111913:Swing gui
#@-node:ekr.20070703111913:Swing gui
#@-node:ekr.20071102191642:Other guis
#@+node:ekr.20070307082503:Make Leo an IPython notebook
#@+node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060603085719.1:Use IPython autocompleter?
#@-node:ekr.20060603085719.1:Use IPython autocompleter?
#@+node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@-node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@+node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@-node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@+node:ekr.20060603090445.9:Script button that saves environment between runs
This would allow IPython-like operation.
#@nonl
#@-node:ekr.20060603090445.9:Script button that saves environment between runs
#@-node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20070521100324.1:Using Leo as a notebook
@nocolor
https://sourceforge.net/forum/message.php?msg_id=4314394
By: duanekaufman

I am starting a kinda 'stream-of-thought' document, one in which I can put down
a paragraph of thought (perhaps in a pretty fashion, using ReST markup), develop
some code, to do some calculations, run the code and display the results...rinse,
repeat.

The document, in pseudo-form, would look like:

<Development of thought #1>
<Code to calculate something>
<Results from code execution>
<Discussion of results>

Each of the above would probably be a node, and I have already put together
things that look like the above, all except for the <results> part. I can run
the code, but how can I get the output automatically in my node? I can cut-and-paste
from the underlying command window (I run under Linux and Windows XP), but I
would like o automate it as much as possible.

Does anyone have any ideas on how to accomodate this workflow?

------ Reply

A most interesting and important question--with such a capability one could make Leo into a full-fledged engineering notebook, e.g., as envisaged by the IPython Notebook project: 

http://projects.scipy.org/ipython/ipython/wiki/NbshellManual 

I can think of several possible approaches: 

1. Create a custom version of the execute script command that would put script output in a particular node. Perhaps the headline of the node could be an argument to the enhanced command. 

2. Have your script write to some 'standard place', and create a command to put that script in the presently selected node. Something like insert-script-output. 

3. Create a script button that executes the script in the presently selected node and puts the result in the node *following* the selected node. You can then either move the node by hand, or use another script button to move the node to a 'standard place', say the last child of the <<results>> node. 

As I write this I think the script-button approach is likely to be the simplest, most flexible and most powerful. I'll look into this myself soon... 

Edward
#@nonl
#@-node:ekr.20070521100324.1:Using Leo as a notebook
#@-node:ekr.20070307082503:Make Leo an IPython notebook
#@-node:ekr.20070923103337:Not associated with any release
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
