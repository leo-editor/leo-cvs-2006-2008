#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20070521100324:Marketing/tools
#@+node:ekr.20070521100324.1:Using Leo as a notebook
@nocolor
https://sourceforge.net/forum/message.php?msg_id=4314394
By: duanekaufman

I am starting a kinda 'stream-of-thought' document, one in which I can put down
a paragraph of thought (perhaps in a pretty fashion, using ReST markup), develop
some code, to do some calculations, run the code and display the results...rinse,
repeat.

The document, in pseudo-form, would look like:

<Development of thought #1>
<Code to calculate something>
<Results from code execution>
<Discussion of results>

Each of the above would probably be a node, and I have already put together
things that look like the above, all except for the <results> part. I can run
the code, but how can I get the output automatically in my node? I can cut-and-paste
from the underlying command window (I run under Linux and Windows XP), but I
would like o automate it as much as possible.

Does anyone have any ideas on how to accomodate this workflow?

------ Reply

A most interesting and important question--with such a capability one could make Leo into a full-fledged engineering notebook, e.g., as envisaged by the IPython Notebook project: 

http://projects.scipy.org/ipython/ipython/wiki/NbshellManual 

I can think of several possible approaches: 

1. Create a custom version of the execute script command that would put script output in a particular node. Perhaps the headline of the node could be an argument to the enhanced command. 

2. Have your script write to some 'standard place', and create a command to put that script in the presently selected node. Something like insert-script-output. 

3. Create a script button that executes the script in the presently selected node and puts the result in the node *following* the selected node. You can then either move the node by hand, or use another script button to move the node to a 'standard place', say the last child of the <<results>> node. 

As I write this I think the script-button approach is likely to be the simplest, most flexible and most powerful. I'll look into this myself soon... 

Edward


#@-node:ekr.20070521100324.1:Using Leo as a notebook
#@+node:ekr.20070521105645:Improve api docs with epidoc?
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319363
By: ktenney

I think there is room for improvement in documenting Leo's
API, making it easier to write these kind of scripts.
I'm not sure of the best way to do that.

Epydoc seems to be the most active project in this realm.
http://epydoc.sourceforge.net/epydoc.html
#@-node:ekr.20070521105645:Improve api docs with epidoc?
#@+node:ekr.20060306194040:asap: Video and more screen shots on Leo's web site
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/


http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

Thanks,
Kent
#@nonl
#@+node:ekr.20060531134434:Tutorials
http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
#@nonl
#@-node:ekr.20060531134434:Tutorials
#@+node:ekr.20060531134434.1:Screencasts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3758303
By: ktenney

My sense is that documentation/screencasts has the
greatest potential for expanding Leo's mindshare.

I really like those produced by the good folks
at Dabo;
http://leafe.com/screencasts/
http://leafe.com/screencasts/populategrid.html

The TurboGears people have taken this to the extreme;
http://www.turbogears.org/ultimate.html

Leo is different enough that it warrants a 
demonstration of it's advantages.
#@nonl
#@-node:ekr.20060531134434.1:Screencasts
#@+node:ekr.20060829103523:Render Leo slideshows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3889246
By: terry_n_brown

Three packages that might be candidates for "rendering" slides authored in Leo:

MagicPoint: http://member.wide.ad.jp/wg/mgp/

  uses a text file format that leo could produce

Slidy: http://www.w3.org/Talks/Tools/Slidy/

  uses XHTML / canned Java script

S5: http://meyerweb.com/eric/tools/s5/

  Similar to Slidy I think, haven't looked at it
#@nonl
#@-node:ekr.20060829103523:Render Leo slideshows
#@-node:ekr.20060306194040:asap: Video and more screen shots on Leo's web site
#@+node:ekr.20061130084909:Improve What's special whitepaper
@nocolor

- Answer the question: how can Leo help me with programming?
#@nonl
#@-node:ekr.20061130084909:Improve What's special whitepaper
#@+node:ekr.20070414090051:Study
@nocolor

- launchpad http://launchpad.net 

- bazaar (bzr)
#@nonl
#@-node:ekr.20070414090051:Study
#@-node:ekr.20070521100324:Marketing/tools
#@+node:ekr.20070531075258:Fix problems with @enabled-plugins
#@+node:ekr.20070224075914:doEnabledPlugins
def doEnabledPlugins (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c
    s = p.bodyString()

    # This setting is handled differently from all other settings,
    # because the last setting must be retrieved before any commander exists.

    # g.trace('len(s)',len(s))

    # Set the global config ivars.
    g.app.config.enabledPluginsString = s
    g.app.config.enabledPluginsFileName = c and c.shortFileName() or '<no settings file>'
#@-node:ekr.20070224075914:doEnabledPlugins
#@+node:ekr.20070224075914.1:getEnabledPlugins
def getEnabledPlugins (self):

    """Search all dictionaries for the setting & check it's type"""

    return g.app.config.enabledPluginsString
#@-node:ekr.20070224075914.1:getEnabledPlugins
#@+node:ekr.20031218072017.3440:loadHandlers & helper
def loadHandlers(tag):

    """Load all enabled plugins from the plugins directory"""

    def pr (*args,**keys):
        if not g.app.unitTesting:
            g.es_print(*args,**keys)

    fileName = "pluginsManager.txt"
    plugins_path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_abspath(theFile) for theFile in files]
    s = g.app.config.getEnabledPlugins()
    theConfigFile = g.app.config.enabledPluginsFileName
    # g.trace('len(s)',s and len(s) or 0)
    if s:
        pr('@enabled-plugins found in %s' % (theConfigFile),color='blue')
        enabled_files = getEnabledFiles(s,plugins_path)
    else:
        for theDir,place in (
            (g.app.homeDir,'HOME'),
            (plugins_path,'leo/config')
        ):
            manager_path = g.os_path_join(theDir,fileName)
            if g.os_path_exists(manager_path):
                g.es_print('%s: %s' % (fileName,theDir),color='blue')
                break
        else: pr('%s not found. No plugins will be loaded' % fileName)
        if g.os_path_exists(manager_path):
            << set enabled_files from pluginsManager.txt >>
        else:  return

    # Load plugins in the order they appear in the enabled_files list.
    if files and enabled_files:
        for theFile in enabled_files:
            if theFile in files:
                loadOnePlugin(theFile)

    # Note: g.plugin_signon adds module names to g.app.loadedPlugins
    if 0:
        if g.app.loadedPlugins:
            pr("%d plugins loaded" % (len(g.app.loadedPlugins)), color="blue")
#@+node:ekr.20031218072017.3441:<< set enabled_files from pluginsManager.txt >>
try:
    # New in 4.3: The first reference to a plugin in pluginsManager.txt controls.
    theFile = open(manager_path)
    s = theFile.read()
    pr('Using settings in pluginsManager.txt')
    enabled_files = getEnabledFiles(s,plugins_path)
    theFile.close()
except IOError:
    pr("Can not open: %s"  % manager_path)
    # Don't import leoTest initially.  It causes problems.
    import leoTest ; leoTest.fail()
    return
#@-node:ekr.20031218072017.3441:<< set enabled_files from pluginsManager.txt >>
#@+node:ekr.20070224082131:getEnabledFiles
def getEnabledFiles (s,plugins_path):

    enabled_files = []
    disabled_files = []
    for s in g.splitLines(s):
        s = s.strip()
        if s:
            if g.match(s,0,"#"):
                s = s[1:].strip()
                # Kludge: ignore comment lines containing a blank or not ending in '.py'.
                if s and s.find(' ') == -1 and s[-3:] == '.py':
                    path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                    if path not in enabled_files and path not in disabled_files:
                        # print 'disabled',path
                        disabled_files.append(path)
            else:
                path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                if path not in enabled_files and path not in disabled_files:
                    # print 'enabled',path
                    enabled_files.append(path)

    return enabled_files
#@nonl
#@-node:ekr.20070224082131:getEnabledFiles
#@-node:ekr.20031218072017.3440:loadHandlers & helper
#@-node:ekr.20070531075258:Fix problems with @enabled-plugins
#@+node:ekr.20060531161030:To do: 4.4.3
#@+node:ekr.20070605114358:Improve how recent files works??
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4347116
By: terry_n_brown

This is just a nit I guess, but I move between two machines all the time, and
Leo keeps changing the paths I open from /home/tbrown/project/project.leo to
/media/hda8/project/project.leo, so that when I switch to the other machine,
where /home/tbrown/project/project.leo is actually /media/hdb2/project/project.leo,
the recent files link is wrong.

If it would be trivial for Leo to not do this, I'd like that feature.  If it's
a big deal, then not to worry, I can always navigate to the file of course.
#@-node:ekr.20070605114358:Improve how recent files works??
#@+node:ekr.20070515100356:To do: b2
#@+node:ekr.20070325054325:Docs
#@+node:ekr.20070215093739:Improve Leo's getting started page
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4159734
By: rogererens

Here are some issues with respect to installing Leo on Windows:

I think you should divide the "How to install Leo on Windows" into separate
sections: one section that describes the use of the installer and another one
that describes the use of the .zip-file. In the near future probably Vista deserves
its own section, too.

The notes warn about Python 2.4 and spaces in paths. The installer appears to
work properly with Python 2.5 though, and installing into a path that contains
spaces works fine too, AFAIK. Or are there any usability test cases to check
this?

Also, I would advice the person that is installing Leo to create an environment
variable (either a user variable or a system variable) called HOME with the
value "%USERPROFILE%\My Documents" when %HOME% does not yet exist (check in
a cmd-window by typing "echo %HOME%" without the quotes).
Then, after installing, a user should have the shortcut icon on his/her desktop;
change this by right-clicking and choosing properties to change the directory
where the application starts from the default "C:\Program Files\Leo\test\unittest"
into %HOME%.
I'm not sure if this could all be done automatically by the NSIS installer.

Finally, there's the issue that I installed Leo in the default Program Files
folder, while having the Administrator's role. After which I copied and adapted
the Leo shortcut to the desktop of a user with limited rights.
Unfortunately, when logged on as such a limited user, no plugins can be
enabled/disabled because of the restrictions on writing in program
files\leo\plugin.
(Even if the limited user _could_ write in that folder, it would be problematic:
his set of enabled plugins would overwrite the set of enabled plugins for the
administrator or another user).

Hope this helps to improve the installation experience for novices...
#@-node:ekr.20070215093739:Improve Leo's getting started page
#@+node:ekr.20070218143918:Improve Windows installation instructions
This section is way too confusing:

Users Guide-->Chapter 1: Installing Leo-->@rst html\install.html-->How to install Leo on Windows
#@nonl
#@-node:ekr.20070218143918:Improve Windows installation instructions
#@+node:ekr.20070603222100:Mention that the -i option is not valid for pythonw.exe
@nocolor

I wanted to give Leo a try and was faced with some obstacles that I want you to know, so you can remove them if you got the time for it.

1. I read on the Homepage that Leo is "100% pure Python" but it didn't tell me, that I actually needed to have Python installed. The regular Windows user will download the Leo-Installer and then realize that Leo won't install.

2. First time using the generated link in the startmenu, Leo asks me for an ID. Okay, I write "Richard" press enter and then ... nothing else happens. I saw the link automaticly using my "pythonw.exe" so I gave it a try and erased the "w" and with "python.exe" Leo started.

It would be cooler to not have the Dos-Box open while using Leo but I don't know how hard it would be to program Leo that way.

I will start using Leo I don't know exactly for what, maybe as a "Getting-Things-Done" tool and eventually mail you some things I my notice, if you want to hear them. For now, I'm a little bit overwhelmed by the number of commands and I will need some extra time to understand them, because there is no german version available.

Richard Kolodziej <Richard.Kolodziej@web.de>

#@-node:ekr.20070603222100:Mention that the -i option is not valid for pythonw.exe
#@+node:ekr.20070606165218:Improve documentation for search/replace
@nocolor

> I'm finding it less than intuitive to do a simple  
'replace all occurrences of 'xxxxx' with 'yyyyy' 

An excellent question. This isn't properly documented. There is a very important trick: 

<Ctrl-shift-r>find-pattern<return>replace-text<return> 

But I usually forget to type <ctrl-shift-r> and instead type <ctrl-f> 

No problem. I put in a hack so the following works: 

<Ctrl-f>find-pattern<Ctrl-shift-r>replace-text<return> 


After typing <ctrl-f> or <shift-ctrl-r> you can use <alt-ctrl> keys to set or clear find options. Example: 

<ctrl-f><alt-ctrl-w><find-pattern><return> 

<ctrl-f>shows the find dialog 

<alt-ctrl-w> toggles the Whole Word checkbox 

<return> starts the search for <find-pattern> 

You can type the <alt-ctrl> keys anytime after <ctrl-f> (or <shift-ctrl-r>) and before <return>. 
You can type multiple <alt-ctrl-keys> to toggle multiple checkboxes.
#@nonl
#@-node:ekr.20070606165218:Improve documentation for search/replace
#@-node:ekr.20070325054325:Docs
#@+node:ekr.20070515113707:Dist
#@+node:ekr.20070202080824:Enable more plugins by default
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4134565

I have been talking more and more people lately into giving Leo a try. These
are end-users, not programmer-type people. One of the problems I find is that
many features users expect as standard are plug-ins that are disabled at
startup.

From my experience, some of the plug-ins that people seem to want right away
are Cleo, Image, Maximize windows, Export to HTML, and Navibuttons.

Also, everyone seems to ask for spell checking, which I know is a separate install
(I haven't tried putting it in). Perhaps even that could be included?

I think it is a lot easier for power users to turn off things they don't like
than less sophisticated users to turn them on. However, I realize that each
additional plug-in means a longer load time and large memory footprint.

-------------------

From: Rich

These are the plugins that I use often:
Add directives & color markup
Cleo 3
Chapters 2 (unless Chapters works with newer releases, I will stick with Leo 4.4 final)
Group Operations
Nav_buttons
Open_with
RClick
Universal Scrolling

These are the plugins that I do not use too often:
New Buttons
UNL

The following are plugins I would like to use:
Edit Attributes
Conceptual Sort
Labels

"Labels" has a nice assortment of commands; however the labels are (1) not saved
between sessions, and (2) cannot be seen by "Edit Attributes."
I'd be more inclined to use "Edit Attributes" and "C-Sort" IF there was some
way to SEE the attributes (this goes for "Labels," as well).


---- Enable Aspell automatically if possible.

#@-node:ekr.20070202080824:Enable more plugins by default
#@+node:ekr.20070307082503.1:Create Linux distribution
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319356
By: ktenney

> - A proper Ubuntu/Linux distribution 

- "eggification" of Leo

register Leo at http://cheeseshop.python.org/pypi

Pythonistas have come to expect that::

 $ easy_install <app>

will locate and install the most recent version of app and install it.
#@-node:ekr.20070307082503.1:Create Linux distribution
#@-node:ekr.20070515113707:Dist
#@+node:ekr.20031218072017.2406:Code
@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
 d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.
#@nonl
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20031218072017.2582: version & signon stuff
#@+node:ekr.20040629121554:getBuildNumber
def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"
#@-node:ekr.20040629121554:getBuildNumber
#@+node:ekr.20040629121554.1:getSignOnLine (Contains hard-coded version info)
def getSignOnLine (self):
    c = self
    return "Leo 4.4.3 beta 1, build %s, May 18, 2007" % c.getBuildNumber()
#@-node:ekr.20040629121554.1:getSignOnLine (Contains hard-coded version info)
#@+node:ekr.20040629121554.2:initVersion
def initVersion (self):
    c = self
    c.ver = "$Revision$" # CVS updates this.
#@-node:ekr.20040629121554.2:initVersion
#@+node:ekr.20040629121554.3:c.signOnWithVersion
def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info

    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass

    else: version = sys.platform

    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
    g.enl()
#@-node:ekr.20040629121554.3:c.signOnWithVersion
#@-node:ekr.20031218072017.2582: version & signon stuff
#@+node:ekr.20031218072017.2604:Core classes...
#@+node:ekr.20031218072017.2605:@thin leo.py 
@first #! /usr/bin/env python

"""Entry point for Leo in Python."""

@language python
@tabwidth -4

<< Import pychecker >>

__pychecker__ = '--no-import --no-reimportself --no-reimport'
    # Suppress import errors: this module must do strange things with imports.

# Warning: do not import any Leo modules here!
# Doing so would make g.app invalid in the imported files.
import os
import string
import sys

@others

if __name__ == "__main__":
    if len(sys.argv) > 1:
        if sys.platform=="win32": # Windows
            fileName = string.join(sys.argv[1:],' ')
        else:
            fileName = sys.argv[1]
        run(fileName)
    else:
        run()
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    __pychecker__ = '--no-argsused' # keywords not used.

    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    adjustSysPath(g)
    if pymacs:
        script = windowFlag = False
    else:
        script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"

# NOW we can set g.
g = leoGlobals
assert(g.app)
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()

try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20070306085724:adjustSysPath
def adjustSysPath (g):

    '''Adjust sys.path to enable imports as usual with Leo.'''

    import sys

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','src','test')

    for theDir in leoDirs:
        path = g.os_path_abspath(
            g.os_path_join(g.app.loadDir,'..',theDir))
        if path not in sys.path:
            sys.path.append(path)
#@-node:ekr.20070306085724:adjustSysPath
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):

    import leoGlobals as g

    if not fileName:
        return None

    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):

    """Create a LeoFrame during Leo's startup process."""

    import leoGlobals as g

    # g.trace('fileName',fileName)

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName,initEditCommanders=False)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if frame.c.chapterController:
        frame.c.chapterController.finishCreate()
        frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@nonl
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):

    import leoGlobals as g
    import leoGui

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    # if not g.app.root:
        # g.app.root = g.app.gui.createRootWindow()
    # g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():

    import leoGlobals as g
    windowFlag = False

    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        if arg in ("--script-window","-script-window"):
            name = sys.argv[i+1].strip() ; windowFlag = True ; break
        i += 1

    if not name:
        return None, windowFlag
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()

    # Bug fix 4/27/07: Don't put a return in a finally clause.
    return script, windowFlag
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,'2.2.1')
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):

    import leoGlobals as g

    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@-node:ekr.20041130093254:reportDirectories
#@+node:ekr.20040411081633:startPsyco
def startPsyco ():

    import leoGlobals as g

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        g.app.use_psyco = False
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
        g.app.use_psyco = False
#@-node:ekr.20040411081633:startPsyco
#@-node:ekr.20031218072017.1934:run & allies
#@+node:ekr.20031218072017.2607:profile
@ To gather statistics, do the following in a Python window, not idle:

    import leo
    leo.profile()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile ():

    """Gather and print statistics about Leo"""

    import profile, pstats

    # name = "c:/prog/test/leoProfile.txt"
    name = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','leoProfile.txt'))

    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('cum','file','name')
    p.print_stats()
#@-node:ekr.20031218072017.2607:profile
#@-node:ekr.20031218072017.2605:@thin leo.py 
#@+node:ekr.20031218072017.2608:@thin leoApp.py
@first # -*- coding: utf-8 -*-

@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import os
import sys

class LeoApp:

    """A class representing the Leo application itself.

    Ivars of this class are Leo's global variables."""

    @others
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.disableSave = False
    self.globalConfigDir = None # The directory that is assumed to contain the global configuration files.
    self.globalOpenDir = None # The directory last used to open a file.
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scanErrors = 0 # The number of errors seen by g.scanError.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.statsDict = {} # Statistics dict used by g.stat, g.clear_stats, g.print_stats.
    self.trace = False # True: enable debugging traces.
    self.trace_gc = False # defined in run()
    self.trace_gc_calls = False # defined in run()
    self.trace_gc_verbose = False # defined in run()
    self.trace_gc_inited = False
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.use_psyco = False # Can't be a config param because it is used before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None

    << Define global constants >>
    << Define global data structures >>
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "cpp" : "// /* */",# C++.
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "lua" : "--",  # ddm 13/02/06
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "cpp" : "cpp",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.

self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@+node:ekr.20031218072017.2609:app.closeLeoWindow
def closeLeoWindow (self,frame):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    c = frame.c

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c) # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        frame = g.app.windowList[0]
        frame.deiconify()
        frame.lift()
        frame.c.setLog()
        frame.c.bodyWantsFocusNow()
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
#@-node:ekr.20031218072017.2609:app.closeLeoWindow
#@+node:ekr.20031218072017.2610:app.createTkGui
def createTkGui (self,fileName=None):

    # Do NOT omit fileName param: it is used in plugin code.
    __pychecker__ = '--no-argsused'

    """A convenience routines for plugins to create the default Tk gui class."""

    import leoTkinterGui # Do this import after app module is fully imported.

    g.app.gui = leoTkinterGui.tkinterGui()
    g.app.root = g.app.gui.createRootWindow()

    # Show a dialog and exit immediately if Pmw can not be imported.
    g.importExtension("Pmw",pluginName="Leo's core",verbose=False,required=True)
    g.app.gui.finishCreate()

    if 0:
        if fileName:
            print "Tk gui created in", g.shortFileName(fileName)
#@-node:ekr.20031218072017.2610:app.createTkGui
#@+node:ekr.20031218072017.2612:app.destroyAllOpenWithFiles
def destroyAllOpenWithFiles (self):

    """Try to remove temp files created with the Open With command.

    This may fail if the files are still open."""

    # We can't use g.es here because the log stream no longer exists.

    for theDict in self.openWithFiles[:]: # 7/10/03.
        g.app.destroyOpenWithFileWithDict(theDict)

    # Delete the list so the gc can recycle Leo windows!
    g.app.openWithFiles = []
#@-node:ekr.20031218072017.2612:app.destroyAllOpenWithFiles
#@+node:ekr.20031218072017.2613:app.destroyOpenWithFilesForFrame
def destroyOpenWithFilesForFrame (self,frame):

    """Close all "Open With" files associated with frame"""

    # Make a copy of the list: it may change in the loop.
    openWithFiles = g.app.openWithFiles

    for theDict in openWithFiles[:]: # 6/30/03
        c = theDict.get("c")
        if c.frame == frame:
            g.app.destroyOpenWithFileWithDict(theDict)
#@-node:ekr.20031218072017.2613:app.destroyOpenWithFilesForFrame
#@+node:ekr.20031218072017.2614:app.destroyOpenWithFileWithDict
def destroyOpenWithFileWithDict (self,theDict):

    path = theDict.get("path")
    if path and g.os_path_exists(path):
        try:
            os.remove(path)
            print "deleting temp file:", g.shortFileName(path)
        except:
            print "can not delete temp file:", path

    # Remove theDict from the list so the gc can recycle the Leo window!
    g.app.openWithFiles.remove(theDict)
#@-node:ekr.20031218072017.2614:app.destroyOpenWithFileWithDict
#@+node:ekr.20031218072017.2615:app.destroyWindow
def destroyWindow (self,frame):

    # g.trace(frame in g.app.windowList,frame)

    g.app.destroyOpenWithFilesForFrame(frame)

    if frame in g.app.windowList:
        g.app.windowList.remove(frame)
        # g.trace(g.app.windowList)

    # force the window to go away now.
    # Important: this also destroys all the objects of the commander.
    frame.destroySelf()
#@-node:ekr.20031218072017.2615:app.destroyWindow
#@+node:ekr.20031218072017.1732:app.finishQuit
def finishQuit(self):

    # forceShutdown may already have fired the "end1" hook.
    if not g.app.killed:
        g.doHook("end1")

    self.destroyAllOpenWithFiles()

    if g.app.gui:
        g.app.gui.destroySelf()

    # Don't use g.trace!
    # print 'app.finishQuit: setting g.app.killed',g.callers()

    g.app.killed = True
        # Disable all further hooks and events.
        # Alas, "idle" events can still be called even after the following code.

    if g.app.afterHandler:
        # TK bug: This appears to have no effect, at least on Windows.
        # print "finishQuit: cancelling",g.app.afterHandler
        if g.app.gui and g.app.gui.guiName() == "tkinter":
            self.root.after_cancel(g.app.afterHandler)
        g.app.afterHandler = None
#@-node:ekr.20031218072017.1732:app.finishQuit
#@+node:ekr.20031218072017.2616:app.forceShutdown
def forceShutdown (self):

    """Forces an immediate shutdown of Leo at any time.

    In particular, may be called from plugins during startup."""

    # Wait until everything is quiet before really quitting.
    g.doHook("end1")

    self.log = None # Disable writeWaitingLog
    self.killed = True # Disable all further hooks.

    for w in self.windowList[:]:
        self.destroyWindow(w)

    self.finishQuit()
#@-node:ekr.20031218072017.2616:app.forceShutdown
#@+node:ekr.20031218072017.2617:app.onQuit
def onQuit (self,event=None):

    '''Exit Leo, prompting to save unsaved outlines first.'''

    g.app.quitting = True

    while g.app.windowList:
        w = g.app.windowList[0]
        if not g.app.closeLeoWindow(w):
            break

    if g.app.windowList:
        g.app.quitting = False # If we get here the quit has been disabled.
#@-node:ekr.20031218072017.2617:app.onQuit
#@+node:ekr.20031218072017.2618:app.setEncoding
@ According to Martin v. Löwis, getdefaultlocale() is broken, and cannot be fixed. The workaround is to copy the g.getpreferredencoding() function from locale.py in Python 2.3a2.  This function is now in leoGlobals.py.
@c

def setEncoding (self):

    """Set g.app.tkEncoding."""

    try: locale_encoding = g.getpreferredencoding()
    except Exception: locale_encoding = None

    try: sys_encoding = sys.getdefaultencoding()
    except Exception: sys_encoding = None

    for (encoding,src) in (
        (self.config.tkEncoding,"config"),
        (locale_encoding,"locale"),
        (sys_encoding,"sys"),
        ("utf-8","default")):

        if g.isValidEncoding (encoding):
            self.tkEncoding = encoding
            # g.trace(self.tkEncoding,src)
            break
        elif encoding:
            color = g.choose(self.tkEncoding=="ascii","red","blue")
            g.trace("ignoring invalid %s encoding: %s" % (src,encoding),color=color)
#@-node:ekr.20031218072017.2618:app.setEncoding
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = not g.app.unitTesting
    << return if we can set leoID from sys.leoID >>
    << return if we can set leoID from "leoID.txt" >>
    << return if we can set leoID from os.getenv('USER') >>
    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@+node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose and not g.app.unitTesting:
        g.es_print("leoID = " + g.app.leoID, color='red')
    return
else:
    g.app.leoID = None
#@-node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                if verbose and not g.app.unitTesting:
                    g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                return
            elif verbose and not g.app.unitTesting:
                g.es("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es_print('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose and not g.app.unitTesting:
            g.es("using os.getenv('USER'): %s " % (repr(theId)),color='red')
        g.app.leoID = theId
        return

except Exception:
    pass
#@-node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()

# g.trace(g.app.leoID)
g.es("leoID = %s" % (repr(g.app.leoID)),color="blue")
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        cant = "can not create %s in %s" % (tag,theDir)
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                s = "%s created in %s" % (tag,theDir)
                g.es_print(s, color="red")
                return
            else:
                g.es(cant,color='red')
        except IOError:
            g.es(cant,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@+node:ekr.20031218072017.1847:app.setLog, lockLog, unlocklog
def setLog (self,log):

    """set the frame to which log messages will go"""

    # print "setLog:",tag,"locked:",self.logIsLocked,log
    if not self.logIsLocked:
        self.log = log

def lockLog(self):
    """Disable changes to the log"""
    self.logIsLocked = True

def unlockLog(self):
    """Enable changes to the log"""
    self.logIsLocked = False
#@-node:ekr.20031218072017.1847:app.setLog, lockLog, unlocklog
#@+node:ekr.20031218072017.2619:app.writeWaitingLog
def writeWaitingLog (self):

    # g.trace(g.app.gui,self.log)

    if self.log:
        if 1: # not self.log.isNull: # The test for isNull would probably interfere with batch mode.
            for s,color in self.logWaiting:
                g.es(s,color=color,newline=0) # The caller must write the newlines.
            self.logWaiting = []
    else:
        print 'writeWaitingLog: still no log!'
#@-node:ekr.20031218072017.2619:app.writeWaitingLog
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,fileName,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leoCommands

    if not fileName: fileName = ""
    << compute the window title >>

    # Create an unfinished frame to pass to the commanders.
    frame = app.gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    if updateRecentFiles:
        c.updateRecentFiles(fileName)

    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@-node:ekr.20031218072017.2608:@thin leoApp.py
#@+node:ekr.20041005105605.1:@thin leoAtFile.py
@first # -*- coding: utf-8 -*-
    # Needed because of unicode characters in tests.

"""Classes to read and write @file nodes."""

@language python
@tabwidth -4
@pagewidth 80

__pychecker__ = '--no-reimport --no-constCond -- no-constant1'
    # Reimports needed in test methods.
    # Disable checks for if 0, if 1.

<< imports >>

@others
#@+node:ekr.20041005105605.2:<< imports >>
import leoGlobals as g

if g.app and g.app.use_psyco:
    # print "enabled psyco classes",__file__
    try: from psyco.classes import *
    except ImportError: pass

import leoColor
import leoNodes
import os
import string
import time
#@-node:ekr.20041005105605.2:<< imports >>
#@+node:ekr.20041005105605.4:class atFile
class atFile:

    << define class constants >>
    << define sentinelDict >>

    """The class implementing the atFile subcommander."""

    @others
#@+node:ekr.20041005105605.5:<< define class constants >>
# These constants must be global to this module because they are shared by several classes.

# The kind of at_directives.
noDirective     =  1 # not an at-directive.
allDirective    =  2 # at-all (4.2)
docDirective    =  3 # @doc.
atDirective     =  4 # @<space> or @<newline>
codeDirective   =  5 # @code
cDirective      =  6 # @c<space> or @c<newline>
othersDirective =  7 # at-others
miscDirective   =  8 # All other directives
rawDirective    =  9 # @raw
endRawDirective = 10 # @end_raw

# The kind of sentinel line.
noSentinel   = 20 # Not a sentinel
endAt        = 21 # @-at
endBody      = 22 # @-body
# not used   = 23
endDoc       = 24 # @-doc
endLeo       = 25 # @-leo
endNode      = 26 # @-node
endOthers    = 27 # @-others

# not used     = 40
startAt        = 41 # @+at
startBody      = 42 # @+body
startDoc       = 43 # @+doc
startLeo       = 44 # @+leo
startNode      = 45 # @+node
startOthers    = 46 # @+others

startComment   = 60 # @comment
startDelims    = 61 # @delims
startDirective = 62 # @@
startRef       = 63 # @< < ... > >
startVerbatim  = 64 # @verbatim
startVerbatimAfterRef = 65 # @verbatimAfterRef (3.0 only)

# New in 4.x. Paired
endAll         = 70 # at-all (4.2)
endMiddle      = 71 # at-middle (4.2)
startAll       = 72 # at+all (4.2)
startMiddle    = 73 # at+middle (4.2)

# New in 4.x.  Unpaired.
startAfterRef  = 80 # @afterref (4.0)
startClone     = 81 # @clone (4.2)
startNl        = 82 # @nl (4.0)
startNonl      = 83 # @nonl (4.0)
#@-node:ekr.20041005105605.5:<< define class constants >>
#@+node:ekr.20041005105605.6:<< define sentinelDict >>
sentinelDict = {

    # Unpaired sentinels: 3.x and 4.x.
    "@comment" : startComment,
    "@delims" :  startDelims,
    "@verbatim": startVerbatim,

    # Unpaired sentinels: 3.x only.
    "@verbatimAfterRef": startVerbatimAfterRef,

    # Unpaired sentinels: 4.x only.
    "@afterref" : startAfterRef,
    "@clone"    : startClone,
    "@nl"       : startNl,
    "@nonl"     : startNonl,

    # Paired sentinels: 3.x only.
    "@+body":   startBody,   "@-body":   endBody,

    # Paired sentinels: 3.x and 4.x.
    "@+all":    startAll,    "@-all":    endAll,
    "@+at":     startAt,     "@-at":     endAt,
    "@+doc":    startDoc,    "@-doc":    endDoc,
    "@+leo":    startLeo,    "@-leo":    endLeo,
    "@+middle": startMiddle, "@-middle": endMiddle,
    "@+node":   startNode,   "@-node":   endNode,
    "@+others": startOthers, "@-others": endOthers,
}
#@-node:ekr.20041005105605.6:<< define sentinelDict >>
#@+node:ekr.20041005105605.7:Birth & init
#@+node:ekr.20041005105605.8:atFile.__init__ & initIvars
def __init__(self,c):

    # Note: Pychecker complains if we assign to at.x instead of self.x.

    # **Warning**: all these ivars must **also** be inited in initCommonIvars.
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = False # True: enable additional checks.
    self.errors = 0 # Make sure at.error() works even when not inited.
    # New in Leo 4.4a5: For createThinChild4 (LeoUser).
    self._forcedGnxPositionList = []
        # Must be here, putting it in initReadIvars doesn't work.

    << define the dispatch dictionary used by scanText4 >>
#@+node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }
#@-node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
#@-node:ekr.20041005105605.8:atFile.__init__ & initIvars
#@+node:ekr.20041005105605.10:initCommonIvars
def initCommonIvars (self):

    """Init ivars common to both reading and writing.

    The defaults set here may be changed later."""

    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.

    c = self.c

    if self.testing:
        # Save "permanent" ivars
        fileCommands = self.fileCommands
        dispatch_dict = self.dispatch_dict
        _forcedGnxPositionList = self._forcedGnxPositionList
        # Clear all ivars.
        g.clearAllIvars(self)
        # Restore permanent ivars
        self.testing = True
        self.c = c
        self.fileCommands = fileCommands
        self.dispatch_dict = dispatch_dict
        self._forcedGnxPositionList = _forcedGnxPositionList

    << set defaults for arguments and options >>
    << init common ivars >>
#@+node:ekr.20041005105605.11:<< set defaults for arguments and options >>
# These may be changed in initReadIvars or initWriteIvars.

# Support of output_newline option.
self.output_newline = g.getOutputNewline(c=c)

# Set by scanHeader when reading and scanAllDirectives when writing.
self.encoding = c.config.default_derived_file_encoding
self.endSentinelComment = ""
self.startSentinelComment = ""

# Set by scanAllDirectives when writing.
self.default_directory = None
self.page_width = None
self.tab_width  = None
self.startSentinelComment = ""
self.endSentinelComment = ""
self.language = None
#@-node:ekr.20041005105605.11:<< set defaults for arguments and options >>
#@+node:ekr.20041005105605.12:<< init common ivars >>
# These may be set by initReadIvars or initWriteIvars.

self.errors = 0
self.inCode = True
self.indent = 0  # The unit of indentation is spaces, not tabs.
self.pending = []
self.raw = False # True: in @raw mode
self.root = None # The root of tree being read or written.
self.root_seen = False # True: root vnode has been handled in this file.
self.toString = False # True: sring-oriented read or write.
#@-node:ekr.20041005105605.12:<< init common ivars >>
#@-node:ekr.20041005105605.10:initCommonIvars
#@+node:ekr.20041005105605.13:initReadIvars
def initReadIvars(self,root,fileName,
    importFileName=None,
    perfectImportRoot=None,
    thinFile=False):

    importing = importFileName is not None

    self.initCommonIvars()

    << init ivars for reading >>

    self.scanDefaultDirectory(root,importing=importing)
    if self.errors: return

    # Init state from arguments.
    self.perfectImportRoot = perfectImportRoot
    self.importing = importing
    self.root = root
    self.targetFileName = fileName
    self.thinFile = thinFile
#@+node:ekr.20041005105605.14:<< init ivars for reading >>
self.cloneSibCount = 0 # n > 1: Make sure n cloned sibs exists at next @+node sentinel
self.docOut = [] # The doc part being accumulated.
self.done = False # True when @-leo seen.
self.endSentinelStack = []
self.importing = False
self.importRootSeen = False
self.indentStack = []
self.inputFile = None
self.lastLines = [] # The lines after @-leo
self.lastThinNode = None # Used by createThinChild4.
self.leadingWs = ""
self.out = None
self.outStack = []
self.tnodeList = []
self.tnodeListIndex = 0
self.t = None
self.tStack = []
self.thinNodeStack = [] # Used by createThinChild4.
self.updateWarningGiven = False
#@-node:ekr.20041005105605.14:<< init ivars for reading >>
#@-node:ekr.20041005105605.13:initReadIvars
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False,
    forcePythonSentinels=None):

    self.initCommonIvars()
    << init ivars for writing >>

    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite

    if root:
        self.scanAllDirectives(root,
            scripting=scriptWrite,
            forcePythonSentinels=forcePythonSentinels)

    # g.trace(forcePythonSentinels,self.startSentinelComment,self.endSentinelComment)

    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root

    # Ignore config settings for unit testing.
    if toString and g.app.unitTesting: self.output_newline = '\n'

    # Init all other ivars even if there is an error.
    if not self.errors and self.root:
        self.root.v.t.tnodeList = []
        self.root.v.t._p_changed = True
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False
self.force_newlines_in_at_nosent_bodies = self.c.config.getBool('force_newlines_in_at_nosent_bodies')
self.write_strips_blank_lines = self.c.config.getBool('write_strips_blank_lines')

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@-node:ekr.20041005105605.7:Birth & init
#@+node:ekr.20041005105605.17:Reading...
#@+node:ekr.20041005105605.18:Reading (top level)
@

All reading happens in the readOpenFile logic, so plugins should need to
override only this method.
#@+node:ekr.20041005105605.19:openFileForReading
def openFileForReading(self,fileName,fromString=False):

    at = self

    if fromString:
        at.inputFile = g.fileLikeObject(fromString=fromString)
    else:
        fn = g.os_path_join(at.default_directory,fileName)
        fn = g.os_path_normpath(fn)
        try:
            # Open the file in binary mode to allow 0x1a in bodies & headlines.
            at.inputFile = self.openForRead(fn,'rb') #bwm
            << warn on read-only file >>
        except IOError:
            at.error("can not open: '@file %s'" % (fn))
            at.inputFile = None
#@+node:ekr.20041005105605.20:<< warn on read-only file >>
# os.access() may not exist on all platforms.
try:
    read_only = not os.access(fn,os.W_OK)
except AttributeError:
    read_only = False 

if read_only:
    g.es("read only: " + fn,color="red")
#@-node:ekr.20041005105605.20:<< warn on read-only file >>
#@-node:ekr.20041005105605.19:openFileForReading
#@+node:ekr.20041005105605.21:read
# The caller must enclose this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False,fromString=None):

    """Read any derived file."""

    at = self ; c = at.c
    if 0:
        p = c.currentPosition()
        g.trace('1',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    g.es("reading: " + root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    if 0:
        p = c.currentPosition()
        g.trace('2',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0 and not at.thinFile:
        << warn about non-empty unvisited nodes >>
    if at.errors == 0 and not at.importing:
        if 1: # Package this as a method for use by mod_labels plugin.
            self.copyAllTempBodyStringsToTnodes(root,thinFile)
        else:
            << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file: %s" % p.headString())
        p.v.t.setVisited() # One message is enough.
#@-node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            c.setBodyString(p,s) # Sets c and p dirty.

        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@-node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():

    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read
#@+node:ekr.20041005105605.26:readAll
def readAll(self,root,partialFlag=False,forceGnx=False):

    """Scan vnodes, looking for @file nodes to read."""

    at = self ; c = at.c
    if partialFlag:
        # Capture the current headline only if we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            if forceGnx: # New in Leo 4.4.2 b1: support for sax read.
                at.forceGnxOnPosition(p)
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for p in c.allNodes_iter():
        p.v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")
#@-node:ekr.20041005105605.26:readAll
#@+node:ekr.20041005105605.27:readOpenFile
def readOpenFile(self,root,theFile,fileName):

    """Read an open derived file, either 3.x or 4.x."""

    at = self

    firstLines,read_new,isThinDerivedFile = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        lastLines = at.scanText3(theFile,root,[],at.endLeo)

    root.v.t.setVisited() # Disable warning about set nodes.

    << handle first and last lines >>
#@+node:ekr.20041005105605.28:<< handle first and last lines >>
try:
    body = root.v.t.tempBodyString
except:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s
#@-node:ekr.20041005105605.28:<< handle first and last lines >>
#@-node:ekr.20041005105605.27:readOpenFile
#@+node:bwmulder.20041231170726:openForRead
def openForRead(self, *args, **kw):
    """
    Hook for the mod_shadow plugin.
    """
    return open(*args, **kw)
#@-node:bwmulder.20041231170726:openForRead
#@+node:bwmulder.20050101094804:openForWrite
def openForWrite(self, *args, **kw):
    """
    Hook for the mod_shadow plugin
    """
    return open(*args, **kw)
#@-node:bwmulder.20050101094804:openForWrite
#@+node:ekr.20050103163224:scanHeaderForThin
def scanHeaderForThin (self,theFile,fileName):

    '''Scan the header of a derived file and return True if it is a thin file.

    N.B. We are not interested in @first lines, so any encoding will do.'''

    at = self

    # The encoding doesn't matter.  No error messages are given.
    at.encoding = at.c.config.default_derived_file_encoding

    junk,junk,isThin = at.scanHeader(theFile,fileName)

    return isThin
#@-node:ekr.20050103163224:scanHeaderForThin
#@-node:ekr.20041005105605.18:Reading (top level)
#@+node:ekr.20041005105605.29:Reading (3.x)
#@+node:ekr.20041005105605.30:createNthChild3
@ Sections appear in the derived file in reference order, not tree order.  Therefore, when we insert the nth child of the parent there is no guarantee that the previous n-1 children have already been inserted. And it won't work just to insert the nth child as the last child if there aren't n-1 previous siblings.  For example, if we insert the third child followed by the second child followed by the first child the second and third children will be out of order.

To ensure that nodes are placed in the correct location we create "dummy" children as needed as placeholders.  In the example above, we would insert two dummy children when inserting the third child.  When inserting the other two children we replace the previously inserted dummy child with the actual children.

vnode child indices are zero-based.  Here we use 1-based indices.

With the "mirroring" scheme it is a structure error if we ever have to create dummy vnodes.  Such structure errors cause a second pass to be made, with an empty root.  This second pass will generate other structure errors, which are ignored.
@c
def createNthChild3(self,n,parent,headline):

    """Create the nth child of the parent."""

    at = self
    assert(n > 0)

    if at.importing:
        return at.createImportedNode(at.root,headline)

    # Create any needed dummy children.
    dummies = n - parent.numberOfChildren() - 1
    if dummies > 0:
        if 0: # CVS produces to many errors for this to be useful.
            g.es("dummy created")
        at.errors += 1
    while dummies > 0:
        dummies -= 1
        dummy = parent.insertAsLastChild(leoNodes.tnode())
        # The user should never see this headline.
        dummy.initHeadString("Dummy")

    if n <= parent.numberOfChildren():
        << check the headlines >>
    else:
        # This is using a dummy; we should already have bumped errors.
        result = parent.insertAsLastChild(leoNodes.tnode())
    result.initHeadString(headline)

    result.setVisited() # Suppress all other errors for this node.
    result.t.setVisited() # Suppress warnings about unvisited nodes.
    return result
#@+node:ekr.20041005105605.31:<< check the headlines >>
# 1/24/03: A kludgy fix to the problem of headlines containing comment delims.

result = parent.nthChild(n-1)
resulthead = result.headString()

if headline.strip() != resulthead.strip():
    start = at.startSentinelComment
    end = at.endSentinelComment
    if end and len(end) > 0:
        # 1/25/03: The kludgy fix.
        # Compare the headlines without the delims.
        h1 =   headline.replace(start,"").replace(end,"")
        h2 = resulthead.replace(start,"").replace(end,"")
        if h1.strip() == h2.strip():
            # 1/25/03: Another kludge: use the headline from the outline, not the derived file.
            headline = resulthead
        else:
            at.errors += 1
    else:
        at.errors += 1
#@-node:ekr.20041005105605.31:<< check the headlines >>
#@-node:ekr.20041005105605.30:createNthChild3
#@+node:ekr.20041005105605.32:handleLinesFollowingSentinel
def handleLinesFollowingSentinel (self,lines,sentinel,comments = True):

    """convert lines following a sentinel to a single line"""

    at = self
    m = " following" + sentinel + " sentinel"
    start = at.startSentinelComment
    end   = at.endSentinelComment

    if len(lines) == 1: # The expected case.
        s = lines[0]
    elif len(lines) == 5:
        at.readError("potential cvs conflict" + m)
        s = lines[1]
        g.es("using " + s)
    else:
        at.readError("unexpected lines" + m)
        g.es(len(lines), " lines" + m)
        s = "bad " + sentinel
        if comments: s = start + ' ' + s

    if comments:
        << remove the comment delims from s >>

    # Undo the cweb hack: undouble @ signs if the opening comment delim ends in '@'.
    if start[-1:] == '@':
        s = s.replace('@@','@')

    return s
#@+node:ekr.20041005105605.33:<< remove the comment delims from s >>
# Remove the starting comment and the blank.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.
comment = start + '@ '
if g.match(s,0,comment):
    s = s[len(comment):]
else:
    at.readError("expecting comment" + m)

# Remove the trailing comment.
if len(end) == 0:
    s = string.strip(s[:-1])
else:
    k = s.rfind(end)
    s = string.strip(s[:k]) # works even if k == -1
#@-node:ekr.20041005105605.33:<< remove the comment delims from s >>
#@-node:ekr.20041005105605.32:handleLinesFollowingSentinel
#@+node:ekr.20041005105605.34:readLinesToNextSentinel
# We expect only a single line, and more may exist if cvs detects a conflict.
# We accept the first line even if it looks like a sentinel.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.

def readLinesToNextSentinel (self,theFile):

    """read lines following multiline sentinels"""

    at = self
    lines = []
    start = at.startSentinelComment + '@ '
    nextLine = at.readLine(theFile)
    while nextLine and len(nextLine) > 0:
        if len(lines) == 0:
            lines.append(nextLine)
            nextLine = at.readLine(theFile)
        else:
            # 5/1/03: looser test then calling sentinelKind3.
            s = nextLine ; i = g.skip_ws(s,0)
            if g.match(s,i,start):
                lines.append(nextLine)
                nextLine = at.readLine(theFile)
            else: break

    return nextLine,lines
#@-node:ekr.20041005105605.34:readLinesToNextSentinel
#@+node:ekr.20041005105605.35:scanDoc3
# Scans the doc part and appends the text out.
# s,i point to the present line on entry.

def scanDoc3(self,theFile,s,i,out,kind):

    at = self
    endKind = g.choose(kind ==at.startDoc,at.endDoc,at.endAt)
    single = len(at.endSentinelComment) == 0
    << Skip the opening sentinel >>
    << Skip an opening block delim >>
    nextLine = None ; kind = at.noSentinel
    while len(s) > 0:
        << set kind, nextLine >>
        if kind == endKind: break
        << Skip the leading stuff >>
        << Append s to out >>
        if nextLine:
            s = nextLine ; nextLine = None
        else: s = at.readLine(theFile)
    if kind != endKind:
        at.readError("Missing " + at.sentinelName(endKind) + " sentinel")
    << Remove a closing block delim from out >>
#@+node:ekr.20041005105605.36:<< Skip the opening sentinel >>
assert(g.match(s,i,g.choose(kind == at.startDoc, "+doc", "+at")))

out.append(g.choose(kind == at.startDoc, "@doc", "@"))
s = at.readLine(theFile)
#@-node:ekr.20041005105605.36:<< Skip the opening sentinel >>
#@+node:ekr.20041005105605.37:<< Skip an opening block delim >>
if not single:
    j = g.skip_ws(s,0)
    if g.match(s,j,at.startSentinelComment):
        s = at.readLine(theFile)
#@-node:ekr.20041005105605.37:<< Skip an opening block delim >>
#@+node:ekr.20041005105605.38:<< set kind, nextLine >>
@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.
@c

assert(nextLine==None)

kind = at.sentinelKind3(s)

if kind == at.noSentinel:
    j = g.skip_ws(s,0)
    blankLine = s[j] == '\n'
    nextLine = at.readLine(theFile)
    nextKind = at.sentinelKind3(nextLine)
    if blankLine and nextKind == endKind:
        kind = endKind # stop the scan now
#@-node:ekr.20041005105605.38:<< set kind, nextLine >>
#@+node:ekr.20041005105605.39:<< Skip the leading stuff >>
# Point i to the start of the real line.

if single: # Skip the opening comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0, at.indent)
#@-node:ekr.20041005105605.39:<< Skip the leading stuff >>
#@+node:ekr.20041005105605.40:<< Append s to out >>
# Append the line with a newline if it is real

line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    out.append(line + '\n')
else:
    # trailing whitespace: the newline is not real.
    out.append(line)
#@-node:ekr.20041005105605.40:<< Append s to out >>
#@+node:ekr.20041005105605.41:<< Remove a closing block delim from out >>
# This code will typically only be executed for HTML files.

if not single:

    delim = at.endSentinelComment
    n = len(delim)

    # Remove delim and possible a leading newline.
    s = string.join(out,"")
    s = s.rstrip()
    if s[-n:] == delim:
        s = s[:-n]
    if s[-1] == '\n':
        s = s[:-1]

    # Rewrite out in place.
    del out[:]
    out.append(s)
#@-node:ekr.20041005105605.41:<< Remove a closing block delim from out >>
#@-node:ekr.20041005105605.35:scanDoc3
#@+node:ekr.20041005105605.42:scanText3
def scanText3 (self,theFile,p,out,endSentinelKind,nextLine=None):

    """Scan a 3.x derived file recursively."""

    __pychecker__ = '--maxbranches=100 --maxlines=500'

    at = self
    lastLines = [] # The lines after @-leo
    lineIndent = 0 ; linep = 0 # Changed only for sentinels.
    while 1:
        << put the next line into s >>
        << set kind, nextKind >>
        if kind != at.noSentinel:
            << set lineIndent, linep and leading_ws >>
            i = at.skipSentinelStart3(s,0)
        << handle the line in s >>
    << handle unexpected end of text >>
    assert(len(s)==0 and nextLine==None) # We get here only if readline fails.
    return lastLines # We get here only if there are problems.
#@+node:ekr.20041005105605.43:<< put the next line into s >>
if nextLine:
    s = nextLine ; nextLine = None
else:
    s = at.readLine(theFile)
    if len(s) == 0: break
#@-node:ekr.20041005105605.43:<< put the next line into s >>
#@+node:ekr.20041005105605.44:<< set kind, nextKind >>
@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.  If so, the newline that ends a non-sentinel line belongs to the next sentinel.
@c

assert(nextLine==None)

kind = at.sentinelKind3(s)

if kind == at.noSentinel:
    nextLine = at.readLine(theFile)
    nextKind = at.sentinelKind3(nextLine)
else:
    nextLine = nextKind = None

# nextLine != None only if we have a non-sentinel line.
# Therefore, nextLine == None whenever scanText3 returns.
#@-node:ekr.20041005105605.44:<< set kind, nextKind >>
#@+node:ekr.20041005105605.45:<< Set lineIndent, linep and leading_ws >>
@ lineIndent is the total indentation on a sentinel line.  The first "self.indent" portion of that must be removed when recreating text.  leading_ws is the remainder of the leading whitespace.  linep points to the first "real" character of a line, the character following the "indent" whitespace.
@c

# Point linep past the first self.indent whitespace characters.
if at.raw: # 10/15/02
    linep =0
else:
    linep = at.skipIndent(s,0,at.indent)

# Set lineIndent to the total indentation on the line.
lineIndent = 0 ; i = 0
while i < len(s):
    if s[i] == '\t': lineIndent += (abs(at.tab_width) - (lineIndent % abs(at.tab_width)))
    elif s[i] == ' ': lineIndent += 1
    else: break
    i += 1
# g.trace("lineIndent,s:",lineIndent,s)

# Set leading_ws to the additional indentation on the line.
leading_ws = s[linep:i]
#@-node:ekr.20041005105605.45:<< Set lineIndent, linep and leading_ws >>
#@+node:ekr.20041005105605.46:<< handle the line in s >>
if kind == at.noSentinel:
    << append non-sentinel line >>
<< handle common sentinels >>
<< handle rare sentinels >>
else:
    << warn about unknown sentinel >>
#@+node:ekr.20041005105605.47:<< append non-sentinel line >>
# We don't output the trailing newline if the next line is a sentinel.
if at.raw: # 10/15/02
    i = 0
else:
    i = at.skipIndent(s,0,at.indent)

assert(nextLine != None)

if nextKind == at.noSentinel:
    line = s[i:]
    out.append(line)
else:
    line = s[i:-1] # don't output the newline
    out.append(line)
#@-node:ekr.20041005105605.47:<< append non-sentinel line >>
#@+node:ekr.20041005105605.48:<< handle common sentinels >>
elif kind in (at.endAt, at.endBody,at.endDoc,at.endLeo,at.endNode,at.endOthers):
        << handle an ending sentinel >>
elif kind == at.startBody:
    << scan @+body >>
elif kind == at.startNode:
    << scan @+node >>
elif kind == at.startRef:
    << scan old ref >>
elif kind == at.startAt:
    << scan @+at >>
elif kind == at.startDoc:
    << scan @+doc >>
elif kind == at.startOthers:
    << scan @+others >>
#@+node:ekr.20041005105605.49:<< handle an ending sentinel >>
# g.trace("end sentinel:", at.sentinelName(kind))

if kind == endSentinelKind:
    if kind == at.endLeo:
        # Ignore everything after @-leo.
        # Such lines were presumably written by @last.
        while 1:
            s = at.readLine(theFile)
            if len(s) == 0: break
            lastLines.append(s) # Capture all trailing lines, even if empty.
    elif kind == at.endBody:
        at.raw = False
    # nextLine != None only if we have a non-sentinel line.
    # Therefore, nextLine == None whenever scanText3 returns.
    assert(nextLine==None)
    return lastLines # End the call to scanText3.
else:
    # Tell of the structure error.
    name = at.sentinelName(kind)
    expect = at.sentinelName(endSentinelKind)
    at.readError("Ignoring " + name + " sentinel.  Expecting " + expect)
#@-node:ekr.20041005105605.49:<< handle an ending sentinel >>
#@+node:ekr.20041005105605.50:<< scan @+body >> 3.x
assert(g.match(s,i,"+body"))

child_out = [] ; child = p.copy() # Do not change out or p!
oldIndent = at.indent ; at.indent = lineIndent
at.scanText3(theFile,child,child_out,at.endBody)

# Set the body, removing cursed newlines.
# This must be done here, not in the @+node logic.
body = string.join(child_out, "")
body = body.replace('\r', '')
body = g.toUnicode(body,g.app.tkEncoding) # 9/28/03

if at.importing:
    child.t.bodyString = body
else:
    child.t.tempBodyString = body

at.indent = oldIndent
#@-node:ekr.20041005105605.50:<< scan @+body >> 3.x
#@+node:ekr.20041005105605.51:<< scan @+node >>
assert(g.match(s,i,"+node:"))
i += 6

childIndex = 0 ; cloneIndex = 0
<< Set childIndex >>
<< Set cloneIndex >>
headline = ""
<< Set headline and ref >>

# print childIndex,headline

if childIndex == 0: # The root node.
    if not at.importing:
        << Check the filename in the sentinel >>
    # Put the text of the root node in the current node.
    at.scanText3(theFile,p,out,at.endNode)
    p.v.t.setCloneIndex(cloneIndex)
    # if cloneIndex > 0: g.trace("clone index:",cloneIndex,p)
else:
    # NB: this call to createNthChild3 is the bottleneck!
    child = at.createNthChild3(childIndex,p,headline)
    child.t.setCloneIndex(cloneIndex)
    # if cloneIndex > 0: g.trace("cloneIndex,child:"cloneIndex,child)
    at.scanText3(theFile,child,out,at.endNode)

<< look for sentinels that may follow a reference >>
#@+node:ekr.20041005105605.52:<< Set childIndex >>
i = g.skip_ws(s,i) ; j = i
while i < len(s) and s[i].isdigit():
    i += 1

if j == i:
    at.readError("Implicit child index in @+node")
    childIndex = 0
else:
    childIndex = int(s[j:i])

if g.match(s,i,':'):
    i += 1 # Skip the ":".
else:
    at.readError("Bad child index in @+node")
#@-node:ekr.20041005105605.52:<< Set childIndex >>
#@+node:ekr.20041005105605.53:<< Set cloneIndex >>
while i < len(s) and s[i] != ':' and not g.is_nl(s,i):
    if g.match(s,i,"C="):
        # set cloneIndex from the C=nnn, field
        i += 2 ; j = i
        while i < len(s) and s[i].isdigit():
            i += 1
        if j < i:
            cloneIndex = int(s[j:i])
    else: i += 1 # Ignore unknown status bits.

if g.match(s,i,":"):
    i += 1
else:
    at.readError("Bad attribute field in @+node")
#@-node:ekr.20041005105605.53:<< Set cloneIndex >>
#@+node:ekr.20041005105605.54:<< Set headline and ref >>
# Set headline to the rest of the line.
# 6/22/03: don't strip leading whitespace.
if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    # 10/24/02: search from the right, not the left.
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# 10/23/02: The cweb hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')

# Set reference if it exists.
i = g.skip_ws(s,i)

if 0: # no longer used
    if g.match(s,i,"<<"):
        k = s.find(">>",i)
        if k != -1: ref = s[i:k+2]
#@-node:ekr.20041005105605.54:<< Set headline and ref >>
#@+node:ekr.20041005105605.55:<< Check the filename in the sentinel >>
h = headline.strip()

if h[:5] == "@file":
    i,junk,junk = g.scanAtFileOptions(h)
    fileName = string.strip(h[i:])
    if fileName != at.targetFileName:
        at.readError("File name in @node sentinel does not match file's name")
elif h[:8] == "@rawfile":
    fileName = string.strip(h[8:])
    if fileName != at.targetFileName:
        at.readError("File name in @node sentinel does not match file's name")
else:
    at.readError("Missing @file in root @node sentinel")
#@-node:ekr.20041005105605.55:<< Check the filename in the sentinel >>
#@+node:ekr.20041005105605.56:<< look for sentinels that may follow a reference >>
s = at.readLine(theFile)
kind = at.sentinelKind3(s)

if len(s) > 1 and kind == at.startVerbatimAfterRef:
    s = at.readLine(theFile)
    # g.trace("verbatim:",repr(s))
    out.append(s)
elif len(s) > 1 and at.sentinelKind3(s) == at.noSentinel:
    out.append(s)
else:
    nextLine = s # Handle the sentinel or blank line later.
#@-node:ekr.20041005105605.56:<< look for sentinels that may follow a reference >>
#@-node:ekr.20041005105605.51:<< scan @+node >>
#@+node:ekr.20041005105605.57:<< scan old ref >> (3.0)
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

assert(g.match(s,i,"<<"))

if len(at.endSentinelComment) == 0:
    line = s[i:-1] # No trailing newline
else:
    k = s.find(at.endSentinelComment,i)
    line = s[i:k] # No trailing newline, whatever k is.

# 10/30/02: undo cweb hack here
start = at.startSentinelComment
if start and len(start) > 0 and start[-1] == '@':
    line = line.replace('@@','@')

out.append(line)
#@-node:ekr.20041005105605.57:<< scan old ref >> (3.0)
#@+node:ekr.20041005105605.58:<< scan @+at >>
assert(g.match(s,i,"+at"))
at.scanDoc3(theFile,s,i,out,kind)
#@-node:ekr.20041005105605.58:<< scan @+at >>
#@+node:ekr.20041005105605.59:<< scan @+doc >>
assert(g.match(s,i,"+doc"))
at.scanDoc3(theFile,s,i,out,kind)
#@-node:ekr.20041005105605.59:<< scan @+doc >>
#@+node:ekr.20041005105605.60:<< scan @+others >>
assert(g.match(s,i,"+others"))

# Make sure that the generated at-others is properly indented.
out.append(leading_ws + "@others")

at.scanText3(theFile,p,out,at.endOthers)
#@-node:ekr.20041005105605.60:<< scan @+others >>
#@-node:ekr.20041005105605.48:<< handle common sentinels >>
#@+node:ekr.20041005105605.61:<< handle rare sentinels >>
elif kind == at.startComment:
    << scan @comment >>
elif kind == at.startDelims:
    << scan @delims >>
elif kind == at.startDirective:
    << scan @@ >>
elif kind == at.startLeo:
    << scan @+leo >>
elif kind == at.startVerbatim:
    << scan @verbatim >>
#@+node:ekr.20041005105605.62:<< scan @comment >>
assert(g.match(s,i,"comment"))

# We need do nothing more to ignore the comment line!
#@-node:ekr.20041005105605.62:<< scan @comment >>
#@+node:ekr.20041005105605.63:<< scan @delims >>
assert(g.match(s,i-1,"@delims"));

# Skip the keyword and whitespace.
i0 = i-1
i = g.skip_ws(s,i-1+7)

# Get the first delim.
j = i
while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1

if j < i:
    at.startSentinelComment = s[j:i]
    # print "delim1:", at.startSentinelComment

    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    end = g.choose(j<i,s[j:i],"")
    i2 = g.skip_ws(s,i)
    if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
        at.endSentinelComment = "" # Not really two params.
        line = s[i0:j]
        line = line.rstrip()
        out.append(line+'\n')
    else:
        at.endSentinelComment = end
        # print "delim2:",end
        line = s[i0:i]
        line = line.rstrip()
        out.append(line+'\n')
else:
    at.readError("Bad @delims")
    # Append the bad @delims line to the body text.
    out.append("@delims")
#@-node:ekr.20041005105605.63:<< scan @delims >>
#@+node:ekr.20041005105605.64:<< scan @@ >>
# The first '@' has already been eaten.
assert(g.match(s,i,"@"))

if g.match_word(s,i,"@raw"):
    at.raw = True
elif g.match_word(s,i,"@end_raw"):
    at.raw = False

e = at.endSentinelComment
s2 = s[i:]
if len(e) > 0:
    k = s.rfind(e,i)
    if k != -1:
        s2 = s[i:k] + '\n'

start = at.startSentinelComment
if start and len(start) > 0 and start[-1] == '@':
    s2 = s2.replace('@@','@')
out.append(s2)
# g.trace(s2)
#@-node:ekr.20041005105605.64:<< scan @@ >>
#@+node:ekr.20041005105605.65:<< scan @+leo >>
assert(g.match(s,i,"+leo"))
at.readError("Ignoring unexpected @+leo sentinel")
#@-node:ekr.20041005105605.65:<< scan @+leo >>
#@+node:ekr.20041005105605.66:<< scan @verbatim >>
assert(g.match(s,i,"verbatim"))

# Skip the sentinel.
s = at.readLine(theFile) 

# Append the next line to the text.
i = at.skipIndent(s,0,at.indent)
out.append(s[i:])
#@-node:ekr.20041005105605.66:<< scan @verbatim >>
#@-node:ekr.20041005105605.61:<< handle rare sentinels >>
#@+node:ekr.20041005105605.67:<< warn about unknown sentinel >>
j = i
i = g.skip_line(s,i)
line = s[j:i]
at.readError("Unknown sentinel: " + line)
#@-node:ekr.20041005105605.67:<< warn about unknown sentinel >>
#@-node:ekr.20041005105605.46:<< handle the line in s >>
#@+node:ekr.20041005105605.68:<< handle unexpected end of text >>
# Issue the error.
name = at.sentinelName(endSentinelKind)
at.readError("Unexpected end of file. Expecting " + name + "sentinel" )
#@-node:ekr.20041005105605.68:<< handle unexpected end of text >>
#@-node:ekr.20041005105605.42:scanText3
#@+node:ekr.20041005105605.69:sentinelKind3
def sentinelKind3(self,s):

    """This method tells what kind of sentinel appears in line s.

    Typically s will be an empty line before the actual sentinel,
    but it is also valid for s to be an actual sentinel line.

    Returns (kind, s, emptyFlag), where emptyFlag is True if
    kind == at.noSentinel and s was an empty line on entry."""

    at = self
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # 10/30/02: locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s = s[:i] + string.replace(s[i:],'@@','@')

    # Do not skip whitespace here!
    if g.match(s,i,"@<<"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) > 0 and at.sentinelDict.has_key(key):
        # g.trace("found:",key)
        return at.sentinelDict[key]
    else:
        # g.trace("not found:",key)
        return at.noSentinel
#@-node:ekr.20041005105605.69:sentinelKind3
#@+node:ekr.20041005105605.70:skipSentinelStart3
def skipSentinelStart3(self,s,i):

    """Skip the start of a sentinel."""

    at = self
    start = at.startSentinelComment
    assert(start and len(start)>0)

    if g.is_nl(s,i): i = g.skip_nl(s,i)

    i = g.skip_ws(s,i)
    assert(g.match(s,i,start))
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert(i < len(s) and s[i] == '@')
    return i + 1
#@-node:ekr.20041005105605.70:skipSentinelStart3
#@-node:ekr.20041005105605.29:Reading (3.x)
#@+node:ekr.20041005105605.71:Reading (4.x)
#@+node:ekr.20041005105605.72:createThinChild4
def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)

    # New in Leo 4.4a5: Solve Read @file nodes problem (by LeoUser)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove(last)

    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)

    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount > 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies > 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert indices.areEqual(t.fileIndex,gnx), 't.fileIndex: %s gnx: %s' % (t.fileIndex,gnx)
            # g.trace('not created, should already exist',gnxString)
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child
#@-node:ekr.20041005105605.72:createThinChild4
#@+node:ekr.20041005105605.73:findChild4
def findChild4 (self,headline):

    """Return the next tnode in at.root.t.tnodeList."""

    __pychecker__ = '--no-argsused' # headline might be used for debugging.

    # Note: tnodeLists are used _only_ when reading @file (not @thin) nodes.
    # tnodeLists compensate (a hack) for not having gnx's in derived files! 

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None

    if at.tnodeListIndex >= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None

    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None

    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t
#@-node:ekr.20041005105605.73:findChild4
#@+node:ekr.20041005105605.74:scanText4 & allies
def scanText4 (self,theFile,fileName,p,verbose=False):

    """Scan a 4.x derived file non-recursively."""

    __pychecker__ = '--no-argsused' # fileName,verbose might be used for debugging.

    at = self
    << init ivars for scanText4 >>
    while at.errors == 0 and not at.done:
        s = at.readLine(theFile)
        if len(s) == 0: break
        kind = at.sentinelKind4(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == at.noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart4(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        << report unexpected end of text >>

    return at.lastLines
#@+node:ekr.20041005105605.75:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p.copy() # Bug fix: 12/10/05
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)

# g.trace(at.startSentinelComment)
#@-node:ekr.20041005105605.75:<< init ivars for scanText4 >>
#@+node:ekr.20041005105605.76:<< report unexpected end of text >>
assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))
#@-node:ekr.20041005105605.76:<< report unexpected end of text >>
#@+node:ekr.20041005105605.77:readNormalLine
def readNormalLine (self,s,i):

    at = self

    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        << Skip the leading stuff >>
        << Append s to docOut >>
#@+node:ekr.20041005105605.78:<< Skip the leading stuff >>
if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)
#@-node:ekr.20041005105605.78:<< Skip the leading stuff >>
#@+node:ekr.20041005105605.79:<< Append s to docOut >>
line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)
#@-node:ekr.20041005105605.79:<< Append s to docOut >>
#@-node:ekr.20041005105605.77:readNormalLine
#@+node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.81:readStartAll (4.2)
def readStartAll (self,s,i):

    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")

    at.endSentinelStack.append(at.endAll)
#@-node:ekr.20041005105605.81:readStartAll (4.2)
#@+node:ekr.20041005105605.82:readStartAt & readStartDoc
def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)

def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)

def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)
#@-node:ekr.20041005105605.82:readStartAt & readStartDoc
#@+node:ekr.20041005105605.83:readStartLeo
def readStartLeo (self,s,i):

    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")
#@-node:ekr.20041005105605.83:readStartLeo
#@+node:ekr.20041005105605.84:readStartMiddle
def readStartMiddle (self,s,i):

    """Read an @+middle sentinel."""

    at = self

    at.readStartNode(s,i,middle=True)
#@-node:ekr.20041005105605.84:readStartMiddle
#@+node:ekr.20041005105605.85:readStartNode (4.x)
def readStartNode (self,s,i,middle=False):

    """Read an @+node or @+middle sentinel."""

    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6

    if at.thinFile:
        << set gnx and bump i >>
    << Set headline, undoing the CWEB hack >>
    if not at.root_seen:
        at.root_seen = True
        << Check the filename in the sentinel >>

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent

    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild4(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild4(headline)

    at.endSentinelStack.append(at.endNode)
#@+node:ekr.20041005105605.86:<< set gnx and bump i >>
# We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i
#@-node:ekr.20041005105605.86:<< set gnx and bump i >>
#@+node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
# Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')
#@-node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
#@+node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()

        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")
#@-node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
#@-node:ekr.20041005105605.85:readStartNode (4.x)
#@+node:ekr.20041005105605.89:readStartOthers
def readStartOthers (self,s,i):

    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")

    at.endSentinelStack.append(at.endOthers)
#@-node:ekr.20041005105605.89:readStartOthers
#@-node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.91:readEndAll (4.2)
def readEndAll (self,s,i):

    """Read an @-all sentinel."""

    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.popSentinelStack(at.endAll)
#@-node:ekr.20041005105605.91:readEndAll (4.2)
#@+node:ekr.20041005105605.92:readEndAt & readEndDoc
def readEndAt (self,s,i):

    """Read an @-at sentinel."""

    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True

def readEndDoc (self,s,i):

    """Read an @-doc sentinel."""

    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True
#@-node:ekr.20041005105605.92:readEndAt & readEndDoc
#@+node:ekr.20041005105605.93:readEndLeo
def readEndLeo (self,s,i):

    """Read an @-leo sentinel."""

    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True
#@-node:ekr.20041005105605.93:readEndLeo
#@+node:ekr.20041005105605.94:readEndMiddle
def readEndMiddle (self,s,i):

    """Read an @-middle sentinel."""

    at = self

    at.readEndNode(s,i,middle=True)
#@-node:ekr.20041005105605.94:readEndMiddle
#@+node:ekr.20041005105605.95:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):

    """Handle end-of-node processing for @-others and @-ref sentinels."""

    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c

    # End raw mode.
    at.raw = False

    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            << indicate that the node has been changed >>
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just setting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if 0: # New in 4.4.1 final.  This warning can be very confusing.
        if not at.updateWarningGiven:
            at.updateWarningGiven = True
            # print "***",at.t,at.root.t
            g.es("Warning: updating changed text in %s" %
                (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:readEndNode (4.x)
#@+node:ekr.20041005105605.98:readEndOthers
def readEndOthers (self,s,i):

    """Read an @-others sentinel."""

    __pychecker__ = '--no-argsused' # s,i unused, but must be present.

    at = self
    at.popSentinelStack(at.endOthers)
#@-node:ekr.20041005105605.98:readEndOthers
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):

    """Read the @c line that terminates the doc part.
    tag is @doc or @."""

    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)

    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    # Bug fix: Append any whitespace following the tag to tag.
    while s and s[0] in (' ','\t'):
        tag = tag + s[0] ; s = s[1:]

    if end:
        # Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace('tag',repr(tag),'start',repr(start),'s',repr(s))
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
#@-node:ekr.20041005105605.99:readLastDocLine
#@-node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.101:ignoreOldSentinel
def  ignoreOldSentinel (self,s,i):

    """Ignore an 3.x sentinel."""

    __pychecker__ = '--no-argsused' # i unused, but must be present.

    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")
#@-node:ekr.20041005105605.101:ignoreOldSentinel
#@+node:ekr.20041005105605.102:readAfterRef
def  readAfterRef (self,s,i):

    """Read an @afterref sentinel."""

    at = self
    assert(g.match(s,i,"afterref"))

    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)
#@-node:ekr.20041005105605.102:readAfterRef
#@+node:ekr.20041005105605.103:readClone
def readClone (self,s,i):

    at = self ; tag = "clone"

    assert(g.match(s,i,tag))

    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))

    # Get the clone count.
    junk,val = g.skip_long(s,i)

    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount = val
#@-node:ekr.20041005105605.103:readClone
#@+node:ekr.20041005105605.104:readComment
def readComment (self,s,i):

    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
#@-node:ekr.20041005105605.104:readComment
#@+node:ekr.20041005105605.105:readDelims
def readDelims (self,s,i):

    """Read an @delims sentinel."""

    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)

    # Get the first delim.
    j = i
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1

    if j < i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment

        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j<i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")
#@-node:ekr.20041005105605.105:readDelims
#@+node:ekr.20041005105605.106:readDirective (@@)
def readDirective (self,s,i):

    """Read an @@sentinel."""

    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.

    # g.trace(g.get_line(s,i))

    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False

    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'

    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')

    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    at.out.append(s2)
#@+node:ekr.20041005105605.107:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")
#@-node:ekr.20041005105605.107:<< handle @language >>
#@+node:ekr.20041005105605.108:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")
#@-node:ekr.20041005105605.108:<< handle @comment >>
#@-node:ekr.20041005105605.106:readDirective (@@)
#@+node:ekr.20041005105605.109:readNl
def readNl (self,s,i):

    """Handle an @nonl sentinel."""

    at = self
    assert(g.match(s,i,"nl"))

    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')
#@-node:ekr.20041005105605.109:readNl
#@+node:ekr.20041005105605.110:readNonl
def readNonl (self,s,i):

    """Handle an @nonl sentinel."""

    at = self
    assert(g.match(s,i,"nonl"))

    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")
#@-node:ekr.20041005105605.110:readNonl
#@+node:ekr.20041005105605.111:readRef
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):

    """Handle an @<< sentinel."""

    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"<<"))

    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.

    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
#@-node:ekr.20041005105605.111:readRef
#@+node:ekr.20041005105605.112:readVerbatim
def readVerbatim (self,s,i):

    """Read an @verbatim sentinel."""

    at = self
    assert(g.match(s,i,"verbatim"))

    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])
#@-node:ekr.20041005105605.112:readVerbatim
#@-node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.113:badEndSentinel, push/popSentinelStack
def badEndSentinel (self,expectedKind):

    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)

def popSentinelStack (self,expectedKind):

    """Pop an entry from endSentinelStack and check it."""

    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)
#@-node:ekr.20041005105605.113:badEndSentinel, push/popSentinelStack
#@-node:ekr.20041005105605.74:scanText4 & allies
#@+node:ekr.20041005105605.114:sentinelKind4
def sentinelKind4(self,s):

    """Return the kind of sentinel at s."""

    at = self

    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment): 
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # Locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s = s[:i] + string.replace(s[i:],'@@','@')

    # 4.0: Look ahead for @[ws]@others and @[ws]<<
    if g.match(s,i,"@"):
        j = g.skip_ws(s,i+1)
        if j > i+1:
            # g.trace(ws,s)
            if g.match(s,j,"@+others"):
                return at.startOthers
            elif g.match(s,j,"<<"):
                return at.startRef
            else:
                # No other sentinels allow whitespace following the '@'
                return at.noSentinel

    # Do not skip whitespace here!
    if g.match(s,i,"@<<"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) > 0 and at.sentinelDict.has_key(key):
        return at.sentinelDict[key]
    else:
        return at.noSentinel
#@-node:ekr.20041005105605.114:sentinelKind4
#@+node:ekr.20041005105605.115:skipSentinelStart4
def skipSentinelStart4(self,s,i):

    """Skip the start of a sentinel."""

    start = self.startSentinelComment
    assert(start and len(start)>0)

    i = g.skip_ws(s,i)
    assert(g.match(s,i,start))
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert(i < len(s) and s[i] == '@')
    return i + 1
#@-node:ekr.20041005105605.115:skipSentinelStart4
#@-node:ekr.20041005105605.71:Reading (4.x)
#@+node:ekr.20041005105605.116:Reading utils...
#@+node:ekr.20041005105605.117:completeFirstDirectives
# 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @first directives
# and appends the corresponding line from 'firstLines' to each @first 
# directive found.  NOTE: the @first directives must be the very first
# lines in 'out'.
def completeFirstDirectives(self,out,firstLines):

    tag = "@first"
    foundAtFirstYet = 0
    outRange = range(len(out))
    j = 0
    for k in outRange:
        # skip leading whitespace lines
        if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @first directive
        i = 0
        if not g.match(out[k],i,tag): break;
        foundAtFirstYet = 1
        # quit if no leading lines to apply
        if j >= len(firstLines): break
        # make the new @first directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
        leadingLine = " " + firstLines[j]
        out[k] = tag + leadingLine.rstrip() ; j += 1
#@-node:ekr.20041005105605.117:completeFirstDirectives
#@+node:ekr.20041005105605.118:completeLastDirectives
# 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @last directives
# and appends the corresponding line from 'lastLines' to each @last 
# directive found.  NOTE: the @last directives must be the very last
# lines in 'out'.
def completeLastDirectives(self,out,lastLines):

    tag = "@last"
    foundAtLastYet = 0
    outRange = range(-1,-len(out),-1)
    j = -1
    for k in outRange:
        # skip trailing whitespace lines
        if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @last directive
        i = 0
        if not g.match(out[k],i,tag): break;
        foundAtLastYet = 1
        # quit if no trailing lines to apply
        if j < -len(lastLines): break
        # make the new @last directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
        trailingLine = " " + lastLines[j]
        out[k] = tag + trailingLine.rstrip() ; j -= 1
#@-node:ekr.20041005105605.118:completeLastDirectives
#@+node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
def  copyAllTempBodyStringsToTnodes (self,root,thinFile):

    c = self.c
    for p in root.self_and_subtree_iter():
        try: s = p.v.t.tempBodyString
        except: s = ""
        old_body = p.bodyString()
        if s != old_body:
            if 0: # For debugging.
                print ; print "changed: " + p.headString()
                print ; print "new:",s
                print ; print "old:",p.bodyString()
            if thinFile:
                p.v.setTnodeText(s)
                if p.v.isDirty():
                    p.setAllAncestorAtFileNodesDirty()
            else:
                c.setBodyString(p,s) # Sets c and p dirty.

            if not thinFile or (thinFile and p.v.isDirty()):
                # New in Leo 4.3: support for mod_labels plugin:
                try:
                    c.mod_label_controller.add_label(p,"before change:",old_body)
                except Exception:
                    pass
                g.es("changed: " + p.headString(),color="blue")
                p.setMarked()
#@-node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
#@+node:ekr.20041005105605.119:createImportedNode
def createImportedNode (self,root,headline):

    at = self

    if at.importRootSeen:
        p = root.insertAsLastChild()
        p.initHeadString(headline)
    else:
        # Put the text into the already-existing root node.
        p = root
        at.importRootSeen = True

    p.v.t.setVisited() # Suppress warning about unvisited node.
    return p
#@-node:ekr.20041005105605.119:createImportedNode
#@+node:ekr.20041005105605.120:parseLeoSentinel
def parseLeoSentinel (self,s):

    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    << set the opening comment delim >>
    << make sure we have @+leo >>
    << read optional version param >>
    << read optional thin param >>
    << read optional encoding param >>
    << set the closing comment delim >>
    return valid,new_df,start,end,isThinDerivedFile
#@+node:ekr.20041005105605.121:<< set the opening comment delim >>
# s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j < i:
    start = s[j:i]
else:
    valid = False
#@-node:ekr.20041005105605.121:<< set the opening comment delim >>
#@+node:ekr.20041005105605.122:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False
#@-node:ekr.20041005105605.122:<< make sure we have @+leo >>
#@+node:ekr.20041005105605.123:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
    # Pre Leo 4.4.1: Skip to the next minus sign or end-of-line.
    # Leo 4.4.1 +:   Skip to next minus sign, end-of-line, or non numeric character.
    # This is required to handle trailing comment delims properly.
    i += len(version_tag)
    j = i
    while i < len(s) and (s[i] == '.' or s[i].isdigit()):
        i += 1

    if j < i:
        pass
    else:
        valid = False
#@-node:ekr.20041005105605.123:<< read optional version param >>
#@+node:ekr.20041005105605.124:<< read optional thin param >>
if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True
#@-node:ekr.20041005105605.124:<< read optional thin param >>
#@+node:ekr.20041005105605.125:<< read optional encoding param >>
# Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j > -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 2 # 6/8/04, 1/11/05 (was i = j + 1)
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j > -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            print "bad encoding in derived file:",encoding
            g.es("bad encoding in derived file:",encoding)
    else:
        valid = False
#@-node:ekr.20041005105605.125:<< read optional encoding param >>
#@+node:ekr.20041005105605.126:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]
#@-node:ekr.20041005105605.126:<< set the closing comment delim >>
#@+node:ekr.20050211111552:test_parseLeoSentinel
def test_parseLeoSentinel (self):

    s1 = '#@+leo-ver=4-thin-encoding=utf-8,.'  # 4.2 format.
    s2 = '#@+leo-ver=4-thin-encoding=utf-8.' # pre-4.2 format.

    at=c.atFileCommands # Self is a dummy argument.

    for s in (s1,s2):
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
        # g.trace('start',start,'end',repr(end),'len(s)',len(s))
        assert valid, 'not valid'
        assert new_df, 'not new_df'
        assert isThinDerivedFile, 'not thin'
        assert end == '', 'invalid end: %s' % repr(end)
        assert at.encoding == 'utf-8', 'bad encoding: %s' % repr(at.encoding)
#@-node:ekr.20050211111552:test_parseLeoSentinel
#@-node:ekr.20041005105605.120:parseLeoSentinel
#@+node:ekr.20041005105605.127:readError
def readError(self,message):

    c = self.c

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        self.printError("----- error reading @file: %s" % self.targetFileName)

    # g.trace(self.root,g.callers())

    self.error(message)

    # Bug fix: 12/10/05: Delete all of root's tree.
    self.root.v.t._firstChild = None

    self.root.setOrphan()
    self.root.setDirty()
#@-node:ekr.20041005105605.127:readError
#@+node:ekr.20041005105605.128:readLine
def readLine (self,theFile):

    """Reads one line from file using the present encoding"""

    s = g.readlineForceUnixNewline(theFile) # calls theFile.readline
    u = g.toUnicode(s,self.encoding)
    return u
#@-node:ekr.20041005105605.128:readLine
#@+node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
def scanHeader(self,theFile,fileName):

    """Scan the @+leo sentinel.

    Sets self.encoding, and self.start/endSentinelComment.

    Returns (firstLines,new_df) where:
    firstLines contains all @first lines,
    new_df is True if we are reading a new-format derived file."""

    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False ; isThinDerivedFile = False
    << skip any non @+leo lines >>
    if valid:
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
        # g.trace('start',repr(start),'end',repr(end))
    else:
        at.error("Bad @+leo sentinel in: %s" % fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines,new_df,isThinDerivedFile
#@+node:ekr.20041005105605.130:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(theFile)
while len(s) > 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)

n = len(s)
valid = n > 0
#@-node:ekr.20041005105605.130:<< skip any non @+leo lines >>
#@-node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
#@+node:ekr.20041005105605.131:skipIndent
# Skip past whitespace equivalent to width spaces.

def skipIndent(self,s,i,width):

    ws = 0 ; n = len(s)
    while i < n and ws < width:
        if   s[i] == '\t': ws += (abs(self.tab_width) - (ws % abs(self.tab_width)))
        elif s[i] == ' ':  ws += 1
        else: break
        i += 1
    return i
#@-node:ekr.20041005105605.131:skipIndent
#@-node:ekr.20041005105605.116:Reading utils...
#@-node:ekr.20041005105605.17:Reading...
#@+node:ekr.20041005105605.132:Writing...
#@+node:ekr.20041005105605.133:Writing (top level)
#@+node:ekr.20041005105605.134:Don't override in plugins
# Plugins probably should not need to override these methods.
#@+node:ekr.20041005105605.135:closeWriteFile
# 4.0: Don't use newline-pending logic.

def closeWriteFile (self):

    at = self

    if at.outputFile:
        at.outputFile.flush()
        if self.toString:
            self.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
#@-node:ekr.20041005105605.135:closeWriteFile
#@+node:ekr.20041005105605.136:norefWrite
def norefWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atNorefFileNodeName()
        at.initWriteIvars(root,targetFileName,nosentinels=False,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            return
        << write root's tree >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)

rawWrite = norefWrite
#@+node:ekr.20041005105605.137:<< write root's tree >>
<< put all @first lines in root >>
at.putOpenLeoSentinel("@+leo-ver=4")
<< put optional @comment sentinel lines >>

for p in root.self_and_subtree_iter():
    << Write p's node >>

at.putSentinel("@-leo")
<< put all @last lines in root >>
#@+node:ekr.20041005105605.138:<< put all @first lines in root >>
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.putBuffered(line) ; at.onl()
    i = g.skip_nl(s,i)
#@-node:ekr.20041005105605.138:<< put all @first lines in root >>
#@+node:ekr.20041005105605.139:<< put optional @comment sentinel lines >>
s2 = c.config.output_initial_comment
if s2:
    lines = string.split(s2,"\\n")
    for line in lines:
        line = line.replace("@date",time.asctime())
        if len(line)> 0:
            at.putSentinel("@comment " + line)
#@-node:ekr.20041005105605.139:<< put optional @comment sentinel lines >>
#@+node:ekr.20041005105605.140:<< Write p's node >>
at.putOpenNodeSentinel(p)

s = p.bodyString()

if self.write_strips_blank_lines:
    s = self.cleanLines(p,s)

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True)
    at.outputStringWithLineEndings(s)

# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
    at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p)
#@-node:ekr.20041005105605.140:<< Write p's node >>
#@+node:ekr.20041005105605.141:<< put all @last lines in root >>
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j >= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j >= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    at.putBuffered(line[i:]) ; at.onl()
#@-node:ekr.20041005105605.141:<< put all @last lines in root >>
#@-node:ekr.20041005105605.137:<< write root's tree >>
#@-node:ekr.20041005105605.136:norefWrite
#@+node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
def openFileForWriting (self,root,fileName,toString):

    at = self ; c = at.c
    at.outputFile = None

    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "<string: %s>" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        at.openFileForWritingHelper(fileName)

    # New in 4.3 b2: root may be none when writing from a string.
    if root:
        if at.outputFile:
            root.clearOrphan()
        else:
            root.setOrphan()
            root.setDirty()

    return at.outputFile is not None
#@+node:ekr.20041005105605.143:openFileForWritingHelper
def openFileForWritingHelper (self,fileName):

    at = self ; c = at.c

    try:
        at.shortFileName = g.shortFileName(fileName)
        fileName = g.os_path_join(at.default_directory,fileName)
        at.targetFileName = g.os_path_normpath(fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            if path:
                path = g.makeAllNonExistentDirectories(path,c=c)
            if not path or not g.os_path_exists(path):
                path = g.os_path_dirname(at.targetFileName)
                at.writeError("path does not exist: " + path)
                return
    except Exception:
        at.exception("exception creating path: %s" % repr(path))
        g.es_exception()
        return

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not create: read only: " + at.targetFileName)
                return
        except AttributeError: pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        at.outputFile = self.openForWrite(at.outputFileName,'wb') # bwm
        if not at.outputFile:
            at.writeError("can not create " + at.outputFileName)
    except:
        at.exception("exception creating:" + at.outputFileName)
#@-node:ekr.20041005105605.143:openFileForWritingHelper
#@-node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
#@+node:ekr.20041005105605.144:write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):

    """Write a 4.x derived file."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@-node:ekr.20041005105605.144:write
#@+node:ekr.20050506084734:writeFromString
# This is at.write specialized for scripting.

def writeFromString(self,root,s,forcePythonSentinels=True,useSentinels=True):

    """Write a 4.x derived file from a string.

    This is used by the scripting logic."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline, but don't change the focus!

    at.initWriteIvars(root,"<string-file>",
        nosentinels=not useSentinels,thinFile=False,scriptWrite=True,toString=True,
        forcePythonSentinels=forcePythonSentinels)

    try:
        at.openFileForWriting(root,at.targetFileName,toString=True)
        # Simulate writing the entire file so error recovery works.
        at.writeOpenFile(root,nosentinels=not useSentinels,toString=True,fromString=s)
        at.closeWriteFile()
        # Major bug: failure to clear this wipes out headlines!
        # Minor bug: sometimes this causes slight problems...
        if root:
            root.v.t.tnodeList = []
            root.v.t._p_changed = True
    except:
        at.exception("exception preprocessing script")

    return at.stringOutput
#@-node:ekr.20050506084734:writeFromString
#@+node:ekr.20041005105605.147:writeAll
def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):

    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    return mustAutoSave
#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.149:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False

    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@-node:ekr.20041005105605.149:<< handle v's tree >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@-node:ekr.20041005105605.147:writeAll
#@+node:ekr.20041005105605.151:writeMissing
def writeMissing(self,p,toString=False):

    at = self
    writtenFiles = False ; changedFiles = False

    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after: # Don't use iterator.
        if p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode()):
            at.targetFileName = p.anyAtFileNodeName()
            if at.targetFileName:
                at.targetFileName = g.os_path_join(self.default_directory,at.targetFileName)
                at.targetFileName = g.os_path_normpath(at.targetFileName)
                if not g.os_path_exists(at.targetFileName):
                    at.openFileForWriting(p,at.targetFileName,toString)
                    if at.outputFile:
                        << write the @file node >>
                        at.closeWriteFile()
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    if writtenFiles > 0:
        g.es("finished")
    else:
        g.es("no missing @file node in the selected tree")

    return changedFiles # So caller knows whether to do an auto-save.
#@+node:ekr.20041005105605.152:<< write the @file node >>
if p.isAtAsisFileNode():
    at.asisWrite(p)
elif p.isAtNorefFileNode():
    at.norefWrite(p)
elif p.isAtNoSentFileNode():
    at.write(p,nosentinels=True)
elif p.isAtFileNode():
    at.write(p)
else: assert(0)

writtenFiles = True

if at.fileChangedFlag: # Set by replaceTargetFileIfDifferent.
    changedFiles = True
#@-node:ekr.20041005105605.152:<< write the @file node >>
#@-node:ekr.20041005105605.151:writeMissing
#@-node:ekr.20041005105605.134:Don't override in plugins
#@+node:ekr.20041005105605.153:Override in plugins...
@

All writing eventually goes through the asisWrite or writeOpenFile methods, so
plugins should need only to override these two methods.

In particular, plugins should not need to override the write, writeAll or
writeMissing methods.
#@+node:ekr.20041005105605.154:asisWrite
def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString): return
        for p in root.self_and_subtree_iter():
            << Write p's headline if it starts with @@ >>
            << Write p's body >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)

silentWrite = asisWrite # Compatibility with old scripts.
#@+node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
s = p.headString()

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) > 0:
        s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
        at.outputFile.write(s)
#@-node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
#@+node:ekr.20041005105605.156:<< Write p's body >>
s = p.bodyString()

if self.write_strips_blank_lines:
    s = self.cleanLines(p,s)

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
#@-node:ekr.20041005105605.156:<< Write p's body >>
#@-node:ekr.20041005105605.154:asisWrite
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""

    at = self ; s = g.choose(fromString,fromString,root.v.t.bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()
#@-node:ekr.20041005105605.157:writeOpenFile
#@-node:ekr.20041005105605.153:Override in plugins...
#@-node:ekr.20041005105605.133:Writing (top level)
#@+node:ekr.20041005105605.160:Writing 4.x
#@+node:ekr.20041005105605.161:putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    at = self

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.bodyString())

    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    if self.write_strips_blank_lines:
        s = self.cleanLines(p,s)
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@+node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
@

If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if (at.sentinels or at.force_newlines_in_at_nosent_bodies) and not trailingNewlineFlag:
        # g.trace('Added newline',repr(s))
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@-node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
#@+node:ekr.20041005105605.163:<< handle line at s[i]  >>
if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    # g.trace('miscDirective')
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@-node:ekr.20041005105605.163:<< handle line at s[i]  >>
#@-node:ekr.20041005105605.161:putBody
#@+node:ekr.20041005105605.164:writing code lines...
#@+node:ekr.20041005105605.165:@all
#@+node:ekr.20041005105605.166:putAtAllLine
def putAtAllLine (self,s,i,p):

    """Put the expansion of @others."""

    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+all")
    else:
        at.putSentinel("@+all")

    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putSentinel("@-all")
    at.indent -= delta
#@-node:ekr.20041005105605.166:putAtAllLine
#@+node:ekr.20041005105605.167:putatAllBody
def putAtAllBody(self,p):

    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()

    p.v.setVisited()   # Make sure v is never expanded again.
    p.v.t.setVisited() # Use the tnode for the orphans check.
    if not at.thinFile and not s: return
    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@+node:ekr.20041005105605.168:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@-node:ekr.20041005105605.168:<< Make sure all lines end in a newline >>
#@-node:ekr.20041005105605.167:putatAllBody
#@+node:ekr.20041005105605.169:putAtAllChild
@
This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the derived
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):

    at = self

    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs > 1:
        if thisClonedSibIndex == 1:
            at.putSentinel("@clone %d" % (clonedSibs))
        else: return # Don't write second or greater trees.

    at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
    at.putAtAllBody(p) 

    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putCloseNodeSentinel(p)
#@-node:ekr.20041005105605.169:putAtAllChild
#@-node:ekr.20041005105605.165:@all
#@+node:ekr.20041005105605.170:@others
#@+node:ekr.20041005105605.171:inAtOthers
def inAtOthers(self,p):

    """Returns True if p should be included in the expansion of the at-others directive

    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False

    # Return False if this is a definition node.
    h = p.headString() ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True
#@-node:ekr.20041005105605.171:inAtOthers
#@+node:ekr.20041005105605.172:putAtOthersChild
def putAtOthersChild(self,p):

    at = self

    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs > 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")

    at.putOpenNodeSentinel(p)
    at.putBody(p) 

    # Insert expansions of all children.
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putCloseNodeSentinel(p)
#@-node:ekr.20041005105605.172:putAtOthersChild
#@+node:ekr.20041005105605.173:putAtOthersLine
def putAtOthersLine (self,s,i,p):

    """Put the expansion of @others."""

    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+others")
    else:
        at.putSentinel("@+others")

    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putSentinel("@-others")
    at.indent -= delta
#@-node:ekr.20041005105605.173:putAtOthersLine
#@-node:ekr.20041005105605.170:@others
#@+node:ekr.20041005105605.174:putCodeLine
def putCodeLine (self,s,i):

    """Put a normal code line."""

    at = self

    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # g.trace('atRaw',at.raw,'line',repr(line),g.callers(4))

    if self.write_strips_blank_lines:
        # Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)

            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)

        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
#@-node:ekr.20041005105605.174:putCodeLine
#@+node:ekr.20041005105605.175:putRefLine & allies
#@+node:ekr.20041005105605.176:putRefLine
def putRefLine(self,s,i,n1,n2,p):

    """Put a line containing one or more references."""

    at = self

    # Compute delta only once.
    delta = self.putRefAt(s,i,n1,n2,p,delta=None)
    if delta is None: return # 11/23/03

    while 1:
        i = n2 + 2
        hasRef,n1,n2 = at.findSectionName(s,i)
        if hasRef:
            self.putAfterMiddleRef(s,i,n1,delta)
            self.putRefAt(s,n1,n1,n2,p,delta)
        else:
            break

    self.putAfterLastRef(s,i,delta)
#@-node:ekr.20041005105605.176:putRefLine
#@+node:ekr.20041005105605.177:putRefAt
def putRefAt (self,s,i,n1,n2,p,delta):

    """Put a reference at s[n1:n2+2] from p."""

    at = self ; c = at.c ; name = s[n1:n2+2]

    ref = g.findReference(c,name,p)
    if not ref:
        at.writeError(
            "undefined section: %s\n\treferenced from: %s" %
                ( name,p.headString()))
        return None

    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)

    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()

    at.indent += delta

    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)

    if inBetween:
        # Bug fix: reverse the +middle sentinels, not the -middle sentinels.
        inBetween.reverse()
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)

    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)

    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)

    at.indent -= delta

    return delta
#@-node:ekr.20041005105605.177:putRefAt
#@+node:ekr.20041005105605.178:putAfterLastRef
def putAfterLastRef (self,s,start,delta):

    """Handle whatever follows the last ref of a line."""

    at = self

    j = g.skip_ws(s,start)

    if j < len(s) and s[j] != '\n':
        end = g.skip_line(s,start)
        after = s[start:end] # Ends with a newline only if the line did.
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
    else:
        # Temporarily readjust delta to make @nl look better.
        at.indent += delta
        at.putSentinel("@nl")
        at.indent -= delta
#@-node:ekr.20041005105605.178:putAfterLastRef
#@+node:ekr.20041005105605.179:putAfterMiddleef
def putAfterMiddleRef (self,s,start,end,delta):

    """Handle whatever follows a ref that is not the last ref of a line."""

    at = self

    if start < end:
        after = s[start:end]
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after) ; at.onl_sent() # Not a real newline.
        at.putSentinel("@nonl")
        at.indent -= delta
#@-node:ekr.20041005105605.179:putAfterMiddleef
#@-node:ekr.20041005105605.175:putRefLine & allies
#@-node:ekr.20041005105605.164:writing code lines...
#@+node:ekr.20041005105605.180:writing doc lines...
#@+node:ekr.20041005105605.181:putBlankDocLine
def putBlankDocLine (self):

    at = self

    at.putPending(split=False)

    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment) ; at.oblank()

    at.onl()
#@-node:ekr.20041005105605.181:putBlankDocLine
#@+node:ekr.20041005105605.182:putStartDocLine
def putStartDocLine (self,s,i,kind):

    """Write the start of a doc part."""

    at = self ; at.docKind = kind

    sentinel = g.choose(kind == at.docDirective,"@+doc","@+at")
    directive = g.choose(kind == at.docDirective,"@doc","@")

    if 0: # New code: put whatever follows the directive in the sentinel
        # Skip past the directive.
        i += len(directive)
        j = g.skip_to_end_of_line(s,i)
        follow = s[i:j]

        # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
        at.putSentinel(sentinel + follow)

        # Put the opening comment if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    else: # old code.
        # Skip past the directive.
        i += len(directive)

        # Get the trailing whitespace.
        j = g.skip_ws(s,i)
        ws = s[i:j]

        # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
        at.putSentinel(sentinel + ws)

        # Put the opening comment.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()

        # Put an @nonl sentinel if there is significant text following @doc or @.
        if not g.is_nl(s,j):
            # Doesn't work if we are using block comments.
            at.putSentinel("@nonl")
            at.putDocLine(s,j)
#@-node:ekr.20041005105605.182:putStartDocLine
#@+node:ekr.20041005105605.183:putDocLine
def putDocLine (self,s,i):

    """Handle one line of a doc part.

    Output complete lines and split long lines and queue pending lines.
    Inserted newlines are always preceded by whitespace."""

    at = self
    j = g.skip_line(s,i)
    s = s[i:j]

    if at.endSentinelComment:
        leading = at.indent
    else:
        leading = at.indent + len(at.startSentinelComment) + 1

    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    else:
        << append words to pending line, splitting the line if needed >>
#@+node:ekr.20041005105605.184:<< append words to pending line, splitting the line if needed >>
@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c

i = 0
while i < len(s):

    # Scan to the next word.
    word1 = i # Start of the current word.
    word2 = i = g.skip_ws(s,i)
    while i < len(s) and s[i] not in (' ','\t'):
        i += 1
    word3 = i = g.skip_ws(s,i)
    # g.trace(s[word1:i])

    if leading + word3 - word1 + len(''.join(at.pending)) >= at.page_width:
        if at.pending:
            # g.trace("splitting long line.")
            # Ouput the pending line, and start a new line.
            at.putPending(split=True)
            at.pending = [s[word2:word3]]
        else:
            # Output a long word on a line by itself.
            # g.trace("long word:",s[word2:word3])
            at.pending = [s[word2:word3]]
            at.putPending(split=True)
    else:
        # Append the entire word to the pending line.
        # g.trace("appending",s[word1:word3])
        at.pending.append(s[word1:word3])

# Output the remaining line: no more is left.
at.putPending(split=False)
#@-node:ekr.20041005105605.184:<< append words to pending line, splitting the line if needed >>
#@-node:ekr.20041005105605.183:putDocLine
#@+node:ekr.20041005105605.185:putEndDocLine
def putEndDocLine (self):

    """Write the conclusion of a doc part."""

    at = self

    at.putPending(split=False)

    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.

    sentinel = g.choose(at.docKind == at.docDirective,"@-doc","@-at")
    at.putSentinel(sentinel)
#@-node:ekr.20041005105605.185:putEndDocLine
#@+node:ekr.20041005105605.186:putPending
def putPending (self,split):

    """Write the pending part of a doc part.

    We retain trailing whitespace iff the split flag is True."""

    at = self ; s = ''.join(at.pending) ; at.pending = []

    # g.trace("split",s)

    # Remove trailing newline temporarily.  We'll add it back later.
    if s and s[-1] == '\n':
        s = s[:-1]

    if not split:
        s = s.rstrip()
        if not s:
            return

    at.putIndent(at.indent)

    if not at.endSentinelComment:
        at.os(at.startSentinelComment) ; at.oblank()

    at.os(s) ; at.onl()
#@-node:ekr.20041005105605.186:putPending
#@-node:ekr.20041005105605.180:writing doc lines...
#@-node:ekr.20041005105605.160:Writing 4.x
#@+node:ekr.20041005105605.187:Writing 4,x sentinels...
#@+node:ekr.20041005105605.188:nodeSentinelText 4.x
def nodeSentinelText(self,p):

    """Return the text of a @+node or @-node sentinel for p."""

    at = self ; h = p.headString()
    << remove comment delims from h if necessary >>

    if at.thinFile:
        gnx = g.app.nodeIndices.toString(p.v.t.fileIndex)
        return "%s:%s" % (gnx,h)
    else:
        return h
#@+node:ekr.20041005105605.189:<< remove comment delims from h if necessary >>
@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

start = at.startSentinelComment
end = at.endSentinelComment

if end and len(end) > 0:
    h = h.replace(start,"")
    h = h.replace(end,"")
#@-node:ekr.20041005105605.189:<< remove comment delims from h if necessary >>
#@-node:ekr.20041005105605.188:nodeSentinelText 4.x
#@+node:ekr.20041005105605.190:putLeadInSentinel 4.x
def putLeadInSentinel (self,s,i,j,delta):

    """Generate @nonl sentinels as needed to ensure a newline before a group of sentinels.

    Set at.leadingWs as needed for @+others and @+<< sentinels.

    i points at the start of a line.
    j points at @others or a section reference.
    delta is the change in at.indent that is about to happen and hasn't happened yet."""

    at = self
    at.leadingWs = "" # Set the default.
    if i == j:
        return # The @others or ref starts a line.

    k = g.skip_ws(s,i)
    if j == k:
        # Only whitespace before the @others or ref.
        at.leadingWs = s[i:j] # Remember the leading whitespace, including its spelling.
    else:
        # g.trace("indent",self.indent)
        self.putIndent(self.indent) # 1/29/04: fix bug reported by Dan Winkler.
        at.os(s[i:j]) ; at.onl_sent() # 10/21/03
        at.indent += delta # Align the @nonl with the following line.
        at.putSentinel("@nonl")
        at.indent -= delta # Let the caller set at.indent permanently.
#@-node:ekr.20041005105605.190:putLeadInSentinel 4.x
#@+node:ekr.20041005105605.191:putCloseNodeSentinel 4.x
def putCloseNodeSentinel(self,p,middle=False):

    at = self

    s = self.nodeSentinelText(p)

    if middle:
        at.putSentinel("@-middle:" + s)
    else:
        at.putSentinel("@-node:" + s)
#@-node:ekr.20041005105605.191:putCloseNodeSentinel 4.x
#@+node:ekr.20041005105605.192:putOpenLeoSentinel 4.x
def putOpenLeoSentinel(self,s):

    """Write @+leo sentinel."""

    at = self

    if not at.sentinels:
        return # Handle @nosentinelsfile.

    if at.thinFile:
        s = s + "-thin"

    encoding = at.encoding.lower()
    if encoding != "utf-8":
        # New in 4.2: encoding fields end in ",."
        s = s + "-encoding=%s,." % (encoding)

    at.putSentinel(s)
#@-node:ekr.20041005105605.192:putOpenLeoSentinel 4.x
#@+node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
def putOpenNodeSentinel(self,p,inAtAll=False,middle=False):

    """Write @+node sentinel for p."""

    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return

    # g.trace(at.thinFile,p)

    s = at.nodeSentinelText(p)

    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)

    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        # It may not exist when executing scripts.
        try:
            # Pychecker doesn't like so many references in a row...
            t = at.root.v.t
            t.tnodeList.append(p.v.t)
            t._p_changed = True
        except AttributeError:
            pass # Do nothing.  We are creating a script.
#@-node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
#@+node:ekr.20041005105605.194:putSentinel (applies cweb hack) 4.x
# This method outputs all sentinels.

def putSentinel(self,s):

    "Write a sentinel whose text is s, applying the CWEB hack if needed."

    at = self

    if not at.sentinels:
        return # Handle @file-nosent

    at.putIndent(at.indent)
    at.os(at.startSentinelComment)
    << apply the cweb hack to s >>
    at.os(s)
    if at.endSentinelComment:
        at.os(at.endSentinelComment)
    at.onl()
#@+node:ekr.20041005105605.195:<< apply the cweb hack to s >>
@ The cweb hack:

If the opening comment delim ends in '@', double all '@' signs except the first, which is "doubled" by the trailing '@' in the opening comment delimiter.
@c

start = at.startSentinelComment
if start and start[-1] == '@':
    assert(s and s[0]=='@')
    s = s.replace('@','@@')[1:]
#@-node:ekr.20041005105605.195:<< apply the cweb hack to s >>
#@-node:ekr.20041005105605.194:putSentinel (applies cweb hack) 4.x
#@-node:ekr.20041005105605.187:Writing 4,x sentinels...
#@+node:ekr.20041005105605.196:Writing 4.x utils...
#@+node:ekr.20041005105605.197:compareFiles
# This routine is needed to handle cvs stupidities.

def compareFiles (self,path1,path2,ignoreLineEndings):

    """Compare two text files ignoring line endings."""

    try:
        # Opening both files in text mode converts all line endings to '\n'.
        mode = g.choose(ignoreLineEndings,"r","rb")
        f1 = open(path1,mode)
        f2 = open(path2,mode)
        equal = f1.read() == f2.read()
        f1.close() ; f2.close()
        return equal
    except IOError:
        return False # Should never happen
#@-node:ekr.20041005105605.197:compareFiles
#@+node:ekr.20041005105605.198:directiveKind4 & test
def directiveKind4(self,s,i):

    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i >= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))

    # Rewritten 6/8/2005.
    if i+1 >= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if not s[i+1].isalpha():
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective

    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
#@+node:ekr.20050608103755:test_directiveKind4
def test_directiveKind4 (self):

    # pychecker complains about c not being used.

    at=c.atFileCommands # Self is a dummy argument.
    import leoColor
    table = [
        ('@=',0,at.noDirective),
        ('@',0,at.atDirective),
        ('@ ',0,at.atDirective),
        ('@\t',0,at.atDirective),
        ('@\n',0,at.atDirective),
        ('@all',0,at.allDirective),
        ('    @all',4,at.allDirective),
        ("@c",0,at.cDirective),
        ("@code",0,at.codeDirective),
        ("@doc",0,at.docDirective),
        ("@end_raw",0,at.endRawDirective),
        ('@others',0,at.othersDirective),
        ('    @others',4,at.othersDirective),
        ("@raw",0,at.rawDirective),
    ]
    for name in leoColor.leoKeywords:
        if name not in ('@','@all','@c','@code','@doc','@end_raw','@others','@raw',):
            table.append((name,0,at.miscDirective),)

    for s,i,expected in table:
        result = at.directiveKind4(s,i)
        assert result == expected, '%d %s result: %s expected: %s' % (
            i,repr(s),at.sentinelName(result),at.sentinelName(expected))
#@-node:ekr.20050608103755:test_directiveKind4
#@-node:ekr.20041005105605.198:directiveKind4 & test
#@+node:ekr.20041005105605.199:hasSectionName
def findSectionName(self,s,i):

    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("<<",i)
        n2 = s.find(">>",i)
    else:
        n1 = s.find("<<",i,end)
        n2 = s.find(">>",i,end)

    ok = -1 < n1 < n2

    # New in Leo 4.4.3: warn on extra brackets.
    if ok:
        for ch,j in (('<',n1+2),('>',n2+2)):
            if g.match(s,j,ch):
                line = g.get_line(s,i)
                g.es('dubious brackets in %s' % line)
                break

    return ok, n1, n2
#@-node:ekr.20041005105605.199:hasSectionName
#@+node:ekr.20041005105605.200:isSectionName
# returns (flag, end). end is the index of the character after the section name.

def isSectionName(self,s,i):

    if not g.match(s,i,"<<"):
        return False, -1
    i = g.find_on_line(s,i,">>")
    if i:
        return True, i + 2
    else:
        return False, -1
#@-node:ekr.20041005105605.200:isSectionName
#@+node:ekr.20041005105605.201:os and allies
# Note:  self.outputFile may be either a fileLikeObject or a real file.
#@+node:ekr.20041005105605.202:oblank, oblanks & otabs
def oblank(self):
    self.os(' ')

def oblanks (self,n):
    self.os(' ' * abs(n))

def otabs(self,n):
    self.os('\t' * abs(n))
#@-node:ekr.20041005105605.202:oblank, oblanks & otabs
#@+node:ekr.20041005105605.203:onl & onl_sent
def onl(self):

    """Write a newline to the output stream."""

    self.os(self.output_newline)

def onl_sent(self):

    """Write a newline to the output stream, provided we are outputting sentinels."""

    if self.sentinels:
        self.onl()
#@-node:ekr.20041005105605.203:onl & onl_sent
#@+node:ekr.20041005105605.204:os
def os (self,s):

    """Write a string to the output stream.

    All output produced by leoAtFile module goes here."""

    at = self

    if s and at.outputFile:
        try:
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            at.outputFile.write(s)
        except:
            at.exception("exception writing:" + s)
#@-node:ekr.20041005105605.204:os
#@-node:ekr.20041005105605.201:os and allies
#@+node:ekr.20041005105605.205:outputStringWithLineEndings
# Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):

    # Calling self.onl() runs afoul of queued newlines.
    self.os(s.replace('\n',self.output_newline))
#@-node:ekr.20041005105605.205:outputStringWithLineEndings
#@+node:ekr.20050506090446.1:putAtFirstLines (new in 4.3 b2)
def putAtFirstLines (self,s):

    '''Write any @firstlines from string s.
    These lines are converted to @verbatim lines,
    so the read logic simply ignores lines preceding the @+leo sentinel.'''

    at = self ; tag = "@first"

    i = 0
    while g.match(s,i,tag):
        i += len(tag)
        i = g.skip_ws(s,i)
        j = i
        i = g.skip_to_end_of_line(s,i)
        # Write @first line, whether empty or not
        line = s[j:i]
        at.os(line) ; at.onl()
        i = g.skip_nl(s,i)
#@-node:ekr.20050506090446.1:putAtFirstLines (new in 4.3 b2)
#@+node:ekr.20050506090955:putAtLastLines (new in 4.3 b2)
def putAtLastLines (self,s):

    '''Write any @last lines from string s.
    These lines are converted to @verbatim lines,
    so the read logic simply ignores lines following the @-leo sentinel.'''

    at = self ; tag = "@last"

    # Use g.splitLines to preserve trailing newlines.
    lines = g.splitLines(s)
    n = len(lines) ; j = k = n - 1

    # Scan backwards for @last directives.
    while j >= 0:
        line = lines[j]
        if g.match(line,0,tag): j -= 1
        elif not line.strip():
            j -= 1
        else: break

    # Write the @last lines.
    for line in lines[j+1:k+1]:
        if g.match(line,0,tag):
            i = len(tag) ; i = g.skip_ws(line,i)
            at.os(line[i:])
#@-node:ekr.20050506090955:putAtLastLines (new in 4.3 b2)
#@+node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
@ It is important for PHP and other situations that @first and @last directives get translated to verbatim lines that do _not_ include what follows the @first & @last directives.
@c

def putDirective(self,s,i):

    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i < len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]

    if g.match_word(s,k,"@delims"):
        << handle @delims >>
    elif g.match_word(s,k,"@language"):
        << handle @language >>
    elif g.match_word(s,k,"@comment"):
        << handle @comment >>
    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)

    i = g.skip_line(s,k)
    return i
#@+node:ekr.20041005105605.207:<< handle @delims >>
# Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j < i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j<i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")
#@-node:ekr.20041005105605.207:<< handle @delims >>
#@+node:ekr.20041005105605.208:<< handle @language >>
self.putSentinel("@" + directive)

if 0: # Bug fix: Leo 4.4.1
    # Do not scan the @language directive here!
    # These ivars have already been scanned by the init code.

    # Skip the keyword and whitespace.
    i = k + len("@language")
    i = g.skip_ws(s,i)
    j = g.skip_c_id(s,i)
    language = s[i:j]

    delim1,delim2,delim3 = g.set_delims_from_language(language)

    # g.trace(delim1,delim2,delim3)

    # Returns a tuple (single,start,end) of comment delims
    if delim1:
        self.startSentinelComment = delim1
        self.endSentinelComment = ""
    elif delim2 and delim3:
        self.startSentinelComment = delim2
        self.endSentinelComment = delim3
    else:
        line = g.get_line(s,i)
        g.es("Ignoring bad @language directive: %s" % line,color="blue")
#@-node:ekr.20041005105605.208:<< handle @language >>
#@+node:ekr.20041005105605.209:<< handle @comment >>
self.putSentinel("@" + directive)

if 0: # Bug fix: Leo 4.4.1
    # Do not scan the @comment directive here!
    # These ivars have already been scanned by the init code.

    # g.trace(delim1,delim2,delim3)

    j = g.skip_line(s,i)
    line = s[i:j]
    delim1,delim2,delim3 = g.set_delims_from_string(line)

    # Returns a tuple (single,start,end) of comment delims
    if delim1:
        self.startSentinelComment = delim1
        self.endSentinelComment = None
    elif delim2 and delim3:
        self.startSentinelComment = delim2
        self.endSentinelComment = delim3
    else:
        g.es("Ignoring bad @comment directive: %s" % line,color="blue")
#@-node:ekr.20041005105605.209:<< handle @comment >>
#@-node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
#@+node:ekr.20041005105605.210:putIndent
def putIndent(self,n):

    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w > 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
#@-node:ekr.20041005105605.210:putIndent
#@+node:ekr.20041005105605.211:putInitialComment
def putInitialComment (self):

    c = self.c
    s2 = c.config.output_initial_comment
    if s2:
        lines = string.split(s2,"\\n")
        for line in lines:
            line = line.replace("@date",time.asctime())
            if len(line)> 0:
                self.putSentinel("@comment " + line)
#@-node:ekr.20041005105605.211:putInitialComment
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):

    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.'''

    assert(self.outputFile is None)

    self.fileChangedFlag = False

    if self.toString: return self.fileChangedFlag

    if g.os_path_exists(self.targetFileName):
        if (
            << files are identical >>
        ):
            self.remove(self.outputFileName)
            g.es('%-10s %s' % ('unchanged:',self.shortFileName))
            return False
        else:
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                g.es('%-10s %s' % ('wrote:',self.shortFileName))
                self.fileChangedFlag = True
            return True # bwm
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            g.es('%-10s %s' % ('created:',self.targetFileName))
            self.fileChangedFlag = True
        return False
#@+node:ekr.20050104131343:<< files are identical >>
self.compareFiles(
    self.outputFileName,
    self.targetFileName,
    not self.explicitLineEnding)
#@-node:ekr.20050104131343:<< files are identical >>
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@+node:ekr.20041005105605.216:warnAboutOrpanAndIgnoredNodes
def warnAboutOrphandAndIgnoredNodes (self):

    # Always warn, even when language=="cweb"
    at = self ; root = at.root

    for p in root.self_and_subtree_iter():
        if not p.v.t.isVisited(): # Check tnode bit, not vnode bit.
            at.writeError("Orphan node:  " + p.headString())
            if p.hasParent():
                g.es("parent node: " + p.parent().headString(),color="blue")
            if not at.thinFile and p.isAtIgnoreNode():
                at.writeError("@ignore node: " + p.headString())

    if at.thinFile:
        p = root.copy() ; after = p.nodeAfterTree()
        while p and p != after:
            if p.isAtAllNode():
                p.moveToNodeAfterTree()
            else:
                if p.isAtIgnoreNode():
                    at.writeError("@ignore node: " + p.headString())
                p.moveToThreadNext()
#@-node:ekr.20041005105605.216:warnAboutOrpanAndIgnoredNodes
#@+node:ekr.20041005105605.217:writeError
def writeError(self,message=None):

    c = self.c

    if self.errors == 0:
        g.es_error("errors writing: " + self.targetFileName)

    self.error(message)

    self.root.setOrphan()
    self.root.setDirty()
#@-node:ekr.20041005105605.217:writeError
#@+node:ekr.20041005105605.218:writeException
def writeException (self,root=None):

    c = self.c

    g.es("exception writing:" + self.targetFileName,color="red")
    g.es_exception()

    if self.outputFile:
        self.outputFile.flush()
        self.outputFile.close()
        self.outputFile = None

    if self.outputFileName != None:
        try: # Just delete the temp file.
            os.remove(self.outputFileName)
        except:
            g.es("exception deleting:" + self.outputFileName,color="red")
            g.es_exception()

    if root:
        # Make sure we try to rewrite this file.
        root.setOrphan()
        root.setDirty()
#@-node:ekr.20041005105605.218:writeException
#@-node:ekr.20041005105605.196:Writing 4.x utils...
#@-node:ekr.20041005105605.132:Writing...
#@+node:ekr.20041005105605.219:Uilites... (atFile)
#@+node:ekr.20041005105605.220:atFile.error
def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1

    # g.trace('errors',self.errors)
#@-node:ekr.20041005105605.220:atFile.error
#@+node:ekr.20051219122720:atFile.forceGnxOnPosition
def forceGnxOnPosition (self,p):

    # g.trace(p.headString())

    self._forcedGnxPositionList.append(p.v)
#@-node:ekr.20051219122720:atFile.forceGnxOnPosition
#@+node:ekr.20050206085258:atFile.printError & test
def printError (self,message):

    '''Print an error message that may contain non-ascii characters.'''

    if self.errors == 0:
        g.es_error(message)
    else:
        try:
            print message
        except UnicodeError:
            print g.toEncodedString(message,'ascii')

def test_atFile_printError(self):

    at = c.atFileCommands
    at.errors = 0
    at.printError(
        "test of printError: Ᾱ(U+1FB9: Greek Capital Letter Alpha With Macron)")
#@-node:ekr.20050206085258:atFile.printError & test
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):

    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    __pychecker__ = '--maxlines=400'
    # g.stat()

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):

    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        g.trace()
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@+node:ekr.20041005105605.237:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.237:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20041005105605.238:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path and len(path) > 0:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = path.strip()
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@+node:ekr.20070529083836:cleanLines
def cleanLines (self,p,s):

    '''Return a copy of s, with all trailing whitespace removed.
    If a change was made, update p's body text and set c dirty.'''

    c = self.c ; cleanLines = [] ; changed = False
    lines = g.splitLines(s)
    for line in lines:
        if line.strip():
            cleanLines.append(line)
        elif line.endswith('\n'):
            cleanLines.append('\n')
            if line != '\n': changed = True
        else:
            cleanLines.append('')
            if line != '': changed = True
    s = g.joinLines(cleanLines)

    if changed:
        p.setTnodeText(s)
        c.setBodyString(p,s)
        c.setChanged(True)

    return s
#@nonl
#@-node:ekr.20070529083836:cleanLines
#@+node:ekr.20041005105605.221:exception
def exception (self,message):

    self.error(message)
    g.es_exception()
#@-node:ekr.20041005105605.221:exception
#@+node:ekr.20050104131929:file operations...
@ The difference, if any, between these methods and the corresponding g.utils_x
functions is that these methods may call self.error.
#@+node:ekr.20050104131820:chmod
def chmod (self,fileName,mode):

    # Do _not_ call self.error here.
    return g.utils_chmod(fileName,mode)
#@-node:ekr.20050104131820:chmod
#@+node:ekr.20050104131929.1:atFile.rename & test
<< about os.rename >>

def rename (self,src,dst,mode=None,verbose=True):

    '''remove dst if it exists, then rename src to dst.

    Change the mode of the renamed file if mode is given.

    Return True if all went well.'''

    c = self.c
    head,tail=g.os_path_split(dst)
    if head and len(head) > 0:
        g.makeAllNonExistentDirectories(head,c=c)

    if g.os_path_exists(dst):
        if not self.remove(dst,verbose=verbose):
            return False

    try:
        os.rename(src,dst)
        if mode != None:
            self.chmod(dst,mode)
        return True
    except Exception:
        if verbose:
            self.error("exception renaming: %s to: %s" % (
                self.outputFileName,self.targetFileName))
            g.es_exception()
        return False
#@+node:ekr.20050104131929.2:<< about os.rename >>
@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
#@-node:ekr.20050104131929.2:<< about os.rename >>
#@+node:ekr.20050107085710:test_atFile_rename
def test_atFile_rename (self):

    __pychecker__ = '--no-reimport'

    import os
    at = c.atFileCommands

    exists = g.os_path_exists
    path = g.os_path_join(g.app.testDir,'xyzzy')
    path2 = g.os_path_join(g.app.testDir,'xyzzy2')

    # Create both paths.
    for p in (path,path2):
        if exists(p):
            os.remove(p)
        assert not exists(p)
        f = file(p,'w')
        f.write('test %s' % p)
        f.close()
        assert exists(p)

    assert at.rename(path,path2,verbose=True)
    assert exists(path2)
    f = file(path2)
    s = f.read()
    f.close()
    # print 'Contents of %s: %s' % (path2,s)
    assert s == 'test %s' % path
    os.remove(path2)
    assert not exists(path)
#@-node:ekr.20050107085710:test_atFile_rename
#@-node:ekr.20050104131929.1:atFile.rename & test
#@+node:ekr.20050104132018:remove & test
def remove (self,fileName,verbose=True):

    try:
        os.remove(fileName)
        return True
    except:
        if verbose:
            self.error("exception removing: %s" % fileName)
            g.es_exception()
        return False
#@+node:ekr.20050107090156:test_atFile_remove
def test_atFile_remove(self):

    __pychecker__ = '--no-reimport'
    import os
    at = c.atFileCommands
    exists = g.os_path_exists

    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)

    assert not exists(path)
    assert not at.remove(path,verbose=False)

    f = file(path,'w')
    f.write('test')
    f.close()

    assert exists(path)
    assert at.remove(path)
    assert not exists(path)
#@-node:ekr.20050107090156:test_atFile_remove
#@-node:ekr.20050104132018:remove & test
#@+node:ekr.20050104132026:stat
def stat (self,fileName):

    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''

    # Do _not_ call self.error here.
    return g.utils_stat(fileName)
#@-node:ekr.20050104132026:stat
#@-node:ekr.20050104131929:file operations...
#@+node:ekr.20041005105605.242:scanForClonedSibs (reading & writing)
def scanForClonedSibs (self,v):

    """Scan the siblings of vnode v looking for clones of v.
    Return the number of cloned sibs and n where p is the n'th cloned sibling."""

    clonedSibs = 0 # The number of cloned siblings of p, including p.
    thisClonedSibIndex = 0 # Position of p in list of cloned siblings.

    if v and v.isCloned():
        sib = v
        while sib.back():
            sib = sib.back()
        while sib:
            if sib.t == v.t:
                clonedSibs += 1
                if sib == v:
                    thisClonedSibIndex = clonedSibs
            sib = sib.next()

    # g.trace(clonedSibs,thisClonedSibIndex)

    return clonedSibs,thisClonedSibIndex
#@-node:ekr.20041005105605.242:scanForClonedSibs (reading & writing)
#@+node:ekr.20041005105605.243:sentinelName
# Returns the name of the sentinel for warnings.

def sentinelName(self, kind):

    at = self

    sentinelNameDict = {
        at.noSentinel:    "<no sentinel>",
        at.startAt:       "@+at",     at.endAt:     "@-at",
        at.startBody:     "@+body",   at.endBody:   "@-body", # 3.x only.
        at.startDoc:      "@+doc",    at.endDoc:    "@-doc",
        at.startLeo:      "@+leo",    at.endLeo:    "@-leo",
        at.startNode:     "@+node",   at.endNode:   "@-node",
        at.startOthers:   "@+others", at.endOthers: "@-others",
        at.startAll:      "@+all",    at.endAll:    "@-all", # 4.x
        at.startMiddle:   "@+middle", at.endMiddle: "@-middle", # 4.x
        at.startAfterRef: "@afterref", # 4.x
        at.startComment:  "@comment",
        at.startDelims:   "@delims",
        at.startDirective:"@@",
        at.startNl:       "@nl",   # 4.x
        at.startNonl:     "@nonl", # 4.x
        at.startClone:    "@clone", # 4.2
        at.startRef:      "@<<",
        at.startVerbatim: "@verbatim",
        at.startVerbatimAfterRef: "@verbatimAfterRef" } # 3.x only.

    return sentinelNameDict.get(kind,"<unknown sentinel!>")
#@-node:ekr.20041005105605.243:sentinelName
#@-node:ekr.20041005105605.219:Uilites... (atFile)
#@-node:ekr.20041005105605.4:class atFile
#@-node:ekr.20041005105605.1:@thin leoAtFile.py
#@+node:ekr.20070227091955.1:@thin leoBridge.py
@first #! /usr/bin/env python

'''A module to allow full access to Leo commanders from outside Leo.'''

@language python
@tabwidth -4

<< about the leoBridge module >>

gBridgeController = None # The singleton bridge controller.

# This module must import *no* modules at the outer level!

@others
#@+node:ekr.20070227091955.2:<< about the leoBridge module >>
@nocolor
@

A **host** program is a Python program separate from Leo. Host programs may be
created by Leo, but at the time they are run host programs are not part of Leo in
any way. The leoBridge module gives host programs access to all aspects of Leo,
including all of Leo's source code, the contents of any .leo file, all
configuration settings in .leo files, etc.

Host programs will use the leoBridge module like this::
    import leoBridge
    bridge = leoBridge.controller(gui='nullGui',verbose=False)
    if bridge.isOpen():
        g = bridge.globals()
        c = bridge.openLeoFile(path)
Notes:

- The leoBridge module imports no modules at the top level.

- leoBridge.controller creates a singleton *bridge controller* that grants
access to Leo's objects, including fully initialized g and c objects. In
particular, the g.app and g.app.gui vars are fully initialized.

- By default, leoBridge.controller creates a null gui so that no Leo windows
appear on the screen.

- As shown above, the host program should gain access to Leo's leoGlobals module
using bridge.globals(). The host program should not import leoGlobals directly.

- bridge.openLeoFile(path) returns a completely standard Leo commander. Host
programs can use these commanders as described in Leo's scripting chapter.
#@nonl
#@-node:ekr.20070227091955.2:<< about the leoBridge module >>
#@+node:ekr.20070227092442:controller
def controller(gui='nullGui',verbose='True'):

    '''Create an singleton instance of a bridge controller.'''

    global gBridgeController

    if not gBridgeController:
        gBridgeController = bridgeController(gui,verbose)

    return gBridgeController
#@nonl
#@-node:ekr.20070227092442:controller
#@+node:ekr.20070227092442.2:class bridgeController
class bridgeController:

    '''Creates a way for host programs to access Leo.'''

    @others
#@+node:ekr.20070227092442.3:ctor (bridgeController)
def __init__ (self,guiName,verbose):

    self.g = None
    self.gui = None
    self.guiName = guiName
    self.mainLoop = False # True only if a non-null-gui mainloop is active.
    self.verbose = verbose

    self.initLeo()
#@nonl
#@-node:ekr.20070227092442.3:ctor (bridgeController)
#@+node:ekr.20070227092442.4:globals
def globals (self):

    '''Return a fully initialized leoGlobals module.'''

    return self.isOpen() and self.g
#@nonl
#@-node:ekr.20070227092442.4:globals
#@+node:ekr.20070227093530:initLeo & helpers
def initLeo (self):

    '''Init the Leo app to which this class gives access.
    This code is based on leo.run().'''

    if not self.isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    if not self.getLeoID(): return
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    g.app.config.readSettingsFiles(None,verbose=True)
    self.createGui() # Create the gui *before* loading plugins.
    if self.verbose: self.reportDirectories()
    self.adjustSysPath()
    g.doHook("start1") # Load plugins.
    g.init_sherlock(args=[])
    g.app.initing = False
    g.doHook("start2",c=None,p=None,v=None,fileName=None)
#@+node:ekr.20070227093629.1:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"

# NOW we can set g.
self.g = g = leoGlobals
assert(g.app)
g.app.leoID = None
#@-node:ekr.20070227093629.1:<< import leoGlobals and leoApp >>
#@+node:ekr.20070227093629.2:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()

try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@-node:ekr.20070227093629.2:<< import leoNodes and leoConfig >>
#@+node:ekr.20070302061713:adjustSysPath
def adjustSysPath (self):

    '''Adjust sys.path to enable imports as usual with Leo.'''

    import sys

    g = self.g

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','src','test')

    for theDir in leoDirs:
        path = g.os_path_abspath(
            g.os_path_join(g.app.loadDir,'..',theDir))
        if path not in sys.path:
            sys.path.append(path)
#@-node:ekr.20070302061713:adjustSysPath
#@+node:ekr.20070227095743:createGui
def createGui (self):

    g = self.g

    if self.guiName == 'nullGui':
        import leoGui
        import leoFrame
        g.app.gui = leoGui.nullGui("nullGui")
        # print 'createGui:','g.app:',id(g.app),g.app
        # print 'createGui:','g.app.gui',g.app.gui
        g.app.log = g.app.gui.log = log = leoFrame.nullLog()
        log.isNull = False
        log.enabled = True # Allow prints from nullLog.
        # g.app.writeWaitingLog()
    else:
        assert False,'leoBridge.py must run with nullGui'

    if 0: # A gui main loop is probably a bad idea.
        if self.guiName == 'tkinter':
            import leoTkinterGui
            g.app.gui = leoTkinterGui.tkinterGui()
            g.app.root = g.app.gui.createRootWindow()
            g.app.gui.finishCreate()


#@-node:ekr.20070227095743:createGui
#@+node:ekr.20070227093629.4:isValidPython
def isValidPython(self):

    import sys

    if sys.platform == 'cli':
        return True

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,'2.2.1')
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20070227093629.4:isValidPython
#@+node:ekr.20070227094232:getLeoID
def getLeoID (self):

    import os
    import sys

    g = self.g ; tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = False and not g.app.unitTesting
    << try to get leoID from sys.leoID >>
    if not g.app.leoID:
        << try to get leoID from "leoID.txt" >>
    if not g.app.leoID:
        << try to get leoID from os.getenv('USER') >>
    return g.app.leoID
#@+node:ekr.20070227094232.1:<< try to get leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose: g.es("leoID = " + g.app.leoID, color='red')
#@nonl
#@-node:ekr.20070227094232.1:<< try to get leoID from sys.leoID>>
#@+node:ekr.20070227094232.2:<< try to get leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                if verbose:
                    g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                break
            elif verbose:
                g.es("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20070227094232.2:<< try to get leoID from "leoID.txt" >>
#@+node:ekr.20070227094232.3:<< try to get leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'): %s " % (repr(theId)),color='red')
        g.app.leoID = theId

except Exception:
    pass
#@-node:ekr.20070227094232.3:<< try to get leoID from os.getenv('USER') >>
#@-node:ekr.20070227094232:getLeoID
#@+node:ekr.20070227093629.9:reportDirectories
def reportDirectories (self):

    g = self.g

    for kind,theDir in (
        ("global config",g.app.globalConfigDir),
        ("home",g.app.homeDir),
    ):
        g.es('%s dir: %s' % (kind,theDir),color="blue")
#@-node:ekr.20070227093629.9:reportDirectories
#@-node:ekr.20070227093530:initLeo & helpers
#@+node:ekr.20070227093918:isOpen
def isOpen (self):

    g = self.g

    return g and g.app and g.app.gui
#@nonl
#@-node:ekr.20070227093918:isOpen
#@+node:ekr.20070227092442.5:openLeoFile & helpers
def openLeoFile (self,fileName):

    '''Open a .leo file, or create a new Leo frame if no fileName is given.'''

    g = self.g

    if self.isOpen():
        fileName = self.completeFileName(fileName)
        c = self.createFrame(fileName)
        g.app.gui.log = log = c.frame.log
        log.isNull = False
        log.enabled = True
        # print 'createGui:','g.app:',id(g.app),g.app
        # print 'createGui:','g.app.gui',g.app.gui
        return c
    else:
        return None
#@+node:ekr.20070227093629.5:completeFileName
def completeFileName (self,fileName):

    g = self.g

    if not fileName.strip(): return ''

    import os

    fileName = g.os_path_join(os.getcwd(),fileName)
    head,ext = g.os_path_splitext(fileName)
    if not ext: fileName = fileName + ".leo"

    return fileName
#@-node:ekr.20070227093629.5:completeFileName
#@+node:ekr.20070227093629.6:createFrame
def createFrame (self,fileName):

    '''Create a commander and frame for the given file.
    Create a new frame if the fileName is empty or non-exisent.'''

    g = self.g

    if fileName.strip():
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok: return frame.c
        else: g.es("File not found %s, creating new window: " % fileName)

    # Create a new frame. Unlike leo.run, this is not a startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)
    return c
#@nonl
#@-node:ekr.20070227093629.6:createFrame
#@-node:ekr.20070227092442.5:openLeoFile & helpers
#@-node:ekr.20070227092442.2:class bridgeController
#@-node:ekr.20070227091955.1:@thin leoBridge.py
#@+node:ekr.20031218072017.2794:@thin leoColor.py
"""Syntax coloring routines for Leo."""

@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import re
import string

# php_re = re.compile("<?(\s|=|[pP][hH][pP])")
php_re = re.compile("<?(\s[pP][hH][pP])")

<< define leo keywords >>
<< define colorizer constants >>
<< define global colorizer data >>

@others
#@+node:ekr.20031218072017.1595:<< define leo keywords >>
# leoKeywords is used by directivesKind, so it should be a module-level symbol.

# leoKeywords must be a list so that plugins may alter it.

leoKeywords = [
    "@","@all","@c","@code","@color","@comment",
    "@delims","@doc","@encoding","@end_raw",
    "@first","@header","@ignore",
    "@killcolor",
    "@language","@last","@lineending",
    "@nocolor","@noheader","@nowrap","@others",
    "@pagewidth","@path","@quiet","@raw","@root","@root-code","@root-doc",
    "@silent","@tabwidth","@terse",
    "@unit","@verbose","@wrap" ]
#@-node:ekr.20031218072017.1595:<< define leo keywords >>
#@+node:ekr.20031218072017.2795:<< define colorizer constants >>
# These defaults are sure to exist.
default_colors_dict = {
    # tag name      :(     option name,           default color),
    "comment"       :("comment_color",               "red"),
    "cwebName"      :("cweb_section_name_color",     "red"),
    "pp"             :("directive_color",             "blue"),
    "docPart"        :("doc_part_color",              "red"),
    "keyword"        :("keyword_color",               "blue"),
    "leoKeyword"     :("leo_keyword_color",           "blue"),
    "link"           :("section_name_color",          "red"),
    "nameBrackets"   :("section_name_brackets_color", "blue"),
    "string"         :("string_color",                "#00aa00"), # Used by IDLE.
    "name"           :("undefined_section_name_color","red"),
    "latexBackground":("latex_background_color","white"),
}

default_font_dict = {
    # tag name       : option name
    'comment'        :'comment_font',
    'cwebName'       :'cweb_section_name_font',
    'pp'             :'directive_font',
    'docPart'        :'doc_part_font',
    'keyword'        :'keyword_font',
    'leoKeyword'     :'leo_keyword_font',
    'link'           :'section_name_font',
    'nameBrackets'   :'section_name_brackets_font',
    'string'         :'string_font',
    'name'           :'undefined_section_name_font',
    'latexBackground':'latex_background_font',
}
#@nonl
#@-node:ekr.20031218072017.2795:<< define colorizer constants >>
#@+node:EKR.20040623090054:<< define global colorizer data >>
case_insensitiveLanguages = ['plsql',]
#@-node:EKR.20040623090054:<< define global colorizer data >>
#@+node:ekr.20031218072017.2796:class colorizer
class baseColorizer:
    """The base class for Leo's syntax colorer."""
    << define colorizer keywords >>
    def interrupt(self): pass
    @others

class colorizer (baseColorizer):
    """Leo's syntax colorer class"""
    pass
#@+node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
@others

cweb_keywords = c_keywords
perlpod_keywords = perl_keywords
#@+node:ekr.20031218072017.372:actionscript keywords
actionscript_keywords = [
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
]
#@-node:ekr.20031218072017.372:actionscript keywords
#@+node:bwmulder.20041023131509:ada keywords
ada_keywords = [
    "abort",       "else",       "new",        "return",
    "abs",         "elsif",      "not",        "reverse",
    "abstract",    "end",        "null",
    "accept",      "entry",      "select",
    "access",      "exception",  "separate",
    "aliased",     "exit",       "of",         "subtype",
    "all",                       "or",
    "and",         "for",        "others",     "tagged",
    "array",       "function",   "out",        "task",
    "at",                                      "terminate",
                   "generic",    "package",    "then",
    "begin",       "goto",       "pragma",     "type",
    "body",                      "private",
                   "if",         "procedure",
    "case",        "in",         "protected",  "until",
    "constant",    "is",                       "use",
                                 "raise",
    "declare",                   "range",      "when",
    "delay",       "limited",    "record",     "while",
    "delta",       "loop",       "rem",        "with",
    "digits",                    "renames",
    "do",          "mod",        "requeue",    "xor"
   ]
#@-node:bwmulder.20041023131509:ada keywords
#@+node:ekr.20040206072057:c# keywords
csharp_keywords = [
    "abstract","as",
    "base","bool","break","byte",
    "case","catch","char","checked","class","const","continue",
    "decimal","default","delegate","do","double",
    "else","enum","event","explicit","extern",
    "false","finally","fixed","float","for","foreach",
    "get","goto",
    "if","implicit","in","int","interface","internal","is",
    "lock","long",
    "namespace","new","null",
    "object","operator","out","override",
    "params","partial","private","protected","public",
    "readonly","ref","return",
    "sbyte","sealed","set","short","sizeof","stackalloc",
    "static","string","struct","switch",
    "this","throw","true","try","typeof",
    "uint","ulong","unchecked","unsafe","ushort","using",
    "value","virtual","void","volatile",
    "where","while",
    "yield"]
#@-node:ekr.20040206072057:c# keywords
#@+node:ekr.20031218072017.373:c/c++ keywords
c_keywords = [
    # C keywords
    "auto","break","case","char","continue",
    "default","do","double","else","enum","extern",
    "float","for","goto","if","int","long","register","return",
    "short","signed","sizeof","static","struct","switch",
    "typedef","union","unsigned","void","volatile","while",
    # C++ keywords
    "asm","bool","catch","class","const","const_cast",
    "delete","dynamic_cast","explicit","false","friend",
    "inline","mutable","namespace","new","operator",
    "private","protected","public","reinterpret_cast","static_cast",
    "template","this","throw","true","try",
    "typeid","typename","using","virtual","wchar_t"]
#@-node:ekr.20031218072017.373:c/c++ keywords
#@+node:ekr.20040401103539:css keywords
css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]
#@-node:ekr.20040401103539:css keywords
#@+node:ekr.20031218072017.374:elisp keywords
# EKR: needs more work.
elisp_keywords = [
    # Maybe...
    "error","princ",
    # More typical of other lisps...
    "apply","eval",
    "t","nil",
    "and","or","not",
    "cons","car","cdr",
    "cond",
    "defconst","defun","defvar",
    "eq","ne","equal","gt","ge","lt","le",
    "if",
    "let",
    "mapcar",
    "prog","progn",
    "set","setq",
    "type-of",
    "unless",
    "when","while"]
#@-node:ekr.20031218072017.374:elisp keywords
#@+node:ekr.20041107093834:forth keywords
# Default forth keywords: extended by leo-forthwords.txt.
forth_keywords = [
    "variable", "constant", "code", "end-code",
    "dup", "2dup", "swap", "2swap", "drop", "2drop",
    "r>", ">r", "2r>", "2>r",
    "if", "else", "then",
    "begin", "again", "until", "while", "repeat",
    "v-for", "v-next", "exit",
    "meta", "host", "target", "picasm", "macro",
    "needs", "include",
    "'", "[']",
    ":", ";",
    "@", "!", ",", "1+", "+", "-",
    "<", "<=", "=", ">=", ">",
    "invert", "and", "or", 
    ]

# Forth words which define other words: extended by leo-forthdefwords.txt.
forth_definingwords = [
    ":", "variable", "constant", "code",
    ]

# Forth words which start strings: extended by leo-forthstringwords.txt.
forth_stringwords = [
    's"', '."', '"', '."',
    'abort"',
    ]

# Forth words to be rendered in boldface: extended by leo-forthboldwords.txt.
forth_boldwords = [ ]

# Forth words to be rendered in italics: extended by leo-forthitalicwords.txt.
forth_italicwords = [ ]

# Forth bold-italics words: extemded leo-forthbolditalicwords.txt if present
# Note: on some boxen, bold italics may show in plain bold.
forth_bolditalicwords = [ ]
#@-node:ekr.20041107093834:forth keywords
#@+node:ekr.20031218072017.375:html keywords
# No longer used by syntax colorer.
html_keywords = []

if 0: # Not used at present.
    unused_keywords = [
        # html constructs.
        "a","body","cf",
        "h1","h2","h3","h4","h5","h6",
        "head","html","hr",
        "i","img","li","lu","meta",
        "p","title","ul",
        # Common tags
        "caption","col","colgroup",
        "table","tbody","td","tfoot","th","thead","tr",
        "script","style"]

    html_specials = [ "<%","%>" ]
#@-node:ekr.20031218072017.375:html keywords
#@+node:ekr.20031218072017.376:java keywords
java_keywords = [
    "abstract","boolean","break","byte","byvalue",
    "case","cast","catch","char","class","const","continue",
    "default","do","double","else","extends",
    "false","final","finally","float","for","future",
    "generic","goto","if","implements","import","inner",
    "instanceof","int","interface","long","native",
    "new","null","operator","outer",
    "package","private","protected","public","rest","return",
    "short","static","super","switch","synchronized",
    "this","throw","transient","true","try",
    "var","void","volatile","while"]
#@-node:ekr.20031218072017.376:java keywords
#@+node:ekr.20031218072017.377:latex keywords
#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
    #special keyworlds
    "\\%", # 11/9/03
    "\\@", "\\(", "\\)", "\\{", "\\}",
    #A
    "\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
    "\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
    "\\appendix", 
    "\\approx", "\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
    #B
    "\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
    "\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap",
    "\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus",
    "\\bigvee", "\\bigwedge", "\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
    #C
    "\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter",
    "\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage",
    "\\cline", "\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh",
    "\\cot", "\\coth", "csc",
    #D
    "\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl",
    "\\deg", "\\Delta", 
    "\\delta", "\\depthits", "\\det", 
    "\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj",
    "\\documentclass", "\\documentstyle", 
    "\\dot", "\\dotfil", "\\downarrow",
    #E
    "\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath",
    "\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",
    "\\eta", "\\example", "\\exists", "\\exp",
    #F
    "\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote",
    "\\footnotemark", "\\fotenotesize", 
    "\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing",
    "\\frontmatter",
    #G
    "\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
    "\\guillemotright", "\\guilsinglleft", "\\guilsinglright",
    #H
    "\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
    "\\hrulefill", "\\hspace", "\\huge", "\\Huge", "\\hyphenation"
    #I
    "\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
    "\\input", "\\int", "\\iota", "\\it", "\\item", "\\itshape",
    #J
    "\\jmath", "\\Join",
    #K
    "\\k", "\\kappa", "\\ker", "\\kill",
    #L
    "\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
    "\\LaTeX", "\\LaTeXe", 
    "\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
    "\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", "\\linebreak", 
    "\\linethickness", "\\linewidth", "\\listfiles",
    "\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
    "\\Longrightarrow", "longrightarrow",
    #M
    "\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
    "\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
    "\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
    "\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
    #N
    "\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
    "\\newenvironment", "\\newfont",
    "\\newlength", "\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
    "\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
    "\\not", "\\nu", "nwarrow",
    #O
    "\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
    "\\overbrace", "\\overline",
    #P
    "\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
    "\\par", "\\parbox", "\\paragraph", "\\parindent", "\\parskip", "\\part", 
    "\\partial", "\\per", "\\Phi", "\\phi", "\\Pi", "\\pi", "\\pm", 
    "\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
    "\\providecomamnd", "\\Psi", "\\psi", "\\put",
    #Q
    "\\qbezier", "\\quoteblbase", "\\quotesinglbase",
    #R
    "\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
    "\\Re", "\\ref", "\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
    "\\Rightarrow", "\\rightarrow", "\\rm", "\\rmfamily",
    "\\Roman", "\\roman", "\\rule", 
    #S
    "\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
    "\\searrow", "\\sec", "\\section",
    "\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
    "\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
    "\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
    "\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",
    "\\sqsupset", "\\SS",
    "\\stackrel", "\\star", "\\subsection", "\\subset", 
    "\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
    #T
    "\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
    "\\tau", "\\telephone", "\\TeX", "\\textbf",
    "\\textbullet", "\\textcircled", "\\textcompworkmark", "\\textemdash", 
    "\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
    "\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
    "\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
    "\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
    "\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
    "\\Theta", "theta", 
    "\\tilde", "\\thinlines", 
    "\\thispagestyle", "\\times", "\\tiny", "\\title", "\\today", "\\totalheightits", 
    "\\triangle", "\\tt", 
    "\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
    #U
    "\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
    "\\uparrow", "\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",
    "\\usecounter", "\\usepackage", 
    #V
    "\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
    "\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", "\\vfill",
    "\\vline", "\\vphantom", "\\vspace",
    #W
    "\\widehat", "\\widetilde", "\\widthits", "\\wp",
    #X
    "\\Xi", "\\xi",
    #Z
    "\\zeta" ]
#@-node:ekr.20031218072017.377:latex keywords
#@+node:ekr.20060328110802:lua keywords
# ddm 13/02/06
lua_keywords = [
    "and", "break", "do", "else", "elseif", "end",
    "false", "for", "function", "if", "in", "local",
    "nil", "not", "or", "repeat", "return", "then",
    "true", "until", "while",
]
#@-node:ekr.20060328110802:lua keywords
#@+node:ekr.20031218072017.378:pascal keywords
pascal_keywords = [
    "and","array","as","begin",
    "case","const","class","constructor","cdecl"
    "div","do","downto","destructor","dispid","dynamic",
    "else","end","except","external",
    "false","file","for","forward","function","finally",
    "goto","if","in","is","label","library",
    "mod","message","nil","not","nodefault""of","or","on",
    "procedure","program","packed","pascal",
    "private","protected","public","published",
    "record","repeat","raise","read","register",
    "set","string","shl","shr","stdcall",
    "then","to","true","type","try","until","unit","uses",
    "var","virtual","while","with","xor"
    # object pascal
    "asm","absolute","abstract","assembler","at","automated",
    "finalization",
    "implementation","inherited","initialization","inline","interface",
    "object","override","resident","resourcestring",
    "threadvar",
    # limited contexts
    "exports","property","default","write","stored","index","name" ]
#@-node:ekr.20031218072017.378:pascal keywords
#@+node:ekr.20031218072017.379:perl keywords
perl_keywords = [
    "continue","do","else","elsif","format","for","format","for","foreach",
    "if","local","package","sub","tr","unless","until","while","y",
    # Comparison operators
    "cmp","eq","ge","gt","le","lt","ne",
    # Matching ooperators
    "m","s",
    # Unary functions
    "alarm","caller","chdir","cos","chroot","exit","eval","exp",
    "getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
    "hex","int","length","localtime","log","ord","oct",
    "require","reset","rand","rmdir","readlink",
    "scalar","sin","sleep","sqrt","srand","umask",
    # Transfer ops
    "next","last","redo","go","dump",
    # File operations...
    "select","open",
    # FL ops
    "binmode","close","closedir","eof",
    "fileno","getc","getpeername","getsockname","lstat",
    "readdir","rewinddir","stat","tell","telldir","write",
    # FL2 ops
    "bind","connect","flock","listen","opendir",
    "seekdir","shutdown","truncate",
    # FL32 ops
    "accept","pipe",
    # FL3 ops
    "fcntl","getsockopt","ioctl","read",
    "seek","send","sysread","syswrite",
    # FL4 & FL5 ops
    "recv","setsocket","socket","socketpair",
    # Array operations
    "pop","shift","split","delete",
    # FLIST ops
    "sprintf","grep","join","pack",
    # LVAL ops
    "chop","defined","study","undef",
    # f0 ops
    "endhostent","endnetent","endservent","endprotoent",
    "endpwent","endgrent","fork",
    "getgrent","gethostent","getlogin","getnetent","getppid",
    "getprotoent","getpwent","getservent",
    "setgrent","setpwent","time","times","wait","wantarray",
    # f1 ops
    "getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
    "sethostent","setnetent","setprotoent","setservent",
    # f2 ops
    "atan2","crypt",
    "gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
    "index","link","mkdir","msgget","rename",
    "semop","setpgrp","symlink","unpack","waitpid",
    # f2 or 3 ops
    "index","rindex","substr",
    # f3 ops
    "msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
    # f4 & f5 ops
    "semctl","shmread","shmwrite","msgrcv",
    # Assoc ops
    "dbmclose","each","keys","values",
    # List ops
    "chmod","chown","die","exec","kill",
    "print","printf","return","reverse",
    "sort","system","syscall","unlink","utime","warn"]
#@-node:ekr.20031218072017.379:perl keywords
#@+node:ekr.20031218072017.380:php keywords
php_keywords = [ # 08-SEP-2002 DTHEIN
    "__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
    "and", "as", "break",
    "case", "cfunction", "class", "const", "continue",
    "declare", "default", "do",
    "else", "elseif", "enddeclare", "endfor", "endforeach",
    "endif", "endswitch",  "endwhile", "eval", "extends",
    "for", "foreach", "function", "global", "if",
    "new", "old_function", "or", "static", "switch",
    "use", "var", "while", "xor" ]

# The following are supposed to be followed by ()
php_paren_keywords = [
    "array", "die", "echo", "empty", "exit",
    "include", "include_once", "isset", "list",
    "print", "require", "require_once", "return",
    "unset" ]

# The following are handled by special case code:
# "<?php", "?>"
#@-node:ekr.20031218072017.380:php keywords
#@+node:ekr.20050618052653:plsql keywords
plsql_keywords = [
# reserved keywords
"abort",
"accept",
"access",
"add",
"admin",
"after",
"all",
"allocate",
"alter",
"analyze",
"and",
"any",
"archive",
"archivelog",
"array",
"arraylen",
"as",
"asc",
"assert",
"assign",
"at",
"audit",
"authorization",
"avg",
"backup",
"base_table",
"become",
"before",
"begin",
"between",
"binary_integer",
"block",
"body",
"boolean",
"by",
"cache",
"cancel",
"cascade",
"case",
"change",
"char",
"char_base",
"character",
"check",
"checkpoint",
"close",
"cluster",
"clusters",
"cobol",
"colauth",
"column",
"columns",
"comment",
"commit",
"compile",
"compress",
"connect",
"constant",
"constraint",
"constraints",
"contents",
"continue",
"controlfile",
"count",
"crash",
"create",
"current",
"currval",
"cursor",
"cycle",
"data_base",
"database",
"datafile",
"date",
"dba",
"debugoff",
"debugon",
"dec",
"decimal",
"declare",
"default",
"definition",
"delay",
"delete",
"delta",
"desc",
"digits",
"disable",
"dismount",
"dispose",
"distinct",
"distinct",
"do",
"double",
"drop",
"drop",
"dump",
"each",
"else",
"else",
"elsif",
"enable",
"end",
"end",
"entry",
"escape",
"events",
"except",
"exception",
"exception_init",
"exceptions",
"exclusive",
"exec",
"execute",
"exists",
"exists",
"exit",
"explain",
"extent",
"externally",
"false",
"fetch",
"fetch",
"file",
"float",
"float",
"flush",
"for",
"for",
"force",
"foreign",
"form",
"fortran",
"found",
"freelist",
"freelists",
"from",
"from",
"function",
"generic",
"go",
"goto",
"grant",
"group",
"groups",
"having",
"identified",
"if",
"immediate",
"in",
"including",
"increment",
"index",
"indexes",
"indicator",
"initial",
"initrans",
"insert",
"instance",
"int",
"integer",
"intersect",
"into",
"is",
"key",
"language",
"layer",
"level",
"like",
"limited",
"link",
"lists",
"lock",
"logfile",
"long",
"loop",
"manage",
"manual",
"max",
"maxdatafiles",
"maxextents",
"maxinstances",
"maxlogfiles",
"maxloghistory",
"maxlogmembers",
"maxtrans",
"maxvalue",
"min",
"minextents",
"minus",
"minvalue",
"mlslabel",
"mod",
"mode",
"modify",
"module",
"mount",
"natural",
"new",
"new",
"next",
"nextval",
"noarchivelog",
"noaudit",
"nocache",
"nocompress",
"nocycle",
"nomaxvalue",
"nominvalue",
"none",
"noorder",
"noresetlogs",
"normal",
"nosort",
"not",
"notfound",
"nowait",
"null",
"number",
"number_base",
"numeric",
"of",
"off",
"offline",
"old",
"on",
"online",
"only",
"open",
"open",
"optimal",
"option",
"or",
"order",
"others",
"out",
"own",
"package",
"package",
"parallel",
"partition",
"pctfree",
"pctincrease",
"pctused",
"plan",
"pli",
"positive",
"pragma",
"precision",
"primary",
"prior",
"private",
"private",
"privileges",
"procedure",
"procedure",
"profile",
"public",
"quota",
"raise",
"range",
"raw",
"read",
"real",
"record",
"recover",
"references",
"referencing",
"release",
"remr",
"rename",
"resetlogs",
"resource",
"restricted",
"return",
"reuse",
"reverse",
"revoke",
"role",
"roles",
"rollback",
"row",
"rowid",
"rowlabel",
"rownum",
"rows",
"rowtype",
"run",
"savepoint",
"schema",
"scn",
"section",
"segment",
"select",
"select",
"separate",
"sequence",
"session",
"set",
"set",
"share",
"shared",
"size",
"size",
"smallint",
"smallint",
"snapshot",
"some",
"sort",
"space",
"sql",
"sqlbuf",
"sqlcode",
"sqlerrm",
"sqlerror",
"sqlstate",
"start",
"start",
"statement",
"statement_id",
"statistics",
"stddev",
"stop",
"storage",
"subtype",
"successful",
"sum",
"sum",
"switch",
"synonym",
"sysdate",
"system",
"tabauth",
"table",
"tables",
"tables",
"tablespace",
"task",
"temporary",
"terminate",
"then",
"thread",
"time",
"to",
"tracing",
"transaction",
"trigger",
"triggers",
"true",
"truncate",
"type",
"uid",
"under",
"union",
"unique",
"unlimited",
"until",
"update",
"use",
"user",
"using",
"validate",
"values",
"varchar",
"varchar2",
"variance",
"view",
"views",
"when",
"whenever",
"where",
"while",
"with",
"work",
"write",
"xor" ]
#@-node:ekr.20050618052653:plsql keywords
#@+node:ekr.20031218072017.381:python keywords
python_keywords = [
    "and",       "del",       "for",       "is",        "raise",    
    "assert",    "elif",      "from",      "lambda",    "return",   
    "break",     "else",      "global",    "not",       "try",      
    "class",     "except",    "if",        "or",        "yield",   
    "continue",  "exec",      "import",    "pass",      "while",
    "def",       "finally",   "in",        "print"]
#@-node:ekr.20031218072017.381:python keywords
#@+node:ekr.20040331145826:rapidq keywords
rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]
#@-node:ekr.20040331145826:rapidq keywords
#@+node:ekr.20031218072017.382:rebol keywords
rebol_keywords = [
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
]
#@-node:ekr.20031218072017.382:rebol keywords
#@+node:ekr.20040401111125:shell keywords
shell_keywords = [
    # reserved keywords
    "case","do","done","elif","else","esac","fi",
    "for","if","in","then",
    "until","while",
    "break","cd","chdir","continue","eval","exec",
    "exit","kill","newgrp","pwd","read","readonly",
    "return","shift","test","trap","ulimit",
    "umask","wait" ]
#@-node:ekr.20040401111125:shell keywords
#@+node:ekr.20031218072017.383:tcl/tk keywords
tcltk_keywords = [ # Only the tcl keywords are here.
    "after",     "append",    "array",
    "bgerror",   "binary",    "break",
    "catch",     "cd",        "clock",
    "close",     "concat",    "continue",
    "dde",
    "encoding",  "eof",       "eval",
    "exec",      "exit",      "expr",
    "fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
    "filename",  "flush",     "for",       "foreach",   "format",
    "gets",      "glob",      "global",
    "history",
    "if",        "incr",      "info",      "interp",
    "join",
    "lappend",   "lindex",    "linsert",   "list",      "llength",
    "load",      "lrange",    "lreplace",  "lsearch",   "lsort",
    "memory",    "msgcat",
    "namespace",
    "open",
    "package",   "parray",    "pid",
    "proc",      "puts",      "pwd",
    "read",      "regexp",    "registry",   "regsub",
    "rename",    "resource",  "return",
    "scan",      "seek",      "set",        "socket",   "source",
    "split",     "string",    "subst",      "switch",
    "tell",      "time",      "trace",
    "unknown",   "unset",     "update",     "uplevel",   "upvar",
    "variable",  "vwait",
    "while" ]
#@-node:ekr.20031218072017.383:tcl/tk keywords
#@-node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
#@+node:ekr.20031218072017.1605:color.__init__
def __init__(self,c):

    self.c = c
    self.frame = c.frame
    self.body = c.frame.body

    self.trace = c.config.getBool('trace_colorizer')

    self.count = 0 # how many times this has been called.
    self.use_hyperlinks = False # True: use hyperlinks and underline "live" links.
    self.enabled = True # True: syntax coloring enabled
    self.fonts = {}
    self.showInvisibles = False # True: show "invisible" characters.
    self.comment_string = None # Set by scanColorDirectives on @comment
    # For incremental coloring.
    self.tags = (
        "blank","comment","cwebName","docPart","keyword","leoKeyword",
        "latexModeBackground","latexModeKeyword",
        "latexBackground","latexKeyword",
        "link","name","nameBrackets","pp","string","tab",
        "elide","bold","bolditalic","italic") # new for wiki styling.
    self.color_pass = 0
    self.incremental = False
    self.redoColoring = False
    self.redoingColoring = False
    self.sel = None
    self.lines = []
    self.states = []
    self.last_flag = "unknown"
    self.last_language = "unknown"
    self.last_comment = "unknown"
    # For use of external markup routines.
    self.last_markup = "unknown" 
    self.markup_string = "unknown"
    << ivars for communication between colorizeAnyLanguage and its allies >>
    << define dispatch dicts >>
    self.setFontFromConfig()
    << extend forth words from files >>
#@+node:ekr.20031218072017.1606:<< ivars for communication between colorizeAnyLanguage and its allies >>
# Copies of arguments.
self.p = None
self.language = None
self.flag = None
self.killFlag = False
self.line_index = 0

# Others.
self.single_comment_start = None
self.block_comment_start = None
self.block_comment_end = None
self.case_sensitiveLanguage = True
self.has_string = None
self.string_delims = ("'",'"')
self.has_pp_directives = None
self.keywords = None
self.lb = None
self.rb = None
self.rootMode = None # None, "code" or "doc"

self.latex_cweb_docs     = c.config.getBool("color_cweb_doc_parts_with_latex")
self.latex_cweb_comments = c.config.getBool("color_cweb_comments_with_latex")
# print "docs,comments",self.latex_cweb_docs,self.latex_cweb_comments
#@-node:ekr.20031218072017.1606:<< ivars for communication between colorizeAnyLanguage and its allies >>
#@+node:ekr.20031218072017.1607:<< define dispatch dicts >>
self.state_dict = {
    "blockComment" : self.continueBlockComment,
    "doubleString" : self.continueDoubleString, # 1/25/03
    "nocolor"      : self.continueNocolor,
    "normal"       : self.doNormalState,
    "singleString" : self.continueSingleString,  # 1/25/03
    "string3s"     : self.continueSinglePythonString,
    "string3d"     : self.continueDoublePythonString,
    "doc"          : self.continueDocPart,
    "unknown"      : self.doNormalState, # 8/25/05
}

# Eventually all entries in these dicts will be entered dynamically
# under the control of the XML description of the present language.

if 0: # not ready yet.

    self.dict1 = { # 1-character patterns.
        '"' : self.doString,
        "'" : self.doString,
        '@' : self.doPossibleLeoKeyword,
        ' ' : self.doBlank,
        '\t': self.doTab }

    self.dict2 = {} # 2-character patterns

    # Searching this list might be very slow!
    mutli_list = [] # Multiple character patterns.

    # Enter single-character patterns...
    if self.has_pp_directives:
        dict1 ["#"] = self.doPPDirective

    for ch in string.ascii_letters:
        dict1 [ch] = self.doPossibleKeyword
    dict1 ['_'] = self.doPossibleKeyword

    if self.language == "latex":
        dict1 ['\\'] = self.doPossibleKeyword

    if self.language == "php":
        dict1 ['<'] = self.doSpecialPHPKeyword
        dict1 ['?'] = self.doSpecialPHPKeyword

    # Enter potentially multi-character patterns.  (or should this be just 2-character patterns)
    if self.language == "cweb":
        dict2 ["@("] = self.doPossibleSectionRefOrDef
    else:
        dict2 ["<<"] = self.doPossibleSectionRefOrDef

    if self.single_comment_start:
        n = len(self.single_comment_start)
        if n == 1:
            dict1 [self.single_comment_start] = self.doSingleCommentLine
        elif n == 2:
            dict2 [self.single_comment_start] = self.doSingleCommentLine
        else:
            mutli_list.append((self.single_comment_start,self.doSingleCommentLine),)

    if self.block_comment_start:
        n = len(self.block_comment_start)
        if n == 1:
            dict1 [self.block_comment_start] = self.doBlockComment
        elif n == 2:
            ddict2 [self.block_comment_start] = self.doBlockComment
        else:
            mutli_list.append((self.block_comment_start,self.doBlockComment),)
#@-node:ekr.20031218072017.1607:<< define dispatch dicts >>
#@+node:ekr.20041107094252:<< extend forth words from files >>
# Associate files with lists: probably no need to edit this.
forth_items = (
    (self.forth_definingwords, "leo-forthdefwords.txt", "defining words"),
    (self.forth_keywords, "leo-forthwords.txt", "words"),
    (self.forth_stringwords, "leo-forthstringwords.txt", "string words"),
    (self.forth_boldwords, "leo-forthboldwords.txt", "bold words"),
    (self.forth_bolditalicwords, "leo-forthbolditalicwords.txt", "bold-italic words"),
    (self.forth_italicwords, "leo-forthitalicwords.txt", "italic words"),
)

# Add entries from files (if they exist) and to the corresponding wordlists.
for (lst, path, typ) in forth_items:
    try:
        extras = []
        path = g.os_path_join(g.app.loadDir,"..","plugins",path) # EKR.
        for line in file(path).read().strip().split("\n"):
            line = line.strip()
            if line and line[0] != '\\':
                extras.append(line)
        if extras:
            if 0: # I find this annoying.  YMMV.
                if not g.app.unitTesting and not g.app.batchMode:
                    print "Found extra forth %s" % typ + ": " + " ".join(extras)
            lst.extend(extras)
    except IOError:
        # print "Not found",path
        pass
#@-node:ekr.20041107094252:<< extend forth words from files >>
#@-node:ekr.20031218072017.1605:color.__init__
#@+node:ekr.20050420083821:disable & enable
def disable (self):

    # print "disabling all syntax coloring"
    self.enabled=False

def enable (self):

    self.enabled=True
#@-node:ekr.20050420083821:disable & enable
#@+node:ekr.20041217041016:setFontFromConfig (colorizer)
def setFontFromConfig (self):

    c = self.c

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    if self.bold_font:
        self.bold_font.configure(weight="bold")

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    if self.italic_font:
        self.italic_font.configure(slant="italic",weight="normal")

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    if self.bolditalic_font:
        self.bolditalic_font.configure(weight="bold",slant="italic")

    self.color_tags_list = []
    self.image_references = []
#@-node:ekr.20041217041016:setFontFromConfig (colorizer)
#@+node:ekr.20031218072017.2801:colorize & recolor_range
# The main colorizer entry point.

def colorize(self,p,incremental=False,interruptable=True):
    # interruptable used only in new colorizer.

    # g.trace(g.callers())

    if self.enabled:
        # if self.trace: g.trace("incremental",incremental)
        self.incremental=incremental
        self.updateSyntaxColorer(p)
        return self.colorizeAnyLanguage(p)
    else:
        return "ok" # For unit testing.

# Called from incremental undo code.
# Colorizes the lines between the leading and trailing lines.

def recolor_range(self,p,leading,trailing):

    # g.trace(g.callers())

    if self.enabled:
        # if self.trace: g.trace("leading,trailing",leading,trailing)
        self.incremental=True
        self.updateSyntaxColorer(p)
        return self.colorizeAnyLanguage(p,leading=leading,trailing=trailing)
    else:
        return "ok" # For unit testing.
#@-node:ekr.20031218072017.2801:colorize & recolor_range
#@+node:ekr.20031218072017.1880:colorizeAnyLanguage & allies
def colorizeAnyLanguage (self,p,leading=None,trailing=None):

    """Color the body pane either incrementally or non-incrementally"""

    __pychecker__ = 'maxlines=500'

    # g.trace(p and p.headString())

    c = self.c ; w = self.body.bodyCtrl

    if not c.config.getBool('use_syntax_coloring'):
        # There have been reports of this trace causing crashes.
        # Certainly it is not necessary.
        # g.trace('no coloring')
        return

    if self.killFlag:
        self.removeAllTags()
        return
    try:
        << initialize ivars & tags >>
        g.doHook("init-color-markup",colorer=self,p=self.p,v=self.p)
        self.color_pass = 0
        if self.incremental and (
            << all state ivars match >> ):
            << incrementally color the text >>
        else:
            << non-incrementally color the text >>
        if self.redoColoring:
            << completely recolor in two passes >>
        << update state ivars >>
        return "ok" # for testing.
    except:
        << set state ivars to "unknown" >>
        if self.c:
            g.es_exception()
        else:
            import traceback ; traceback.print_exc()
        return "error" # for unit testing.
#@+node:ekr.20031218072017.1602:<< initialize ivars & tags >> colorizeAnyLanguage
# Add any newly-added user keywords.
for d in g.globalDirectiveList:
    name = '@' + d
    if name not in leoKeywords:
        leoKeywords.append(name)

# Copy the arguments.
self.p = p

# Get the body text, converted to unicode.
self.allBodyText = w.getAllText()
sel = w.getInsertPoint()
start,end = g.convertPythonIndexToRowCol(self.allBodyText,sel)
start += 1 # Simulate the old 1-based Tk scheme.  self.index undoes this hack.
# g.trace('new',start,end)

if self.language: self.language = self.language.lower()
# g.trace(self.count,self.p)
# g.trace(body.tag_names())

if not self.incremental:
    self.removeAllTags()
    self.removeAllImages()

self.redoColoring = False
self.redoingColoring = False

<< configure fonts >>
<< configure tags >>
<< configure language-specific settings >>

self.hyperCount = 0 # Number of hypertext tags
self.count += 1
lines = string.split(self.allBodyText,'\n')
#@nonl
#@+node:ekr.20060829084924:<< configure fonts >> (revise,maybe)
# Get the default body font.
defaultBodyfont = self.fonts.get('default_body_font')
if not defaultBodyfont:
    defaultBodyfont = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.fonts['default_body_font'] = defaultBodyfont

# Configure fonts.
w = c.frame.body.bodyCtrl
keys = default_font_dict.keys() ; keys.sort()
for key in keys:
    option_name = default_font_dict[key]
    # First, look for the language-specific setting, then the general setting.
    for name in ('%s_%s' % (self.language,option_name),(option_name)):
        font = self.fonts.get(name)
        if font:
            # g.trace('found',name,id(font))
            w.tag_config(key,font=font)
            break
        else:
            family = c.config.get(name + '_family','family')
            size   = c.config.get(name + '_size',  'size')   
            slant  = c.config.get(name + '_slant', 'slant')
            weight = c.config.get(name + '_weight','weight')
            if family or slant or weight or size:
                family = family or g.app.config.defaultFontFamily
                size   = size or c.config.defaultBodyFontSize
                slant  = slant or 'roman'
                weight = weight or 'normal'
                font = g.app.gui.getFontFromParams(family,size,slant,weight)
                # Save a reference to the font so it 'sticks'.
                self.fonts[name] = font 
                # g.trace(key,name,family,size,slant,weight,id(font))
                w.tag_config(key,font=font)
                break
    else: # Neither the general setting nor the language-specific setting exists.
        if len(self.fonts.keys()) > 1: # Restore the default font.
            # g.trace('default',key)
            w.tag_config(key,font=defaultBodyfont)
#@nonl
#@-node:ekr.20060829084924:<< configure fonts >> (revise,maybe)
#@+node:ekr.20031218072017.1603:<< configure tags >>
# g.trace('configure tags',self.body.bodyCtrl)

for name in default_colors_dict.keys(): # Python 2.1 support.
    option_name,default_color = default_colors_dict[name]
    option_color = c.config.getColor(option_name)
    color = g.choose(option_color,option_color,default_color)
    # Must use foreground, not fg.
    try:
        self.body.tag_configure(name, foreground=color)
    except: # Recover after a user error.
        self.body.tag_configure(name, foreground=default_color)

underline_undefined = c.config.getBool("underline_undefined_section_names")
use_hyperlinks      = c.config.getBool("use_hyperlinks")
self.use_hyperlinks = use_hyperlinks

# underline=var doesn't seem to work.
if 0: # use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
    self.body.tag_configure("link",underline=1) # defined
    self.body.tag_configure("name",underline=0) # undefined
else:
    self.body.tag_configure("link",underline=0)
    if underline_undefined:
        self.body.tag_configure("name",underline=1)
    else:
        self.body.tag_configure("name",underline=0)

# 8/4/02: we only create tags for whitespace when showing invisibles.
if self.showInvisibles:
    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80")):
        option_color = c.config.getColor(option_name)
        color = g.choose(option_color,option_color,default_color)
        try:
            self.body.tag_configure(name,background=color)
        except: # Recover after a user error.
            self.body.tag_configure(name,background=default_color)

# 11/15/02: Colors for latex characters.  Should be user options...

if 1: # Alas, the selection doesn't show if a background color is specified.
    self.body.tag_configure("latexModeBackground",foreground="black")
    self.body.tag_configure("latexModeKeyword",foreground="blue")
    self.body.tag_configure("latexBackground",foreground="black")
    self.body.tag_configure("latexKeyword",foreground="blue")
else: # Looks cool, and good for debugging.
    self.body.tag_configure("latexModeBackground",foreground="black",background="seashell1")
    self.body.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
    self.body.tag_configure("latexBackground",foreground="black",background="white")
    self.body.tag_configure("latexKeyword",foreground="blue",background="white")

# Tags for wiki coloring.
if self.showInvisibles:
    self.body.tag_configure("elide",background="yellow")
else:
    self.body.tag_configure("elide",elide="1")
self.body.tag_configure("bold",font=self.bold_font)
self.body.tag_configure("italic",font=self.italic_font)
self.body.tag_configure("bolditalic",font=self.bolditalic_font)
for name in self.color_tags_list:
    self.body.tag_configure(name,foreground=name)
#@-node:ekr.20031218072017.1603:<< configure tags >>
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex","lua",
    "pascal","perl","perlpod","php","plsql","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@-node:ekr.20031218072017.1602:<< initialize ivars & tags >> colorizeAnyLanguage
#@+node:ekr.20031218072017.1881:<< all state ivars match >>
self.flag == self.last_flag and
self.last_language == self.language and
self.comment_string == self.last_comment and
self.markup_string == self.last_markup
#@-node:ekr.20031218072017.1881:<< all state ivars match >>
#@+node:ekr.20031218072017.1882:<< incrementally color the text >>
@  Each line has a starting state.  The starting state for the first line is always "normal".

We need remember only self.lines and self.states between colorizing.  It is not necessary to know where the text comes from, only what the previous text was!  We must always colorize everything when changing nodes, even if all lines match, because the context may be different.

We compute the range of lines to be recolored by comparing leading lines and trailing lines of old and new text.  All other lines (the middle lines) must be colorized, as well as any trailing lines whose states may have changed as the result of changes to the middle lines.
@c

if self.trace: g.trace("incremental",self.language)

# 6/30/03: make a copies of everything
old_lines = self.lines[:]
old_states = self.states[:]
new_lines = lines[:]
new_states = []

new_len = len(new_lines)
old_len = len(old_lines)

if new_len == 0:
    self.states = []
    self.lines = []
    return

# Bug fix: 11/21/02: must test against None.
if leading != None and trailing != None:
    # print "leading,trailing:",leading,trailing
    leading_lines = leading
    trailing_lines = trailing
else:
    << compute leading, middle & trailing lines >>

middle_lines = new_len - leading_lines - trailing_lines
# print "middle lines", middle_lines

<< clear leading_lines if middle lines involve @color or @recolor  >>
<< initialize new states >>
<< colorize until the states match >>
#@+node:ekr.20031218072017.1883:<< compute leading, middle & trailing  lines >>
@ The leading lines are the leading matching lines.  The trailing lines are the trailing matching lines.  The middle lines are all other new lines.  We will color at least all the middle lines.  There may be no middle lines if we delete lines.
@c

min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading_lines = i

if leading_lines == new_len:
    # All lines match, and we must color _everything_.
    # (several routine delete, then insert the text again,
    # deleting all tags in the process).
    # print "recolor all"
    leading_lines = trailing_lines = 0
else:
    i = 0
    while i < min_len - leading_lines:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing_lines = i
#@-node:ekr.20031218072017.1883:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1884:<< clear leading_lines if middle lines involve @color or @recolor  >>
@ 11/19/02: Changing @color or @nocolor directives requires we recolor all leading states as well.
@c

if trailing_lines == 0:
    m1 = new_lines[leading_lines:]
    m2 = old_lines[leading_lines:]
else:
    m1 = new_lines[leading_lines:-trailing_lines]
    m2 = old_lines[leading_lines:-trailing_lines]
m1.extend(m2) # m1 now contains all old and new middle lines.
if m1:
    for s in m1:
        s = g.toUnicode(s,g.app.tkEncoding) # 10/28/03
        i = g.skip_ws(s,0)
        if g.match_word(s,i,"@color") or g.match_word(s,i,"@nocolor"):
            leading_lines = 0
            break
#@-node:ekr.20031218072017.1884:<< clear leading_lines if middle lines involve @color or @recolor  >>
#@+node:ekr.20031218072017.1885:<< initialize new states >>
# Copy the leading states from the old to the new lines.
i = 0
while i < leading_lines and i < old_len: # 12/8/02
    new_states.append(old_states[i])
    i += 1

# We know the starting state of the first middle line!
if middle_lines > 0 and i < old_len:
    new_states.append(old_states[i])
    i += 1

# Set the state of all other middle lines to "unknown".
first_trailing_line = max(0,new_len - trailing_lines)
while i < first_trailing_line:
    new_states.append("unknown")
    i += 1

# Copy the trailing states from the old to the new lines.
i = max(0,old_len - trailing_lines)
while i < old_len and i < len(old_states):
    new_states.append(old_states[i])
    i += 1

# 1/8/03: complete new_states by brute force.
while len(new_states) < new_len:
    new_states.append("unknown")
#@-node:ekr.20031218072017.1885:<< initialize new states >>
#@+node:ekr.20031218072017.1886:<< colorize until the states match >>
# Colorize until the states match.
# All middle lines have "unknown" state, so they will all be colored.

# Start in the state _after_ the last leading line, which may be unknown.
i = leading_lines
while i > 0:
    if i < old_len and i < new_len:
        state = new_states[i]
        # assert(state!="unknown") # This can fail.
        break
    else:
        i -= 1

if i == 0:
    # Color plain text unless we are under the control of @nocolor.
    # state = g.choose(self.flag,"normal","nocolor")
    state = self.setFirstLineState()
    new_states[0] = state

# The new_states[] will be "unknown" unless the lines match,
# so we do not need to compare lines here.
while i < new_len:
    self.line_index = i + 1
    state = self.colorizeLine(new_lines[i],state)
    i += 1
    # Set the state of the _next_ line.
    if i < new_len and state != new_states[i]:
        new_states[i] = state
    else: break

# Update the ivars
self.states = new_states
self.lines = new_lines
#@-node:ekr.20031218072017.1886:<< colorize until the states match >>
#@-node:ekr.20031218072017.1882:<< incrementally color the text >>
#@+node:ekr.20031218072017.1887:<< non-incrementally color the text >>
if self.trace: g.trace("non-incremental",self.language)

self.line_index = 1 # The Tk line number for indices, as in n.i
for s in lines:
    state = self.colorizeLine(s,state)
    self.line_index += 1
#@-node:ekr.20031218072017.1887:<< non-incrementally color the text >>
#@+node:ekr.20031218072017.1890:<< completely recolor in two passes >>
# This code is executed only if graphics characters will be inserted by user markup code.

# Pass 1:  Insert all graphics characters.

self.removeAllImages()
lines = self.allBodyText.split('\n')

self.color_pass = 1
self.line_index = 1
state = self.setFirstLineState()
for s in lines:
    state = self.colorizeLine(s,state)
    self.line_index += 1

# Pass 2: Insert one blank for each previously inserted graphic.

self.color_pass = 2
self.line_index = 1
state = self.setFirstLineState()
for s in lines:
    << kludge: insert a blank in s for every image in the line >>
    state = self.colorizeLine(s,state)
    self.line_index += 1
#@+node:ekr.20031218072017.1891:<< kludge: insert a blank in s for every image in the line >>
@ A spectacular kludge.

Images take up a real index, yet the get routine does not return any character for them!
In order to keep the colorer in synch, we must insert dummy blanks in s at the positions corresponding to each image.
@c

inserted = 0

for photo,image,line_index,i in self.image_references:
    if self.line_index == line_index:
        n = i+inserted ; inserted += 1
        s = s[:n] + ' ' + s[n:]
#@-node:ekr.20031218072017.1891:<< kludge: insert a blank in s for every image in the line >>
#@-node:ekr.20031218072017.1890:<< completely recolor in two passes >>
#@+node:ekr.20031218072017.1888:<< update state ivars >>
self.last_flag = self.flag
self.last_language = self.language
self.last_comment = self.comment_string
self.last_markup = self.markup_string
#@-node:ekr.20031218072017.1888:<< update state ivars >>
#@+node:ekr.20031218072017.1889:<< set state ivars to "unknown" >>
self.last_flag = "unknown"
self.last_language = "unknown"
self.last_comment = "unknown"
#@-node:ekr.20031218072017.1889:<< set state ivars to "unknown" >>
#@-node:ekr.20031218072017.1880:colorizeAnyLanguage & allies
#@+node:ekr.20031218072017.1892:colorizeLine & allies
def colorizeLine (self,s,state):

    # print "line,inc,state,s:",self.line_index,self.incremental,state,s

    s = g.toUnicode(s,g.app.tkEncoding) # 10/28/03

    if self.incremental:
        self.removeTagsFromLine()

    i = 0
    while i < len(s):
        self.progress = i
        func = self.state_dict[state]
        i,state = func(s,i)

    return state
#@+node:ekr.20031218072017.1618:continueBlockComment
def continueBlockComment (self,s,i):

    j = s.find(self.block_comment_end,i)

    if j == -1:
        j = len(s) # The entire line is part of the block comment.
        if self.language=="cweb":
            self.doLatexLine(s,i,j)
        else:
            if not g.doHook("color-optional-markup",
                colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
                self.tag("comment",i,j)
        return j,"blockComment" # skip the rest of the line.

    else:
        # End the block comment.
        k = len(self.block_comment_end)
        if self.language=="cweb" and self.latex_cweb_comments:
            self.doLatexLine(s,i,j)
            self.tag("comment",j,j+k)
        else:
            if not g.doHook("color-optional-markup",
                colorer=self,p=self.p,v=self.p,s=s,i=i,j=j+k,colortag="comment"):
                self.tag("comment",i,j+k)
        i = j + k
        return i,"normal"
#@-node:ekr.20031218072017.1618:continueBlockComment
#@+node:ekr.20031218072017.1893:continueSingle/DoubleString
def continueDoubleString (self,s,i):
    return self.continueString(s,i,'"',"doubleString")

def continueSingleString (self,s,i):
    return self.continueString(s,i,"'","singleString")

# Similar to skip_string.
def continueString (self,s,i,delim,continueState):
    # g.trace(delim + s[i:])
    continueFlag = g.choose(self.language in ("elisp","html"),True,False)
    j = i
    while i < len(s) and s[i] != delim:
        if s[i:] == "\\":
            i = len(s) ; continueFlag = True ; break
        elif s[i] == "\\":
            i += 2
        else:
            i += 1
    if i >= len(s):
        i = len(s)
    elif s[i] == delim:
        i += 1 ; continueFlag = False
    self.tag("string",j,i)
    state = g.choose(continueFlag,continueState,"normal")
    return i,state
#@-node:ekr.20031218072017.1893:continueSingle/DoubleString
#@+node:ekr.20031218072017.1614:continueDocPart
def continueDocPart (self,s,i):

    state = "doc"
    if self.language == "cweb":
        << handle cweb doc part >>
    else:
        << handle noweb doc part >>
    return i,state
#@+node:ekr.20031218072017.1615:<< handle cweb doc part >>
word = self.getCwebWord(s,i)
if word and len(word) > 0:
    j = i + len(word)
    if word in ("@<","@(","@c","@d","@f","@p"):
        state = "normal" # end the doc part and rescan
    else:
        # The control code does not end the doc part.
        self.tag("keyword",i,j)
        i = j
        if word in ("@^","@.","@:","@="): # Ended by "@>"
            j = s.find("@>",i)
            if j > -1:
                self.tag("cwebName",i,j)
                self.tag("nameBrackets",j,j+2)
                i = j + 2
elif g.match(s,i,self.lb):
    j = self.doNowebSecRef(s,i)
    if j == i + 2: # not a section ref.
        self.tag("docPart",i,j)
    i = j
elif self.latex_cweb_docs:
    # Everything up to the next "@" is latex colored.
    j = s.find("@",i+1)
    if j == -1: j = len(s)
    self.doLatexLine(s,i,j)
    i = j
else:
    # Everthing up to the next "@" is in the doc part.
    j = s.find("@",i+1)
    if j == -1: j = len(s)
    self.tag("docPart",i,j)
    i = j
#@-node:ekr.20031218072017.1615:<< handle cweb doc part >>
#@+node:ekr.20031218072017.1616:<< handle noweb doc part >>
if i == 0 and g.match(s,i,"<<"):
    # Possible section definition line.
    return i,"normal" # rescan the line.

if i == 0 and s[i] == '@':
    j = self.skip_id(s,i+1,chars='-')
    word = s[i:j]
    word = word.lower()
else:
    word = ""

if word in ["@c","@code","@unit","@root","@root-code","@root-doc","@color","@nocolor"]:
    # End of the doc part.
    self.body.tag_remove("docPart",self.index(i),self.index(j)) # 10/27/03
    self.tag("leoKeyword",i,j)
    state = "normal"
    if word != '@nocolor': i = j # 3/8/05: Rescan @nocolor.
else:
    # The entire line is in the doc part.
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="docPart"):
        self.tag("docPart",i,j)
    i = j # skip the rest of the line.
#@-node:ekr.20031218072017.1616:<< handle noweb doc part >>
#@-node:ekr.20031218072017.1614:continueDocPart
#@+node:ekr.20031218072017.1894:continueNocolor
def continueNocolor (self,s,i):

    if i == 0 and s[i] == '@':
        j = self.skip_id(s,i+1)
        word = s[i:j]
        word = word.lower()
    else:
        word = ""

    if word == "@color" and self.language != "plain":
        # End of the nocolor part.
        self.tag("leoKeyword",0,j)
        return i,"normal"
    else:
        # The entire line is in the nocolor part.
        # Add tags for blanks and tabs to make "Show Invisibles" work.
        for ch in s[i:]:
            if ch == ' ':
                self.tag("blank",i,i+1)
            elif ch == '\t':
                self.tag("tab",i,i+1)
            i += 1
        return i,"nocolor"
#@-node:ekr.20031218072017.1894:continueNocolor
#@+node:ekr.20031218072017.1613:continueSingle/DoublePythonString
def continueDoublePythonString (self,s,i):
    j = s.find('"""',i)
    return self.continuePythonString(s,i,j,"string3d")

def continueSinglePythonString (self,s,i):
    j = s.find("'''",i)
    return self.continuePythonString(s,i,j,"string3s")

def continuePythonString (self,s,i,j,continueState):

    if j == -1: # The entire line is part of the triple-quoted string.
        j = len(s)
        if continueState == "string3d":
            if not g.doHook("color-optional-markup",
                colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
                self.tag("string",i,j)
        else:
            self.tag("string",i,j)
        return j,continueState # skip the rest of the line.

    else: # End the string
        if continueState == "string3d":
            if not g.doHook("color-optional-markup",
                colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
                self.tag("string",i,j+3)
            else:
                self.tag("string",i,j+3)
        else:
            self.tag("string",i,j+3)
        return j+3,"normal"
#@-node:ekr.20031218072017.1613:continueSingle/DoublePythonString
#@+node:ekr.20031218072017.1620:doAtKeyword: NOT for cweb keywords
# Handles non-cweb keyword.

def doAtKeyword (self,s,i):

    j = self.skip_id(s,i+1,chars="-") # to handle @root-code, @root-doc
    word = s[i:j]
    word = word.lower()
    if i != 0 and word not in ("@others","@all"):
        word = "" # can't be a Leo keyword, even if it looks like it.

    # 7/8/02: don't color doc parts in plain text.
    if self.language != "plain" and (word == "@" or word == "@doc"):
        # at-space is a Leo keyword.
        self.tag("leoKeyword",i,j)
        k = len(s) # Everything on the line is in the doc part.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=j,j=k,colortag="docPart"):
            self.tag("docPart",j,k)
        return k,"doc"
    elif word == "@nocolor":
        # Nothing on the line is colored.
        self.tag("leoKeyword",i,j)
        return j,"nocolor"
    elif word in leoKeywords:
        self.tag("leoKeyword",i,j)
        return j,"normal"
    else:
        return j,"normal"
#@-node:ekr.20031218072017.1620:doAtKeyword: NOT for cweb keywords
#@+node:ekr.20031218072017.1895:doLatexLine
# Colorize the line from i to j.

def doLatexLine (self,s,i,j):

    while i < j:
        if g.match(s,i,"\\"):
            k = self.skip_id(s,i+1)
            word = s[i:k]
            if word in self.latex_keywords:
                self.tag("latexModeKeyword",i,k)
            i = k
        else:
            self.tag("latexModeBackground",i,i+1)
            i += 1
#@-node:ekr.20031218072017.1895:doLatexLine
#@+node:ekr.20031218072017.1896:doNormalState
def doNormalState (self,s,i):

    __pychecker__ = 'maxlines=500'

    ch = s[i] ; state = "normal"
    assert(type(ch)==type(u""))

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&<>' and self.language=="html") or
        (ch == '$' and self.language=="rapidq") or
        (self.language == 'forth' and ch in "`~!@#$%^&*()_+-={}|[];':\",./<>?")
    ):
        << handle possible keyword >>
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        << handle at keyword >>
    elif g.match(s,i,self.single_comment_start):
        << handle single-line comment >>
    elif g.match(s,i,self.block_comment_start):
        << start block comment >>
    elif ch == '%' and self.language=="cweb":
        << handle latex line >>
    elif self.language=="latex":
        << handle latex normal character >>
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        << handle string >>
    elif ch == '#' and self.has_pp_directives:
        << handle C preprocessor line >>
    elif self.language == "php" and (g.match(s,i,"<") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        << handle special php keywords >>
    elif ch == ' ':
        << handle blank >>
    elif ch == '\t':
        << handle tab >>
    else:
        << handle normal character >>

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress < i)
    return i,state
#@+node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1898:<< handle possible  keyword >>
if self.language == "latex":
    << handle possible latex keyword >>
elif self.language == "html":
    << handle possible html keyword >>
elif self.language == "forth":
    << handle possible forth keyword >>
else:
    << handle general keyword >>
i = j
#@+node:ekr.20031218072017.1899:<< handle possible latex keyword >>
if g.match(s,i,"\\"):
    if i + 1 < len(s) and s[i+1] in self.latex_special_keyword_characters:
        j = i + 2 # A special 2-character LaTex keyword.
    else:
        j = self.skip_id(s,i+1)
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.
#@-node:ekr.20031218072017.1899:<< handle possible latex keyword >>
#@+node:ekr.20031218072017.1900:<< handle possible html keyword >>
if g.match(s,i,"<!---") or g.match(s,i,"<!--"):
    if g.match(s,i,"<!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"<"):
    if g.match(s,i,"</"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/>"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,">"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
#@-node:ekr.20031218072017.1900:<< handle possible html keyword >>
#@+node:ekr.20041107093219.3:<< handle possible forth keyword >>
j = self.skip_id(s,i+1,chars="`~!@#$%^&*()-_=+[]{};:'\\\",./<>?")
word = s[i:j]

#print "word=%s" % repr(word)

if not self.case_sensitiveLanguage:
    word = word.lower()

if self.nextForthWordIsNew:
    #print "trying to bold the defined word '%s'" % word
    self.tag("bold", i, j)
    self.nextForthWordIsNew = False
else:
    if word in self.forth_definingwords:
        self.nextForthWordIsNew = True

    if word in self.forth_boldwords:
        self.tag("bold", i, j)
    elif word in self.forth_bolditalicwords:
        self.tag("bolditalic", i, j)
    elif word in self.forth_italicwords:
        self.tag("italic", i, j)
    elif word in self.forth_stringwords:
        self.tag("keyword", i, j-1)
        i = j - 1
        j, state = self.skip_string(s,j-1)
        self.tag("string",i,j)
        word = ''
    elif word in self.keywords:
        self.tag("keyword",i,j)
#@-node:ekr.20041107093219.3:<< handle possible forth keyword >>
#@+node:ekr.20031218072017.1901:<< handle general keyword >>
if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2
#@-node:ekr.20031218072017.1901:<< handle general keyword >>
#@-node:ekr.20031218072017.1898:<< handle possible  keyword >>
#@+node:ekr.20031218072017.1902:<< handle at keyword >>
if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@<"):
        << handle cweb ref or def >>
    else:
        word = self.getCwebWord(s,i)
        if word:
            << Handle cweb control word >>
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)
#@+node:ekr.20031218072017.1904:<< handle cweb ref or def >>
self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@>=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@>",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
#@-node:ekr.20031218072017.1904:<< handle cweb ref or def >>
#@+node:ekr.20031218072017.1903:<< Handle cweb control word >>
# Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@<","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@>"
    j = s.find("@>",i)
    if j > -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2
#@-node:ekr.20031218072017.1903:<< Handle cweb control word >>
#@-node:ekr.20031218072017.1902:<< handle at keyword >>
#@+node:ekr.20031218072017.1617:<< handle single-line comment >>
# print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i>0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j
#@-node:ekr.20031218072017.1617:<< handle single-line comment >>
#@+node:ekr.20031218072017.1619:<< start block comment >>
k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"
#@-node:ekr.20031218072017.1619:<< start block comment >>
#@+node:ekr.20031218072017.1905:<< handle latex line >>
self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
#@-node:ekr.20031218072017.1905:<< handle latex line >>
#@-node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1907:<< handle latex normal character >>
if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1
#@-node:ekr.20031218072017.1907:<< handle latex normal character >>
#@-node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1908:Valid when not in latex_mode
#@+node:ekr.20031218072017.1612:<< handle string >>
# g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
#@-node:ekr.20031218072017.1612:<< handle string >>
#@+node:ekr.20031218072017.1909:<< handle C preprocessor line >>
# 10/17/02: recognize comments in preprocessor lines.
j = i
while i < len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)
#@-node:ekr.20031218072017.1909:<< handle C preprocessor line >>
#@+node:ekr.20031218072017.1910:<< handle special php keywords >>
if g.match(s.lower(),i,"<?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?>"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1
#@-node:ekr.20031218072017.1910:<< handle special php keywords >>
#@+node:ekr.20031218072017.1911:<< handle blank >>
if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1
#@-node:ekr.20031218072017.1911:<< handle blank >>
#@+node:ekr.20031218072017.1912:<< handle tab >>
if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1
#@-node:ekr.20031218072017.1912:<< handle tab >>
#@+node:ekr.20031218072017.1913:<< handle normal character >>
# self.tag("normal",i,i+1)
i += 1
#@-node:ekr.20031218072017.1913:<< handle normal character >>
#@-node:ekr.20031218072017.1908:Valid when not in latex_mode
#@-node:ekr.20031218072017.1896:doNormalState
#@+node:ekr.20031218072017.1914:doNowebSecRef (colorizer)
def doNowebSecRef (self,s,i):

    c = self.c
    self.tag("nameBrackets",i,i+2)

    # See if the line contains the right name bracket.
    j = s.find(self.rb+"=",i+2)
    k = g.choose(j==-1,2,3)
    if j == -1:
        j = s.find(self.rb,i+2)
    if j == -1:
        return i + 2
    else:
        # includes brackets
        searchName = s[i:j]
        ref = g.findReference(c,searchName,self.p)
        if ref:
            self.tag("link",i+2,j)
            if self.use_hyperlinks:
                << set the hyperlink >>
        elif k == 3: # a section definition
            self.tag("link",i+2,j)
        else:
            self.tag("name",i+2,j)
        self.tag("nameBrackets",j,j+k)
        return j + k
#@nonl
#@+node:ekr.20031218072017.1915:<< set the hyperlink >>
# Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
self.body.tag_delete(tagName)
self.tag(tagName,i+2,j)

ref.tagName = tagName
self.body.tag_bind(tagName,"<Control-1>",ref.OnHyperLinkControlClick)
self.body.tag_bind(tagName,"<Any-Enter>",ref.OnHyperLinkEnter)
self.body.tag_bind(tagName,"<Any-Leave>",ref.OnHyperLinkLeave)
#@-node:ekr.20031218072017.1915:<< set the hyperlink >>
#@-node:ekr.20031218072017.1914:doNowebSecRef (colorizer)
#@+node:ekr.20031218072017.1604:removeAllTags & removeTagsFromLines
def removeAllTags (self):

    # Warning: the following DOES NOT WORK: self.body.tag_delete(self.tags)
    for tag in self.tags:
        self.body.tag_delete(tag) # 10/27/03

    for tag in self.color_tags_list:
        self.body.tag_delete(tag) # 10/27/03

def removeTagsFromLine (self):

    # print "removeTagsFromLine",self.line_index
    for tag in self.tags:
        self.body.tag_remove(tag,self.index(0),self.index("end")) # 10/27/03

    for tag in self.color_tags_list:
        self.body.tag_remove(tag,self.index(0),self.index("end")) # 10/27/03
#@-node:ekr.20031218072017.1604:removeAllTags & removeTagsFromLines
#@-node:ekr.20031218072017.1892:colorizeLine & allies
#@+node:ekr.20031218072017.1377:scanColorDirectives
def scanColorDirectives(self,p):

    """Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.
    """

    p = p.copy() ; c = self.c
    if c == None: return # self.c may be None for testing.

    if c.target_language:
        c.target_language = c.target_language.lower()
    self.language = language = c.target_language
    self.comment_string = None
    self.rootMode = None # None, "code" or "doc"

    for p in p.self_and_parents_iter():
        # g.trace(p)
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment or @language >>
        << Test for @root, @root-doc or @root-code >>

    return self.language # For use by external routines.
#@+node:ekr.20031218072017.1378:<< Test for @comment or @language >>
# 10/17/02: @comment and @language may coexist in the same node.

if theDict.has_key("comment"):
    k = theDict["comment"]
    self.comment_string = s[k:]

if theDict.has_key("language"):
    i = theDict["language"]
    language,junk,junk,junk = g.set_language(s,i)
    self.language = language

if theDict.has_key("comment") or theDict.has_key("language"):
    break
#@-node:ekr.20031218072017.1378:<< Test for @comment or @language >>
#@+node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
if theDict.has_key("root") and not self.rootMode:

    k = theDict["root"]
    if g.match_word(s,k,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,k,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@-node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
#@-node:ekr.20031218072017.1377:scanColorDirectives
#@+node:ekr.20031218072017.2802:color.schedule & idle_colorize (not used)
def schedule(self,p,incremental=0):

    __pychecker__ = '--no-argsused'
        # p not used, but it is difficult to remove.

    if self.enabled:
        self.incremental=incremental
        g.app.gui.setIdleTimeHook(self.idle_colorize)

def idle_colorize(self):

    # New in 4.3b1: make sure the colorizer still exists!
    if hasattr(self,'enabled') and self.enabled:
        p = self.c.currentPosition()
        if p:
            self.colorize(p,self.incremental)
#@-node:ekr.20031218072017.2802:color.schedule & idle_colorize (not used)
#@+node:ekr.20031218072017.2803:getCwebWord
def getCwebWord (self,s,i):

    # g.trace(g.get_line(s,i))
    if not g.match(s,i,"@"):
        return None

    ch1 = ch2 = word = None
    if i + 1 < len(s): ch1 = s[i+1]
    if i + 2 < len(s): ch2 = s[i+2]

    if g.match(s,i,"@**"):
        word = "@**"
    elif not ch1:
        word = "@"
    elif not ch2:
        word = s[i:i+2]
    elif (
        (ch1 in string.ascii_letters and not ch2 in string.ascii_letters) or # single-letter control code
        ch1 not in string.ascii_letters # non-letter control code
    ):
        word = s[i:i+2]

    # if word: g.trace(word)

    return word
#@-node:ekr.20031218072017.2803:getCwebWord
#@+node:ekr.20031218072017.1944:removeAllImages (leoColor)
def removeAllImages (self):

    for photo,image,line_index,i in self.image_references:
        try:
            ### self.body.deleteCharacter(image)
            s = self.allBodyText
            w = self.body.bodyCtrl
            index = g.convertRowColToPythonIndex(s,line_index,i)
            w.delete(index)
            self.allBodyText = w.getAllText()
        except:
            pass # The image may have been deleted earlier.

    self.image_references = []
#@-node:ekr.20031218072017.1944:removeAllImages (leoColor)
#@+node:ekr.20031218072017.2804:updateSyntaxColorer
# self.flag is True unless an unambiguous @nocolor is seen.

def updateSyntaxColorer (self,p):

    p = p.copy()
    self.flag = self.useSyntaxColoring(p)
    self.scanColorDirectives(p)
#@-node:ekr.20031218072017.2804:updateSyntaxColorer
#@+node:ekr.20031218072017.2805:useSyntaxColoring
def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    p = p.copy() ; first = p.copy()
    val = True ; self.killFlag = False
    for p in p.self_and_parents_iter():
        # g.trace(p)
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        no_color = theDict.has_key("nocolor")
        color = theDict.has_key("color")
        kill_color = theDict.has_key("killcolor")
        # A killcolor anywhere disables coloring.
        if kill_color:
            val = False ; self.killFlag = True ; break
        # A color anywhere in the target enables coloring.
        if color and p == first:
            val = True ; break
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            val = False ; break
        elif color and not no_color:
            val = True ; break

    return val
#@-node:ekr.20031218072017.2805:useSyntaxColoring
#@+node:ekr.20031218072017.2806:Utils
@ These methods are like the corresponding functions in leoGlobals.py except they issue no error messages.
#@+node:ekr.20031218072017.1609:index & tag (leoColor)
def index (self,i):

    # Short-circuit the redundant computations.
    w = self.body.bodyCtrl ; s = self.allBodyText
    return w.rowColToGuiIndex(s,self.line_index-1,i)

def tag (self,name,i,j):

    self.body.tag_add(name,self.index(i),self.index(j))
#@nonl
#@-node:ekr.20031218072017.1609:index & tag (leoColor)
#@+node:ekr.20031218072017.2807:setFirstLineState
def setFirstLineState (self):

    if self.flag:
        if self.rootMode:
            state = g.choose(self.rootMode=="code","normal","doc")
        else:
            state = "normal"
    else:
        state = "nocolor"

    return state
#@-node:ekr.20031218072017.2807:setFirstLineState
#@+node:ekr.20031218072017.2808:skip_id
def skip_id(self,s,i,chars=None):

    n = len(s)
    chars = chars and g.toUnicode(chars,encoding='ascii') or u''
    while i < n and (g.isWordChar(s[i]) or s[i] in chars):
            i += 1
    return i
#@-node:ekr.20031218072017.2808:skip_id
#@+node:ekr.20031218072017.1610:skip_python_string
def skip_python_string(self,s,i):

    delim = s[i:i+3]
    if delim == "'''" or delim == '"""':
        k = s.find(delim,i+3)
        if k == -1:
            return len(s),g.choose(delim=="'''","string3s","string3d")
        else:
            return k+3, "normal"
    else:
        return self.skip_string(s,i)
#@-node:ekr.20031218072017.1610:skip_python_string
#@+node:ekr.20031218072017.2809:skip_string
def skip_string(self,s,i):

    """Skip a string literal."""

    allow_newlines = self.language == "elisp"
    delim = s[i] ; i += 1
    continue_state = g.choose(delim=="'","singleString","doubleString")
    assert(delim == '"' or delim == "'")
    n = len(s)
    while i < n and s[i] != delim and (allow_newlines or not s[i] == '\n'): # 6/3/04: newline ends most strings.
        if s[i:] == "\\": # virtual trailing newline.
            return n,continue_state
        elif s[i] == '\\': i += 2
        else: i += 1

    if i >= n:
        return n, g.choose(allow_newlines,continue_state,"normal")
    if s[i] == delim:
        i += 1
    return i,"normal"
#@-node:ekr.20031218072017.2809:skip_string
#@-node:ekr.20031218072017.2806:Utils
#@-node:ekr.20031218072017.2796:class colorizer
#@+node:ekr.20031218072017.2218:class nullColorizer
class nullColorizer (colorizer):

    """A do-nothing colorer class"""

    @others
#@+node:ekr.20031218072017.2219:__init__
def __init__ (self,c):

    colorizer.__init__(self,c) # init the base class.

    self.c = c
    self.enabled = False
#@-node:ekr.20031218072017.2219:__init__
#@+node:ekr.20031218072017.2220:entry points
def colorize(self,p,incremental=False,interruptable=True):
    return 'ok' # Used by unit tests.

def disable(self):                          pass
def enable(self):                           pass
# def idle_colorize(self):                  pass
def recolor_range(self,p,leading,trailing): pass
def scanColorDirectives(self,p):            pass
def schedule(self,p,incremental=0):         pass
def updateSyntaxColorer (self,p):           pass
#@-node:ekr.20031218072017.2220:entry points
#@-node:ekr.20031218072017.2218:class nullColorizer
#@-node:ekr.20031218072017.2794:@thin leoColor.py
#@+node:ekr.20031218072017.2810:@thin leoCommands.py
@language python
@tabwidth -4
@pagewidth 80

### from __future__ import generators # To make the code work in Python 2.2.

__pychecker__ = '--no-constCond -- no-constant1'
    # Disable checks for constant conditionals.

<< imports >>

@others
#@+node:ekr.20040712045933:<< imports  >> (leoCommands)
import leoGlobals as g

if g.app and g.app.use_psyco:
    # print "enabled psyco classes",__file__
    try: from psyco.classes import *
    except ImportError: pass

import leoAtFile
import leoConfig
import leoEditCommands
import leoFileCommands
import leoKeys
import leoImport
import leoNodes
import leoTangle
import leoUndo

import keyword
import os
import string
import sys
import tempfile
import tabnanny # for Check Python command
import time
import tokenize # for Check Python command

try:
    # IronPython has troubles with these.
    import compiler # for Check Python command
    import parser # needed only for weird Python 2.2 parser errors.
except Exception:
    pass

subprocess = g.importExtension('subprocess',None,verbose=False)

# The following import _is_ used.
__pychecker__ = '--no-import'

import token    # for Check Python command
#@-node:ekr.20040712045933:<< imports  >> (leoCommands)
#@+node:ekr.20041118104831:class commands
class baseCommands:
    """The base class for Leo's main commander."""
    @others

class Commands (baseCommands):
    """A class that implements most of Leo's commands."""
    pass
#@+node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self

    # g.trace('Commands')

    c.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.

    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.chapterController = None
    self.frame = frame
    self.isZipped = False # May be set to True by g.openWithFileName.
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@+node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.doubleClickFlag = False
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui

# Interlock to prevent setting c.changed when switching chapters.
c.suppressHeadChanged = False

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False

# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False

# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files

# For outline navigation.
self.navPrefix = '' # Must always be a string.
self.navTime = None
#@-node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
#@-node:ekr.20040731071037:c.initIvars
#@+node:ekr.20031218072017.2814:c.__repr__ & __str__
def __repr__ (self):

    return "Commander %d: %s" % (id(self),repr(self.mFileName))

__str__ = __repr__
#@-node:ekr.20031218072017.2814:c.__repr__ & __str__
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@-node:ekr.20041130173135:c.hash
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self,initEditCommanders=True):  # New in 4.4.

    '''Finish creating the commander after frame.finishCreate.

    Important: this is the last step in the startup process.'''

    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName())

    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = g.app.gui.createKeyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if initEditCommanders: ### g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    c.frame.log.finishCreate()

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)

    c.bodyWantsFocusNow()
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):

    c = self

    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@-node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2817: doCommand
command_count = 0

def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""

    c = self ; p = c.currentPosition()
    commandName = command and command.__name__
    c.setLog()

    self.command_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_doCommand'):
        g.trace(commandName)

    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            c.inCommand = True
            val = command(event)
            c.inCommand = False
            if c and c.exists: # Be careful: the command could destroy c.
                c.k.funcReturn = val
        except:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            else:
                g.es("exception executing command")
                print "exception executing command"
                g.es_exception(c=c)
                if c and c.exists and hasattr(c,'frame'):
                    c.redraw_now()

        if c and c.exists and c.requestCloseWindow:
            g.trace('Closing window after command')
            c.requestCloseWindow = False
            g.app.closeLeoWindow(c.frame)

    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)

    return "break" # Inhibit all other handlers.
#@-node:ekr.20031218072017.2817: doCommand
#@+node:ekr.20031218072017.2582: version & signon stuff
#@+node:ekr.20040629121554:getBuildNumber
def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"
#@-node:ekr.20040629121554:getBuildNumber
#@+node:ekr.20040629121554.1:getSignOnLine (Contains hard-coded version info)
def getSignOnLine (self):
    c = self
    return "Leo 4.4.3 beta 1, build %s, May 18, 2007" % c.getBuildNumber()
#@-node:ekr.20040629121554.1:getSignOnLine (Contains hard-coded version info)
#@+node:ekr.20040629121554.2:initVersion
def initVersion (self):
    c = self
    c.ver = "$Revision$" # CVS updates this.
#@-node:ekr.20040629121554.2:initVersion
#@+node:ekr.20040629121554.3:c.signOnWithVersion
def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info

    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass

    else: version = sys.platform

    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
    g.enl()
#@-node:ekr.20040629121554.3:c.signOnWithVersion
#@-node:ekr.20031218072017.2582: version & signon stuff
#@+node:ekr.20040312090934:c.iterators
#@+node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
# New in Leo 4.4.2 (It used to be defined in terms of p.allNodes_iter.)

class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):

    c = self
    return self.allNodes_iter_class(c,copy)

all_positions_iter = allNodes_iter
#@nonl
#@+node:ekr.20060907085906.1:__init__ & __iter__ (p.allNodesIter)
def __init__(self,c,copy):

    # g.trace('c.allNodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20060907085906.1:__init__ & __iter__ (p.allNodesIter)
#@+node:ekr.20060907085906.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@-node:ekr.20060907085906.2:next
#@-node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
#@+node:EKR.20040529091232.1:c.all_tnodes_iter
def all_tnodes_iter(self):

    c = self
    for p in c.all_positions_iter():
        yield p.v.t

    # return c.rootPosition().all_tnodes_iter(all=True)
#@-node:EKR.20040529091232.1:c.all_tnodes_iter
#@+node:EKR.20040529091232.2:c.all_unique_tnodes_iter
def all_unique_tnodes_iter(self):

    c = self ; marks = {}

    for p in c.all_positions_iter():
        if not p.v.t in marks:
            marks[p.v.t] = p.v.t
            yield p.v.t
#@-node:EKR.20040529091232.2:c.all_unique_tnodes_iter
#@+node:EKR.20040529091232.3:c.all_vnodes_iter
def all_vnodes_iter(self):

    c = self
    for p in c.all_positions_iter():
        yield p.v
#@-node:EKR.20040529091232.3:c.all_vnodes_iter
#@+node:EKR.20040529091232.4:c.all_unique_vnodes_iter
def all_unique_vnodes_iter(self):

    c = self ; marks = {}
    for p in c.all_positions_iter():
        if not p.v in marks:
            marks[p.v] = p.v
            yield p.v
#@-node:EKR.20040529091232.4:c.all_unique_vnodes_iter
#@-node:ekr.20040312090934:c.iterators
#@+node:ekr.20051106040126:c.executeMinibufferCommand
def executeMinibufferCommand (self,commandName):

    c = self ; k = c.k

    func = c.commandsDict.get(commandName)

    if func:
        event = g.Bunch(c=c,char='',keysym=None,widget=c.frame.body.bodyCtrl)
        stroke = None
        k.masterCommand(event,func,stroke)
        return k.funcReturn
    else:
        g.trace('no such command: %s' % (commandName),color='red')
        return None
#@-node:ekr.20051106040126:c.executeMinibufferCommand
#@+node:ekr.20031218072017.2818:Command handlers...
#@+node:ekr.20031218072017.2819:File Menu
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:new
def new (self,event=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """

    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"

if ext[0] != ".":
    ext = "."+ext

# print "ext",ext
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None

body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed

if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):

    """Return the path to the temp file corresponding to p and ext."""

    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)

        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)

        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)

        name = g.toUnicode(name,g.app.tkEncoding)

        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))

        path = g.os_path_join(td,name)

        return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    c.beginUpdate()
    try:
        if c.mFileName != "":
            # Calls c.setChanged(False) if no error.
            c.fileCommands.save(c.mFileName)
        else:
            fileName = g.app.gui.runSaveFileDialog(
                initialfile = c.mFileName,
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
            c.bringToFront()

            if fileName:
                # Don't change mFileName until the dialog has suceeded.
                c.mFileName = g.ensure_extension(fileName, ".leo")
                c.frame.title = c.mFileName
                c.frame.setTitle(g.computeWindowTitle(c.mFileName))
                c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
                c.fileCommands.save(c.mFileName)
                c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save As",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # 7/2/02: don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            # Calls c.setChanged(False) if no error.
            c.fileCommands.saveAs(c.mFileName)
            c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
#@-node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        # set local fileName, _not_ c.mFileName
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save To",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            fileName = g.ensure_extension(fileName, ".leo")
            c.fileCommands.saveTo(fileName)
            c.updateRecentFiles(fileName)

    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.2079:Recent Files submenu & allies
#@+node:ekr.20031218072017.2080:clearRecentFiles
def clearRecentFiles (self,event=None):

    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer

    bunch = u.beforeClearRecentFiles()

    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.delete_range(recentFilesMenu,0,len(c.recentFiles))

    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.fileName())

    g.app.config.appendToRecentFiles(c.recentFiles)

    u.afterClearRecentFiles(bunch)
#@-node:ekr.20031218072017.2080:clearRecentFiles
#@+node:ekr.20031218072017.2081:openRecentFile
def openRecentFile(self,name=None):

    if not name: return

    c = self ; v = c.currentVnode()
    << Set closeFlag if the only open window is empty >>

    fileName = name
    if not g.doHook("recentfiles1",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag):
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame) # 12/12/03
            c = frame.c # Switch to the new commander so the "recentfiles2" hook doesn't crash.
            c.setLog() # Sets the log stream for g.es()

    g.doHook("recentfiles2",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag)
#@+node:ekr.20031218072017.2082:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2082:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2081:openRecentFile
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):

    """Create the RecentFiles menu.  May be called with Null fileName."""

    if g.app.unitTesting: return

    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if compareFileName == munge(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace(fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@-node:ekr.20031218072017.2079:Recent Files submenu & allies
#@+node:ekr.20031218072017.2838:Read/Write submenu
#@+node:ekr.20031218072017.2839:readOutlineOnly
def readOutlineOnly (self,event=None):

    '''Open a Leo outline from a .leo file, but do not read any derived files.'''

    fileName = g.app.gui.runOpenFileDialog(
        title="Read Outline Only",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if not fileName:
        return

    try:
        theFile = open(fileName,'r')
        c,frame = g.app.newLeoCommanderAndFrame(fileName)
        frame.deiconify()
        frame.lift()
        g.app.root.update() # Force a screen redraw immediately.
        c.fileCommands.readOutlineOnly(theFile,fileName) # closes file.
    except:
        g.es("can not open:" + fileName)
#@-node:ekr.20031218072017.2839:readOutlineOnly
#@+node:ekr.20031218072017.1839:readAtFileNodes (commands)
def readAtFileNodes (self,event=None):

    '''Read all @file nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    c.beginUpdate()
    try:
        undoData = u.beforeChangeTree(p)
        c.fileCommands.readAtFileNodes()
        u.afterChangeTree(p,'Read @file Nodes',undoData)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.1839:readAtFileNodes (commands)
#@+node:ekr.20031218072017.1809:importDerivedFile
def importDerivedFile (self,event=None):

    """Create a new outline from a 4.0 derived file."""

    c = self ; p = c.currentPosition()

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importDerivedFiles(parent=p,paths=names)
#@-node:ekr.20031218072017.1809:importDerivedFile
#@-node:ekr.20031218072017.2838:Read/Write submenu
#@+node:ekr.20031218072017.2841:Tangle submenu
#@+node:ekr.20031218072017.2842:tangleAll
def tangleAll (self,event=None):

    '''Tangle all @root nodes in the entire outline.'''

    c = self
    c.tangleCommands.tangleAll()
#@-node:ekr.20031218072017.2842:tangleAll
#@+node:ekr.20031218072017.2843:tangleMarked
def tangleMarked (self,event=None):

    '''Tangle all marked @root nodes in the entire outline.'''

    c = self
    c.tangleCommands.tangleMarked()
#@-node:ekr.20031218072017.2843:tangleMarked
#@+node:ekr.20031218072017.2844:tangle
def tangle (self,event=None):

    '''Tangle all @root nodes in the selected outline.'''

    c = self
    c.tangleCommands.tangle()
#@-node:ekr.20031218072017.2844:tangle
#@-node:ekr.20031218072017.2841:Tangle submenu
#@+node:ekr.20031218072017.2845:Untangle submenu
#@+node:ekr.20031218072017.2846:untangleAll
def untangleAll (self,event=None):

    '''Untangle all @root nodes in the entire outline.'''

    c = self
    c.tangleCommands.untangleAll()
    c.undoer.clearUndoState()
#@-node:ekr.20031218072017.2846:untangleAll
#@+node:ekr.20031218072017.2847:untangleMarked
def untangleMarked (self,event=None):

    '''Untangle all marked @root nodes in the entire outline.'''

    c = self
    c.tangleCommands.untangleMarked()
    c.undoer.clearUndoState()
#@-node:ekr.20031218072017.2847:untangleMarked
#@+node:ekr.20031218072017.2848:untangle
def untangle (self,event=None):

    '''Untangle all @root nodes in the selected outline.'''

    c = self
    c.tangleCommands.untangle()
    c.undoer.clearUndoState()
#@-node:ekr.20031218072017.2848:untangle
#@-node:ekr.20031218072017.2845:Untangle submenu
#@+node:ekr.20031218072017.2849:Import&Export submenu
#@+node:ekr.20031218072017.2850:exportHeadlines
def exportHeadlines (self,event=None):

    '''Export all headlines to an external file.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.exportHeadlines(fileName)
#@-node:ekr.20031218072017.2850:exportHeadlines
#@+node:ekr.20031218072017.2851:flattenOutline
def flattenOutline (self,event=None):

    '''Export the selected outline to an external file.
    The outline is represented in MORE format.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="flat.txt",
        title="Flatten Outline",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.flattenOutline(fileName)
#@-node:ekr.20031218072017.2851:flattenOutline
#@+node:ekr.20031218072017.2852:importAtRoot
def importAtRoot (self,event=None):

    '''Import one or more external files, creating @root trees.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @root",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        c.importCommands.importFilesCommand (names,"@root")
#@-node:ekr.20031218072017.2852:importAtRoot
#@+node:ekr.20031218072017.2853:importAtFile
def importAtFile (self,event=None):

    '''Import one or more external files, creating @file trees.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        c.importCommands.importFilesCommand(names,"@file")
#@-node:ekr.20031218072017.2853:importAtFile
#@+node:ekr.20031218072017.2854:importCWEBFiles
def importCWEBFiles (self,event=None):

    '''Import one or more external CWEB files, creating @file trees.'''

    c = self

    filetypes = [
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import CWEB Files",
        filetypes=filetypes,
        defaultextension=".w",
        multiple=True)
    c.bringToFront()

    if names:
        c.importCommands.importWebCommand(names,"cweb")
#@-node:ekr.20031218072017.2854:importCWEBFiles
#@+node:ekr.20031218072017.2855:importFlattenedOutline
def importFlattenedOutline (self,event=None):

    '''Import an external created by the flatten-outline command.'''

    c = self

    types = [("Text files","*.txt"), ("All files","*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import MORE Text",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        c.importCommands.importFlattenedOutline(names)
#@-node:ekr.20031218072017.2855:importFlattenedOutline
#@+node:ekr.20031218072017.2856:importNowebFiles
def importNowebFiles (self,event=None):

    '''Import one or more external noweb files, creating @file trees.'''

    c = self

    filetypes = [
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import Noweb Files",
        filetypes=filetypes,
        defaultextension=".nw",
        multiple=True)
    c.bringToFront()

    if names:
        c.importCommands.importWebCommand(names,"noweb")
#@-node:ekr.20031218072017.2856:importNowebFiles
#@+node:ekr.20031218072017.2857:outlineToCWEB
def outlineToCWEB (self,event=None):

    '''Export the selected outline to an external file.
    The outline is represented in CWEB format.'''

    c = self

    filetypes=[
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="cweb.w",
        title="Outline To CWEB",
        filetypes=filetypes,
        defaultextension=".w")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.outlineToWeb(fileName,"cweb")
#@-node:ekr.20031218072017.2857:outlineToCWEB
#@+node:ekr.20031218072017.2858:outlineToNoweb
def outlineToNoweb (self,event=None):

    '''Export the selected outline to an external file.
    The outline is represented in noweb format.'''

    c = self

    filetypes=[
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile=self.outlineToNowebDefaultFileName,
        title="Outline To Noweb",
        filetypes=filetypes,
        defaultextension=".nw")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.outlineToWeb(fileName,"noweb")
        c.outlineToNowebDefaultFileName = fileName
#@-node:ekr.20031218072017.2858:outlineToNoweb
#@+node:ekr.20031218072017.2859:removeSentinels
def removeSentinels (self,event=None):

    '''Import one or more files, removing any sentinels.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        c.importCommands.removeSentinelsCommand (names)
#@-node:ekr.20031218072017.2859:removeSentinels
#@+node:ekr.20031218072017.2860:weave
def weave (self,event=None):

    '''Simulate a literate-programming weave operation by writing the outline to a text file.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="weave.txt",
        title="Weave",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.weave(fileName)
#@-node:ekr.20031218072017.2860:weave
#@-node:ekr.20031218072017.2849:Import&Export submenu
#@-node:ekr.20031218072017.2819:File Menu
#@+node:ekr.20031218072017.2861:Edit Menu...
#@+node:ekr.20031218072017.2862:Edit top level
#@+node:ekr.20031218072017.2140:c.executeScript & helpers
def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                    execfile(scriptFile,d)
                else:
                    exec script in d
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
#@+node:ekr.20031218072017.2143:redirectScriptOutput
def redirectScriptOutput (self):

    c = self

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
#@-node:ekr.20031218072017.2143:redirectScriptOutput
#@+node:EKR.20040627100424:unredirectScriptOutput
def unredirectScriptOutput (self):

    c = self

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
#@-node:EKR.20040627100424:unredirectScriptOutput
#@+node:ekr.20070115135502:writeScriptFile
def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        parts = path.split('/')
        path = g.app.loadDir
        for part in parts:
            path = g.os_path_abspath(g.os_path_join(path,part))
    else:
        path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile.py'))

    # Write the file.
    try:
        f = file(path,'w')
        f.write(script)
        f.close()
    except Exception:
        path = None

    return path
#@nonl
#@-node:ekr.20070115135502:writeScriptFile
#@-node:ekr.20031218072017.2140:c.executeScript & helpers
#@+node:ekr.20031218072017.2864:goToLineNumber & allies
def goToLineNumber (self,event=None,root=None,lines=None,n=None,scriptFind=False):

    '''Place the cursor on the n'th line of a derived file or script.'''

    __pychecker__ = 'maxlines=400'

    c = self ; p = c.currentPosition() ; w = c.frame.body.bodyCtrl
    root1 = root
    if root is None:
        << set root >>
    if lines is None:
        << read the file into lines >>
    if n is None:
        << get n, the line number, from a dialog >>
    n = self.applyLineNumberMappingIfAny(n) #bwm
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n >= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        << count outline lines, setting p,n2,found >>
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root,scriptFind)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        << set p to the node given by vnodeName, etc. >>
    << select p and make it visible >>
    << put the cursor on line n2 of the body text >>
#@+node:ekr.20031218072017.2865:<< set root >>
# First look for ancestor @file node.
fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break

if fileName:
    root = p.copy()
else:
    # New in 4.2.1: assume the c.currentPosition is the root of a script.
    root = c.currentPosition()
    g.es("No ancestor @file node: using script line numbers", color="blue")
    scriptFind = True
    lines = g.getScript (c,root,useSelectedText=False)
    lines = g.splitLines(lines)
    if 0:
        for line in lines:
            print line,
#@-node:ekr.20031218072017.2865:<< set root >>
#@+node:ekr.20031218072017.2866:<< read the file into lines >>
# 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    lines=self.gotoLineNumberOpen(fileName) # bwm
except:
    g.es("not found: " + fileName)
    return
#@-node:ekr.20031218072017.2866:<< read the file into lines >>
#@+node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
n = g.app.gui.runAskOkCancelNumberDialog(c,"Enter Line Number","Line number:")
if n == -1:
    return
#@-node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
#@+node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) > 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines >= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)
#@-node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
#@+node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
if scriptFind:
    << just scan for the node name >>
elif gnx:
    << 4.2: get node from gnx >>
elif childIndex == -1:
    << 4.x: scan for the node using tnodeList and n >>
else:
    << 3.x: scan for the node with the given childIndex >>
#@+node:ekr.20041111093404:<< just scan for the node name >>
# This is safe enough because clones are not much of an issue.
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@-node:ekr.20041111093404:<< just scan for the node name >>
#@+node:EKR.20040609110138:<< 4.2: get node from gnx >>
found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@-node:EKR.20040609110138:<< 4.2: get node from gnx >>
#@+node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
# This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    g.es_print(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    << set tnodeIndex to the number of +node sentinels before line n >>
    tnodeIndex = max(0,tnodeIndex)
    << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>

if not ok:
    # Fall back to the old logic.
    << set p to the first node whose headline matches vnodeName >>
#@+node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@-node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        g.es_print(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            g.es_print(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        g.es_print(s, color = "red")
    ok = False
#@-node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    g.es_print(s, color="red")
    return
#@-node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
#@+node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex <= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@-node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
#@-node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
#@+node:ekr.20031218072017.2875:<< select p and make it visible >>
c.beginUpdate()
try:
    c.frame.tree.expandAllAncestors(p)
    c.selectVnode(p)
finally:
    c.endUpdate()
#@-node:ekr.20031218072017.2875:<< select p and make it visible >>
#@+node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
s = w.getAllText()
if found:
    ins = g.convertRowColToPythonIndex(s,n2-1,0)    
    # c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    #c.frame.body.setInsertionPointToEnd()
    ins = len(s)
    g.es("%d lines" % len(lines), color="blue")

w.setInsertPoint(ins)
c.bodyWantsFocusNow()
w.seeInsertPoint()
#@-node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
#@+node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root,scriptFind):

    """Convert a line number n to a vnode name, (child index or gnx) and line number."""

    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    << set vnodeName and (childIndex or gnx) from s >>
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,derivedFileIsThin = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line >= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i > -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i < len(s) and colons < 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 < len(s) and s[i+1].isdigit():
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()

# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
#@-node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
#@-node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
#@+node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
def skipToMatchingNodeSentinel (self,lines,n,delim):

    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta

    # g.trace(n)
    return n
#@-node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
#@-node:ekr.20031218072017.2864:goToLineNumber & allies
#@+node:bwmulder.20041231211219:gotoLineNumberOpen
def gotoLineNumberOpen(self, *args, **kw):
    """
    Hook for mod_shadow plugin.
    """
    theFile = open(*args, **kw)
    lines = theFile.readlines()
    theFile.close()
    return lines
#@-node:bwmulder.20041231211219:gotoLineNumberOpen
#@+node:bwmulder.20041231211219.1:applyLineNumberMappingIfAny
def applyLineNumberMappingIfAny(self, n):
    """
    Hook for mod_shadow plugin.
    """
    return n
#@-node:bwmulder.20041231211219.1:applyLineNumberMappingIfAny
#@+node:EKR.20040612232221:goToScriptLineNumber
def goToScriptLineNumber (self,root,script,n):

    """Go to line n of a script."""

    c = self

    # g.trace(n,root)

    lines = g.splitLines(script)
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)
#@-node:EKR.20040612232221:goToScriptLineNumber
#@+node:ekr.20031218072017.2088:fontPanel
def fontPanel (self,event=None):

    '''Open the font dialog.'''

    c = self ; frame = c.frame

    if not frame.fontPanel:
        frame.fontPanel = g.app.gui.createFontPanel(c)

    frame.fontPanel.bringToFront()
#@-node:ekr.20031218072017.2088:fontPanel
#@+node:ekr.20031218072017.2090:colorPanel
def colorPanel (self,event=None):

    '''Open the color dialog.'''

    c = self ; frame = c.frame

    if not frame.colorPanel:
        frame.colorPanel = g.app.gui.createColorPanel(c)

    frame.colorPanel.bringToFront()
#@-node:ekr.20031218072017.2090:colorPanel
#@+node:ekr.20031218072017.2883:show/hide/toggleInvisibles
def hideInvisibles (self,event=None):
    c = self ; c.showInvisiblesHelper(False)

def showInvisibles (self,event=None):
    c = self ; c.showInvisiblesHelper(True)

def toggleShowInvisibles (self,event=None):
    c = self ; colorizer = c.frame.body.getColorizer()
    val = g.choose(colorizer.showInvisibles,0,1)
    c.showInvisiblesHelper(val)

def showInvisiblesHelper (self,val):
    c = self ; frame = c.frame ; p = c.currentPosition()
    colorizer = frame.body.getColorizer()
    colorizer.showInvisibles = val

     # It is much easier to change the menu name here than in the menu updater.
    menu = frame.menu.getMenu("Edit")
    index = frame.menu.getMenuLabel(menu,g.choose(val,'Hide Invisibles','Show Invisibles'))
    if index is None:
        if val: frame.menu.setMenuLabel(menu,"Show Invisibles","Hide Invisibles")
        else:   frame.menu.setMenuLabel(menu,"Hide Invisibles","Show Invisibles")

    c.frame.body.recolor_now(p)
#@-node:ekr.20031218072017.2883:show/hide/toggleInvisibles
#@+node:ekr.20031218072017.2086:preferences
def preferences (self,event=None):

    '''Handle the preferences command.'''

    c = self
    c.openLeoSettings()
#@-node:ekr.20031218072017.2086:preferences
#@-node:ekr.20031218072017.2862:Edit top level
#@+node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20031218072017.1704:convertAllBlanks
def convertAllBlanks (self,event=None):

    '''Convert all blanks to tabs in the selected outline.'''

    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    try: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    finally:
        c.endUpdate(count > 0)
#@-node:ekr.20031218072017.1704:convertAllBlanks
#@+node:ekr.20031218072017.1705:convertAllTabs
def convertAllTabs (self,event=None):

    '''Convert all tabs to blanks in the selected outline.'''

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    try: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    finally:
        c.endUpdate(count > 0)
#@-node:ekr.20031218072017.1705:convertAllTabs
#@+node:ekr.20031218072017.1821:convertBlanks (test)
def convertBlanks (self,event=None):

    '''Convert all blanks to tabs in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Blanks'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
#@-node:ekr.20031218072017.1821:convertBlanks (test)
#@+node:ekr.20031218072017.1822:convertTabs (test)
def convertTabs (self,event=None):

    '''Convert all tabs to blanks in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
            s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Tabs'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
#@-node:ekr.20031218072017.1822:convertTabs (test)
#@+node:ekr.20031218072017.1823:createLastChildNode
def createLastChildNode (self,parent,headline,body):

    '''A helper function for the three extract commands.'''

    c = self

    if body and len(body) > 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p
#@-node:ekr.20031218072017.1823:createLastChildNode
#@+node:ekr.20031218072017.1824:dedentBody (test)
def dedentBody (self,event=None):

    '''Remove one tab's worth of indentation from all presently selected lines.'''

    c = self ; current = c.currentPosition() ; undoType='Unindent'

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = ''.join(result)
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@-node:ekr.20031218072017.1824:dedentBody (test)
#@+node:ekr.20031218072017.1706:extract (test)
def extract (self,event=None):

    '''Create child node from the elected body text, deleting all selected text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if lines:
        headline = lines[0].strip()
        del lines[0]
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = ''.join(strippedLines)
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+'\n',None,tail,undoType=undoType,oldSel=None,oldYview=oldYview)
        u.afterChangeGroup(current,undoType=undoType)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.1706:extract (test)
#@+node:ekr.20031218072017.1708:extractSection (test)
def extractSection (self,event=None):

    '''Create a section definition node from the selected body text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType='Extract Section'
    current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    << Set headline for extractSection >>
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = ''.join(strippedLines)
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType=undoType,oldSel=None,oldYview=oldYview)
        u.afterChangeGroup(current,undoType=undoType)
    finally:
        c.endUpdate()
#@+node:ekr.20031218072017.1709:<< Set headline for extractSection >>
if len(headline) < 5:
    oops = True
else:
    head1 = headline[0:2] == '<<'
    head2 = headline[0:2] == '@<'
    tail1 = headline[-2:] == '>>'
    tail2 = headline[-2:] == '@>'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
#@-node:ekr.20031218072017.1709:<< Set headline for extractSection >>
#@-node:ekr.20031218072017.1708:extractSection (test)
#@+node:ekr.20031218072017.1710:extractSectionNames (test)
def extractSectionNames(self,event=None):

    '''Create child nodes for every section reference in the selected text.
    The headline of each new child node is the section reference.
    The body of each child node is empty.'''

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                << Find the next section name >>
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setSelectionRange(oldSel)
    body.setFocus()
#@+node:ekr.20031218072017.1711:<< Find the next section name >>
head1 = string.find(s,"<<")
if head1 > -1:
    head2 = string.find(s,">>",head1)
else:
    head1 = string.find(s,"@<")
    if head1 > -1:
        head2 = string.find(s,"@>",head1)

if head1 == -1 or head2 == -1 or head1 > head2:
    name = None
else:
    name = s[head1:head2+2]
#@-node:ekr.20031218072017.1711:<< Find the next section name >>
#@-node:ekr.20031218072017.1710:extractSectionNames (test)
#@+node:ekr.20031218072017.1825:c.findBoundParagraph
def findBoundParagraph (self,event=None):

    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None

    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        << trace head_lines, ins, tail_lines >>

    # Scan backwards.
    i = len(head_lines)
    while i > 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    for line in tail_lines:
        if not line or line.isspace() or line.startswith('@'):
            break
        i += 1

    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]

    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    return head,result,tail # string, list, string
#@nonl
#@+node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es_print("head_lines: ",head_lines)
    g.es_print("ins: ",ins)
    g.es_print("tail_lines: ",tail_lines)
#@-node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
#@-node:ekr.20031218072017.1825:c.findBoundParagraph
#@+node:ekr.20031218072017.1827:c.findMatchingBracket & helper
def findMatchingBracket (self,event=None):

    '''Select the text between matching brackets.'''

    c = self ; w = c.frame.body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}<>"
    s = w.getAllText()
    ins = w.getInsertPoint()
    ch1 = 0 <= ins-1 < len(s) and s[ins-1] or ''
    ch2 = 0 <= ins   < len(s) and s[ins] or ''
    # g.trace(repr(ch1),repr(ch2),ins)

    # Prefer to match the character to the left of the cursor.
    if ch1 and ch1 in brackets:
        ch = ch1 ; index = max(0,ins-1)
    elif ch2 and ch2 in brackets:
        ch = ch2 ; index = ins
    else:
        return

    index2 = self.findMatchingBracketHelper(s,ch,index)
    # g.trace('index,index2',index,index2)
    if index2 is not None:
        if index2 < index:
            w.setSelectionRange(index2,index+1,insert=index2) # was insert=index2+1
            # g.trace('case 1',s[index2:index+1])
        else:
            w.setSelectionRange(index,index2+1,insert=min(len(s),index2+1))
            # g.trace('case2',s[index:index2+1])
        w.see(index2)
    else:
        g.es("unmatched %s" % repr(ch))
#@nonl
#@+node:ekr.20061113221414:findMatchingBracketHelper
# To do: replace comments with blanks before scanning.
# Test  unmatched())
def findMatchingBracketHelper(self,s,ch,index):

    c = self
    open_brackets  = "([{<" ; close_brackets = ")]}>"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    # g.trace('index',index,'ch',repr(ch),'brackets',brackets)
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    else:
        return None
    # g.trace('index',index,'ch',repr(ch),'match_ch',repr(match_ch))
    level = 0
    while 1:
        if forward and index >= len(s):
            # g.trace("not found")
            return None
        ch2 = 0 <= index < len(s) and s[index] or ''
        # g.trace('forward',forward,'ch2',repr(ch2),'index',index)
        if ch2 == ch:
            level += 1
        if ch2 == match_ch:
            level -= 1
            if level <= 0:
                return index
        if not forward and index <= 0:
            # g.trace("not found")
            return None
        index += g.choose(forward,1,-1)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
#@-node:ekr.20061113221414:findMatchingBracketHelper
#@-node:ekr.20031218072017.1827:c.findMatchingBracket & helper
#@+node:ekr.20031218072017.1829:getBodyLines
def getBodyLines (self,expandSelection=False):

    """Return head,lines,tail where:

    before is string containg all the lines before the selected text
    (or the text before the insert point if no selection)
    lines is a list of lines containing the selected text (or the line containing the insert point if no selection)
    after is a string all lines after the selected text
    (or the text after the insert point if no selection)"""

    c = self ; body = c.frame.body ; w = body.bodyCtrl
    oldVview = body.getYScrollPosition()

    if expandSelection:
        s = w.getAllText()
        head = tail = ''
        oldSel = 0,len(s)
        lines = g.splitLines(s) # Retain the newlines of each line.
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,s,tail = body.getSelectionLines()
        lines = g.splitLines(s) # Retain the newlines of each line.

        # Expand the selection.
        i = len(head)
        j = max(i,len(head)+len(s)-1)
        oldSel = i,j

    return head,lines,tail,oldSel,oldVview # string,list,string,tuple.
#@-node:ekr.20031218072017.1829:getBodyLines
#@+node:ekr.20031218072017.1830:indentBody (test)
def indentBody (self,event=None):

    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; current = c.currentPosition() ; undoType='Indent Region'
    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = ''.join(result)
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@-node:ekr.20031218072017.1830:indentBody (test)
#@+node:ekr.20031218072017.1831:insertBodyTime & allies (passed)
def insertBodyTime (self,event=None):

    '''Insert a time/date stamp at the cursor.'''

    c = self ; undoType = 'Insert Body Time'
    w = c.frame.body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    oldSel = c.frame.body.getSelectionRange()
    w.deleteTextSelection()
    s = self.getTime(body=True)
    i = w.getInsertPoint()
    w.insert(i,s)

    c.frame.body.onBodyChanged(undoType,oldSel=oldSel)
#@+node:ekr.20031218072017.1832:getTime & test
def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55

    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getBool("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt    = c.config.getBool("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoSettings.leo.
        s = time.strftime(default_format,time.gmtime())
    return s
#@-node:ekr.20031218072017.1832:getTime & test
#@-node:ekr.20031218072017.1831:insertBodyTime & allies (passed)
#@+node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20050312114529.1:addComments (test)
def addComments (self,event=None):

    '''Convert all selected lines in the body text to comment lines.'''

    c = self ; p = c.currentPosition()
    d = g.scanDirectives(c,p)
    d1,d2,d3 = d.get('delims') # d1 is the line delim.
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines:
        g.es('No text selected',color='blue')
        return

    d2 = d2 or '' ; d3 = d3 or ''
    if d1: openDelim,closeDelim = d1+' ',''
    else:  openDelim,closeDelim = d2+' ',d3+' '

    # Comment out non-blank lines.
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line,0)
            result.append(line[0:i]+openDelim+line[i:]+closeDelim)
        else:
            result.append(line)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Add Comments',oldSel=None,oldYview=oldYview)
#@-node:ekr.20050312114529.1:addComments (test)
#@+node:ekr.20050312114529.2:deleteComments (test)
def deleteComments (self,event=None):

    '''Remove one level of comment delimiters from all selected lines in the body text.'''

    c = self ; p = c.currentPosition()
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return

    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Delete Comments',oldSel=None,oldYview=oldYview)
#@-node:ekr.20050312114529.2:deleteComments (test)
#@-node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20031218072017.1833:reformatParagraph
def reformatParagraph (self,event=None):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body ; w = body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    << compute vars for reformatParagraph >>
    if lines:
        << compute the leading whitespace >>
        << compute the result of wrapping all lines >>
        << update the body, selection & undo state >>
#@nonl
#@+node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = w.getAllText()
oldSel =  w.getSelectionRange()
oldYview = body.getYScrollPosition()

head,lines,tail = c.findBoundParagraph()
#@-node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
#@+node:ekr.20031218072017.1835:<< compute the leading whitespace >>
indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i < len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)

indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
#@-node:ekr.20031218072017.1835:<< compute the leading whitespace >>
#@+node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
trailingNL = lines and lines[-1].endswith('\n')
lines = [g.choose(z.endswith('\n'),z[:-1],z) for z in lines]

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult)
if trailingNL: result = result + '\n'
#@nonl
#@-node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
#@+node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
junk, ins = body.setSelectionAreas(head,result,tail)

# Advance to the next paragraph.
s = w.getAllText()
ins += 1 # Move past the selection.
while ins < len(s):
    i,j = g.getLine(s,ins)
    line = s[i:j]
    if line.startswith('@') or line.isspace():
        ins = j+1
    else:
        ins = i ; break

changed = original != head + result + tail
if changed:
    undoType = g.choose(changed,"Reformat Paragraph",None)
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

w.setSelectionRange(ins,ins,insert=ins)
w.see(ins)
if changed:
    c.recolor()
#@-node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
#@-node:ekr.20031218072017.1833:reformatParagraph
#@+node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview):

    c = self ; body = c.frame.body ; p = c.currentPosition()

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    # Expand the selection.
    head = head or ''
    middle = middle or ''
    tail = tail or ''
    i = len(head)
    j = max(i,len(head)+len(middle)-1)
    newSel = i,j
    body.setSelectionRange(newSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel or newSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.seeInsertPoint()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
#@-node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
#@-node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20031218072017.2885:Edit Headline submenu
#@+node:ekr.20031218072017.2886:c.editHeadline
def editHeadline (self,event=None):

    '''Begin editing the headline of the selected node.'''

    c = self ; k = c.k ; tree = c.frame.tree

    if g.app.batchMode:
        c.notValidInBatchMode("Edit Headline")
        return

    if k:
        k.setDefaultUnboundKeyAction()
        k.showStateAndMode()

    tree.editLabel(c.currentPosition())
#@-node:ekr.20031218072017.2886:c.editHeadline
#@+node:ekr.20031218072017.2290:toggleAngleBrackets
def toggleAngleBrackets (self,event=None):

    '''Add or remove double angle brackets from the headline of the selected node.'''

    c = self ; v = c.currentVnode()

    if g.app.batchMode:
        c.notValidInBatchMode("Toggle Angle Brackets")
        return

    c.endEditing()

    s = v.headString().strip()
    if (s[0:2] == "<<"
        or s[-2:] == ">>"): # Must be on separate line.
        if s[0:2] == "<<": s = s[2:]
        if s[-2:] == ">>": s = s[:-2]
        s = s.strip()
    else:
        s = g.angleBrackets(' ' + s + ' ')

    c.frame.tree.editLabel(v)
    w = c.edit_widget(v)
    if w:
        w.setAllText(s)
        c.frame.tree.onHeadChanged(v,'Toggle Angle Brackets')
#@-node:ekr.20031218072017.2290:toggleAngleBrackets
#@-node:ekr.20031218072017.2885:Edit Headline submenu
#@+node:ekr.20031218072017.2887:Find submenu (frame methods)
#@+node:ekr.20051013084200:dismissFindPanel
def dismissFindPanel (self,event=None):

    c = self

    if c.frame.findPanel:
        c.frame.findPanel.dismiss()
#@-node:ekr.20051013084200:dismissFindPanel
#@+node:ekr.20031218072017.2888:showFindPanel
def showFindPanel (self,event=None):

    '''Open Leo's legacy Find dialog.'''

    c = self

    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.bringToFront()
#@-node:ekr.20031218072017.2888:showFindPanel
#@+node:ekr.20031218072017.2889:findNext
def findNext (self,event=None):

    c = self

    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.findNextCommand(c)
#@-node:ekr.20031218072017.2889:findNext
#@+node:ekr.20031218072017.2890:findPrevious
def findPrevious (self,event=None):

    c = self

    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.findPreviousCommand(c)
#@-node:ekr.20031218072017.2890:findPrevious
#@+node:ekr.20031218072017.2891:replace
def replace (self,event=None):

    c = self

    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeCommand(c)
#@-node:ekr.20031218072017.2891:replace
#@+node:ekr.20031218072017.2892:replaceThenFind
def replaceThenFind (self,event=None):

    c = self

    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeThenFindCommand(c)
#@-node:ekr.20031218072017.2892:replaceThenFind
#@+node:ekr.20051013083241:replaceAll
def replaceAll (self,event=None):

    c = self

    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeAllCommand(c)
#@-node:ekr.20051013083241:replaceAll
#@-node:ekr.20031218072017.2887:Find submenu (frame methods)
#@+node:ekr.20031218072017.2893:notValidInBatchMode
def notValidInBatchMode(self, commandName):

    g.es("%s command is not valid in batch mode" % commandName)
#@-node:ekr.20031218072017.2893:notValidInBatchMode
#@-node:ekr.20031218072017.2861:Edit Menu...
#@+node:ekr.20031218072017.2894:Outline menu...
#@+node:ekr.20031218072017.2895: Top Level... (Commands)
#@+node:ekr.20031218072017.1548:Cut & Paste Outlines
#@+node:ekr.20031218072017.1549:cutOutline
def cutOutline (self,event=None):

    '''Delete the selected outline and send it to the clipboard.'''

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()
#@-node:ekr.20031218072017.1549:cutOutline
#@+node:ekr.20031218072017.1550:copyOutline
def copyOutline (self,event=None):

    '''Copy the selected outline to the clipboard.'''

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    c.fileCommands.assignFileIndices()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)
#@-node:ekr.20031218072017.1550:copyOutline
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        << remember all data for undo/redo Paste As Clone >>

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return

    c.beginUpdate()
    try:
        copiedBunchList = []
        if pasteAsClone:
            << put only needed info in copiedBunchList >>
        undoData = u.beforeInsertNode(current,
            pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
        c.endEditing()
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        c.setRootPosition(c.findRootPosition(pasted)) # New in 4.4.2.
        u.afterInsertNode(pasted,undoType,undoData)
    finally:
        c.endUpdate()
        c.recolor()
#@+node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())
#@-node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
#@+node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
# Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t

# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
#@-node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:EKR.20040610130943:pasteOutlineRetainingClones
def pasteOutlineRetainingClones (self,event=None):

    '''Paste an outline into the present outline from the clipboard.
    Nodes *retain* their original identify.'''

    c = self

    return c.pasteOutline(reassignIndices=False)
#@-node:EKR.20040610130943:pasteOutlineRetainingClones
#@-node:ekr.20031218072017.1548:Cut & Paste Outlines
#@+node:ekr.20031218072017.2028:Hoist & dehoist
def dehoist (self,event=None):

    '''Undo a previous hoist of an outline.'''

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        c.beginUpdate()
        try:
            if bunch.expanded: p.expand()
            else:              p.contract()
        finally:
            c.endUpdate()
        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')
        g.doHook('hoist-changed',c=c)

def hoist (self,event=None):

    '''Make only the selected outline visible.'''

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        c.beginUpdate()
        try:
            p.expand()
        finally:
            c.endUpdate()
        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
        c.undoer.afterHoist(p,'Hoist')
        g.doHook('hoist-changed',c=c)
#@-node:ekr.20031218072017.2028:Hoist & dehoist
#@+node:ekr.20031218072017.1759:Insert, Delete & Clone (Commands)
#@+node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if warningFlag:
                g.alert(message)
            return False
    return True
#@-node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.currentPosition()
    if not p: return

    if p.hasVisBack(): newNode = p.visBack()
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    try:
       c.endEditing() # Make sure we capture the headline for Undo.
    finally:
        c.endUpdate(False)

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.headString()
        if h.startswith(chapters):
            if p.hasChildren():
               return cc.error('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                return cc.removeChapterByName(name)

    c.beginUpdate()
    try:
        undoData = u.beforeDeleteNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.doDelete()
        c.selectPosition(newNode)
        c.setChanged(True)
        u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()

    c.validateOutline()
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node"):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if (
            (current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)
        ):
            if c.config.getBool('insert_new_nodes_at_end'):
                p = current.insertAsLastChild()
            else:
                p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
    c.beginUpdate()
    try:
        c.editPosition(p,selectAll=True)
    finally:
        c.endUpdate(False)

    return p # for mod_labels plugin.
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20031218072017.1762:c.clone
def clone (self,event=None):

    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone()
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    finally:
        c.endUpdate()

    return clone # For mod_labels and chapters plugins.
#@-node:ekr.20031218072017.1762:c.clone
#@+node:ekr.20031218072017.1765:c.validateOutline
# Makes sure all nodes are valid.

def validateOutline (self,event=None):

    c = self

    if not g.app.debug:
        return True

    root = c.rootPosition()
    parent = c.nullPosition()

    if root:
        return root.validateOutlineWithParent(parent)
    else:
        return True
#@-node:ekr.20031218072017.1765:c.validateOutline
#@-node:ekr.20031218072017.1759:Insert, Delete & Clone (Commands)
#@+node:ekr.20050415134809:c.sortChildren
def sortChildren (self,event=None):

    '''Sort the children of a node.'''

    c = self ; u = c.undoer ; undoType = 'Sort Children'
    p = c.currentPosition()
    if not p or not p.hasChildren(): return

    c.beginUpdate()
    try: # In update
        c.endEditing()
        u.beforeChangeGroup(p,undoType)
        c.sortChildrenHelper(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(p,undoType,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
#@-node:ekr.20050415134809:c.sortChildren
#@+node:ekr.20040303175026.12:c.sortChildrenHelper
def sortChildrenHelper (self,p):

    c = self ; u = c.undoer

    # Create a list of tuples sorted on headlines.
    pairs = [(child.headString().lower(),child.copy()) for child in p.children_iter()]
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        undoData = u.beforeMoveNode(child)
        child.moveToNthChildOf(p,index)
        u.afterMoveNode(child,'Sort',undoData)
        index += 1
#@nonl
#@-node:ekr.20040303175026.12:c.sortChildrenHelper
#@+node:ekr.20050415134809.1:c.sortSiblings
def sortSiblings (self,event=None):

    '''Sort the siblings of a node.'''

    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    p = c.currentPosition()
    if not p: return

    parent = p.parent()
    if not parent:
        c.sortTopLevel()
    else:
        c.beginUpdate()
        try: # In update...
            c.endEditing()
            u.beforeChangeGroup(p,undoType)
            c.sortChildrenHelper(parent)
            dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
            c.setChanged(True)
            u.afterChangeGroup(p,'Sort Siblings',dirtyVnodeList=dirtyVnodeList)
        finally:
            c.endUpdate()
#@-node:ekr.20050415134809.1:c.sortSiblings
#@+node:ekr.20031218072017.2896:c.sortTopLevel
def sortTopLevel (self,event=None):

    '''Sort the top-level nodes of an outline.'''

    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    root = c.rootPosition()
    if not root: return

    # Create a list of tuples sorted by headlines.
    pairs = [(p.headString().lower(),p.copy())
        for p in root.self_and_siblings_iter()]
    pairs.sort()

    c.beginUpdate()
    try: # In update...
        dirtyVnodeList = []
        u.beforeChangeGroup(root,undoType)
        if 1: # In group...
            h,p = pairs[0]
            if p != root:
                undoData = u.beforeMoveNode(p)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                p.moveToRoot(oldRoot=root)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMoveNode(p,'Sort',undoData)
            for h,next in pairs[1:]:
                undoData = u.beforeMoveNode(next)
                next.moveAfter(p)
                u.afterMoveNode(next,'Sort',undoData)
                p = next
            c.setRootPosition(c.findRootPosition(root)) # New in 4.4.2.
        u.afterChangeGroup(root,undoType,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2896:c.sortTopLevel
#@-node:ekr.20031218072017.2895: Top Level... (Commands)
#@+node:ekr.20040711135959.2:Check Outline submenu...
#@+node:ekr.20031218072017.2072:c.checkOutline
def checkOutline (self,event=None,verbose=True,unittest=False,full=True):

    """Report any possible clone errors in the outline.

    Remove any unused tnodeLists."""

    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    for p in c.allNodes_iter():
        try:
            count += 1
            << remove unused tnodeList >>
            if full: # Unit tests usually set this false.
                << do full tests >>
        except AssertionError,message:
            errors += 1
            << give test failed message >>
    if verbose or not unittest:
        << print summary message >>
    return errors
#@+node:ekr.20040313150633:<< remove unused tnodeList >>
# Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; g.es_print(s,color="blue")
    delattr(v.t,"tnodeList")
    v.t._p_changed = True
#@-node:ekr.20040313150633:<< remove unused tnodeList >>
#@+node:ekr.20040323155951:<< do full tests >>
if not unittest:
    if count % 100 == 0:
        g.es('.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others
#@+node:ekr.20040314035615:assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"
#@-node:ekr.20040314035615:assert consistency of threadNext & threadBack links
#@+node:ekr.20040314035615.1:assert consistency of next and back links
back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"

if next:
    assert p == next.back(), "p==next.back"
#@-node:ekr.20040314035615.1:assert consistency of next and back links
#@+node:ekr.20040314035615.2:assert consistency of parent and child links
if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"

for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"

if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"
#@-node:ekr.20040314035615.2:assert consistency of parent and child links
#@+node:ekr.20040323155951.1:assert consistency of directParents and parent
if p.hasParent():
    t = p.parent().v.t
    for v in p.directParents():
        try:
            assert v.t == t
        except:
            print "p",p
            print "p.directParents",p.directParents()
            print "v",v
            print "v.t",v.t
            print "t = p.parent().v.t",t
            raise AssertionError,"v.t == t"
#@-node:ekr.20040323155951.1:assert consistency of directParents and parent
#@+node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
if p.isCloned():
    parents = p.v.t.vnodeList
    for child in p.children_iter():
        vparents = child.directParents()
        assert len(parents) == len(vparents), "len(parents) == len(vparents)"
        for parent in parents:
            assert parent in vparents, "parent in vparents"
        for parent in vparents:
            assert parent in parents, "parent in parents"
#@-node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20040314043623:assert consistency of vnodeList
vnodeList = p.v.t.vnodeList

for v in vnodeList:

    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) > 1, "len(vnodeList) > 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"
#@-node:ekr.20040314043623:assert consistency of vnodeList
#@+node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
# Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = c.edit_widget(p)
    if t:
        s = t.getAllText()
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"
#@-node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
#@-node:ekr.20040323155951:<< do full tests >>
#@+node:ekr.20040314044652:<< give test failed message >>
s = "test failed: %s %s" % (message,repr(p))
print s ; g.es_print(s,color="red")
#@-node:ekr.20040314044652:<< give test failed message >>
#@+node:ekr.20040314043900:<<print summary message >>
if full:
    print
    g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
    g.es_print(s,color="red")
elif verbose:
    g.es(s,color="green")
#@-node:ekr.20040314043900:<<print summary message >>
#@-node:ekr.20031218072017.2072:c.checkOutline
#@+node:ekr.20040723094220:Check Outline commands & allies
#@+node:ekr.20040723094220.1:checkAllPythonCode
def checkAllPythonCode(self,event=None,unittest=False,ignoreAtIgnore=True):

    '''Check all nodes in the selected tree for syntax and tab errors.'''

    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():

        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (not ignoreAtIgnore or not g.scanForAtIgnore(c,p)):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    import traceback ; traceback.print_exc()
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.cleanHeadString()
                    return result # End the unit test: it has failed.

    if not unittest:
        g.es("Check complete",color="blue")

    return result
#@+node:ekr.20040723094220.2:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@-node:ekr.20040723094220.2:<< print dots >>
#@-node:ekr.20040723094220.1:checkAllPythonCode
#@+node:ekr.20040723094220.3:checkPythonCode
def checkPythonCode (self,event=None,unittest=False,ignoreAtIgnore=True,suppressErrors=False):

    '''Check the selected tree for syntax and tab errors.'''

    c = self ; count = 0 ; result = "ok"

    if not unittest:
        g.es("checking Python code   ")

    for p in c.currentPosition().self_and_subtree_iter():

        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest,suppressErrors)
                except (parser.ParserError,SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    g.es("surprise in checkPythonNode")
                    g.es_exception()
                    return "surprise" # abort

    if not unittest:
        g.es("Check complete",color="blue")

    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result
#@+node:ekr.20040723094220.4:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@-node:ekr.20040723094220.4:<< print dots >>
#@-node:ekr.20040723094220.3:checkPythonCode
#@+node:ekr.20040723094220.5:checkPythonNode
def checkPythonNode (self,p,unittest=False,suppressErrors=False):

    c = self

    h = p.headString()
    # We must call getScript so that we can ignore directives and section references.
    body = g.getScript(c,p.copy())
    if not body: return

    try:
        compiler.parse(body + '\n')
    except (parser.ParserError,SyntaxError):
        if not suppressErrors:
            s = "Syntax error in: %s" % h
            g.es_print(s,color="blue")
        if unittest: raise
        else:
            g.es_exception(full=False,color="black")
            c.setMarked(p)

    c.tabNannyNode(p,h,body,unittest,suppressErrors)
#@-node:ekr.20040723094220.5:checkPythonNode
#@+node:ekr.20040723094220.6:tabNannyNode
# This code is based on tabnanny.check.

def tabNannyNode (self,p,headline,body,unittest=False,suppressErrors=False):

    """Check indentation using tabnanny."""

    c = self

    try:
        # readline = g.readLinesGenerator(body).next
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
        return

    except parser.ParserError, msg:
        if not suppressErrors:
            g.es("ParserError in %s" % headline,color="blue")
            g.es(str(msg))

    except tokenize.TokenError, msg:
        if not suppressErrors:
            g.es("TokenError in %s" % headline,color="blue")
            g.es(str(msg))

    except tabnanny.NannyNag, nag:
        if not suppressErrors:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("Indentation error in %s, line %d" % (headline, badline),color="blue")
            g.es(message)
            g.es("offending line:\n%s" % repr(str(line))[1:-1])

    except:
        g.trace("unexpected exception")
        g.es_exception()

    if unittest: raise
    else: c.setMarked(p)
#@-node:ekr.20040723094220.6:tabNannyNode
#@-node:ekr.20040723094220:Check Outline commands & allies
#@+node:ekr.20040412060927:c.dumpOutline
def dumpOutline (self,event=None):

    """ Dump all nodes in the outline."""

    c = self

    for p in c.allNodes_iter():
        p.dump()
#@-node:ekr.20040412060927:c.dumpOutline
#@+node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040712053025:prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,event=None,dump=False):

    '''Reformat all Python code in the outline to make it look more beautiful.'''

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():

        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyAllPythonCode (self,event=None,dump=False):
    return self.prettyPrintAllPythonCode (event,dump)
#@nonl
#@-node:ekr.20040712053025:prettyPrintAllPythonCode
#@+node:ekr.20040712053025.1:prettyPrintPythonCode
def prettyPrintPythonCode (self,event=None,p=None,dump=False):

    '''Reformat all Python code in the selected tree to make it look more beautiful.'''

    c = self

    if p: root = p.copy()
    else: root = c.currentPosition();

    pp = c.prettyPrinter(c)

    for p in root.self_and_subtree_iter():

        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyPythonCode (self,event=None,dump=False):
    return self.prettyPrintPythonCode (event,dump)

#@-node:ekr.20040712053025.1:prettyPrintPythonCode
#@+node:ekr.20050729211526:prettyPrintPythonNode
def prettyPrintPythonNode (self,p=None,dump=False):

    c = self

    if not p:
        p = c.currentPosition()

    pp = c.prettyPrinter(c)

    # Unlike scanDirectives, scanForAtLanguage ignores @comment.
    if g.scanForAtLanguage(c,p) == "python":
        pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()
#@-node:ekr.20050729211526:prettyPrintPythonNode
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:

    @others
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):

    self.array = []
        # List of strings comprising the line being accumulated.
        # Important: this list never crosses a line.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.lastName = None # The name of the previous token type.
    self.line = 0 # Same as self.srow
    self.lineParenLevel = 0
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.squareBracketLevel = 0
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False
    << define dispatch dict >>
#@+node:ekr.20041021100850:<< define dispatch dict >>
self.dispatchDict = {

    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
#@-node:ekr.20041021100850:<< define dispatch dict >>
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding

    print ; print '-'*10, p.cleanHeadString()

    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040713091855:endUndo
def endUndo (self):

    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.currentPosition()

    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)
#@-node:ekr.20040713091855:endUndo
#@+node:ekr.20040711135244.8:get
def get (self):

    if self.lastName != 'newline' and self.lines:
        # Strip the trailing whitespace from the last line.
        self.lines[-1] = self.lines[-1].rstrip()

    return self.lines
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return

    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):

    """Put s to self.array, and strip trailing whitespace if strip is True."""

    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20041021104237:putArray
def putArray (self):

    """Add the next text by joining all the strings is self.array"""

    self.lines.append(''.join(self.array))
    self.array = []
    self.lineParenLevel = 0
#@-node:ekr.20041021104237:putArray
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
    self.lastName = self.name
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):

    self.putArray()
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):

    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):

    pass

def doIndent (self):

    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine (strings, etc).
def doMultiLine (self):

    # Ensure a blank before comments not preceded entirely by whitespace.

    if self.val.startswith('#') and self.array:
        prev = self.array[-1]
        if prev and prev[-1] != ' ':
            self.put(' ') 

    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()

    # Add a blank after the string if there is something in the last line.
    if self.array:
        line = self.array[-1]
        if line.strip():
            self.put(' ')

    # Suppress start-of-line logic.
    self.line = self.erow
#@-node:ekr.20041021102340:doMultiLine (strings, etc).
#@+node:ekr.20041021101911.5:doName
def doName(self):

    # Ensure whitespace or start-of-line precedes the name.
    if self.array:
        last = self.array[-1]
        ch = last[-1]
        outer = self.parenLevel == 0 and self.squareBracketLevel == 0
        chars = '@ \t{([.'
        if not outer: chars += ',=<>*-+&|/'
        if ch not in chars:
            self.array.append(' ')

    self.array.append("%s " % self.val)

    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.

    self.prevName = self.val
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):

    # Remove trailing whitespace.
    # This never removes trailing whitespace from multi-line tokens.
    if self.array:
        self.array[-1] = self.array[-1].rstrip()

    self.array.append('\n')
    self.putArray()
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):

    val = self.val
    outer = self.lineParenLevel <= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','<=','>=','<','>','<>','*','**','+','&','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '>>':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '<<':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and not g.isWordChar(prev[-1]):
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):

    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]

    if self.ws:
        self.array.append(self.ws)
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):

    print "unknown PrettyPrinting code: %s" % (self.name)
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):

    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):

    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):

    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    sel = c.frame.body.getInsertPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')

    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        c.setBodyString(p,body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
#@-node:ekr.20040713070356:replaceBody
#@-node:ekr.20040711135244.5:class prettyPrinter
#@-node:ekr.20040711135959.1:Pretty Print commands
#@-node:ekr.20040711135959.2:Check Outline submenu...
#@+node:ekr.20031218072017.2898:Expand & Contract...
#@+node:ekr.20031218072017.2899:Commands
#@+node:ekr.20031218072017.2900:contractAllHeadlines
def contractAllHeadlines (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self

    c.beginUpdate()
    try: # update...
        for p in c.allNodes_iter():
            p.contract()
        # Select the topmost ancestor of the presently selected node.
        p = c.currentPosition()
        while p and p.hasParent():
            p.moveToParent()
        c.selectVnode(p)
    finally:
        c.endUpdate()

    c.treeFocusHelper()

    c.expansionLevel = 1 # Reset expansion level.
#@-node:ekr.20031218072017.2900:contractAllHeadlines
#@+node:ekr.20031218072017.2901:contractNode
def contractNode (self,event=None):

    '''Contract the presently selected node.'''

    c = self ; p = c.currentPosition()

    # g.trace(p.headString())

    c.beginUpdate()
    try:
        p.contract()
    finally:
        c.endUpdate()

    c.treeFocusHelper()
#@-node:ekr.20031218072017.2901:contractNode
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent (self,event=None):

    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()

    if p.hasChildren() and p.isExpanded():
        # g.trace('contract',p.headString())
        c.contractNode()
    elif p.hasParent():
        # g.trace('goto parent',p.headString())
        c.goToParent()

    c.treeFocusHelper()
#@nonl
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@+node:ekr.20031218072017.2902:contractParent
def contractParent (self,event=None):

    '''Contract the parent of the presently selected node.'''

    c = self ; p = c.currentPosition()

    parent = p.parent()
    if not parent: return

    c.beginUpdate()
    try:
        parent.contract()
    finally:
        c.endUpdate(False)

    c.treeSelectHelper(parent)
#@-node:ekr.20031218072017.2902:contractParent
#@+node:ekr.20031218072017.2903:expandAllHeadlines
def expandAllHeadlines (self,event=None):

    '''Expand all headlines.
    Warning: this can take a long time for large outlines.'''

    c = self ; p = root = c.rootPosition()

    c.beginUpdate()
    try:
        while p:
            c.expandSubtree(p)
            p.moveToNext()
        c.selectVnode(root)
    finally:
        c.endUpdate()
        c.treeFocusHelper()

    c.expansionLevel = 0 # Reset expansion level.
#@-node:ekr.20031218072017.2903:expandAllHeadlines
#@+node:ekr.20031218072017.2904:expandAllSubheads
def expandAllSubheads (self,event=None):

    '''Expand all children of the presently selected node.'''

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.beginUpdate()
    try:
        c.expandSubtree(v)
        while child:
            c.expandSubtree(child)
            child = child.next()
        c.selectVnode(v)
    finally:
        c.endUpdate()
        c.treeFocusHelper()
#@-node:ekr.20031218072017.2904:expandAllSubheads
#@+node:ekr.20031218072017.2905:expandLevel1..9
def expandLevel1 (self,event=None):
    '''Expand the outline to level 1'''
    self.expandToLevel(1)

def expandLevel2 (self,event=None):
    '''Expand the outline to level 2'''
    self.expandToLevel(2)

def expandLevel3 (self,event=None):
    '''Expand the outline to level 3'''
    self.expandToLevel(3)

def expandLevel4 (self,event=None):
    '''Expand the outline to level 4'''
    self.expandToLevel(4)

def expandLevel5 (self,event=None):
    '''Expand the outline to level 5'''
    self.expandToLevel(5)

def expandLevel6 (self,event=None):
    '''Expand the outline to level 6'''
    self.expandToLevel(6)

def expandLevel7 (self,event=None):
    '''Expand the outline to level 7'''
    self.expandToLevel(7)

def expandLevel8 (self,event=None):
    '''Expand the outline to level 8'''
    self.expandToLevel(8)

def expandLevel9 (self,event=None):
    '''Expand the outline to level 9'''
    self.expandToLevel(9)
#@-node:ekr.20031218072017.2905:expandLevel1..9
#@+node:ekr.20031218072017.2906:expandNextLevel
def expandNextLevel (self,event=None):

    '''Increase the expansion level of the outline and
    Expand all nodes at that level or lower.'''

    c = self ; v = c.currentVnode()

    # Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v

    self.expandToLevel(c.expansionLevel + 1)
#@-node:ekr.20031218072017.2906:expandNextLevel
#@+node:ekr.20031218072017.2907:expandNode
def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    c = self ; v = c.currentVnode()

    c.beginUpdate()
    try:
        v.expand()
    finally:
        c.endUpdate()
        c.treeFocusHelper()
#@-node:ekr.20031218072017.2907:expandNode
#@+node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        c.treeFocusHelper()
        return

    c.beginUpdate()
    try:
        if not p.isExpanded():
            c.expandNode()
        c.selectVnode(p.firstChild())
    finally:
        c.endUpdate()
        c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode()
        else:
            c.beginUpdate()
            try:
                c.selectVnode(p.firstChild())
            finally:
                c.endUpdate()
    c.treeFocusHelper()
#@-node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
#@+node:ekr.20060928062431:expandOnlyAncestorsOfNode
def expandOnlyAncestorsOfNode (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self ; level = 1

    c.beginUpdate()
    try:
        for p in c.allNodes_iter():
            p.contract()
        for p in c.currentPosition().parents_iter():
            p.expand()
            level += 1
    finally:
        c.endUpdate()
        c.treeFocusHelper()

    c.expansionLevel = level # Reset expansion level.
#@-node:ekr.20060928062431:expandOnlyAncestorsOfNode
#@+node:ekr.20031218072017.2908:expandPrevLevel
def expandPrevLevel (self,event=None):

    '''Decrease the expansion level of the outline and
    Expand all nodes at that level or lower.'''

    c = self ; v = c.currentVnode()

    # Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v

    self.expandToLevel(max(1,c.expansionLevel - 1))
#@-node:ekr.20031218072017.2908:expandPrevLevel
#@-node:ekr.20031218072017.2899:Commands
#@+node:ekr.20031218072017.2909:Utilities
#@+node:ekr.20031218072017.2910:contractSubtree
def contractSubtree (self,p):

    for p in p.subtree_iter():
        p.contract()
#@-node:ekr.20031218072017.2910:contractSubtree
#@+node:ekr.20031218072017.2911:expandSubtree
def expandSubtree (self,v):

    c = self
    last = v.lastNode()

    c.beginUpdate()
    try:
        while v and v != last:
            v.expand()
            v = v.threadNext()
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2911:expandSubtree
#@+node:ekr.20031218072017.2912:expandToLevel (rewritten in 4.4)
def expandToLevel (self,level):

    c = self
    c.beginUpdate()
    try:
        current = c.currentPosition()
        n = current.level()
        for p in current.self_and_subtree_iter():
            if p.level() - n + 1 < level:
                p.expand()
            else:
                p.contract()
        c.expansionLevel = level
        c.expansionNode = c.currentPosition()
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2912:expandToLevel (rewritten in 4.4)
#@-node:ekr.20031218072017.2909:Utilities
#@-node:ekr.20031218072017.2898:Expand & Contract...
#@+node:ekr.20031218072017.2913:Goto
#@+node:ekr.20031218072017.1628:goNextVisitedNode
def goNextVisitedNode (self,event=None):

    '''Select the next visited node.'''

    c = self

    while c.beadPointer + 1 < len(c.beadList):
        c.beadPointer += 1
        v = c.beadList[c.beadPointer]
        if c.positionExists(v):
            c.treeSelectHelper(v)
            return
#@-node:ekr.20031218072017.1628:goNextVisitedNode
#@+node:ekr.20031218072017.1627:goPrevVisitedNode
def goPrevVisitedNode (self,event=None):

    '''Select the previously visited node.'''

    c = self

    while c.beadPointer > 0:
        c.beadPointer -= 1
        v = c.beadList[c.beadPointer]
        if c.positionExists(v):
            c.treeSelectHelper(v)
            return
#@-node:ekr.20031218072017.1627:goPrevVisitedNode
#@+node:ekr.20031218072017.2914:goToFirstNode
def goToFirstNode (self,event=None):

    '''Select the first node of the entire outline.'''

    c = self ; p = c.rootPosition()

    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2914:goToFirstNode
#@+node:ekr.20051012092453:goToFirstSibling
def goToFirstSibling (self,event=None):

    '''Select the first sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    if p.hasBack():
        while p.hasBack():
            p.moveToBack()

    c.treeSelectHelper(p)
#@-node:ekr.20051012092453:goToFirstSibling
#@+node:ekr.20031218072017.2915:goToLastNode
def goToLastNode (self,event=None):

    '''Select the last node in the entire tree.'''

    c = self ; p = c.rootPosition()
    while p and p.hasThreadNext():
        p.moveToThreadNext()

    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2915:goToLastNode
#@+node:ekr.20051012092847.1:goToLastSibling
def goToLastSibling (self,event=None):

    '''Select the last sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    if p.hasNext():
        while p.hasNext():
            p.moveToNext()

    c.treeSelectHelper(p)
#@-node:ekr.20051012092847.1:goToLastSibling
#@+node:ekr.20050711153537:goToLastVisibleNode
def goToLastVisibleNode (self,event=None):

    '''Select the last visible node of the entire outline.'''

    c = self ; p = c.rootPosition()

    while p.hasNext():
        p.moveToNext()

    while p and p.isExpanded():
        p.moveToLastChild()

    c.treeSelectHelper(p)
#@-node:ekr.20050711153537:goToLastVisibleNode
#@+node:ekr.20031218072017.2916:goToNextClone
def goToNextClone (self,event=None):

    '''Select the next node that is a clone of the selected node.'''

    c = self ; p = c.currentPosition()
    if not p: return
    if not p.isCloned(): return

    t = p.v.t
    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.v.t == t:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
#@-node:ekr.20031218072017.2916:goToNextClone
#@+node:ekr.20031218072017.2917:goToNextDirtyHeadline
def goToNextDirtyHeadline (self,event=None):

    '''Select the node that is marked as changed.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isDirty():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
#@-node:ekr.20031218072017.2917:goToNextDirtyHeadline
#@+node:ekr.20031218072017.2918:goToNextMarkedHeadline
def goToNextMarkedHeadline (self,event=None):

    '''Select the next marked node.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isMarked():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
#@-node:ekr.20031218072017.2918:goToNextMarkedHeadline
#@+node:ekr.20031218072017.2919:goToNextSibling
def goToNextSibling (self,event=None):

    '''Select the next sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    c.treeSelectHelper(p and p.next())
#@-node:ekr.20031218072017.2919:goToNextSibling
#@+node:ekr.20031218072017.2920:goToParent
def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.currentPosition()

    c.treeSelectHelper(p and p.parent())
#@-node:ekr.20031218072017.2920:goToParent
#@+node:ekr.20031218072017.2921:goToPrevSibling
def goToPrevSibling (self,event=None):

    '''Select the previous sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    c.treeSelectHelper(p and p.back())
#@-node:ekr.20031218072017.2921:goToPrevSibling
#@+node:ekr.20031218072017.2993:selectThreadBack
def selectThreadBack (self,event=None):

    '''Select the node preceding the selected node in outline order.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadBack()

    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2993:selectThreadBack
#@+node:ekr.20031218072017.2994:selectThreadNext
def selectThreadNext (self,event=None):

    '''Select the node following the selected node in outline order.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()

    c.treeSelectHelper(p)
#@nonl
#@-node:ekr.20031218072017.2994:selectThreadNext
#@+node:ekr.20031218072017.2995:selectVisBack
# This has an up arrow for a control key.

def selectVisBack (self,event=None):

    '''Select the visible node preceding the presently selected node.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToVisBack()

    if p:
        redraw = not p.isVisible()
        if not redraw: c.frame.tree.setSelectedLabelState(c.currentPosition())
    else:
        redraw = True

    c.treeSelectHelper(p,redraw=redraw)
#@-node:ekr.20031218072017.2995:selectVisBack
#@+node:ekr.20031218072017.2996:selectVisNext
def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToVisNext()

    if p:
        redraw = not p.isVisible()
        if not redraw: c.frame.tree.setSelectedLabelState(c.currentPosition())
    else:
        redraw = True

    c.treeSelectHelper(p,redraw=redraw)
#@-node:ekr.20031218072017.2996:selectVisNext
#@+node:ekr.20070417112650:utils
#@+node:ekr.20070226121510: treeFocusHelper (new in Leo 4.4.3)
def treeFocusHelper (self):

    c = self

    if c.config.getBool('stayInTreeAfterSelect'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
#@-node:ekr.20070226121510: treeFocusHelper (new in Leo 4.4.3)
#@+node:ekr.20070226113916: treeSelectHelper (new in Leo 4.4.3)
def treeSelectHelper (self,p,redraw=True):

    c = self ; current = c.currentPosition()

    if p:
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectPosition(p,updateBeadList=False)
        finally:
            c.endUpdate(redraw)

    c.treeFocusHelper()
#@-node:ekr.20070226113916: treeSelectHelper (new in Leo 4.4.3)
#@-node:ekr.20070417112650:utils
#@-node:ekr.20031218072017.2913:Goto
#@+node:ekr.20031218072017.2922:Mark...
#@+node:ekr.20031218072017.2923:markChangedHeadlines
def markChangedHeadlines (self,event=None):

    '''Mark all nodes that have been changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2923:markChangedHeadlines
#@+node:ekr.20031218072017.2924:markChangedRoots
def markChangedRoots (self,event=None):

    '''Mark all changed @root nodes.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                s = p.bodyString()
                flag, i = g.is_special(s,0,"@root")
                if flag:
                    bunch = u.beforeMark(p,undoType)
                    c.setMarked(p)
                    c.setChanged(True)
                    u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2924:markChangedRoots
#@+node:ekr.20031218072017.2925:markAllAtFileNodesDirty (not used)
def markAllAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes as changed.'''

    c = self ; p = c.rootPosition()

    c.beginUpdate()
    try: # In update...
        while p:
            if p.isAtFileNode() and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2925:markAllAtFileNodesDirty (not used)
#@+node:ekr.20031218072017.2926:markAtFileNodesDirty (not used)
def markAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes in the selected tree as changed.'''

    c = self
    p = c.currentPosition()
    if not p: return

    after = p.nodeAfterTree()
    c.beginUpdate()
    try: # In update...
        while p and p != after:
            if p.isAtFileNode() and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2926:markAtFileNodesDirty (not used)
#@+node:ekr.20031218072017.2927:markClones
def markClones (self,event=None):

    '''Mark all clones of the selected node.'''

    c = self ; u = c.undoer ; undoType = 'Mark Clones'
    current = c.currentPosition()
    if not current or not current.isCloned():
        g.es('The current node is not a clone',color='blue')
        return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.v.t == current.v.t:
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                c.setChanged(True)
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@-node:ekr.20031218072017.2927:markClones
#@+node:ekr.20031218072017.2928:markHeadline
def markHeadline (self,event=None):

    '''Toggle the mark of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    try: # In update...
        undoType = g.choose(p.isMarked(),'Unmark','Mark')
        bunch = u.beforeMark(p,undoType)
        if p.isMarked():
            c.clearMarked(p)
        else:
            c.setMarked(p)
        dirtyVnodeList = p.setDirty()
        c.setChanged(True)
        u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2928:markHeadline
#@+node:ekr.20031218072017.2929:markSubheads
def markSubheads (self,event=None):

    '''Mark all children of the selected node as changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in current.children_iter():
            if not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@-node:ekr.20031218072017.2929:markSubheads
#@+node:ekr.20031218072017.2930:unmarkAll
def unmarkAll (self,event=None):

    '''Unmark all nodes in the entire outline.'''

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        changed = False
        for p in c.allNodes_iter():
            if p.isMarked():
                bunch = u.beforeMark(p,undoType)
                c.clearMarked(p)
                p.v.t.setDirty()
                u.afterMark(p,undoType,bunch)
        dirtyVnodeList = [p.v for p in c.allNodes_iter() if p.v.isDirty()]
        if changed: c.setChanged(True)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2930:unmarkAll
#@-node:ekr.20031218072017.2922:Mark...
#@+node:ekr.20031218072017.1766:Move... (Commands)
#@+node:ekr.20070420092425:cantMoveMessage
def cantMoveMessage (self):

    c = self ; h = c.rootPosition().headString()
    g.trace(h)
    kind = g.choose(h.startswith('@chapter'),'chapter','hoist')
    g.es("Can't move node out of %s" % (kind),color="blue")
#@-node:ekr.20070420092425:cantMoveMessage
#@+node:ekr.20031218072017.1767:demote
def demote (self,event=None):

    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    command = 'Demote'
    if not current or not current.hasNext():
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
        return

    # Make sure all the moves will be valid.
    for child in current.children_iter():
        if not c.checkMoveWithParentWithWarning(child,current,True):
            # c.treeWantsFocusNow()
            c.treeFocusHelper()
            return
    c.beginUpdate()
    try: # update...
        c.endEditing()
        u.beforeChangeGroup(current,command)
        p = current.copy()
        while p.hasNext(): # Do not use iterator here.
            child = p.next()
            undoData = u.beforeMoveNode(child)
            child.moveToNthChildOf(p,p.numberOfChildren())
            u.afterMoveNode(child,command,undoData)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = current.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(current,command,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(current)  # Also sets rootPosition.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(current) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1767:demote
#@+node:ekr.20031218072017.1768:moveOutlineDown
@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown (self,event=None):

    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    next = p.visNext()

    while next and p.isAncestorOf(next):
        next = next.visNext()
    if not next:
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        << Move p down & set moved if successful >>
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)

else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)

if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
#@-node:ekr.20031218072017.1768:moveOutlineDown
#@+node:ekr.20031218072017.1770:moveOutlineLeft
def moveOutlineLeft (self,event=None):

    '''Move the selected node left if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    if not p.hasParent():
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
        if sparseMove: # New in Leo 4.4.2
            parent.contract()
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1770:moveOutlineLeft
#@+node:ekr.20031218072017.1771:moveOutlineRight
def moveOutlineRight (self,event=None):

    '''Move the selected node right if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    back = p.back()
    if not back:
        c.treeFocusHelper()
        return

    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeFocusHelper()
        return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # g.trace(p,p.parent())
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1771:moveOutlineRight
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    back = p.visBack()
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack()

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        << Move p up >>
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)

    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1773:<< Move p up >>
if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

parent = p.parent()

# For this special case we move p after back2.
specialCase = back2 and p.v in back2.v.t.vnodeList

if specialCase:
    # The move must be legal.
    moved = True
    back2.contract()
    p.moveAfter(back2)
elif not back2:
    # p will be the new root node
    moved = True
    p.moveToRoot(oldRoot=c.rootPosition())
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1773:<< Move p up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@+node:ekr.20031218072017.1774:promote
def promote (self,event=None):

    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren():
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        u.beforeChangeGroup(p,command)
        after = p
        while p.hasChildren(): # Don't use an iterator.
            child = p.firstChild()
            undoData = u.beforeMoveNode(child)
            child.moveAfter(after)
            after = child
            u.afterMoveNode(child,command,undoData)
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterChangeGroup(p,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1774:promote
#@-node:ekr.20031218072017.1766:Move... (Commands)
#@-node:ekr.20031218072017.2894:Outline menu...
#@+node:ekr.20031218072017.2931:Window Menu
#@+node:ekr.20031218072017.2092:openCompareWindow
def openCompareWindow (self,event=None):

    '''Open a dialog for comparing files and directories.'''

    c = self ; frame = c.frame

    if not frame.comparePanel:
        frame.comparePanel = g.app.gui.createComparePanel(c)

    frame.comparePanel.bringToFront()
#@-node:ekr.20031218072017.2092:openCompareWindow
#@+node:ekr.20031218072017.2932:openPythonWindow
def openPythonWindow (self,event=None):

    '''Open Python's Idle debugger in a separate process.'''

    pythonDir = g.os_path_dirname(sys.executable)
    idle = g.os_path_join(pythonDir,'Lib','idlelib','idle.py')
    args = [sys.executable, idle ]

    if 1: # Use present environment.
        os.spawnv(os.P_NOWAIT, sys.executable, args)
    else: # Use a pristine environment.
        os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
#@-node:ekr.20031218072017.2932:openPythonWindow
#@-node:ekr.20031218072017.2931:Window Menu
#@+node:ekr.20031218072017.2938:Help Menu
#@+node:ekr.20031218072017.2939:about (version number & date)
def about (self,event=None):

    '''Bring up an About Leo Dialog.'''

    c = self

    # Don't use triple-quoted strings or continued strings here.
    # Doing so would add unwanted leading tabs.
    version = c.getSignOnLine() + "\n\n"
    theCopyright = (
        "Copyright 1999-2006 by Edward K. Ream\n" +
        "All Rights Reserved\n" +
        "Leo is distributed under the Python License")
    url = "http://webpages.charter.net/edreamleo/front.html"
    email = "edreamleo@charter.net"

    g.app.gui.runAboutLeoDialog(c,version,theCopyright,url,email)
#@-node:ekr.20031218072017.2939:about (version number & date)
#@+node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)

    # Look in homeDir second.
    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        if configDir == loadDir:
            g.es("%s not found in %s" % (name,configDir))
        else:
            fileName = g.os_path_join(homeDir,name)
            ok, frame = g.openWithFileName(fileName,c)
            if not ok:
                g.es("%s not found in %s or %s" % (name,configDir,homeDir))
#@-node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
#@+node:ekr.20061018094539:openLeoScripts
def openLeoScripts (self,event=None):

    c = self
    fileName = g.os_path_join(g.app.loadDir,'..','scripts','scripts.leo')

    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es('not found: %s' % fileName)
#@-node:ekr.20061018094539:openLeoScripts
#@+node:ekr.20061209131102.1:openTest
def openTest (self, event=None):

    if 1: # Open in a new process.
        cmd = 'c:\Windows\System32\cmd.exe' # Hangs if used.
        python = sys.executable
        leo = g.os_path_abspath(g.os_path_join(g.app.loadDir,'leo.py'))
        test = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test'))

        os.system('%s %s %s %s' % (cmd, python,leo,test))
        # args = [python, leo, test]

        # if 1: # Use present environment.
            # os.spawnv(os.P_NOWAIT, sys.executable, args)
        # else: # Use a pristine environment.
            # os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
    else:
        c = self
        fileName = g.os_path_join(g.app.loadDir,'..','test','test.leo')

        ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es('not found: %s' % fileName)
#@-node:ekr.20061209131102.1:openTest
#@+node:ekr.20031218072017.2940:leoDocumentation
def leoDocumentation (self,event=None):

    '''Open LeoDocs.leo in a new Leo window.'''

    c = self ; name = "LeoDocs.leo"

    fileName = g.os_path_join(g.app.loadDir,"..","doc",name)
    ok,frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es("not found: %s" % name)
#@-node:ekr.20031218072017.2940:leoDocumentation
#@+node:ekr.20031218072017.2941:leoHome
def leoHome (self,event=None):

    '''Open Leo's Home page in a web browser.'''

    import webbrowser

    url = "http://webpages.charter.net/edreamleo/front.html"
    try:
        webbrowser.open_new(url)
    except:
        g.es("not found: " + url)
#@-node:ekr.20031218072017.2941:leoHome
#@+node:ekr.20050130152008:leoPlugins
def openLeoPlugins (self,event=None):

    '''Open leoPlugins.leo in a new Leo window.'''

    c = self ; name = "leoPlugins.leo"
    fileName = g.os_path_join(g.app.loadDir,"..","plugins",name)
    ok,frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es("not found: %s" % name)
#@-node:ekr.20050130152008:leoPlugins
#@+node:ekr.20031218072017.2942:leoTutorial (version number)
def leoTutorial (self,event=None):

    '''Open Leo's online tutorial in a web browser.'''

    import webbrowser

    if 1: # new url
        url = "http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"
    else:
        url = "http://www.evisa.com/e/sbooks/leo/sbframetoc_ie.htm"
    try:
        webbrowser.open_new(url)
    except:
        g.es("not found: " + url)
#@-node:ekr.20031218072017.2942:leoTutorial (version number)
#@+node:ekr.20060613082924:leoUsersGuide
def leoUsersGuide (self,event=None):

    '''Open Leo's users guide in a web browser.'''

    import webbrowser

    theFile = g.os_path_abspath(
        g.os_path_join(
            g.app.loadDir,'..','doc','html','leo_TOC.html'))

    url = 'file:%s' % theFile

    try:
        webbrowser.open_new(url)
    except:
        g.es("not found: " + url)
#@-node:ekr.20060613082924:leoUsersGuide
#@-node:ekr.20031218072017.2938:Help Menu
#@-node:ekr.20031218072017.2818:Command handlers...
#@+node:ekr.20031218072017.2945:Dragging (commands)
#@+node:ekr.20031218072017.2353:c.dragAfter
def dragAfter(self,p,after):

    c = self ; u = self.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkMoveWithParentWithWarning(p,after.parent(),True): return

    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(after)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2353:c.dragAfter
#@+node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()

    c.beginUpdate()
    try: # In update...
        # g.trace("p,parent,n:",p.headString(),parent.headString(),n)
        clone = p.clone() # Creates clone & dependents, does not set undo.
        if not c.checkMoveWithParentWithWarning(clone,parent,True):
            clone.doDelete() # Destroys clone and makes p the current node.
            c.selectPosition(p) # Also sets root position.
            c.endUpdate(False) # Nothing has changed.
            return
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
           dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
           dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(clone) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
#@+node:ekr.20031218072017.2947:c.dragToNthChildOf
def dragToNthChildOf(self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkMoveWithParentWithWarning(p,parent,True): return

    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2947:c.dragToNthChildOf
#@+node:ekr.20031218072017.2948:c.dragCloneAfter
def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()

    c.beginUpdate()
    try: # In update...
        clone = p.clone() # Creates clone.  Does not set undo.
        if c.checkMoveWithParentWithWarning(clone,after.parent(),True):
            inAtIgnoreRange = clone.inAtIgnoreRange()
            c.endEditing()
            undoData = u.beforeInsertNode(current)
            dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
            clone.moveAfter(after)
            if inAtIgnoreRange and not clone.inAtIgnoreRange():
                # The moved node have just become newly unignored.
                dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
            p = clone
        else:
            # g.trace("invalid clone drag")
            clone.doDelete()
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.2948:c.dragCloneAfter
#@-node:ekr.20031218072017.2945:Dragging (commands)
#@+node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.2950:c.begin/endUpdate
@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate()
@c

def beginUpdate(self):

    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''

    c = self
    if c.frame and c.frame.tree:
        c.frame.tree.beginUpdate()

def endUpdate(self,flag=True,scroll=True):

    '''Redraw the screen if flag is True.'''

    c = self
    if c.frame and c.frame.tree:
        c.frame.tree.endUpdate(flag,scroll=scroll)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20031218072017.2950:c.begin/endUpdate
#@+node:ekr.20031218072017.2951:c.bringToFront
def bringToFront(self,set_focus=True):

    # g.trace(g.callers())

    c = self
    c.frame.deiconify()

    if set_focus:
        c.frame.body.setFocus()

BringToFront = bringToFront # Compatibility with old scripts
#@-node:ekr.20031218072017.2951:c.bringToFront
#@+node:ekr.20060210102201:c.xWantsFocusNow
def bodyWantsFocusNow(self):
    c = self ; body = c.frame.body
    #g.trace(body and body.bodyCtrl)
    c.set_focus(body and body.bodyCtrl,force=True)

def headlineWantsFocusNow(self,p):
    c = self
    c.set_focus(p and c.edit_widget(p),force=True)

def logWantsFocusNow(self):
    c = self ; log = c.frame.log
    c.set_focus(log and log.logCtrl,force=True)

def minibufferWantsFocusNow(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocusNow()

def treeWantsFocusNow(self):
    c = self ; tree = c.frame.tree
    c.set_focus(tree and tree.canvas,force=True)

def widgetWantsFocusNow(self,w):
    c = self ; c.set_focus(w,force=True)
#@-node:ekr.20060210102201:c.xWantsFocusNow
#@+node:ekr.20050120092028:c.xWantsFocus
def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)
def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and c.edit_widget(p))

def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)

def minibufferWantsFocus(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocus()

def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)

def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)
#@-node:ekr.20050120092028:c.xWantsFocus
#@+node:ekr.20060205111103:c.widget_name
def widget_name (self,widget):

    c = self

    return g.app.gui.widget_name(widget) or ''
#@-node:ekr.20060205111103:c.widget_name
#@+node:ekr.20060207142332:c.traceFocus
trace_focus_count = 0

def traceFocus (self,w):

    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        print '%4d' % (c.trace_focus_count),c.widget_name(w),g.callers(8)
#@-node:ekr.20060207142332:c.traceFocus
#@+node:ekr.20060208143543:c.restoreFocus
def restoreFocus (self):

    '''Ensure that the focus eventually gets restored.'''

    c =self
    trace = not g.app.unitTesting and c.config.getBool('trace_focus')

    if c.requestedFocusWidget:
        c.hasFocusWidget = None # Force an update
    elif c.hasFocusWidget:
        c.requestedFocusWidget = c.hasFocusWidget
        c.hasFocusWidget = None # Force an update
    else:
        # Should not happen, except during unit testing.
        # c.masterFocusHandler sets c.hasFocusWidget,
        # so if it is not set here it is because this method cleared it.
        if not g.app.unitTesting: g.trace('oops: no requested or present widget.',g.callers())
        c.bodyWantsFocusNow()

    if c.inCommand:
        if trace: g.trace('expecting later call to c.masterFocusHandler')
        pass # A call to c.masterFocusHandler will surely happen.
    else:
        c.masterFocusHandler() # Do it now.
#@-node:ekr.20060208143543:c.restoreFocus
#@+node:ekr.20031218072017.2954:c.redraw and c.redraw_now
def redraw (self):
    c = self
    c.beginUpdate()
    c.endUpdate()

def redraw_now (self):

    c = self

    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    if 0: # Interferes with new colorizer.
        c.frame.top.update_idletasks()

    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
force_redraw = redraw_now
#@-node:ekr.20031218072017.2954:c.redraw and c.redraw_now
#@+node:ekr.20051216171520:c.recolor_now
def recolor_now(self,p=None,incremental=False,interruptable=True):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,
        incremental=incremental,interruptable=interruptable)
#@-node:ekr.20051216171520:c.recolor_now
#@+node:ekr.20031218072017.2953:c.recolor & requestRecolor
def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())

def requestRecolor (self):

    c = self
    c.frame.requestRecolorFlag = True
#@-node:ekr.20031218072017.2953:c.recolor & requestRecolor
#@+node:ekr.20060207140352:c.masterFocusHandler
def masterFocusHandler (self):

    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')

    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget

    if trace: print \
        'requested',c.widget_name(c.requestedFocusWidget),\
        'present',c.widget_name(c.hasFocusWidget)

    if c.hasFocusWidget and (
        not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget):
        if trace: print 'no change.',c.widget_name(w)
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        # This is not an error: it can arise because of a call to k.invalidateFocus.
        if trace: print '*'*20,'oops: moving to body pane.'
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler
#@-node:ekr.20060207140352:c.masterFocusHandler
#@+node:ekr.20060210103358:c.invalidateFocus
def invalidateFocus (self):

    '''Indicate that the focus is in an invalid location, or is unknown.'''

    c = self
    c.requestedFocusWidget = None
    c.hasFocusWidget = None
    # g.trace(g.callers())
#@-node:ekr.20060210103358:c.invalidateFocus
#@+node:ekr.20060205103842:c.get/request/set_focus
def get_focus (self):

    c = self
    return g.app.gui.get_focus(c)

def get_requested_focus (self):

    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)

def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)

def set_focus (self,w,force=False):

    c = self

    if force: # New in Leo 4.4.2: safer.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
        c.traceFocus(w)
    else: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
#@-node:ekr.20060205103842:c.get/request/set_focus
#@-node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.2955:Enabling Menu Items
#@+node:ekr.20040323172420:Slow routines: no longer used
#@+node:ekr.20031218072017.2966:canGoToNextDirtyHeadline (slow)
def canGoToNextDirtyHeadline (self):

    c = self ; current = c.currentPosition()

    for p in c.allNodes_iter():
        if p != current and p.isDirty():
            return True

    return False
#@-node:ekr.20031218072017.2966:canGoToNextDirtyHeadline (slow)
#@+node:ekr.20031218072017.2967:canGoToNextMarkedHeadline (slow)
def canGoToNextMarkedHeadline (self):

    c = self ; current = c.currentPosition()

    for p in c.allNodes_iter():
        if p != current and p.isMarked():
            return True

    return False
#@-node:ekr.20031218072017.2967:canGoToNextMarkedHeadline (slow)
#@+node:ekr.20031218072017.2968:canMarkChangedHeadline (slow)
def canMarkChangedHeadlines (self):

    c = self

    for p in c.allNodes_iter():
        if p.isDirty():
            return True

    return False
#@-node:ekr.20031218072017.2968:canMarkChangedHeadline (slow)
#@+node:ekr.20031218072017.2969:canMarkChangedRoots (slow)
def canMarkChangedRoots (self):

    c = self

    for p in c.allNodes_iter():
        if p.isDirty and p.isAnyAtFileNode():
            return True

    return False
#@-node:ekr.20031218072017.2969:canMarkChangedRoots (slow)
#@-node:ekr.20040323172420:Slow routines: no longer used
#@+node:ekr.20040131170659:canClone (new for hoist)
def canClone (self):

    c = self

    if c.hoistStack:
        current = c.currentPosition()
        bunch = c.hoistStack[-1]
        return current != bunch.p
    else:
        return True
#@-node:ekr.20040131170659:canClone (new for hoist)
#@+node:ekr.20031218072017.2956:canContractAllHeadlines
def canContractAllHeadlines (self):

    c = self

    for p in c.allNodes_iter():
        if p.isExpanded():
            return True

    return False
#@-node:ekr.20031218072017.2956:canContractAllHeadlines
#@+node:ekr.20031218072017.2957:canContractAllSubheads
def canContractAllSubheads (self):

    c = self ; current = c.currentPosition()

    for p in current.subtree_iter():
        if p != current and p.isExpanded():
            return True

    return False
#@-node:ekr.20031218072017.2957:canContractAllSubheads
#@+node:ekr.20031218072017.2958:canContractParent
def canContractParent (self):

    c = self
    return c.currentPosition().parent()
#@-node:ekr.20031218072017.2958:canContractParent
#@+node:ekr.20031218072017.2959:canContractSubheads
def canContractSubheads (self):

    c = self ; current = c.currentPosition()

    for child in current.children_iter():
        if child.isExpanded():
            return True

    return False
#@-node:ekr.20031218072017.2959:canContractSubheads
#@+node:ekr.20031218072017.2960:canCutOutline & canDeleteHeadline
def canDeleteHeadline (self):

    c = self ; p = c.currentPosition()

    if c.hoistStack:
         bunch = c.hoistStack[0]
         if p == bunch.p: return False

    return p.hasParent() or p.hasThreadBack() or p.hasNext()

canCutOutline = canDeleteHeadline
#@-node:ekr.20031218072017.2960:canCutOutline & canDeleteHeadline
#@+node:ekr.20031218072017.2961:canDemote
def canDemote (self):

    c = self
    return c.currentPosition().hasNext()
#@-node:ekr.20031218072017.2961:canDemote
#@+node:ekr.20031218072017.2962:canExpandAllHeadlines
def canExpandAllHeadlines (self):

    c = self

    for p in c.allNodes_iter():
        if not p.isExpanded():
            return True

    return False
#@-node:ekr.20031218072017.2962:canExpandAllHeadlines
#@+node:ekr.20031218072017.2963:canExpandAllSubheads
def canExpandAllSubheads (self):

    c = self

    for p in c.currentPosition().subtree_iter():
        if not p.isExpanded():
            return True

    return False
#@-node:ekr.20031218072017.2963:canExpandAllSubheads
#@+node:ekr.20031218072017.2964:canExpandSubheads
def canExpandSubheads (self):

    c = self ; current = c.currentPosition()

    for p in current.children_iter():
        if p != current and not p.isExpanded():
            return True

    return False
#@-node:ekr.20031218072017.2964:canExpandSubheads
#@+node:ekr.20031218072017.2287:canExtract, canExtractSection & canExtractSectionNames
def canExtract (self):

    c = self ; body = c.frame.body
    return body and body.hasTextSelection()

canExtractSectionNames = canExtract

def canExtractSection (self):

    __pychecker__ = '--no-implicitreturns' # Suppress bad warning.

    c = self ; body = c.frame.body
    if not body: return False

    s = body.getSelectedText()
    if not s: return False

    line = g.get_line(s,0)
    i1 = line.find("<<")
    j1 = line.find(">>")
    i2 = line.find("@<")
    j2 = line.find("@>")
    return -1 < i1 < j1 or -1 < i2 < j2
#@-node:ekr.20031218072017.2287:canExtract, canExtractSection & canExtractSectionNames
#@+node:ekr.20031218072017.2965:canFindMatchingBracket
def canFindMatchingBracket (self):

    c = self ; brackets = "()[]{}"
    body = c.frame.body
    s = body.getAllText()
    ins = body.getInsertPoint()
    c1 = 0 <= ins   < len(s) and s[ins] or ''
    c2 = 0 <= ins-1 < len(s) and s[ins-1] or ''

    return (c1 and c1 in brackets) or (c2 and c2 in brackets)
#@-node:ekr.20031218072017.2965:canFindMatchingBracket
#@+node:ekr.20040303165342:canHoist & canDehoist
def canDehoist(self):

    c = self
    return c.hoistLevel() > 0

def canHoist(self):

    # N.B.  This is called at idle time, so minimizing positions is crucial!
    c = self
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        return bunch.p and not c.isCurrentPosition(bunch.p)
    elif c.currentPositionIsRootPosition():
        return c.currentPositionHasNext()
    else:
        return True

def hoistLevel (self):

    c = self ; cc = c.chapterController
    n = len(c.hoistStack)
    if n > 0 and cc and cc.inChapter():
        n -= 1
    return n
#@-node:ekr.20040303165342:canHoist & canDehoist
#@+node:ekr.20031218072017.2970:canMoveOutlineDown
def canMoveOutlineDown (self):

    c = self ; current = c.currentPosition()

    p = current.visNext()
    while p and current.isAncestorOf(p):
        p.moveToVisNext()

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        return p and p != bunch.p and bunch.p.isAncestorOf(p)
    else:
        return p
#@-node:ekr.20031218072017.2970:canMoveOutlineDown
#@+node:ekr.20031218072017.2971:canMoveOutlineLeft
def canMoveOutlineLeft (self):

    c = self ; p = c.currentPosition()

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        if p and p.hasParent():
            p.moveToParent()
            return p != bunch.p and bunch.p.isAncestorOf(p)
        else:
            return False
    else:
        return p and p.hasParent()
#@-node:ekr.20031218072017.2971:canMoveOutlineLeft
#@+node:ekr.20031218072017.2972:canMoveOutlineRight
def canMoveOutlineRight (self):

    c = self ; p = c.currentPosition()

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        return p and p.hasBack() and p != bunch.p
    else:
        return p and p.hasBack()
#@-node:ekr.20031218072017.2972:canMoveOutlineRight
#@+node:ekr.20031218072017.2973:canMoveOutlineUp
def canMoveOutlineUp (self):

    c = self ; p = c.currentPosition()
    if not p: return False

    pback = p.visBack()
    if not pback: return False

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        return bunch.p != p and bunch.p.isAncestorOf(pback)
    else:
        return True
#@-node:ekr.20031218072017.2973:canMoveOutlineUp
#@+node:ekr.20031218072017.2974:canPasteOutline
def canPasteOutline (self,s=None):

    c = self
    if s == None:
        s = g.app.gui.getTextFromClipboard()
    if not s:
        return False

    # g.trace(s)
    if g.match(s,0,g.app.prolog_prefix_string):
        return True
    elif len(s) > 0:
        return c.importCommands.stringIsValidMoreFile(s)
    else:
        return False
#@-node:ekr.20031218072017.2974:canPasteOutline
#@+node:ekr.20031218072017.2975:canPromote
def canPromote (self):

    c = self ; v = c.currentVnode()
    return v and v.hasChildren()
#@-node:ekr.20031218072017.2975:canPromote
#@+node:ekr.20031218072017.2976:canRevert
def canRevert (self):

    # c.mFileName will be "untitled" for unsaved files.
    c = self
    return (c.frame and c.mFileName and c.isChanged())
#@-node:ekr.20031218072017.2976:canRevert
#@+node:ekr.20031218072017.2977:canSelect....
# 7/29/02: The shortcuts for these commands are now unique.

def canSelectThreadBack (self):
    c = self ; p = c.currentPosition()
    return p.hasThreadBack()

def canSelectThreadNext (self):
    c = self ; p = c.currentPosition()
    return p.hasThreadNext()

def canSelectVisBack (self):
    c = self ; p = c.currentPosition()
    return p.hasVisBack()

def canSelectVisNext (self):
    c = self ; p = c.currentPosition()
    return p.hasVisNext()
#@-node:ekr.20031218072017.2977:canSelect....
#@+node:ekr.20031218072017.2978:canShiftBodyLeft/Right
def canShiftBodyLeft (self):

    c = self ; body = c.frame.body
    return body and body.getAllText()

canShiftBodyRight = canShiftBodyLeft
#@-node:ekr.20031218072017.2978:canShiftBodyLeft/Right
#@+node:ekr.20031218072017.2979:canSortChildren, canSortSiblings
def canSortChildren (self):

    c = self ; p = c.currentPosition()
    return p and p.hasChildren()

def canSortSiblings (self):

    c = self ; p = c.currentPosition()
    return p and (p.hasNext() or p.hasBack())
#@-node:ekr.20031218072017.2979:canSortChildren, canSortSiblings
#@+node:ekr.20031218072017.2980:canUndo & canRedo
def canUndo (self):

    c = self
    return c.undoer.canUndo()

def canRedo (self):

    c = self
    return c.undoer.canRedo()
#@-node:ekr.20031218072017.2980:canUndo & canRedo
#@+node:ekr.20031218072017.2981:canUnmarkAll
def canUnmarkAll (self):

    c = self

    for p in c.allNodes_iter():
        if p.isMarked():
            return True

    return False
#@-node:ekr.20031218072017.2981:canUnmarkAll
#@-node:ekr.20031218072017.2955:Enabling Menu Items
#@+node:ekr.20031218072017.2982:Getters & Setters
#@+node:ekr.20060906211747:Getters
#@+node:ekr.20040803140033:c.currentPosition
def currentPosition (self,copy=True):

    """Return the presently selected position."""

    c = self

    if c._currentPosition:
        # New in Leo 4.4.2: *always* return a copy.
        return c._currentPosition.copy()
    else:
        return c.nullPosition()

# For compatibiility with old scripts.
currentVnode = currentPosition
#@-node:ekr.20040803140033:c.currentPosition
#@+node:ekr.20040306220230.1:c.edit_widget
def edit_widget (self,p):

    c = self

    return p and c.frame.tree.edit_widget(p)
#@nonl
#@-node:ekr.20040306220230.1:c.edit_widget
#@+node:ekr.20031218072017.2986:c.fileName & shortFileName
# Compatibility with scripts

def fileName (self):

    return self.mFileName

def shortFileName (self):

    return g.shortFileName(self.mFileName)

shortFilename = shortFileName
#@-node:ekr.20031218072017.2986:c.fileName & shortFileName
#@+node:ekr.20060906134053:c.findRootPosition New in 4.4.2
@ Aha! The Commands class can easily recompute the root position::

    c.setRootPosition(c.findRootPosition(p))

Any command that changes the outline should call this code.

As a result, the fundamental p and v methods that alter trees need never
convern themselves about reporting the changed root.  A big improvement.
@c

def findRootPosition (self,p):

    '''Return the root position of the outline containing p.'''

    c = self ; p = p.copy()

    while p and p.hasParent():
        p.moveToParent()
        # g.trace(p.headString(),g.callers())

    while p and p.hasBack():
        p.moveToBack()

    # g.trace(p and p.headString())

    return p
#@nonl
#@-node:ekr.20060906134053:c.findRootPosition New in 4.4.2
#@+node:ekr.20040803112200:c.is...Position
#@+node:ekr.20040803155551:c.currentPositionIsRootPosition
def currentPositionIsRootPosition (self):

    """Return True if the current position is the root position.

    This method is called during idle time, so not generating positions
    here fixes a major leak.
    """

    c = self

    return (
        c._currentPosition and c._rootPosition and
        c._currentPosition == c._rootPosition)
#@-node:ekr.20040803155551:c.currentPositionIsRootPosition
#@+node:ekr.20040803160656:c.currentPositionHasNext
def currentPositionHasNext (self):

    """Return True if the current position is the root position.

    This method is called during idle time, so not generating positions
    here fixes a major leak.
    """

    c = self ; current = c._currentPosition 

    return current and current.hasNext()
#@-node:ekr.20040803160656:c.currentPositionHasNext
#@+node:ekr.20040803112450:c.isCurrentPosition
def isCurrentPosition (self,p):

    c = self

    if p is None or c._currentPosition is None:
        return False
    else:
        return p.isEqual(c._currentPosition)
#@-node:ekr.20040803112450:c.isCurrentPosition
#@+node:ekr.20040803112450.1:c.isRootPosition
def isRootPosition (self,p):

    c = self

    if p is None or c._rootPosition is None:
        return False
    else:
        return p.isEqual(c._rootPosition)
#@-node:ekr.20040803112450.1:c.isRootPosition
#@-node:ekr.20040803112200:c.is...Position
#@+node:ekr.20031218072017.2987:c.isChanged
def isChanged (self):

    return self.changed
#@-node:ekr.20031218072017.2987:c.isChanged
#@+node:ekr.20031218072017.4146:c.lastVisible
def lastVisible(self):

    """Move to the last visible node of the entire tree."""

    c = self ; p = c.rootPosition()

    # Move to the last top-level node.
    while p.hasNext():
        p.moveToNext()
    assert(p.isVisible())

    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        p.moveToLastChild()

    return p
#@-node:ekr.20031218072017.4146:c.lastVisible
#@+node:ekr.20040311094927:c.nullPosition
def nullPosition (self):

    c = self ; v = None
    return leoNodes.position(v,[])
#@-node:ekr.20040311094927:c.nullPosition
#@+node:ekr.20040307104131.3:c.positionExists
def positionExists(self,p,root=None):

    """Return True if a position exists in c's tree"""

    c = self ; p = p.copy() ; p2 = p.copy()

    # This code must be fast.
    if not root:
        root = c.rootPosition()

    while p:
        # g.trace(p.headString())
        if p.equal(root):
            # g.trace('True')
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()

    # g.trace('False','p',p2,'root',root)
    return False
#@-node:ekr.20040307104131.3:c.positionExists
#@+node:ekr.20040803140033.2:c.rootPosition
def rootPosition(self):

    """Return the root position."""

    c = self

    if self._rootPosition:
        return self._rootPosition.copy()
    else:
        return  c.nullPosition()

# For compatibiility with old scripts.
rootVnode = rootPosition
#@nonl
#@-node:ekr.20040803140033.2:c.rootPosition
#@-node:ekr.20060906211747:Getters
#@+node:ekr.20060906211747.1:Setters
#@+node:ekr.20040315032503:c.appendStringToBody
def appendStringToBody (self,p,s,encoding="utf-8"):

    c = self
    if not s: return

    body = p.bodyString()
    assert(g.isUnicode(body))
    s = g.toUnicode(s,encoding)

    c.setBodyString(p,body + s,encoding)
#@-node:ekr.20040315032503:c.appendStringToBody
#@+node:ekr.20031218072017.2984:c.clearAllMarked
def clearAllMarked (self):

    c = self

    for p in c.allNodes_iter():
        p.v.clearMarked()
#@-node:ekr.20031218072017.2984:c.clearAllMarked
#@+node:ekr.20031218072017.2985:c.clearAllVisited
def clearAllVisited (self):

    c = self

    for p in c.allNodes_iter():
        p.v.clearVisited()
        p.v.t.clearVisited()
        p.v.t.clearWriteBit()
#@-node:ekr.20031218072017.2985:c.clearAllVisited
#@+node:ekr.20060906211138:c.clearMarked
def clearMarked  (self,p):

    c = self
    p.v.clearMarked()
    g.doHook("clear-mark",c=c,p=p,v=p)
#@nonl
#@-node:ekr.20060906211138:c.clearMarked
#@+node:ekr.20040305223522:c.setBodyString
def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)
        # This code destoys all tags, so we must recolor.
        c.recolor()

    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
#@-node:ekr.20040305223522:c.setBodyString
#@+node:ekr.20031218072017.2989:c.setChanged
def setChanged (self,changedFlag):

    c = self
    if not c.frame: return

    # if changedFlag: g.trace('***',g.callers())

    # Clear all dirty bits _before_ setting the caption.
    # Clear all dirty bits except orphaned @file nodes
    if not changedFlag:
        # g.trace("clearing all dirty bits")
        for p in c.allNodes_iter():
            if p.isDirty() and not (p.isAtFileNode() or p.isAtNorefFileNode()):
                p.clearDirty()

    # Update all derived changed markers.
    c.changed = changedFlag
    s = c.frame.getTitle()
    if len(s) > 2 and not c.loading: # don't update while loading.
        if changedFlag:
            if s [0] != '*': c.frame.setTitle("* " + s)
        else:
            if s[0:2]=="* ": c.frame.setTitle(s[2:])
#@-node:ekr.20031218072017.2989:c.setChanged
#@+node:ekr.20040803140033.1:c.setCurrentPosition
def setCurrentPosition (self,p):

    """Set the presently selected position. For internal use only.

    Client code should use c.selectPosition instead."""

    c = self ; cc = c.chapterController

    # g.trace(p.headString(),g.callers())

    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()

        # New in Leo 4.4.2: always recompute the root position here.
        # This *guarantees* that c.rootPosition always returns the proper value.
        newRoot = c.findRootPosition(c._currentPosition)
        if newRoot:
            c.setRootPosition(newRoot)
        # This is *not* an error: newRoot can be None when switching chapters.
        # else: g.trace('******** no new root')
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@nonl
#@-node:ekr.20040803140033.1:c.setCurrentPosition
#@+node:ekr.20040305223225:c.setHeadString
def setHeadString (self,p,s,encoding="utf-8"):

    c = self
    w = c.edit_widget(p) # w only exists for the Tk gui.

    p.initHeadString(s,encoding)

    if w:
        w.setAllText(s)
        width = c.frame.tree.headWidth(p=None,s=s)
        w.setWidth(width)

    p.setDirty()
#@nonl
#@-node:ekr.20040305223225:c.setHeadString
#@+node:ekr.20060109164136:c.setLog
def setLog (self):

    c = self

    if c.exists:
        try:
            # c.frame or c.frame.log may not exist.
            g.app.setLog(c.frame.log)
        except AttributeError:
            pass
#@-node:ekr.20060109164136:c.setLog
#@+node:ekr.20060906211138.1:c.setMarked
def setMarked (self,p):

    c = self
    p.v.setMarked()
    g.doHook("set-mark",c=c,p=p,v=p)
#@nonl
#@-node:ekr.20060906211138.1:c.setMarked
#@+node:ekr.20040803140033.3:c.setRootPosition
def setRootPosition(self,p):

    """Set the root positioin."""

    c = self

    # g.trace(p and p.headString(),g.callers())

    if p:
        # Important: p.equal requires c._rootPosition to be non-None.
        if c._rootPosition and p.equal(c._rootPosition):
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None
#@nonl
#@-node:ekr.20040803140033.3:c.setRootPosition
#@+node:ekr.20060906131836:c.setRootVnode New in 4.4.2
def setRootVnode (self, v):

    c = self
    newRoot = leoNodes.position(v,[])
    c.setRootPosition(newRoot)
#@nonl
#@-node:ekr.20060906131836:c.setRootVnode New in 4.4.2
#@+node:ekr.20040311173238:c.topPosition & c.setTopPosition
def topPosition(self):

    """Return the root position."""

    c = self

    if c._topPosition:
        return c._topPosition.copy()
    else:
        return c.nullPosition()

def setTopPosition(self,p):

    """Set the root positioin."""

    c = self

    if p:
        c._topPosition = p.copy()
    else:
        c._topPosition = c.nullPosition()

# Define these for compatibiility with old scripts.
topVnode = topPosition
setTopVnode = setTopPosition
#@-node:ekr.20040311173238:c.topPosition & c.setTopPosition
#@+node:ekr.20031218072017.3404:c.trimTrailingLines
def trimTrailingLines (self,p):

    """Trims trailing blank lines from a node.

    It is surprising difficult to do this during Untangle."""

    c = self
    body = p.bodyString()
    lines = string.split(body,'\n')
    i = len(lines) - 1 ; changed = False
    while i >= 0:
        line = lines[i]
        j = g.skip_ws(line,0)
        if j + 1 == len(line):
            del lines[i]
            i -= 1 ; changed = True
        else: break
    if changed:
        body = string.join(body,'') + '\n' # Add back one last newline.
        # g.trace(body)
        c.setBodyString(p,body)
        # Don't set the dirty bit: it would just be annoying.
#@nonl
#@-node:ekr.20031218072017.3404:c.trimTrailingLines
#@-node:ekr.20060906211747.1:Setters
#@-node:ekr.20031218072017.2982:Getters & Setters
#@+node:ekr.20031218072017.2990:Selecting & Updating (commands)
#@+node:ekr.20031218072017.2991:c.editPosition
# Selects v: sets the focus to p and edits p.

def editPosition(self,p,selectAll=False):

    c = self ; k = c.k

    if p:
        c.selectPosition(p)
        c.frame.tree.editLabel(p,selectAll=selectAll)

        if k:
            k.setDefaultUnboundKeyAction()
            k.showStateAndMode()
#@-node:ekr.20031218072017.2991:c.editPosition
#@+node:ekr.20031218072017.2992:c.endEditing (calls tree.endEditLabel)
# Ends the editing in the outline.

def endEditing(self):

    c = self
    c.frame.tree.endEditLabel()
#@-node:ekr.20031218072017.2992:c.endEditing (calls tree.endEditLabel)
#@+node:ekr.20031218072017.2997:c.selectPosition
def selectPosition(self,p,updateBeadList=True):

    """Select a new position."""

    c = self

    # g.trace(p.headString(),g.callers())

    c.frame.tree.select(p,updateBeadList)

    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
#@-node:ekr.20031218072017.2997:c.selectPosition
#@+node:ekr.20031218072017.2998:c.selectVnodeWithEditing
# Selects the given node and enables editing of the headline if editFlag is True.

def selectVnodeWithEditing(self,v,editFlag):

    c = self
    if editFlag:
        c.editPosition(v)
    else:
        c.selectVnode(v)

selectPositionWithEditing = selectVnodeWithEditing
#@-node:ekr.20031218072017.2998:c.selectVnodeWithEditing
#@+node:ekr.20060923202156:c.onCanvasKey
def onCanvasKey (self,event):

    '''Navigate to the next headline starting with ch = event.char.
    If ch is uppercase, search all headlines; otherwise search only visible headlines.
    This is modelled on Windows explorer.'''

    if not event or not event.char or not event.keysym.isalnum():
        return
    c  = self ; p = c.currentPosition() ; p1 = p.copy()
    invisible = c.config.getBool('invisible_outline_navigation')
    ch = event.char
    allFlag = ch.isupper() and invisible # all is a global (!?)
    if not invisible: ch = ch.lower()
    found = False
    extend = self.navQuickKey()
    attempts = g.choose(extend,(True,False),(False,))
    for extend2 in attempts:
        p = p1.copy()
        while 1:
            if allFlag:
                p.moveToThreadNext()
            else:
                p.moveToVisNext()
            if not p:
                p = c.rootPosition()
            if p == p1: # Never try to match the same position.
                # g.trace('failed',extend2)
                found = False ; break
            newPrefix = c.navHelper(p,ch,extend2)
            if newPrefix:
                found = True ; break
        if found: break
    if found:
        if allFlag: c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.navTime = time.clock()
        c.navPrefix = newPrefix
        # g.trace('extend',extend,'extend2',extend2,'navPrefix',c.navPrefix,'p',p.headString())
    else:
        c.navTime = None
        c.navPrefix = ''
    c.treeWantsFocusNow()
#@nonl
#@+node:ekr.20061002095711.1:c.navQuickKey
def navQuickKey (self):

    '''return true if there are two quick outline navigation keys
    in quick succession.

    Returns False if @float outline_nav_extend_delay setting is 0.0 or unspecified.'''

    c = self

    deltaTime = c.config.getFloat('outline_nav_extend_delay')

    if deltaTime in (None,0.0):
        return False
    else:
        nearTime = c.navTime and time.clock() - c.navTime < deltaTime
        return nearTime
#@nonl
#@-node:ekr.20061002095711.1:c.navQuickKey
#@+node:ekr.20061002095711:c.navHelper
def navHelper (self,p,ch,extend):

    c = self ; h = p.headString().lower()

    if extend:
        prefix = c.navPrefix + ch
        return h.startswith(prefix.lower()) and prefix

    if h.startswith(ch):
        return ch

    # New feature: search for first non-blank character after @x for common x.
    if ch != '@' and h.startswith('@'):
        for s in ('button','command','file','thin','asis','nosent','noref'):
            prefix = '@'+s
            if h.startswith('@'+s):
                while 1:
                    n = len(prefix)
                    ch2 = n < len(h) and h[n] or ''
                    if ch2.isspace():
                        prefix = prefix + ch2
                    else: break
                if len(prefix) < len(h) and h.startswith(prefix + ch.lower()):
                    return prefix + ch
    return ''
#@nonl
#@-node:ekr.20061002095711:c.navHelper
#@-node:ekr.20060923202156:c.onCanvasKey
#@-node:ekr.20031218072017.2990:Selecting & Updating (commands)
#@+node:ekr.20031218072017.2999:Syntax coloring interface
@ These routines provide a convenient interface to the syntax colorer.
#@+node:ekr.20031218072017.3000:updateSyntaxColorer
def updateSyntaxColorer(self,v):

    self.frame.body.updateSyntaxColorer(v)
#@-node:ekr.20031218072017.3000:updateSyntaxColorer
#@-node:ekr.20031218072017.2999:Syntax coloring interface
#@-node:ekr.20041118104831:class commands
#@+node:ekr.20041118104831.1:class configSettings
class configSettings:

    """A class to hold config settings for commanders."""

    @others
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):

    self.c = c

    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultMenuFontSize = g.app.config.defaultMenuFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize

    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)

    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):

    c = self.c

    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):

    c = self.c

    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    # New in 4.4b3: use the global setting as a last resort.
    if encoding:
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)
    else:
        encoding = getattr(g.app.config,encodingName)
        # g.trace('g.app.config',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041118053731:Getters
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize)

def getRecentFiles (self):
    return g.app.config.getRecentFiles()

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getAbbrevDict(self):         return g.app.config.getAbbrevDict(self.c)
def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getOpenWith  (self):         return g.app.config.getOpenWith (self.c)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting,):return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@-node:ekr.20041118053731:Getters
#@+node:ekr.20041118195812:Setters... (c.configSettings)
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):

    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):

    __pychecker__ = '--no-argsused' # p not used.

    return g.app.config.setString(self.c,setting,val)

setString = set
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters... (c.configSettings)
#@-node:ekr.20041118104831.1:class configSettings
#@-node:ekr.20031218072017.2810:@thin leoCommands.py
#@+node:ekr.20041117062700:@thin leoConfig.py
@language python
@tabwidth -4
@pagewidth 80

<< imports >>

<< class parserBaseClass >>

@others
#@+node:ekr.20041227063801:<< imports >>
import leoGlobals as g
import leoGui

import sys
#@-node:ekr.20041227063801:<< imports >>
#@+node:ekr.20041119203941.2:<< class parserBaseClass >>
class parserBaseClass:

    """The base class for settings parsers."""

    << parserBaseClass data >>

    @others
#@+node:ekr.20041121130043:<< parserBaseClass data >>
# These are the canonicalized names.  Case is ignored, as are '_' and '-' characters.

basic_types = [
    # Headlines have the form @kind name = var
    'bool','color','directory','int','ints',
    'float','path','ratio','shortcut','string','strings']

control_types = [
    'abbrev','enabledplugins','font','if','ifgui','ifplatform','ignore','mode',
    'openwith','page','settings','shortcuts']

# Keys are settings names, values are (type,value) tuples.
settingsDict = {}
#@-node:ekr.20041121130043:<< parserBaseClass data >>
#@+node:ekr.20041119204700: ctor (parserBaseClass)
def __init__ (self,c):

    self.c = c
    self.recentFiles = [] # List of recent files.
    self.shortcutsDict = {}
        # Keys are cononicalized shortcut names, values are bunches.
    self.openWithList = []
        # A list of dicts containing 'name','shortcut','command' keys.

    # Keys are canonicalized names.
    self.dispatchDict = {
        'abbrev':       self.doAbbrev, # New in 4.4.1 b2.
        'bool':         self.doBool,
        'color':        self.doColor,
        'directory':    self.doDirectory,
        'enabledplugins': self.doEnabledPlugins,
        'font':         self.doFont,
        'if':           self.doIf,
        # 'ifgui':        self.doIfGui,  # Removed in 4.4 b3.
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'mode':         self.doMode, # New in 4.4b1.
        'openwith':     self.doOpenWith, # New in 4.4.3 b1.
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        # 'shortcut':     self.doShortcut, # Removed in 4.4.1 b1.
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }
#@-node:ekr.20041119204700: ctor (parserBaseClass)
#@+node:ekr.20060102103625:createModeCommand
def createModeCommand (self,name,modeDict):

    commandName = 'enter-' + name
    commandName = commandName.replace(' ','-')

    # g.trace(name,len(modeDict.keys()))

    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict

    # New in 4.4.1 b2: silently allow redefinitions of modes.
    d [commandName] = modeDict
#@-node:ekr.20060102103625:createModeCommand
#@+node:ekr.20041120103012:error
def error (self,s):

    print s

    # Does not work at present because we are using a null Gui.
    g.es(s,color="blue")
#@-node:ekr.20041120103012:error
#@+node:ekr.20041120094940:kind handlers (parserBaseClass)
#@+node:ekr.20060608221203:doAbbrev
def doAbbrev (self,p,kind,name,val):

    d = {}
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseAbbrevLine(line)
            if name: d [val] = name

    self.set (p,'abbrev','abbrev',d)
#@-node:ekr.20060608221203:doAbbrev
#@+node:ekr.20041120094940.1:doBool
def doBool (self,p,kind,name,val):

    if val in ('True','true','1'):
        self.set(p,kind,name,True)
    elif val in ('False','false','0'):
        self.set(p,kind,name,False)
    else:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041120094940.1:doBool
#@+node:ekr.20041120094940.2:doColor
def doColor (self,p,kind,name,val):

    # At present no checking is done.
    val = val.lstrip('"').rstrip('"')
    val = val.lstrip("'").rstrip("'")

    self.set(p,kind,name,val)
#@-node:ekr.20041120094940.2:doColor
#@+node:ekr.20041120094940.3:doDirectory & doPath
def doDirectory (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)

doPath = doDirectory
#@-node:ekr.20041120094940.3:doDirectory & doPath
#@+node:ekr.20070224075914:doEnabledPlugins
def doEnabledPlugins (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c
    s = p.bodyString()

    # This setting is handled differently from all other settings,
    # because the last setting must be retrieved before any commander exists.

    # g.trace('len(s)',len(s))

    # Set the global config ivars.
    g.app.config.enabledPluginsString = s
    g.app.config.enabledPluginsFileName = c and c.shortFileName() or '<no settings file>'
#@-node:ekr.20070224075914:doEnabledPlugins
#@+node:ekr.20041120094940.6:doFloat
def doFloat (self,p,kind,name,val):

    try:
        val = float(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041120094940.6:doFloat
#@+node:ekr.20041120094940.4:doFont
def doFont (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind not used.

    d = self.parseFont(p)

    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)
#@-node:ekr.20041120094940.4:doFont
#@+node:ekr.20041120103933:doIf
def doIf(self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # args not used.

    g.trace("'if' not supported yet")
    return None
#@-node:ekr.20041120103933:doIf
#@+node:ekr.20041121125416:doIfGui
@ Alas, @if-gui can't be made to work. The problem is that plugins can set
g.app.gui, but plugins need settings so the leoSettings.leo files must be parsed
before g.app.gui.guiName() is known.
@c

if 0:

    def doIfGui (self,p,kind,name,val):

        __pychecker__ = '--no-argsused' # args not used.

        # g.trace(repr(name))

        if not g.app.gui or not g.app.gui.guiName():
            s = '@if-gui has no effect: g.app.gui not defined yet'
            g.es_print(s,color='blue')
            return "skip"
        elif g.app.gui.guiName().lower() == name.lower():
            return None
        else:
            return "skip"
#@-node:ekr.20041121125416:doIfGui
#@+node:ekr.20041120104215:doIfPlatform
def doIfPlatform (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # args not used.

    # g.trace(sys.platform,repr(name))

    if sys.platform.lower() == name.lower():
        return None
    else:
        return "skip"
#@-node:ekr.20041120104215:doIfPlatform
#@+node:ekr.20041120104215.1:doIgnore
def doIgnore(self,p,kind,name,val):

    return "skip"
#@-node:ekr.20041120104215.1:doIgnore
#@+node:ekr.20041120094940.5:doInt
def doInt (self,p,kind,name,val):

    try:
        val = int(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041120094940.5:doInt
#@+node:ekr.20041217132253:doInts
def doInts (self,p,kind,name,val):

    '''We expect either:
    @ints [val1,val2,...]aName=val
    @ints aName[val1,val2,...]=val'''

    name = name.strip() # The name indicates the valid values.
    i = name.find('[')
    j = name.find(']')

    # g.trace(kind,name,val)

    if -1 < i < j:
        items = name[i+1:j]
        items = items.split(',')
        name = name[:i]+name[j+1:].strip()
        # g.trace(name,items)
        try:
            items = [int(item.strip()) for item in items]
        except ValueError:
            items = []
            self.valueError(p,'ints[]',name,val)
            return
        kind = "ints[%s]" % (','.join([str(item) for item in items]))
        try:
            val = int(val)
        except ValueError:
            self.valueError(p,'int',name,val)
            return
        if val not in items:
            self.error("%d is not in %s in %s" % (val,kind,name))
            return

        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
#@-node:ekr.20041217132253:doInts
#@+node:ekr.20060102103625.1:doMode (ParserBaseClass)
def doMode(self,p,kind,name,val):

    '''Parse an @mode node and create the enter-<name>-mode command.'''

    __pychecker__ = '--no-argsused' # val not used.

    c = self.c ; k = c.k

    # g.trace('%20s' % (name),c.fileName())
    << Compute modeName >>

    # Create a local shortcutsDict.
    old_d = self.shortcutsDict
    d = self.shortcutsDict = {}

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if not name:
                # An entry command: put it in the special *entry-commands* key.
                aList = d.get('*entry-commands*',[])
                aList.append(bunch.entryCommandName)
                d ['*entry-commands*'] = aList
            elif bunch is not None:
                # A regular shortcut.
                bunch.val = k.strokeFromSetting(bunch.val)
                bunch.pane = modeName
                bunchList = d.get(name,[])
                # Important: use previous bindings if possible.
                key2,bunchList2 = c.config.getShortcut(name)
                bunchList3 = [b for b in bunchList2 if b.pane != modeName]
                if bunchList3:
                    # g.trace('inheriting',[b.val for b in bunchList3])
                    bunchList.extend(bunchList3)
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)

    # Restore the global shortcutsDict.
    self.shortcutsDict = old_d

    # Create the command, but not any bindings to it.
    self.createModeCommand(modeName,d)
#@+node:ekr.20060618110649:<< Compute modeName >>
name = name.strip().lower()
j = name.find(' ')
if j > -1: name = name[:j]
if name.endswith('mode'):
    name = name[:-4].strip()
if name.endswith('-'):
    name = name[:-1]
modeName = name + '-mode'
#@-node:ekr.20060618110649:<< Compute modeName >>
#@-node:ekr.20060102103625.1:doMode (ParserBaseClass)
#@+node:ekr.20070411101643.1:doOpenWith (ParserBaseClass)
def doOpenWith (self,p,kind,name,val):

    # g.trace('kind',kind,'name',name,'val',val,'c',self.c)

    d = self.parseOpenWith(p)
    d['name']=name
    d['shortcut']=val
    name = kind = 'openwithtable'
    self.openWithList.append(d)
    self.set(p,kind,name,self.openWithList)
#@-node:ekr.20070411101643.1:doOpenWith (ParserBaseClass)
#@+node:ekr.20041120104215.2:doPage
def doPage(self,p,kind,name,val):

    pass # Ignore @page this while parsing settings.
#@-node:ekr.20041120104215.2:doPage
#@+node:ekr.20041121125741:doRatio
def doRatio (self,p,kind,name,val):

    try:
        val = float(val)
        if 0.0 <= val <= 1.0:
            self.set(p,kind,name,val)
        else:
            self.valueError(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041121125741:doRatio
#@+node:ekr.20041120105609:doShortcuts (ParserBaseClass)
def doShortcuts(self,p,kind,name,val,s=None):

    __pychecker__ = '--no-argsused' # kind,val.

    # g.trace(self.c.fileName(),name)

    c = self.c ; d = self.shortcutsDict
    if s is None: s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if bunch is not None:
                # A regular shortcut.
                bunchList = d.get(name,[])
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)
#@-node:ekr.20041120105609:doShortcuts (ParserBaseClass)
#@+node:ekr.20041217132028:doString
def doString (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)
#@-node:ekr.20041217132028:doString
#@+node:ekr.20041120094940.8:doStrings
def doStrings (self,p,kind,name,val):

    '''We expect one of the following:
    @strings aName[val1,val2...]=val
    @strings [val1,val2,...]aName=val'''

    name = name.strip()
    i = name.find('[')
    j = name.find(']')

    if -1 < i < j:
        items = name[i+1:j]
        items = items.split(',')
        items = [item.strip() for item in items]
        name = name[:i]+name[j+1:].strip()
        kind = "strings[%s]" % (','.join(items))
        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
#@-node:ekr.20041120094940.8:doStrings
#@-node:ekr.20041120094940:kind handlers (parserBaseClass)
#@+node:ekr.20041124063257:munge
def munge(self,s):

    return g.app.config.canonicalizeSettingName(s)
#@-node:ekr.20041124063257:munge
#@+node:ekr.20041119204700.2:oops
def oops (self):
    print ("parserBaseClass oops:",
        g.callers(),
        "must be overridden in subclass")
#@-node:ekr.20041119204700.2:oops
#@+node:ekr.20041213082558:parsers
#@+node:ekr.20041213083651:fontSettingNameToFontKind
def fontSettingNameToFontKind (self,name):

    s = name.strip()
    if s:
        for tag in ('_family','_size','_slant','_weight'):
            if s.endswith(tag):
                return tag[1:]

    return None
#@-node:ekr.20041213083651:fontSettingNameToFontKind
#@+node:ekr.20041213082558.1:parseFont & helper
def parseFont (self,p):

    d = {
        'comments': [],
        'family': None,
        'size': None,
        'slant': None,
        'weight': None,
    }

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseFontLine(line,d)

    comments = d.get('comments')
    d['comments'] = '\n'.join(comments)

    return d
#@+node:ekr.20041213082558.2:parseFontLine
def parseFontLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if g.match(s,0,'#'):
        s = s[1:].strip()
        comments = d.get('comments')
        comments.append(s)
        d['comments'] = comments
    else:
        # name is everything up to '='
        i = s.find('=')
        if i == -1:
            name = s ; val = None
        else:
            name = s[:i].strip()
            val = s[i+1:].strip()
            val = val.lstrip('"').rstrip('"')
            val = val.lstrip("'").rstrip("'")

        fontKind = self.fontSettingNameToFontKind(name)
        if fontKind:
            d[fontKind] = name,val # Used only by doFont.
#@-node:ekr.20041213082558.2:parseFontLine
#@-node:ekr.20041213082558.1:parseFont & helper
#@+node:ekr.20041119205148:parseHeadline
def parseHeadline (self,s):

    """Parse a headline of the form @kind:name=val
    Return (kind,name,val)."""

    kind = name = val = None

    if g.match(s,0,'@'):
        i = g.skip_id(s,1,chars='-')
        kind = s[1:i].strip()
        if kind:
            # name is everything up to '='
            j = s.find('=',i)
            if j == -1:
                name = s[i:].strip()
            else:
                name = s[i:j].strip()
                # val is everything after the '='
                val = s[j+1:].strip()

    # g.trace("%50s %10s %s" %(name,kind,val))
    return kind,name,val
#@-node:ekr.20041119205148:parseHeadline
#@+node:ekr.20070411101643.2:parseOpenWith & helper
def parseOpenWith (self,p):

    d = {'command': None,}

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseOpenWithLine(line,d)

    return d
#@+node:ekr.20070411101643.4:parseOpenWithLine
def parseOpenWithLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if not g.match(s,0,'#'):
        d['command'] = s
#@-node:ekr.20070411101643.4:parseOpenWithLine
#@-node:ekr.20070411101643.2:parseOpenWith & helper
#@+node:ekr.20041120112043:parseShortcutLine (g.app.config)
def parseShortcutLine (self,s):

    '''Parse a shortcut line.  Valid forms:

    --> entry-command
    settingName = shortcut
    settingName ! paneName = shortcut
    command-name -> mode-name = binding
    command-name -> same = binding
    '''

    name = val = nextMode = None ; nextMode = 'none'
    i = g.skip_ws(s,0)

    if g.match(s,i,'-->'): # New in 4.4.1 b1: allow mode-entry commands.
        j = g.skip_ws(s,i+3)
        i = g.skip_id(s,j,'-')
        entryCommandName = s[j:i]
        return None,g.Bunch(entryCommandName=entryCommandName)

    j = i
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None

    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'->'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]

    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]

    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i > 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(nextMode=nextMode,pane=pane,val=val)
#@-node:ekr.20041120112043:parseShortcutLine (g.app.config)
#@+node:ekr.20060608222828:parseAbbrevLine (g.app.config)
def parseAbbrevLine (self,s):

    '''Parse an abbreviation line:
    command-name = abbreviation
    return (command-name,abbreviation)
    '''

    i = j = g.skip_ws(s,0)
    i = g.skip_id(s,i,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None

    i = g.skip_ws(s,i)
    if not g.match(s,i,'='): return None,None

    i = g.skip_ws(s,i+1)
    val = s[i:].strip()
    # Ignore comments after the shortcut.
    i = val.find('#')
    if i > -1: val = val[:i].strip()

    if val: return name,val
    else:   return None,None
#@-node:ekr.20060608222828:parseAbbrevLine (g.app.config)
#@-node:ekr.20041213082558:parsers
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):

    """Init the setting for name to val."""

    __pychecker__ = '--no-argsused' # p used in subclasses, not here.

    c = self.c ; key = self.munge(name)
    # if kind and kind.startswith('setting'): g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d [key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')

#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041227071423:setShortcut (ParserBaseClass)
def setShortcut (self,name,bunch):

    c = self.c

    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&','')
    self.set(c,rawKey,"shortcut",bunch)

    # g.trace(bunch.pane,rawKey,bunch.val)
#@-node:ekr.20041227071423:setShortcut (ParserBaseClass)
#@+node:ekr.20041119204700.1:traverse (parserBaseClass)
def traverse (self):

    c = self.c

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    self.shortcutsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # g.trace(result,p.headString())
        if result == "skip":
            if 0:
                s = 'skipping settings in %s' % p.headString()
                g.es_print(s,color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    return self.settingsDict
#@-node:ekr.20041119204700.1:traverse (parserBaseClass)
#@+node:ekr.20041120094940.10:valueError
def valueError (self,p,kind,name,val):

    """Give an error: val is not valid for kind."""

    __pychecker__ = '--no-argsused' # p not used, but needed.

    self.error("%s is not a valid %s for %s" % (val,kind,name))
#@-node:ekr.20041120094940.10:valueError
#@+node:ekr.20041119204700.3:visitNode (must be overwritten in subclasses)
def visitNode (self,p):

    __pychecker__ = '--no-argsused' # p not used, but needed.

    self.oops()
#@-node:ekr.20041119204700.3:visitNode (must be overwritten in subclasses)
#@-node:ekr.20041119203941.2:<< class parserBaseClass >>
#@+node:ekr.20041119203941:class configClass
class configClass:
    """A class to manage configuration settings."""
    << class data >>
    @others
#@+node:ekr.20041122094813:<<  class data >>
@others

# List of dictionaries to search.  Order not too important.
dictList = [ivarsDict,encodingIvarsDict,defaultsDict]

# Keys are commanders.  Values are optionsDicts.
localOptionsDict = {}

localOptionsList = []

# Keys are setting names, values are type names.
warningsDict = {} # Used by get() or allies.
#@+node:ekr.20041117062717.1:defaultsDict
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultMenuFontSize = g.choose(sys.platform=="win32",9,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {'_hash':'defaultsDict'}

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    ("default_target_language","language","python"),
    ("target_language","language","python"), # Bug fix: 6/20,2005.
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","string","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)
#@-node:ekr.20041117062717.1:defaultsDict
#@+node:ekr.20041118062709:define encodingIvarsDict
encodingIvarsDict = {'_hash':'encodingIvarsDict'}

encodingIvarsData = (
    ("default_derived_file_encoding","string","utf-8"),
    ("new_leo_file_encoding","string","UTF-8"),
        # Upper case for compatibility with previous versions.
    ("tkEncoding","string",None),
        # Defaults to None so it doesn't override better defaults.
)
#@-node:ekr.20041118062709:define encodingIvarsDict
#@+node:ekr.20041117072055:ivarsDict
# Each of these settings sets the corresponding ivar.
# Also, the c.configSettings settings class inits the corresponding commander ivar.
ivarsDict = {'_hash':'ivarsDict'}

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("target_language","language","python"), # Bug fix: added: 6/20/2005.
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",True),
        # New in 4.3: use_plugins = True by default.
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
#@-node:ekr.20041117072055:ivarsDict
#@-node:ekr.20041122094813:<<  class data >>
#@+node:ekr.20041117083202:Birth... (g.app.config)
#@+node:ekr.20041117062717.2:ctor (configClass)
def __init__ (self):

    self.configsExist = False # True when we successfully open a setting file.
    self.defaultFont = None # Set in gui.getDefaultConfigFont.
    self.defaultFontFamily = None # Set in gui.getDefaultConfigFont.
    self.enabledPluginsFileName = None
    self.enabledPluginsString = '' 
    self.globalConfigFile = None # Set in initSettingsFiles
    self.homeFile = None # Set in initSettingsFiles
    self.inited = False
    self.modeCommandsDict = {} # For use by @mode logic. Keys are command names, values are g.Bunches.
    self.myGlobalConfigFile = None
    self.myHomeConfigFile = None
    self.recentFilesFiles = [] # List of g.Bunches describing .leoRecentFiles.txt files.
    self.write_recent_files_as_needed = False # Will be set later.

    # Inited later...
    self.panes = None
    self.sc = None
    self.tree = None

    self.initDicts()
    self.initIvarsFromSettings()
    self.initSettingsFiles()
    self.initRecentFiles()
#@-node:ekr.20041117062717.2:ctor (configClass)
#@+node:ekr.20041227063801.2:initDicts
def initDicts (self):

    # Only the settings parser needs to search all dicts.
    self.dictList = [self.defaultsDict]

    for key,kind,val in self.defaultsData:
        self.defaultsDict[self.munge(key)] = g.Bunch(
            setting=key,kind=kind,val=val,tag='defaults')

    for key,kind,val in self.ivarsData:
        self.ivarsDict[self.munge(key)] = g.Bunch(
            ivar=key,kind=kind,val=val,tag='ivars')

    for key,kind,val in self.encodingIvarsData:
        self.encodingIvarsDict[self.munge(key)] = g.Bunch(
            ivar=key,kind=kind,encoding=val,tag='encodings')
#@-node:ekr.20041227063801.2:initDicts
#@+node:ekr.20041117065611.2:initIvarsFromSettings & helpers
def initIvarsFromSettings (self):

    for ivar in self.encodingIvarsDict.keys():
        if ivar != '_hash':
            self.initEncoding(ivar)

    for ivar in self.ivarsDict.keys():
        if ivar != '_hash':
            self.initIvar(ivar)
#@+node:ekr.20041117065611.1:initEncoding
def initEncoding (self,key):

    '''Init g.app.config encoding ivars during initialization.'''

    # N.B. The key is munged.
    bunch = self.encodingIvarsDict.get(key)
    encoding = bunch.encoding
    ivar = bunch.ivar
    # g.trace('g.app.config',ivar,encoding)
    setattr(self,ivar,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("g.app.config: bad encoding: %s: %s" % (ivar,encoding))
#@-node:ekr.20041117065611.1:initEncoding
#@+node:ekr.20041117065611:initIvar
def initIvar(self,key):

    '''Init g.app.config ivars during initialization.

    This does NOT init the corresponding commander ivars.

    Such initing must be done in setIvarsFromSettings.'''

    # N.B. The key is munged.
    bunch = self.ivarsDict.get(key)
    ivar = bunch.ivar # The actual name of the ivar.
    val = bunch.val

    # g.trace('g.app.config',ivar,key,val)
    setattr(self,ivar,val)
#@-node:ekr.20041117065611:initIvar
#@-node:ekr.20041117065611.2:initIvarsFromSettings & helpers
#@+node:ekr.20041117083202.2:initRecentFiles
def initRecentFiles (self):

    self.recentFiles = []
#@-node:ekr.20041117083202.2:initRecentFiles
#@+node:ekr.20041117083857:initSettingsFiles
def initSettingsFiles (self):

    """Set self.globalConfigFile, self.homeFile and self.myConfigFile."""

    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'

    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        else:
            setattr(self,ivar,None)
    if 0:
        g.trace('global file:',self.globalConfigFile)
        g.trace('home file:',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:',self.myHomeConfigFile)
#@nonl
#@-node:ekr.20041117083857:initSettingsFiles
#@-node:ekr.20041117083202:Birth... (g.app.config)
#@+node:ekr.20041117081009:Getters... (g.app.config)
#@+node:ekr.20041123070429:canonicalizeSettingName (munge)
def canonicalizeSettingName (self,name):

    if name is None:
        return None

    name = name.lower()
    for ch in ('-','_',' ','\n'):
        name = name.replace(ch,'')

    return g.choose(name,name,None)

munge = canonicalizeSettingName
#@-node:ekr.20041123070429:canonicalizeSettingName (munge)
#@+node:ekr.20041123092357:config.findSettingsPosition
def findSettingsPosition (self,c,setting):

    """Return the position for the setting in the @settings tree for c."""

    munge = self.munge

    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()

    setting = munge(setting)

    for p in root.subtree_iter():
        h = munge(p.headString())
        if h == setting:
            return p.copy()

    return c.nullPosition()
#@-node:ekr.20041123092357:config.findSettingsPosition
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):

    """Get the setting and make sure its type matches the expected type."""

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val

    for d in self.localOptionsList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    return None
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,warn=True):

    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    bunch = d.get(self.munge(setting))
    if not bunch: return None,False

    # g.trace(setting,requestedType,bunch.toString())
    val = bunch.val
    if not self.typesMatch(bunch.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            s = (
                'Warning: ignoring %s:%s not %s\n' +
                'There may be conflicting settings!')
            g.es_print(s % (bunch.kind,setting,requestedType),color='red')
            # g.trace(g.callers())
        return None, False
    elif val in (u'None',u'none','None','none','',None):
        return None, True # Exists, but is None
    else:
        # g.trace(setting,val)
        return val, True
#@-node:ekr.20041121143823:getValFromDict
#@+node:ekr.20051015093141:typesMatch
def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything.
    - Shortcut matches shortcuts.
    '''

    shortcuts = ('shortcut','shortcuts',)

    return (
        type1 == None or type2 == None or
        type1.startswith('string') or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
#@-node:ekr.20051015093141:typesMatch
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@+node:ekr.20051011105014:exists (g.app.config)
def exists (self,c,setting,kind):

    '''Return true if a setting of the given kind exists, even if it is None.'''

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            junk,found = self.getValFromDict(d,setting,kind)
            if found: return True

    for d in self.localOptionsList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    for d in self.dictList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    # g.trace('does not exist',setting,kind)
    return False
#@-node:ekr.20051011105014:exists (g.app.config)
#@+node:ekr.20060608224112:getAbbrevDict
def getAbbrevDict (self,c):

    """Search all dictionaries for the setting & check it's type"""

    d = self.get(c,'abbrev','abbrev')
    return d or {}
#@-node:ekr.20060608224112:getAbbrevDict
#@+node:ekr.20041117081009.3:getBool
def getBool (self,c,setting,default=None):

    """Search all dictionaries for the setting & check it's type"""

    val = self.get(c,setting,"bool")

    if val in (True,False):
        return val
    else:
        return default
#@-node:ekr.20041117081009.3:getBool
#@+node:ekr.20041122070339:getColor
def getColor (self,c,setting):

    """Search all dictionaries for the setting & check it's type"""

    return self.get(c,setting,"color")
#@-node:ekr.20041122070339:getColor
#@+node:ekr.20041117093009.1:getDirectory
def getDirectory (self,c,setting):

    """Search all dictionaries for the setting & check it's type"""

    theDir = self.getString(c,setting)

    if g.os_path_exists(theDir) and g.os_path_isdir(theDir):
         return theDir
    else:
        return None
#@-node:ekr.20041117093009.1:getDirectory
#@+node:ekr.20070224075914.1:getEnabledPlugins
def getEnabledPlugins (self):

    """Search all dictionaries for the setting & check it's type"""

    return g.app.config.enabledPluginsString
#@-node:ekr.20070224075914.1:getEnabledPlugins
#@+node:ekr.20041117082135:getFloat
def getFloat (self,c,setting):

    """Search all dictionaries for the setting & check it's type"""

    val = self.get(c,setting,"float")
    try:
        val = float(val)
        return val
    except TypeError:
        return None
#@-node:ekr.20041117082135:getFloat
#@+node:ekr.20041117062717.13:getFontFromParams (config)
def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize

    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"

    # g.trace(g.callers(3),family,size,slant,weight,g.shortFileName(c.mFileName))

    return g.app.gui.getFontFromParams(family,size,slant,weight)
#@-node:ekr.20041117062717.13:getFontFromParams (config)
#@+node:ekr.20041117081513:getInt
def getInt (self,c,setting):

    """Search all dictionaries for the setting & check it's type"""

    val = self.get(c,setting,"int")
    try:
        val = int(val)
        return val
    except TypeError:
        return None
#@-node:ekr.20041117081513:getInt
#@+node:ekr.20041117093009.2:getLanguage
def getLanguage (self,c,setting):

    """Return the setting whose value should be a language known to Leo."""

    language = self.getString(c,setting)
    # g.trace(setting,language)

    return language
#@-node:ekr.20041117093009.2:getLanguage
#@+node:ekr.20070411101643:getOpenWith
def getOpenWith (self,c):

    """Search all dictionaries for the setting & check it's type"""

    val = self.get(c,'openwithtable','openwithtable')

    return val
#@-node:ekr.20070411101643:getOpenWith
#@+node:ekr.20041122070752:getRatio
def getRatio (self,c,setting):

    """Search all dictionaries for the setting & check it's type"""

    val = self.get(c,setting,"ratio")
    try:
        val = float(val)
        if 0.0 <= val <= 1.0:
            return val
        else:
            return None
    except TypeError:
        return None
#@-node:ekr.20041122070752:getRatio
#@+node:ekr.20041117062717.11:getRecentFiles
def getRecentFiles (self):

    return self.recentFiles
#@-node:ekr.20041117062717.11:getRecentFiles
#@+node:ekr.20041117062717.14:getShortcut (config)
def getShortcut (self,c,shortcutName):

    '''Return rawKey,accel for shortcutName'''

    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&','') # Allow '&' in names.

    bunchList = self.get(c,key,"shortcut")
    if bunchList:
        bunchList = [bunch for bunch in bunchList
            if bunch.val and bunch.val.lower() != 'none']
        return key,bunchList
    else:
        return key,[]
#@-node:ekr.20041117062717.14:getShortcut (config)
#@+node:ekr.20041117081009.4:getString
def getString (self,c,setting):

    """Search all dictionaries for the setting & check it's type"""

    return self.get(c,setting,"string")
#@-node:ekr.20041117081009.4:getString
#@+node:ekr.20041117062717.17:setCommandsIvars
# Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsIvars (self,c):

    data = (
        ("default_tangle_directory","tangle_directory","directory"),
        ("default_target_language","target_language","language"),
        ("output_doc_chunks","output_doc_flag","bool"),
        ("page_width","page_width","int"),
        ("run_tangle_done.py","tangle_batch_flag","bool"),
        ("run_untangle_done.py","untangle_batch_flag","bool"),
        ("tab_width","tab_width","int"),
        ("tangle_outputs_header","use_header_flag","bool"),
    )

    for setting,ivar,theType in data:
        val = g.app.config.get(c,setting,theType)
        if val is None:
            if not hasattr(c,setting):
                setattr(c,setting,None)
                # g.trace(setting,None)
        else:
            setattr(c,setting,val)
            # g.trace(setting,val)
#@-node:ekr.20041117062717.17:setCommandsIvars
#@+node:ekr.20041120074536:settingsRoot
def settingsRoot (self,c):

    # g.trace(c,c.rootPosition())

    for p in c.allNodes_iter():
        if p.headString().rstrip() == "@settings":
            return p.copy()
    else:
        return c.nullPosition()
#@-node:ekr.20041120074536:settingsRoot
#@-node:ekr.20041117081009:Getters... (g.app.config)
#@+node:ekr.20041118084146:Setters (g.app.config)
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):

    '''Set the setting.  Not called during initialization.'''

    # if kind.startwith('setting'): g.trace(val)

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041118084241:setString
def setString (self,c,setting,val):

    self.set(c,setting,"string",val)
#@-node:ekr.20041118084241:setString
#@+node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.

    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''

    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)
#@-node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
#@+node:ekr.20041201080436:appendToRecentFiles (g.app.config)
def appendToRecentFiles (self,files):

    files = [theFile.strip() for theFile in files]

    # g.trace(files)

    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@-node:ekr.20041201080436:appendToRecentFiles (g.app.config)
#@-node:ekr.20041118084146:Setters (g.app.config)
#@+node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print()
                print s
                g.app.logWaiting.append((s+'\n','blue'),)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(path,initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):

    """Read settings from a file that may contain an @settings tree."""

    # g.trace(c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@-node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20050424114937.1:Reading and writing .leoRecentFiles.txt (g.app.config)
#@+node:ekr.20070224115832:readRecentFiles & helpers
def readRecentFiles (self,localConfigFile):

    '''Read all .leoRecentFiles.txt files.'''

    # The order of files in this list affects the order of the recent files list.
    seen = [] 
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (
        g.app.homeDir,
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path and path not in seen:
            ok = self.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and self.write_recent_files_as_needed:
        self.createRecentFiles()
#@nonl
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created %s' % (fileName),color='red')
                return
            except Exception:
                g.es_print('can not create %s' % (fileName),color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424115658:readRecentFilesFile
def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:

        print ('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)

    return ok
#@nonl
#@-node:ekr.20050424115658:readRecentFilesFile
#@-node:ekr.20070224115832:readRecentFiles & helpers
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
recentFileMessageWritten = False

def writeRecentFilesFile (self,c):

    '''Write the appropriate .leoRecentFiles.txt file.'''

    tag = '.leoRecentFiles.txt'

    if g.app.unitTesting:
        return

    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None

    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                if not self.recentFileMessageWritten:
                    self.recentFileMessageWritten = True
                    print ('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)

    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass

    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()

    if theFile:
        theFile.close()
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@-node:ekr.20050424114937.1:Reading and writing .leoRecentFiles.txt (g.app.config)
#@+node:ekr.20070418073400:g.app.config.printSettings & helper
def printSettings (self,c):

    '''Prints the value of every setting, except key bindings and commands and open-with tables.
    The following letters indicate where the active setting came from:

    - D indicates default settings.
    - F indicates the file being loaded,
    - L indicates leoSettings.leo,
    - M indicates myLeoSettings.leo,
    '''

    settings = {} # Keys are setting names, values are (letter,val)

    if c:
        d = self.localOptionsDict.get(c.hash())
        self.printSettingsHelper(settings,d,letter='[F]')

    for d in self.localOptionsList:
        self.printSettingsHelper(settings,d)

    for d in self.dictList:
        self.printSettingsHelper(settings,d)

    keys = settings.keys() ; keys.sort()
    for key in keys:
        data = settings.get(key)
        letter,val = data
        print '%45s = %s %s' % (key,letter,val)
        g.es('%s %s = %s' % (letter,key,val))
#@nonl
#@+node:ekr.20070418075804:printSettingsHelper
def printSettingsHelper(self,settings,d,letter=None):

    suppressKind = ('shortcut','shortcuts','openwithtable')
    suppressKeys = (None,'_hash','shortcut')

    if d:
        << set letter >>
        for key in d.keys():
            if key not in suppressKeys and key not in settings.keys():
                bunch = d.get(key)
                if bunch.kind not in suppressKind:
                    settings[key] = (letter,bunch.val)
#@nonl
#@+node:ekr.20070418084502:<< set letter >>
theHash = d.get('_hash').lower()

if letter:
    pass
elif theHash.endswith('myleosettings.leo'):
    letter = '[M]'
elif theHash.endswith('leosettings.leo'):
    letter = ' ' * 3
else:
    letter = '[D]'

# g.trace(letter,theHash)
#@nonl
#@-node:ekr.20070418084502:<< set letter >>
#@-node:ekr.20070418075804:printSettingsHelper
#@-node:ekr.20070418073400:g.app.config.printSettings & helper
#@-node:ekr.20041119203941:class configClass
#@+node:ekr.20041119203941.3:class settingsTreeParser (parserBaseClass)
class settingsTreeParser (parserBaseClass):

    '''A class that inits settings found in an @settings tree.

    Used by read settings logic.'''

    @others
#@+node:ekr.20041119204103:ctor
def __init__ (self,c):

    # Init the base class.
    parserBaseClass.__init__(self,c)
#@-node:ekr.20041119204103:ctor
#@+node:ekr.20041119204714:visitNode (settingsTreeParser)
def visitNode (self,p):

    """Init any settings found in node p."""

    # g.trace(p.headString())

    munge = g.app.config.munge

    kind,name,val = self.parseHeadline(p.headString())
    kind = munge(kind)

    if kind == "settings":
        pass
    elif kind not in self.control_types and val in (u'None',u'none','None','none','',None):
        # None is valid for all data types.
        self.set(p,kind,name,None)
    elif kind in self.control_types or kind in self.basic_types:
        f = self.dispatchDict.get(kind)
        try:
            return f(p,kind,name,val)
        except TypeError:
            g.es_exception()
            print "*** no handler",kind
    elif name:
        # self.error("unknown type %s for setting %s" % (kind,name))
        # Just assume the type is a string.
        self.set(p,kind,name,val)

    return None
#@-node:ekr.20041119204714:visitNode (settingsTreeParser)
#@-node:ekr.20041119203941.3:class settingsTreeParser (parserBaseClass)
#@-node:ekr.20041117062700:@thin leoConfig.py
#@+node:ekr.20050710142719:@thin leoEditCommands.py
@first # -*- coding: utf-8 -*-

'''Basic editor commands for Leo.

Modelled after Emacs and Vim commands.'''

### from __future__ import generators # To make Leo work with Python 2.2

<< imports >>

<< define class baseEditCommandsClass >>

@others

<< define classesList >>
#@+node:ekr.20050710151017:<< imports >>
# __pychecker__ = '--no-import'

import leoGlobals as g

import leoFind
import leoKeys
import leoPlugins
import leoTest

import cPickle
import difflib
import os
import re
import string
import sys

subprocess     = g.importExtension('subprocess',    pluginName=None,verbose=False)

# The following imports is sometimes used.
__pychecker__ = '--no-import'
import threading
#@-node:ekr.20050710151017:<< imports >>
#@+node:ekr.20050920084036.1:<< define class baseEditCommandsClass >>
class baseEditCommandsClass:

    '''The base class for all edit command classes'''

    @others
#@+node:ekr.20050920084036.2: ctor, finishCreate, init (baseEditCommandsClass)
def __init__ (self,c):

    self.c = c
    self.k = self.k = None
    self.registers = {} # To keep pychecker happy.
    self.undoData = None

def finishCreate(self):

    # Class delegators.
    self.k = self.k = self.c.k
    try:
        self.w = self.c.frame.body.bodyCtrl # New in 4.4a4.
    except AttributeError:
        self.w = None

def init (self):

    '''Called from k.keyboardQuit to init all classes.'''

    pass
#@nonl
#@-node:ekr.20050920084036.2: ctor, finishCreate, init (baseEditCommandsClass)
#@+node:ekr.20051214132256:begin/endCommand
#@+node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
def beginCommand (self,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
#@+node:ekr.20051215102349:beingCommandHelper
# New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  w.getSelectionRange()
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
    else:
        self.undoData = None

    return w
#@-node:ekr.20051215102349:beingCommandHelper
#@-node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
#@+node:ekr.20051214133130.1:endCommand
# New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):

    '''Do the common processing at the end of each command.'''

    c = self.c ; b = self.undoData ; k = self.k

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)

    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()

    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
#@-node:ekr.20051214133130.1:endCommand
#@-node:ekr.20051214132256:begin/endCommand
#@+node:ekr.20061007105001:editWidget
def editWidget (self,event):

    c = self.c ; w = event and event.widget

    if w and g.app.gui.isTextWidget(w):
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    if self.w:
        c.widgetWantsFocusNow(self.w)

    return self.w
#@nonl
#@-node:ekr.20061007105001:editWidget
#@+node:ekr.20050920084036.5:getPublicCommands & getStateCommands
def getPublicCommands (self):

    '''Return a dict describing public commands implemented in the subclass.
    Keys are untranslated command names.  Values are methods of the subclass.'''

    return {}
#@-node:ekr.20050920084036.5:getPublicCommands & getStateCommands
#@+node:ekr.20050920084036.6:getWSString
def getWSString (self,s):

    return ''.join([g.choose(ch=='\t',ch,' ') for ch in s])
#@-node:ekr.20050920084036.6:getWSString
#@+node:ekr.20050920084036.7:oops
def oops (self):

    print("baseEditCommandsClass oops:",
        g.callers(),
        "must be overridden in subclass")
#@-node:ekr.20050920084036.7:oops
#@+node:ekr.20050929161635:Helpers
#@+node:ekr.20050920084036.249:_chckSel
def _chckSel (self,event,warning='no selection'):

    c = self.c ; k = self.k

    w = self.editWidget(event)

    val = w and w.hasSelection()

    if warning and not val:
        k.setLabelGrey(warning)

    return val
#@-node:ekr.20050920084036.249:_chckSel
#@+node:ekr.20050920084036.250:_checkIfRectangle
def _checkIfRectangle (self,event):

    k = self.k ; key = event.keysym.lower()

    val = self.registers.get(key)

    if val and type(val) == type([]):
        k.clearState()
        k.setLabelGrey("Register contains Rectangle, not text")
        return True

    return False
#@-node:ekr.20050920084036.250:_checkIfRectangle
#@+node:ekr.20050920084036.233:getRectanglePoints
def getRectanglePoints (self,w):

    c = self.c
    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    r1,r2 = g.convertPythonIndexToRowCol(s,i)
    r3,r4 = g.convertPythonIndexToRowCol(s,j)

    return r1+1,r2,r3+1,r4
#@-node:ekr.20050920084036.233:getRectanglePoints
#@+node:ekr.20051002090441:keyboardQuit
def keyboardQuit (self,event):

    '''Clear the state and the minibuffer label.'''

    return self.k.keyboardQuit(event)
#@-node:ekr.20051002090441:keyboardQuit
#@-node:ekr.20050929161635:Helpers
#@-node:ekr.20050920084036.1:<< define class baseEditCommandsClass >>
#@+node:ekr.20050924100713: Module level...
#@+node:ekr.20050920084720:createEditCommanders (leoEditCommands module)
def createEditCommanders (c):

    '''Create edit classes in the commander.'''

    global classesList

    for name, theClass in classesList:
        theInstance = theClass(c)# Create the class.
        setattr(c,name,theInstance)
        # g.trace(name,theInstance)
#@-node:ekr.20050920084720:createEditCommanders (leoEditCommands module)
#@+node:ekr.20050922104731:finishCreateEditCommanders (leoEditCommands module)
def finishCreateEditCommanders (c):

    '''Finish creating edit classes in the commander.

    Return the commands dictionary for all the classes.'''

    global classesList

    d = {}

    for name, theClass in classesList:
        theInstance = getattr(c,name)
        theInstance.finishCreate()
        theInstance.init()
        d2 = theInstance.getPublicCommands()
        if d2:
            d.update(d2)
            if 0:
                keys = d2.keys()
                keys.sort()
                print '----- %s' % name
                for key in keys: print

    return d
#@-node:ekr.20050922104731:finishCreateEditCommanders (leoEditCommands module)
#@+node:ekr.20050924100713.1:initAllEditCommanders
def initAllEditCommanders (c):

    '''Re-init classes in the commander.'''

    global classesList

    for name, theClass in classesList:
        theInstance = getattr(c,name)
        theInstance.init()
#@-node:ekr.20050924100713.1:initAllEditCommanders
#@-node:ekr.20050924100713: Module level...
#@+node:ekr.20050920085536.84:class Tracker (an iterator)
class Tracker:

    '''An iterator class to allow the user to cycle through and change a list.'''

    @others
#@+node:ekr.20050920085536.85:init
def __init__ (self):

    self.tablist = []
    self.prefix = None 
    self.ng = self._next()
#@-node:ekr.20050920085536.85:init
#@+node:ekr.20050920085536.86:setTabList
def setTabList (self,prefix,tlist):

    self.prefix = prefix 
    self.tablist = tlist
#@-node:ekr.20050920085536.86:setTabList
#@+node:ekr.20050920085536.87:_next
def _next (self):

    while 1:
        tlist = self.tablist 
        if not tlist:yield ''
        for z in self.tablist:
            if tlist!=self.tablist:
                break 
            yield z
#@-node:ekr.20050920085536.87:_next
#@+node:ekr.20050920085536.88:next
def next (self):

    return self.ng.next()
#@-node:ekr.20050920085536.88:next
#@+node:ekr.20050920085536.89:clear
def clear (self):

    self.tablist = []
    self.prefix = None
#@-node:ekr.20050920085536.89:clear
#@-node:ekr.20050920085536.84:class Tracker (an iterator)
#@+node:ekr.20050920084036.13:abbrevCommandsClass (test)
@

type some text, set its abbreviation with Control-x a i g, type the text for abbreviation expansion
type Control-x a e ( or Alt-x expand-abbrev ) to expand abbreviation
type Alt-x abbrev-on to turn on automatic abbreviation expansion
Alt-x abbrev-on to turn it off

an example:
type:
frogs
after typing 's' type Control-x a i g.  This will turn the miniBuffer blue, type in your definition. For example: turtles.

Now in the buffer type:
frogs
after typing 's' type Control-x a e.  This will turn the 'frogs' into:
turtles
@c

class abbrevCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20050920084036.14: ctor & finishCreate
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    # Set local ivars.
    self.abbrevs ={}
    self.daRanges = []
    self.event = None
    self.dynaregex = re.compile(
        r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # Not a unicode problem.
        # For dynamic abbreviations
    self.globalDynamicAbbrevs = c.config.getBool('globalDynamicAbbrevs')
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.w = None

def finishCreate(self):

    baseEditCommandsClass.finishCreate(self)
#@-node:ekr.20050920084036.14: ctor & finishCreate
#@+node:ekr.20050920084036.15: getPublicCommands & getStateCommands
def getPublicCommands (self):

    return {
        # 'expand-abbrev':              self.expandAbbrev, # Not a command.

        # Dynamic...
        'dabbrev-completion':           self.dynamicCompletion,
        'dabbrev-expands':              self.dynamicExpansion,

        # Static...
        'abbrev-mode':                  self.toggleAbbrevMode,
        'add-global-abbrev':            self.addAbbreviation,
        'expand-region-abbrevs':        self.regionalExpandAbbrev,
        'inverse-add-global-abbrev':    self.addInverseAbbreviation,
        'kill-all-abbrevs':             self.killAllAbbrevs,
        'list-abbrevs':                 self.listAbbrevs,
        'read-abbrev-file':             self.readAbbreviations,
        'write-abbrev-file':            self.writeAbbreviations,
    }
#@-node:ekr.20050920084036.15: getPublicCommands & getStateCommands
#@+node:ekr.20050920084036.58:dynamic abbreviation...
#@+node:ekr.20050920084036.60:dynamicCompletion
def dynamicCompletion (self,event=None):

    '''Insert the common prefix of all dynamic abbrev's matching the present word.
    This corresponds to C-M-/ in Emacs.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getWord(s,ins)
    txt = w.get(i,j)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    if rlist:
        prefix = reduce(g.longestCommonPrefix,rlist)
        if prefix:
            w.delete(i,j)
            w.insert(i,prefix)
#@-node:ekr.20050920084036.60:dynamicCompletion
#@+node:ekr.20050920084036.59:dynamicExpansion
def dynamicExpansion (self,event=None):

    '''Expand the word in the buffer before point as a dynamic abbrev,
    by searching in the buffer for words starting with that abbreviation (dabbrev-expand).
    This corresponds to M-/ in Emacs.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() not in ('null','tkinter'):
        return g.es('command not ready yet',color='blue')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getWord(s,ins)
    txt = w.get(i,j)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    if not rlist: return
    prefix = reduce(g.longestCommonPrefix,rlist)
    if prefix and prefix != txt:
        w.delete(i,j)
        w.insert(i,prefix)
    else:
        self.dynamicExpandHelper(prefix,rlist,w)
#@+node:ekr.20070605110441:dynamicExpandHelper
def dynamicExpandHelper (self,prefix=None,rlist=None,w=None):

    k = self.k ; tag = 'dabbrev-expand'
    state = k.getState(tag)

    if state == 0:
        self.w = w
        names = rlist ; event = None
        prefix2 = 'dabbrev-expand: '
        k.setLabelBlue(prefix2+prefix,protect=True)
        k.getArg(event,tag,1,self.dynamicExpandHelper,prefix=prefix2,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            w = self.w
            s = w.getAllText()
            ins = w.getInsertPoint()
            i,j = g.getWord(s,ins)
            w.delete(i,j)
            w.insert(i,k.arg)

#@-node:ekr.20070605110441:dynamicExpandHelper
#@-node:ekr.20050920084036.59:dynamicExpansion
#@+node:ekr.20050920084036.61:getDynamicList (helper)
def getDynamicList (self,w,txt,rlist):

    items = []
    if self.globalDynamicAbbrevs:
        for p in self.c.allNodes_iter():
            s = p.bodyString()
            if s:
                items.extend(self.dynaregex.findall(s))
    else:
        # Make a big list of what we are considering a 'word'
        s = w.getAllText()
        items.append(self.dynaregex.findall(s))

    # g.trace('txt',repr(txt),'len(items)',len(items))

    if items:
        for word in items:
             if not word.startswith(txt) or word == txt:
                 continue
                # dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)

    # g.trace('rlist',rlist)
#@-node:ekr.20050920084036.61:getDynamicList (helper)
#@-node:ekr.20050920084036.58:dynamic abbreviation...
#@+node:ekr.20070531103114:static abbrevs
#@+node:ekr.20050920084036.25:addAbbreviation
def addAbbreviation (self,event):

    '''Add an abbreviation:
    The selected text is the abbreviation;
    the minibuffer prompts you for the name of the abbreviation.
    Also sets abbreviations on.'''

    k = self.k ; state = k.getState('add-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Abbreviation: ',protect=True)
        k.getArg(event,'add-abbr',1,self.addAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        if k.arg.strip():
            self.abbrevs [k.arg] = word
            k.abbrevOn = True
            k.setLabelGrey(
                "Abbreviations are on.\nAbbreviation: '%s' = '%s'" % (
                k.arg,word))
#@-node:ekr.20050920084036.25:addAbbreviation
#@+node:ekr.20051004080550:addInverseAbbreviation
def addInverseAbbreviation (self,event):

    '''Add an inverse abbreviation:
    The selected text is the abbreviation name;
    the minibuffer prompts you for the value of the abbreviation.'''

    k = self.k ; state = k.getState('add-inverse-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Inverse Abbreviation: ',protect=True)
        k.getArg(event,'add-inverse-abbr',1,self.addInverseAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        if word:
            self.abbrevs [word] = k.arg
#@-node:ekr.20051004080550:addInverseAbbreviation
#@+node:ekr.20050920084036.27:expandAbbrev
def expandAbbrev (self,event):

    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.'''

    k = self.k ; c = self.c ; ch = event.char.strip()
    w = self.editWidget(event)
    if not w: return

    word = w.get('insert -1c wordstart','insert -1c wordend')
    g.trace('ch',repr(ch),'word',repr(word))
    if ch:
        # We must do this: expandAbbrev is called from Alt-x and Control-x,
        # we get two differnt types of data and w states.
        word = '%s%s'% (word,ch)

    val = self.abbrevs.get(word)
    if val is not None:
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        if i != j: w.delete(i,j)
        w.insert(i,val)
        c.frame.body.onBodyChanged(undoType='Typing')

    return val is not None
#@-node:ekr.20050920084036.27:expandAbbrev
#@+node:ekr.20050920084036.18:killAllAbbrevs
def killAllAbbrevs (self,event):

    '''Delete all abbreviations.'''

    self.abbrevs = {}
#@-node:ekr.20050920084036.18:killAllAbbrevs
#@+node:ekr.20050920084036.19:listAbbrevs
def listAbbrevs (self,event):

    '''List all abbreviations.'''

    k = self.k

    if self.abbrevs:
        for z in self.abbrevs:
            g.es('%s=%s' % (z,self.abbrevs[z]))
#@-node:ekr.20050920084036.19:listAbbrevs
#@+node:ekr.20050920084036.20:readAbbreviations
def readAbbreviations (self,event):

    '''Read abbreviations from a file.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Abbreviation File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName)
        for x in f:
            a, b = x.split('=')
            b = b [:-1]
            self.abbrevs [a] = b
        f.close()
    except IOError:
        g.es('Can not open',fileName)
#@-node:ekr.20050920084036.20:readAbbreviations
#@+node:ekr.20050920084036.21:regionalExpandAbbrev (TK code)
def regionalExpandAbbrev (self,event):

    '''Exapand abbreviations throughout a region.'''

    k = self.k ; w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    i1,i2 = w.getSelectionRange()
    ins = w.getInsertPoint()
    << define a new generator searchXR >>

    # EKR: the 'result' of calling searchXR is a generator object.
    k.regx.iter = searchXR(i1,i2,ins,event)
    k.regx.iter.next() # Call it the first time.
#@nonl
#@+node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
@ This is a generator (it contains a yield).
To make this work we must define a new generator for each call to regionalExpandAbbrev.
@c
def searchXR (i1,i2,ins,event):
    k = self.k
    w = self.editWidget(event)
    if not w: return

    w.tag_add('sXR',i1,i2)
    while i1:
        tr = w.tag_ranges('sXR')
        if not tr: break
        i1 = w.search(r'\w',i1,stopindex=tr[1],regexp=True)
        if i1:
            word = w.get('%s wordstart' % i1,'%s wordend' % i1)
            w.tag_delete('found')
            w.tag_add('found','%s wordstart' % i1,'%s wordend' % i1)
            w.tag_config('found',background='yellow')
            if self.abbrevs.has_key(word):
                k.setLabel('Replace %s with %s? y/n' % (word,self.abbrevs[word]))
                yield None
                if k.regXKey == 'y':
                    ind = w.index('%s wordstart' % i1)
                    w.delete('%s wordstart' % i1,'%s wordend' % i1)
                    w.insert(ind,self.abbrevs[word])
            i1 = '%s wordend' % i1
    w.setInsertPoint(ins,ins,insert=ins)
    w.tag_delete('sXR')
    w.tag_delete('found')
    k.setLabelGrey('')
    self.k.regx = g.bunch(iter=None,key=None)
#@-node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
#@-node:ekr.20050920084036.21:regionalExpandAbbrev (TK code)
#@+node:ekr.20050920084036.23:toggleAbbrevMode
def toggleAbbrevMode (self,event):

    '''Toggle abbreviation mode.'''

    k = self.k
    k.abbrevOn = not k.abbrevOn
    k.keyboardQuit(event)
    k.setLabel('Abbreviations are ' + g.choose(k.abbrevOn,'On','Off'))
#@-node:ekr.20050920084036.23:toggleAbbrevMode
#@+node:ekr.20050920084036.24:writeAbbreviations
def writeAbbreviations (self,event):

    '''Write abbreviations to a file.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Write Abbreviations',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName,'w')
        for x in self.abbrevs:
            f.write('%s=%s\n' % (x,self.abbrevs[x]))
        f.close()
    except IOError:
        g.es('Can not create',fileName)
#@-node:ekr.20050920084036.24:writeAbbreviations
#@-node:ekr.20070531103114:static abbrevs
#@-node:ekr.20050920084036.13:abbrevCommandsClass (test)
#@+node:ekr.20050920084036.31:bufferCommandsClass
@ An Emacs instance does not have knowledge of what is considered a buffer in the environment.

The call to setBufferInteractionMethods calls the buffer configuration methods.
@c

class bufferCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20050920084036.32: ctor (bufferCommandsClass)
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.fromName = '' # Saved name from getBufferName.
    self.nameList = [] # [n: <headline>]
    self.names = {}
    self.tnodes = {} # Keys are n: <headline>, values are tnodes.

    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None
#@-node:ekr.20050920084036.32: ctor (bufferCommandsClass)
#@+node:ekr.20050920084036.33: getPublicCommands
def getPublicCommands (self):

    return {

        # These do not seem useful.
            # 'copy-to-buffer':               self.copyToBuffer,
            # 'insert-to-buffer':             self.insertToBuffer,

        'append-to-buffer':             self.appendToBuffer,
        'kill-buffer' :                 self.killBuffer,
        'list-buffers' :                self.listBuffers,
        'list-buffers-alphabetically':  self.listBuffersAlphabetically,
        'prepend-to-buffer':            self.prependToBuffer,
        'rename-buffer':                self.renameBuffer,
        'switch-to-buffer':             self.switchToBuffer,
    }
#@-node:ekr.20050920084036.33: getPublicCommands
#@+node:ekr.20050920084036.34:Entry points
#@+node:ekr.20050920084036.35:appendToBuffer
def appendToBuffer (self,event):

    '''Add the selected body text to the end of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Append to buffer: ')
    self.getBufferName(self.appendToBufferFinisher)

def appendToBufferFinisher (self,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.beginUpdate()
        try:
            w = self.w
            c.selectPosition(p)
            self.beginCommand('append-to-buffer: %s' % p.headString())
            w.insert('end',s)
            w.setInsertPoint('end')
            w.seeInsertPoint()
            self.endCommand()
        finally:
            c.endUpdate()
            c.recolor_now()
#@nonl
#@-node:ekr.20050920084036.35:appendToBuffer
#@+node:ekr.20050920084036.36:copyToBuffer
def copyToBuffer (self,event):

    '''Add the selected body text to the end of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Copy to buffer: ')
    self.getBufferName(self.copyToBufferFinisher)

def copyToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.beginUpdate()
        try:
            c.selectPosition(p)
            self.beginCommand('copy-to-buffer: %s' % p.headString())
            w.insert('end',s)
            w.setInsertPoint('end')
            self.endCommand()
        finally:
            c.endUpdate()
            c.recolor_now()
#@-node:ekr.20050920084036.36:copyToBuffer
#@+node:ekr.20050920084036.37:insertToBuffer
def insertToBuffer (self,event):

    '''Add the selected body text at the insert point of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Insert to buffer: ')
    self.getBufferName(self.insertToBufferFinisher)

def insertToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.beginUpdate()
        try:
            c.selectPosition(p)
            self.beginCommand('insert-to-buffer: %s' % p.headString())
            i = w.getInsertPoint()
            w.insert(i,s)
            w.seeInsertPoint()
            self.endCommand()
        finally:
            c.endUpdate()
#@-node:ekr.20050920084036.37:insertToBuffer
#@+node:ekr.20050920084036.38:killBuffer
def killBuffer (self,event):

    '''Delete a buffer (node) and all its descendants.'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Kill buffer: ')
    self.getBufferName(self.killBufferFinisher)

def killBufferFinisher (self,name):

    c = self.c ; p = self.findBuffer(name)
    if p:
        h = p.headString()
        current = c.currentPosition()
        c.selectPosition(p)
        c.deleteOutline (op_name='kill-buffer: %s' % h)
        c.selectPosition(current)
        self.k.setLabelBlue('Killed buffer: %s' % h)
#@-node:ekr.20050920084036.38:killBuffer
#@+node:ekr.20050920084036.42:listBuffers & listBuffersAlphabetically
def listBuffers (self,event):

    '''List all buffers (node headlines), in outline order.
    Nodes with the same headline are disambiguated by giving their parent or child index.
    '''

    self.computeData()
    g.es('Buffers...')
    for name in self.nameList:
        g.es(name)

def listBuffersAlphabetically (self,event):

    '''List all buffers (node headlines), in alphabetical order.
    Nodes with the same headline are disambiguated by giving their parent or child index.'''

    self.computeData()
    names = self.nameList[:] ; names.sort()

    g.es('Buffers...')
    for name in names:
        g.es(name)
#@-node:ekr.20050920084036.42:listBuffers & listBuffersAlphabetically
#@+node:ekr.20050920084036.39:prependToBuffer
def prependToBuffer (self,event):

    '''Add the selected body text to the start of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Prepend to buffer: ')
    self.getBufferName(self.prependToBufferFinisher)

def prependToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.beginUpdate()
        try:
            c.selectPosition(p)
            self.beginCommand('prepend-to-buffer: %s' % p.headString())
            w.insert(0,s)
            w.setInsertPoint(0)
            w.seeInsertPoint()
            self.endCommand()
        finally:
            c.endUpdate()
            c.recolor_now()

#@-node:ekr.20050920084036.39:prependToBuffer
#@+node:ekr.20050920084036.43:renameBuffer
def renameBuffer (self,event):

    '''Rename a buffer, i.e., change a node's headline.'''

    self.k.setLabelBlue('Rename buffer from: ')
    self.getBufferName(self.renameBufferFinisher1)

def renameBufferFinisher1 (self,name):

    self.fromName = name
    self.k.setLabelBlue('Rename buffer from: %s to: ' % (name))
    self.getBufferName(self.renameBufferFinisher2)

def renameBufferFinisher2 (self,name):

    c = self.c ; p = self.findBuffer(self.fromName)
    if p:
        c.endEditing()
        c.beginUpdate()
        c.setHeadString(p,name)
        c.endUpdate()
#@-node:ekr.20050920084036.43:renameBuffer
#@+node:ekr.20050920084036.40:switchToBuffer
def switchToBuffer (self,event):

    '''Select a buffer (node) by its name (headline).'''

    self.k.setLabelBlue('Switch to buffer: ')
    self.getBufferName(self.switchToBufferFinisher)

def switchToBufferFinisher (self,name):

    c = self.c ; p = self.findBuffer(name)
    if p:
        c.beginUpdate()
        try:
            c.selectPosition(p)
        finally:
            c.endUpdate()
#@-node:ekr.20050920084036.40:switchToBuffer
#@-node:ekr.20050920084036.34:Entry points
#@+node:ekr.20050927102133.1:Utils
#@+node:ekr.20051215121416:computeData
def computeData (self):

    counts = {} ; self.nameList = []
    self.names = {} ; self.tnodes = {}

    for p in self.c.allNodes_iter():
        h = p.headString().strip()
        t = p.v.t
        n = counts.get(t,0) + 1
        counts[t] = n
        if n == 1: # Only make one entry per set of clones.
            nameList = self.names.get(h,[])
            if nameList:
                if p.parent():
                    key = '%s, parent: %s' % (h,p.parent().headString())
                else:
                    key = '%s, child index: %d' % (h,p.childIndex())
            else:
                key = h
            self.nameList.append(key)
            self.tnodes[key] = t
            nameList.append(key)
            self.names[h] = nameList
#@-node:ekr.20051215121416:computeData
#@+node:ekr.20051215164823:findBuffer
def findBuffer (self,name):

    t = self.tnodes.get(name)

    for p in self.c.allNodes_iter():
        if p.v.t == t:
            return p

    g.trace("Can't happen",name)
    return None
#@-node:ekr.20051215164823:findBuffer
#@+node:ekr.20050927093851:getBufferName
def getBufferName (self,finisher):

    '''Get a buffer name into k.arg and call k.setState(kind,n,handler).'''

    k = self.k ; c = k.c ; state = k.getState('getBufferName')

    if state == 0:
        self.computeData()
        self.getBufferNameFinisher = finisher
        prefix = k.getLabel() ; event = None
        k.getArg(event,'getBufferName',1,self.getBufferName,
            prefix=prefix,tabList=self.nameList)
    else:
        k.resetLabel()
        k.clearState()
        finisher = self.getBufferNameFinisher
        self.getBufferNameFinisher = None
        finisher(k.arg)
#@-node:ekr.20050927093851:getBufferName
#@-node:ekr.20050927102133.1:Utils
#@-node:ekr.20050920084036.31:bufferCommandsClass
#@+node:ekr.20070522085324:chapterCommandsClass
class chapterCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20070522085340: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    # c.chapterController does not exist yet.
#@-node:ekr.20070522085340: ctor
#@+node:ekr.20070522085429: getPublicCommands (chapterCommandsClass)
def getPublicCommands (self):

    c = self.c ; cc = c.chapterController

    # g.trace('cc',cc,g.callers())

    if cc:
        return {
            'clone-node-to-chapter':    cc.cloneNodeToChapter,
            'copy-node-to-chapter':     cc.copyNodeToChapter,
            'create-chapter':           cc.createChapter,
            'move-node-to-chapter':     cc.moveNodeToChapter,
            'remove-chapter':           cc.removeChapter,
            'rename-chapter':           cc.renameChapter,
            'select-chapter':           cc.selectChapter,
        }
    else:
        return {}
#@-node:ekr.20070522085429: getPublicCommands (chapterCommandsClass)
#@-node:ekr.20070522085324:chapterCommandsClass
#@+node:ekr.20050920084036.150:controlCommandsClass
class controlCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20050920084036.151: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.payload = None
#@-node:ekr.20050920084036.151: ctor
#@+node:ekr.20050920084036.152: getPublicCommands
def getPublicCommands (self):

    k = self.c.k

    return {
        'advertised-undo':              self.advertizedUndo,
        'iconify-frame':                self.iconifyFrame, # Same as suspend.
        'keyboard-quit':                k.keyboardQuit,
        'save-buffers-kill-leo':        self.saveBuffersKillLeo,
        'set-silent-mode':              self.setSilentMode,
        'print-plugins':                self.printPlugins,
        'print-plugin-handlers':        self.printPluginHandlers,
        'shell-command':                self.shellCommand,
        'shell-command-on-region':      self.shellCommandOnRegion,
        'suspend':                      self.suspend,
    }
#@-node:ekr.20050920084036.152: getPublicCommands
#@+node:ekr.20050922110030:advertizedUndo
def advertizedUndo (self,event):

    '''Undo the previous command.'''

    self.c.undoer.undo()
#@-node:ekr.20050922110030:advertizedUndo
#@+node:ekr.20050920084036.160:executeSubprocess
def executeSubprocess (self,event,command,input):

    '''Execute a command in a separate process.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    k.setLabelBlue('started  shell-command: %s' % command)
    try:
        ofile = os.tmpfile()
        efile = os.tmpfile()
        process = subprocess.Popen(command,bufsize=-1,
            stdout = ofile.fileno(), stderr = ofile.fileno(),
            stdin = subprocess.PIPE, shell = True)
        if input: process.communicate(input)
        process.wait()
        efile.seek(0)
        errinfo = efile.read()
        if errinfo: w.insert('insert',errinfo)
        ofile.seek(0)
        okout = ofile.read()
        if okout: w.insert('insert',okout)
    except Exception, x:
        w.insert('insert',x)

    k.setLabelGrey('finished shell-command: %s' % command)
#@-node:ekr.20050920084036.160:executeSubprocess
#@+node:ekr.20070429090859:print-plugins & print-handlers
def printPluginHandlers (self,event=None):

    leoPlugins.printHandlers()

def printPlugins (self,event=None):

    leoPlugins.printPlugins()

#@-node:ekr.20070429090859:print-plugins & print-handlers
#@+node:ekr.20060603161041:setSilentMode
def setSilentMode (self,event=None):

    '''Set the mode to be run silently, without the minibuffer.
    The only use for this command is to put the following in an @mode node::

        --> set-silent-mode'''

    self.c.k.silentMode = True
#@-node:ekr.20060603161041:setSilentMode
#@+node:ekr.20050920084036.158:shellCommand
def shellCommand (self,event):

    '''Execute a shell command.'''

    if subprocess:
        k = self.k ; state = k.getState('shell-command')

        if state == 0:
            k.setLabelBlue('shell-command: ',protect=True)
            k.getArg(event,'shell-command',1,self.shellCommand)
        else:
            command = k.arg
            k.commandName = 'shell-command: %s' % command
            k.clearState()
            self.executeSubprocess(event,command,input=None)
    else:
        k.setLabelGrey('can not execute shell-command: can not import subprocess')
#@-node:ekr.20050920084036.158:shellCommand
#@+node:ekr.20050930112126:shellCommandOnRegion
def shellCommandOnRegion (self,event):

    '''Execute a command taken from the selected text in a separate process.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if subprocess:
        if w.hasSelection():
            command = w.getSelectedText()
            k.commandName = 'shell-command: %s' % command
            self.executeSubprocess(event,command,input=None)
        else:
            k.clearState()
            k.resetLabel()
    else:
        k.setLabelGrey('can not execute shell-command: can not import subprocess')
#@-node:ekr.20050930112126:shellCommandOnRegion
#@+node:ekr.20050920084036.155:shutdown, saveBuffersKillEmacs & setShutdownHook
def shutdown (self,event):

    '''Quit Leo, prompting to save any unsaved files first.'''

    g.app.onQuit()

saveBuffersKillLeo = shutdown
#@-node:ekr.20050920084036.155:shutdown, saveBuffersKillEmacs & setShutdownHook
#@+node:ekr.20050920084036.153:suspend & iconifyFrame
def suspend (self,event):

    '''Minimize the present Leo window.'''

    w = self.editWidget(event)
    if not w: return
    self.c.frame.top.iconify()

# Must be a separate function so that k.inverseCommandsDict will be a true inverse.

def iconifyFrame (self,event):

    '''Minimize the present Leo window.'''

    self.suspend(event)
#@-node:ekr.20050920084036.153:suspend & iconifyFrame
#@-node:ekr.20050920084036.150:controlCommandsClass
#@+node:ekr.20060127162818.1:debugCommandsClass
class debugCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20060127162921: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
#@-node:ekr.20060127162921: ctor
#@+node:ekr.20060127163325: getPublicCommands
def getPublicCommands (self):

    k = self

    return {
        'collect-garbage':      self.collectGarbage,
        'debug':                self.debug,
        'disable-gc-trace':     self.disableGcTrace,
        'dump-all-objects':     self.dumpAllObjects,
        'dump-new-objects':     self.dumpNewObjects,
        'enable-gc-trace':      self.enableGcTrace,
        'free-tree-widgets':    self.freeTreeWidgets,
        'print-focus':          self.printFocus,
        'print-stats':          self.printStats,
        'print-gc-summary':     self.printGcSummary,
        'run-unit-tests':       self.runUnitTests,
        'verbose-dump-objects': self.verboseDumpObjects,
    }
#@-node:ekr.20060127163325: getPublicCommands
#@+node:ekr.20060205050659:collectGarbage
def collectGarbage (self,event=None):

    """Run Python's Gargabe Collector."""

    g.collectGarbage()
#@-node:ekr.20060205050659:collectGarbage
#@+node:ekr.20060519003651:debug & helper
def debug (self,event=None):

    '''Start an external debugger in another process to debug the presently selected text.'''

    c = self.c ; p = c.currentPosition()
    python = sys.executable
    # pythonDir = g.os_path_dirname(python)
    script = p.bodyString()
    winpdb = self.findDebugger()
    if not winpdb: return

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    args = [sys.executable, winpdb, '-t', filename]
    os.chdir(g.app.loadDir)
    try:
        import subprocess
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    except ImportError:
        os.chdir(g.app.loadDir)
        os.spawnv(os.P_NOWAIT, python, args)
#@+node:ekr.20060521140213:findDebugger
def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'scripts','_winpdb.py'),
    )

    for debugger in debuggers:
        if debugger:
            debugger = g.os_path_abspath(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('Debugger does not exist: %s' % (debugger),color='blue')
    else:
        g.es('No debugger found.')
        return None
#@-node:ekr.20060521140213:findDebugger
#@-node:ekr.20060519003651:debug & helper
#@+node:ekr.20060202160523:dumpAll/New/VerboseObjects
def dumpAllObjects (self,event=None):

    '''Print a summary of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcAll()
    g.app.trace_gc = old

def dumpNewObjects (self,event=None):

    '''Print a summary of all Python objects created
    since the last time Python's Garbage collector was run.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcObjects()
    g.app.trace_gc = old

def verboseDumpObjects (self,event=None):

    '''Print a more verbose listing of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcVerbose()
    g.app.trace_gc = old
#@-node:ekr.20060202160523:dumpAll/New/VerboseObjects
#@+node:ekr.20060127163325.1:enable/disableGcTrace
def disableGcTrace (self,event=None):

    '''Enable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = False


def enableGcTrace (self,event=None):

    '''Disable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = True
    g.enable_gc_debug()

    if g.app.trace_gc_verbose:
        g.es('enabled verbose gc stats',color='blue')
    else:
        g.es('enabled brief gc stats',color='blue')
#@-node:ekr.20060127163325.1:enable/disableGcTrace
#@+node:ekr.20060202154734:freeTreeWidgets
def freeTreeWidgets (self,event=None):

    '''Free all widgets used in Leo's outline pane.'''

    c = self.c

    c.frame.tree.destroyWidgets()
    c.redraw_now()
#@-node:ekr.20060202154734:freeTreeWidgets
#@+node:ekr.20060210100432:printFocus
# Doesn't work if the focus isn't in a pane with bindings!

def printFocus (self,event=None):

    '''Print information about the requested focus (for debugging).'''

    c = self.c

    g.es_print('      hasFocusWidget: %s' % c.widget_name(c.hasFocusWidget))
    g.es_print('requestedFocusWidget: %s' % c.widget_name(c.requestedFocusWidget))
    g.es_print('           get_focus: %s' % c.widget_name(c.get_focus()))
#@-node:ekr.20060210100432:printFocus
#@+node:ekr.20060205043324.3:printGcSummary
def printGcSummary (self,event=None):

    '''Print a brief summary of all Python objects.'''

    g.printGcSummary()
#@-node:ekr.20060205043324.3:printGcSummary
#@+node:ekr.20060202133313:printStats
def printStats (self,event=None):

    '''Print statistics about the objects that Leo is using.'''

    c = self.c
    c.frame.tree.showStats()
    self.dumpAllObjects()
#@-node:ekr.20060202133313:printStats
#@+node:ekr.20060328121145:runUnitTest
def runUnitTests (self,event=None):

    '''Run all unit tests contained in the presently selected outline.'''

    c = self.c

    leoTest.doTests(c,all=False)
#@-node:ekr.20060328121145:runUnitTest
#@-node:ekr.20060127162818.1:debugCommandsClass
#@+node:ekr.20050920084036.53:editCommandsClass
class editCommandsClass (baseEditCommandsClass):

    '''Contains editing commands with little or no state.'''

    @others
#@+node:ekr.20050929155208: birth
#@+node:ekr.20050920084036.54: ctor (editCommandsClass)
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.ccolumn = '0'   # For comment column functions.
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.sampleWidget = None # Created later.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.w = None # For use by state handlers.

    # Settings...
    self.autocompleteBrackets   = c.config.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = c.config.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = c.config.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = c.config.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = c.config.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = c.config.getBool('flash-matching-brackets')
    self.smartAutoIndent        = c.config.getBool('smart_auto_indent')

    self.initBracketMatcher(c)
#@-node:ekr.20050920084036.54: ctor (editCommandsClass)
#@+node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
def getPublicCommands (self):        

    c = self.c ; k = self.k 

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-all-lines':                      self.cleanAllLines,
        'clean-lines':                          self.cleanLines,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'cycle-all-focus':                      self.cycleAllFocus,
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-all':                           self.selectAllText,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@-node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
#@+node:ekr.20061012113455:doNothing
def doNothing (self,event):

    '''A placeholder command, useful for testing bindings.'''

    # g.trace()
    pass
#@nonl
#@-node:ekr.20061012113455:doNothing
#@-node:ekr.20050929155208: birth
#@+node:ekr.20050920084036.57:capitalization & case
#@+node:ekr.20051015114221:capitalizeWord & up/downCaseWord
def capitalizeWord (self,event):
    '''Capitalize the word at the cursor.'''
    self.capitalizeHelper(event,'cap','capitalize-word')

def downCaseWord (self,event):
    '''Convert all characters of the word at the cursor to lower case.'''
    self.capitalizeHelper(event,'low','downcase-word')

def upCaseWord (self,event):
    '''Convert all characters of the word at the cursor to UPPER CASE.'''
    self.capitalizeHelper(event,'up','upcase-word')
#@-node:ekr.20051015114221:capitalizeWord & up/downCaseWord
#@+node:ekr.20050920084036.145:changePreviousWord (not used)
def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke
    w = self.editWidget(event)
    if not w: return

    i = w.getInsertPoint()
    self.beginCommand(undoType='change-previous-word')
    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == '<Alt-c>':
        self.capitalizeWord(event)
    elif stroke == '<Alt-u>':
         self.upCaseWord(event)
    elif stroke == '<Alt-l>':
        self.downCaseWord(event)

    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.145:changePreviousWord (not used)
#@+node:ekr.20051015114221.1:capitalizeHelper (passed)
def capitalizeHelper (self,event,which,undoType):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i1 = w.getInsertPoint()
    i,j = g.getWord(s,i1)
    word = s[i:j]
    if not word.strip(): return

    self.beginCommand(undoType=undoType)

    if which == 'cap':  word = word.capitalize()
    if which == 'low':  word = word.lower()
    if which == 'up':   word = word.upper()

    w.delete(i,j)
    w.insert(i,word)
    w.setInsertPoint(i1)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20051015114221.1:capitalizeHelper (passed)
#@-node:ekr.20050920084036.57:capitalization & case
#@+node:ekr.20051022142249:clicks and focus (editCommandsClass)
#@+node:ekr.20060211100905:activate-x-menu & activateMenu (editCommandsClass)
def activateCmdsMenu    (self,event=None):
    '''Activate Leo's Cmnds menu.'''
    self.activateMenu('Cmds')

def activateEditMenu    (self,event=None):
    '''Activate Leo's Edit menu.'''
    self.activateMenu('Edit')

def activateFileMenu    (self,event=None):
    '''Activate Leo's File menu.'''
    self.activateMenu('File')

def activateHelpMenu    (self,event=None):
    '''Activate Leo's Help menu.'''
    self.activateMenu('Help')

def activateOutlineMenu (self,event=None):
    '''Activate Leo's Outline menu.'''
    self.activateMenu('Outline')

def activatePluginsMenu (self,event=None):
    '''Activate Leo's Plugins menu.'''
    self.activateMenu('Plugins')

def activateWindowMenu  (self,event=None):
    '''Activate Leo's Window menu.'''
    self.activateMenu('Window')

def activateMenu (self,menuName):
    c = self.c
    c.frame.menu.activateMenu(menuName)
#@-node:ekr.20060211100905:activate-x-menu & activateMenu (editCommandsClass)
#@+node:ekr.20051022144825.1:cycleFocus
def cycleFocus (self,event):

    '''Cycle the keyboard focus between Leo's outline, body and log panes.'''

    c = self.c ;  w = event.widget


    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas
    panes = [body,log,tree]

    if w in panes:
        i = panes.index(w) + 1
        if i >= len(panes): i = 0
        pane = panes[i]
    else:
        pane = body

    # Warning: traces mess up the focus
    # print g.app.gui.widget_name(w),g.app.gui.widget_name(pane)

    # This works from the minibuffer *only* if there is no typing completion.
    c.widgetWantsFocusNow(pane)
    c.k.newMinibufferWidget = pane
#@nonl
#@-node:ekr.20051022144825.1:cycleFocus
#@+node:ekr.20060613090701:cycleAllFocus
editWidgetCount = 0
logWidgetCount = 0

def cycleAllFocus (self,event):

    '''Cycle the keyboard focus between Leo's outline,
    all body editors and all tabs in the log pane.'''

    c = self.c ; k = c.k
    w = event and event.widget # Does **not** require a text widget.

    pane = None ; w_name = g.app.gui.widget_name
    trace = False
    if trace: print (
        '---- w',w_name(w),id(w),
        '#tabs',c.frame.log.numberOfVisibleTabs(),
        'bodyCtrl',w_name(c.frame.body.bodyCtrl),id(c.frame.body.bodyCtrl))

    # w may not be the present body widget, so test its name, not its id.
    if w_name(w).startswith('body'):
        n = c.frame.body.numberOfEditors
        # g.trace(self.editWidgetCount,n)
        if n > 1:
            self.editWidgetCount += 1
            if self.editWidgetCount == 1:
                pane = c.frame.body.bodyCtrl
            elif self.editWidgetCount > n:
                self.editWidgetCount = 0 ; self.logWidgetCount = 1
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            else:
                c.frame.body.cycleEditorFocus(event) ; pane = None
        else:
            self.editWidgetCount = 0 ; self.logWidgetCount = 1
            c.frame.log.selectTab('Log')
            pane = c.frame.log.logCtrl
    elif w_name(w).startswith('log'):
        n = c.frame.log.numberOfVisibleTabs()
        if n > 1:
            self.logWidgetCount += 1
            if self.logWidgetCount == 1:
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            elif self.logWidgetCount > n:
                self.logWidgetCount = 0
                pane = c.frame.tree.canvas
            else:
                c.frame.log.cycleTabFocus()
                pane = c.frame.log.logCtrl
        else:
            self.logWidgetCount = 0
            pane = c.frame.tree.canvas
    else:
        pane = c.frame.body.bodyCtrl
        self.editWidgetCount = 1 ; self.logWidgetCount = 0

    if trace: print 'old: %10s new: %10s' % (w_name(w),w_name(pane))

    if pane:
        k.newMinibufferWidget = pane
        c.widgetWantsFocusNow(pane)
#@nonl
#@-node:ekr.20060613090701:cycleAllFocus
#@+node:ekr.20051022144825:focusTo...
def focusToBody (self,event):
    '''Put the keyboard focus in Leo's body pane.'''
    self.c.bodyWantsFocusNow()

def focusToLog (self,event):
    '''Put the keyboard focus in Leo's log pane.'''
    self.c.logWantsFocusNow()

def focusToMinibuffer (self,event):
    '''Put the keyboard focus in Leo's minibuffer.'''
    self.c.minibufferWantsFocusNow()

def focusToTree (self,event):
    '''Put the keyboard focus in Leo's outline pane.'''
    self.c.treeWantsFocusNow()
#@-node:ekr.20051022144825:focusTo...
#@+node:ekr.20060211063744.1:clicks in the headline
# These call the actual event handlers so as to trigger hooks.

def clickHeadline (self,event=None):
    '''Simulate a click in the headline of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineClick(event,p=p)

def doubleClickHeadline (self,event=None):
    '''Simulate a double click in headline of the presently selected node.'''
    return self.clickHeadline(event)

def rightClickHeadline (self,event=None):
    '''Simulate a right click in the headline of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineRightClick(event,p=p)
#@-node:ekr.20060211063744.1:clicks in the headline
#@+node:ekr.20060211055455:clicks in the icon box
# These call the actual event handlers so as to trigger hooks.

def clickIconBox (self,event=None):
    '''Simulate a click in the icon box of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxClick(event,p=p)

def doubleClickIconBox (self,event=None):
    '''Simulate a double-click in the icon box of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxDoubleClick(event,p=p)

def rightClickIconBox (self,event=None):

    '''Simulate a right click in the icon box of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxRightClick(event,p=p)
#@-node:ekr.20060211055455:clicks in the icon box
#@+node:ekr.20060211062025:clickClickBox
# Call the actual event handlers so as to trigger hooks.

def clickClickBox (self,event=None):

    '''Simulate a click in the click box (+- box) of the presently selected node.'''

    c = self.c ; p = c.currentPosition()
    c.frame.tree.onClickBoxClick(event,p=p)
#@-node:ekr.20060211062025:clickClickBox
#@+node:ekr.20060211063744.2:simulate...Drag
# These call the drag setup methods which in turn trigger hooks.

def simulateBeginDrag (self,event=None):

    '''Simulate the start of a drag in the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.startDrag(event,p=p)

def simulateEndDrag (self,event=None):

    '''Simulate the end of a drag in the presently selected node.'''
    c = self.c

    # Note: this assumes that tree.startDrag has already been called.
    c.frame.tree.endDrag(event)
#@-node:ekr.20060211063744.2:simulate...Drag
#@-node:ekr.20051022142249:clicks and focus (editCommandsClass)
#@+node:ekr.20051019183105:color & font
#@+node:ekr.20051019183105.1:show-colors
def showColors (self,event):

    '''Open a tab in the log pane showing various color pickers.'''

    c = self.c ; log = c.frame.log ; tabName = 'Colors'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createColorPicker(tabName)
#@-node:ekr.20051019183105.1:show-colors
#@+node:ekr.20051019201809:editCommands.show-fonts & helpers
def showFonts (self,event):

    '''Open a tab in the log pane showing a font picker.'''

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createFontPicker(tabName)
#@-node:ekr.20051019201809:editCommands.show-fonts & helpers
#@-node:ekr.20051019183105:color & font
#@+node:ekr.20050920084036.132:comment column...
#@+node:ekr.20050920084036.133:setCommentColumn
def setCommentColumn (self,event):

    '''Set the comment column for the indent-to-comment-column command.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,ins)
    self.ccolumn = col
#@nonl
#@-node:ekr.20050920084036.133:setCommentColumn
#@+node:ekr.20050920084036.134:indentToCommentColumn (test)
def indentToCommentColumn (self,event):

    '''Insert whitespace to indent to the comment column.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='indent-to-comment-column')

    s = w.getAllText()
    junk, i = g.getLine(s,w.getInsertPoint())
    i1, i2 = g.convertPythonIndexToRowCol(s,i)
    c1 = int(self.ccolumn)

    if i2 < c1: w.insert(i,' '*(c1-i2))
    if i2 >= c1: w.insert(i,' ')
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.134:indentToCommentColumn (test)
#@-node:ekr.20050920084036.132:comment column...
#@+node:ekr.20050920084036.62:esc methods for Python evaluation
#@+node:ekr.20050920084036.63:watchEscape (Revise)
def watchEscape (self,event):

    k = self.k

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        # hi1 = k.keysymHistory [0]
        # hi2 = k.keysymHistory [1]
        data1 = leoKeys.keyHandlerClass.lossage[0]
        data2 = leoKeys.keyHandlerClass.lossage[1]
        ch1, stroke1 = data1
        ch2, stroke2 = data2

        if state == 'esc esc' and event.keysym == ':':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        # elif hi1 == hi2 == 'Escape':
        elif stroke1 == 'Escape' and stroke2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit(event)
#@-node:ekr.20050920084036.63:watchEscape (Revise)
#@+node:ekr.20050920084036.64:escEvaluate (Revise)
def escEvaluate (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            w.insert('insert',result)
            ok = True
        finally:
            k.keyboardQuit(event)
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)
#@-node:ekr.20050920084036.64:escEvaluate (Revise)
#@-node:ekr.20050920084036.62:esc methods for Python evaluation
#@+node:ekr.20050920084036.65:evalExpression
def evalExpression (self,event):

    '''Evaluate a Python Expression entered in the minibuffer.'''

    k = self.k ; state = k.getState('eval-expression')

    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -> %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)
#@-node:ekr.20050920084036.65:evalExpression
#@+node:ekr.20050920084036.66:fill column and centering
@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap

after an center-region command via Alt-x.
@c

@others
#@+node:ekr.20050920084036.67:centerLine
def centerLine (self,event):

    '''Centers line within current fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = g.getLine(s,w.getInsertPoint())
    line = s [i:j].strip()
    if not line or len(line) >= self.fillColumn: return

    self.beginCommand(undoType='center-line')
    n = (self.fillColumn-len(line)) / 2
    ws = ' ' * n
    k = g.skip_ws(s,i)
    if k > i: w.delete(i,k-i)
    w.insert(i,ws)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.67:centerLine
#@+node:ekr.20050920084036.68:setFillColumn
def setFillColumn (self,event):

    '''Set the fill column used by the center-line and center-region commands.'''

    k = self.k ; state = k.getState('set-fill-column')

    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()
#@-node:ekr.20050920084036.68:setFillColumn
#@+node:ekr.20050920084036.69:centerRegion
def centerRegion (self,event):

    '''Centers the selected text within the fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1, sel_2 = w.getSelectionRange()
    ind, junk = g.getLine(s,sel_1)
    junk, end = g.getLine(s,sel_2)

    self.beginCommand(undoType='center-region')

    inserted = 0
    while ind < end:
        s = w.getAllText()
        i, j = g.getLine(s,ind)
        line = s [i:j].strip()
        # g.trace(len(line),repr(line))
        if len(line) >= self.fillColumn:
            ind = j
        else:
            n = (self.fillColumn-len(line)) / 2
            inserted += n
            k = g.skip_ws(s,i)
            if k > i: w.delete(i,k-i)
            w.insert(i,' '*n)
            ind = j + n-(k-i)

    w.setSelectionRange(sel_1,sel_2+inserted)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.69:centerRegion
#@+node:ekr.20050920084036.70:setFillPrefix (test)
def setFillPrefix( self, event ):

    '''Make the selected text the fill prefix.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,junk = g.getLine(s,ins)
    txt = s[i:ins]
    self.fillPrefix = txt
#@-node:ekr.20050920084036.70:setFillPrefix (test)
#@+node:ekr.20050920084036.71:_addPrefix
def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt
#@-node:ekr.20050920084036.71:_addPrefix
#@-node:ekr.20050920084036.66:fill column and centering
#@+node:ekr.20060417194232:find (quick)
#@+node:ekr.20060925151926:backward/findCharacter & helper
def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)

def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)

def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)

def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)
#@nonl
#@+node:ekr.20060417194232.1:findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward ; self.extend = extend ;
        self.insert = w.getInsertPoint()
        s = '%s character %s' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        c.frame.clearStatusLine()
        c.frame.putStatusLine(s,color='blue')
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = s.rfind('\n',0,i)
            if start == -1: start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        else:
            end = s.find('\n',i)
            if end == -1: end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        c.frame.clearStatusLine()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacterHelper
#@-node:ekr.20060925151926:backward/findCharacter & helper
#@+node:ekr.20060417194232.2:findWord (passed)
def findWord (self,event):

    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord)
    else:        
        word = k.arg ; w = self.w ; c = k.c
        if word:
            i = w.getInsertPoint()
            s = w.getAllText()
            j = s.find('\n',i) # Limit to this line.
            if j > -1: s = s[:j]
            while i < len(s):
                if g.match_word(s,i,word) and (i == 0 or not g.isWordChar(s[i-1])):
                    w.setSelectionRange(i,i+len(word))
                    break
                else:
                    i += 1
        k.resetLabel()
        k.clearState()
#@-node:ekr.20060417194232.2:findWord (passed)
#@-node:ekr.20060417194232:find (quick)
#@+node:ekr.20050920084036.72:goto...
#@+node:ekr.20050929115226:gotoCharacter
def gotoCharacter (self,event):

    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto character: ')
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w
        if n.isdigit():
            w.setInsertPoint(n)
            w.seeInsertPoint()
        k.resetLabel()
        k.clearState()
#@-node:ekr.20050929115226:gotoCharacter
#@+node:ekr.20060417181052:gotoGlobalLine
def gotoGlobalLine (self,event):

    '''Put the cursor at the n'th line of a file or script.
    This is a minibuffer interface to Leo's legacy Go To Line number command.'''

    k = self.k ; tag = 'goto-global-line' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto global line: ')
        k.getArg(event,tag,1,self.gotoGlobalLine)
    else:
        n = k.arg
        k.resetLabel()
        k.clearState()
        if n.isdigit():
            self.c.goToLineNumber (n=int(n))
#@-node:ekr.20060417181052:gotoGlobalLine
#@+node:ekr.20050929124234:gotoLine
def gotoLine (self,event):

    '''Put the cursor at the n'th line of the buffer.'''

    k = self.k ; state = k.getState('goto-line')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.w
        if n.isdigit():
            s = w.getAllText()
            i = g.convertRowColToPythonIndex(s,n,0)
            w.setInsertPoint(i)
            w.seeInsertPoint()
        k.resetLabel()
        k.clearState()
#@-node:ekr.20050929124234:gotoLine
#@-node:ekr.20050920084036.72:goto...
#@+node:ekr.20050920084036.74:indent...
#@+node:ekr.20050920084036.75:backToIndentation
def backToIndentation (self,event):

    '''Position the point at the first non-blank character on the line.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='back-to-indentation')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    while i < j and s[i] in (' \t'):
        i += 1
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.75:backToIndentation
#@+node:ekr.20050920084036.76:deleteIndentation (test)
def deleteIndentation (self,event):

    '''Delete indentation in the presently line.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='delete-indentation')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    txt = s[i:j].strip()
    w.delete(i,j)
    w.insert(ins-1,txt)
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.76:deleteIndentation (test)
#@+node:ekr.20050920084036.78:indentRelative
def indentRelative (self,event):

    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.

    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''

    c = self.c ; undoType = 'indent-relative' ; w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    oldSel = w.getSelectionRange()
    oldYview = w.getYScrollPosition()
    # Find the previous non-blank line
    i,j = g.getLine(s,ins)
    while 1:
        if i <= 0: return
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip(): break
    self.beginCommand(undoType=undoType)
    try:
        k = g.skip_ws(s,i)
        ws = s[i:k]
        i2,j2 = g.getLine(s,ins)
        k = g.skip_ws(s,i2)
        line = ws + s[k:j2]
        w.delete(i2,j2)
        w.insert(i2,line)
        w.setInsertPoint(i2+len(ws))
        c.frame.body.onBodyChanged(undoType,oldSel=oldSel,oldText=s,oldYview=oldYview)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.78:indentRelative
#@-node:ekr.20050920084036.74:indent...
#@+node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
def addSpaceToLines (self,event):
    '''Add a space to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=True,undoType='add-space-to-lines')

def addTabToLines (self,event):
    '''Add a tab to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=True,undoType='add-tab-to-lines')

def removeSpaceFromLines (self,event):
    '''Remove a space from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=False,undoType='remove-space-from-lines')

def removeTabFromLines (self,event):
    '''Remove a tab from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=False,undoType='remove-tab-from-lines')
#@+node:ekr.20060417172056:addRemoveHelper
def addRemoveHelper(self,event,ch,add,undoType):

    c = self.c ; k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():s = w.getSelectedText()
    else:               s = w.getAllText()
    if not s: return

    # Insert or delete spaces instead of tabs when negative tab width is in effect.
    d = g.scanDirectives(c) ; width = d.get('tabwidth')
    if ch == '\t' and width < 0: ch = ' ' * abs(width)

    self.beginCommand(undoType=undoType)

    lines = g.splitLines(s)

    if add:
        result = [ch + line for line in lines]
    else:
        result = [g.choose(line.startswith(ch),line[len(ch):],line) for line in lines]

    result = ''.join(result)

    # g.trace('add',add,'hasSelection',w.hasSelection(),'result',repr(result))

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
        w.insert(i,result)
        w.setSelectionRange(i,i+len(result))
    else:
        w.setAllText(result)
        w.setSelectionRange(0,len(s))

    self.endCommand(changed=True,setLabel=True)

#@-node:ekr.20060417172056:addRemoveHelper
#@-node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
#@+node:ekr.20051026092433.1:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):

    '''Delete the character to the left of the cursor.'''

    c = self.c ; p = c.currentPosition()
    w = self.editWidget(event)
    if not w: return

    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = g.scanDirectives(c,p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width > 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                << backspace with negative tab_width >>
        finally:
            self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i,min(j,len(s)))
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter
#@+node:ekr.20070325094935:cleanAllLines
def cleanAllLines (self,event):

    '''Clean all lines in the selected tree.'''

    c = self.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl
    if not w: return

    c.beginUpdate()
    try:
        for p in current.self_and_subtree_iter():
            c.selectPosition(p)
            w.setSelectionRange(0,0,insert=0)
            c.editCommands.cleanLines(event)
        c.selectPosition(current)
    finally:
        c.endUpdate(False)
#@-node:ekr.20070325094935:cleanAllLines
#@+node:ekr.20060415112257:cleanLines
def cleanLines (self,event):

    '''Removes leading whitespace from otherwise blanks lines.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():
        s = w.getSelectedText()
    else:
        s = w.getAllText()

    lines = [] ; changed = False
    for line in g.splitlines(s):
        if line.strip():
            lines.append(line)
        else:
            if line.endswith('\n'):
                lines.append('\n')
            changed = changed or '\n' != line

    if changed:
        self.beginCommand(undoType='clean-lines')
        result = ''.join(lines)
        if w.hasSelection():
            i,j = w.getSelectionRange()
            w.delete(i,j)
            w.insert(i,result)
            w.setSelectionRange(i,j+len(result))
        else:
            w.delete(0,'end')
            w.insert(0,result)
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060415112257:cleanLines
#@+node:ekr.20060414085834:clearSelectedText
def clearSelectedText (self,event):

    '''Delete the selected text.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    i,j = w.getSelectionRange()
    if i == j: return

    self.beginCommand(undoType='clear-selected-text')

    w.delete(i,j)
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20060414085834:clearSelectedText
#@+node:ekr.20050920084036.87:deleteNextChar
def deleteNextChar (self,event):

    '''Delete the character to the right of the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()

    self.beginCommand(undoType='delete-char')

    changed = True
    if i != j:
        w.delete(i,j)
        w.setInsertPoint(i)
    elif j < len(s):
        w.delete(i)
        w.setInsertPoint(i)
    else:
        changed = False

    self.endCommand(changed=changed,setLabel=False)
#@-node:ekr.20050920084036.87:deleteNextChar
#@+node:ekr.20050920084036.135:deleteSpaces
def deleteSpaces (self,event,insertspace=False):

    '''Delete all whitespace surrounding the cursor.'''

    c = self.c ; w = self.editWidget(event)
    undoType = g.choose(insertspace,'insert-space','delete-spaces')
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    w1 = ins-1
    while w1 >= i and s[w1].isspace():
        w1 -= 1
    w1 += 1
    w2 = ins
    while w2 <= j and s[w2].isspace():
        w2 += 1
    spaces = s[w1:w2]
    if spaces:
        self.beginCommand(undoType=undoType)
        if insertspace: s = s[:w1] + ' ' + s[w2:]
        else:           s = s[:w1] + s[w2:]
        w.setAllText(s)
        w.setInsertPoint(w1)
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.135:deleteSpaces
#@+node:ekr.20050920084036.138:insertNewLine
def insertNewLine (self,event):

    '''Insert a newline at the cursor.'''

    w = self.editWidget(event)
    if not w: return
    wname = g.app.gui.widget_name(w)
    if wname.startswith('head'): return

    self.beginCommand(undoType='insert-newline')

    i = w.getInsertPoint()
    w.insert(i,'\n')
    w.setInsertPoint(i+1)

    self.endCommand(changed=True,setLabel=False)

insertNewline = insertNewLine
#@-node:ekr.20050920084036.138:insertNewLine
#@+node:ekr.20050920084036.86:insertNewLineAndTab
def insertNewLineAndTab (self,event):

    '''Insert a newline and tab at the cursor.'''

    w = self.editWidget(event)
    if not w: return
    wname = g.app.gui.widget_name(w)
    if wname.startswith('head'): return

    self.beginCommand(undoType='insert-newline-and-indent')

    i = w.getInsertPoint()
    w.insert(i,'\n\t')
    w.setInsertPoint(i+2)

    self.endCommand(changed=True,setLabel=False)
#@-node:ekr.20050920084036.86:insertNewLineAndTab
#@+node:ekr.20050920084036.139:insertParentheses
def insertParentheses (self,event):

    '''Insert () at the cursor.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='insert-parenthesis')

    i = w.getInsertPoint()
    w.insert(i,'()')
    w.setInsertPoint(i+1)

    self.endCommand(changed=True,setLabel=False)
#@-node:ekr.20050920084036.139:insertParentheses
#@+node:ekr.20050920084036.141:removeBlankLines
def removeBlankLines (self,event):

    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''

    c = self.c
    head,lines,tail,oldSel,oldYview = c.getBodyLines()

    changed = False ; result = []
    for line in lines:
        if line.strip():
            result.append(line)
        else:
            changed = True
    result = ''.join(result)

    if changed:
        oldSel = None ; undoType = 'remove-blank-lines'
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@-node:ekr.20050920084036.141:removeBlankLines
#@+node:ekr.20051125080855:selfInsertCommand & helpers
def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    #g.trace('ch',repr(ch))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:

            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    # g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch and ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
#@nonl
#@-node:ekr.20051026171121:insertNewlineHelper
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'

    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = g.scanDirectives(c,p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.scanColorDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        w.delete(i,j)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]

        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        # g.trace('n',n)
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand & helpers
#@-node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20050920084036.79:info...
#@+node:ekr.20050920084036.80:howMany
def howMany (self,event):

    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
#@-node:ekr.20050920084036.80:howMany
#@+node:ekr.20050920084036.81:lineNumber
def lineNumber (self,event):

    '''Print the line and column number and percentage of insert point.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)
    percent = int((i*100)/len(s))

    k.setLabelGrey(
        'char: %s row: %d col: %d pos: %d (%d%% of %d)' % (
            repr(s[i]),row,col,i,percent,len(s)))
#@-node:ekr.20050920084036.81:lineNumber
#@+node:ekr.20050920084036.83:viewLossage
def viewLossage (self,event):

    '''Put the Emacs-lossage in the minibuffer label.'''

    k = self.k

    g.es('Lossage...')
    aList = leoKeys.keyHandlerClass.lossage
    aList.reverse()
    for data in aList:
        ch,stroke = data
        d = {' ':'Space','\t':'Tab','\b':'Backspace','\n':'Newline','\r':'Return'}
        g.es(stroke or d.get(ch) or ch or 'None')
#@-node:ekr.20050920084036.83:viewLossage
#@+node:ekr.20050920084036.84:whatLine
def whatLine (self,event):

    '''Print the line number of the line containing the cursor.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)

    k.keyboardQuit(event)
    k.setLabel("Line %s" % row)
#@-node:ekr.20050920084036.84:whatLine
#@-node:ekr.20050920084036.79:info...
#@+node:ekr.20050920084036.88:line...
#@+node:ekr.20050920084036.90:flushLines
def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')

    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg
#@-node:ekr.20050920084036.90:flushLines
#@+node:ekr.20051002095724:keepLines
def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')

    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg
#@-node:ekr.20051002095724:keepLines
#@+node:ekr.20050920084036.92:linesHelper
def linesHelper (self,event,pattern,which):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType=which+'-lines')
    if w.hasSelection():
        i,end = w.getSelectionRange()
    else:
        i = w.getInsertPoint()
        end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception, x:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.setInsertPoint(i)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.92:linesHelper
#@+node:ekr.20050920084036.77:splitLine
def splitLine (self,event):

    '''Split a line at the cursor position.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='split-line')

    s = w.getAllText()
    ins = w.getInsertPoint()
    w.setAllText(s[:ins] + '\n' + s[ins:])
    w.setInsertPoint(ins+1)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.77:splitLine
#@-node:ekr.20050920084036.88:line...
#@+node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@nonl
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    col2 = max(0,min(col,j2-i2-1))
    spot = i2 + col2
    # g.trace('spot',spot,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)
#@nonl
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20051218171457:movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i >= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j >= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i < j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 < len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 < len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 > j2: return

    self.moveToHelper(event,i2+1,extend)
#@-node:ekr.20051218171457:movePastCloseHelper
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 <= i < n and not g.isWordChar(s[i]):
            i -= 1
        while 0 <= i < n and g.isWordChar(s[i]):
            i -= 1
        i += 1

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20051213094517:backSentenceHelper
def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    i = w.getInsertPoint()

    while i >= 0:
        if s[i] == '.': break
        i -= 1
    else: return

    j = i-1
    while j >= 0:
        if s[j] == '.':
            j += 1 ; break
        j -= 1
    else: j = 0

    while j < i and s[j].isspace():
        j += 1

    if j < i:
        self.moveToHelper(event,j,extend)
#@-node:ekr.20051213094517:backSentenceHelper
#@+node:ekr.20050920084036.137:forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins) + 1
    i = min(i,len(s))
    self.moveToHelper(event,i,extend)
#@-node:ekr.20050920084036.137:forwardSentenceHelper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1

    # Skip to the next non-blank line.
    i = j
    while j < len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i,j = g.getLine(s,j)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i > 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i > 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@+node:ekr.20060209095101:setMoveCol
def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t
#@nonl
#@-node:ekr.20060209095101:setMoveCol
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=False)

def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=False)

def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=False)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20051218174113:clear/set/ToggleExtendMode
def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    g.es('Extend mode %s' % (g.choose(val,'on','off')), color='red')
    c.widgetWantsFocusNow(w)
#@-node:ekr.20051218174113:clear/set/ToggleExtendMode
#@+node:ekr.20050920084036.136:exchangePointMark
def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange(sort=False)
    if i == j: return

    ins = w.getInsertPoint()
    ins = g.choose(ins==i,j,i)
    w.setInsertPoint(ins)
    w.setSelectionRange(i,j,insert=None)
#@-node:ekr.20050920084036.136:exchangePointMark
#@+node:ekr.20061007082956:extend-to-line
def extendToLine (self,event):

    '''Select the line at the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 <= i < n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
#@-node:ekr.20061007082956:extend-to-line
#@+node:ekr.20061007214835.4:extend-to-sentence
def extendToSentence (self,event):

    '''Select the line at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)
#@nonl
#@-node:ekr.20061007214835.4:extend-to-sentence
#@+node:ekr.20060116074839.2:extend-to-word
def extendToWord (self,event):

    '''Select the word at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not g.isWordChar(s[i]):
        i -= 1
    while 0 <= i < n and g.isWordChar(s[i]):
        i -= 1
    i += 1

    # Move to the end of the word.
    i1 = i
    while 0 <= i < n and g.isWordChar(s[i]):
        i += 1

    w.setSelectionRange(i1,i)
#@nonl
#@-node:ekr.20060116074839.2:extend-to-word
#@+node:ekr.20051218141237:lines
def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=False)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=True)

def endOfLine (self,event): # passed
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=False)

def endOfLineExtendSelection (self,event): # passed
    '''Extend the selection by moving the cursor to the end of the line.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=True)

def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
#@-node:ekr.20051218141237:lines
#@+node:ekr.20050920084036.140:movePastClose
def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)

def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
#@-node:ekr.20050920084036.140:movePastClose
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)

def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)

def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)

def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)

def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)

def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)

def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)

def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)

def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)

def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)

def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20050920084036.95:paragraph...
@others
#@+node:ekr.20050920084036.99:backwardKillParagraph
def backwardKillParagraph (self,event):

    '''Kill the previous paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='backward-kill-paragraph')
    try:
        self.backwardParagraphHelper(event,extend=True)
        i,j = w.getSelectionRange()
        if i > 0: i = min(i+1,j)
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.99:backwardKillParagraph
#@+node:ekr.20050920084036.100:fillRegion
def fillRegion (self,event):

    '''Fill all paragraphs in the selected text.'''
    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='fill-region')

    s = w.getAllText()
    s1,s2 = w.getSelectionRange()
    w.setInsertPoint(s1)
    self.backwardParagraph(event)
    i = w.getInsertPoint()
    i,junk = g.getLine(s,i)
    if i == 0:
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        if w.getInsertPoint() > s2:
            break
        self.fillParagraph(event)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.100:fillRegion
#@+node:ekr.20050920084036.104:fillRegionAsParagraph
def fillRegionAsParagraph (self,event):

    '''Fill the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='fill-region-as-paragraph')

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.104:fillRegionAsParagraph
#@+node:ekr.20050920084036.103:fillParagraph
def fillParagraph( self, event ):

    '''Fill the selected paragraph'''

    w = self.editWidget(event)
    if not w: return

    # Clear the selection range.
    i,j = w.getSelectionRange()
    w.setSelectionRange(i,i,insert=i)

    self.c.reformatParagraph(event)
#@-node:ekr.20050920084036.103:fillParagraph
#@+node:ekr.20050920084036.98:killParagraph
def killParagraph (self,event):

    '''Kill the present paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='kill-paragraph')
    try:
        self.extendToParagraph(event)
        i,j = w.getSelectionRange()
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.98:killParagraph
#@+node:ekr.20050920084036.96:extend-to-paragraph & helper
def extendToParagraph (self,event):

    '''Select the paragraph surrounding the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    # Find the start of the paragraph.
    if line.strip(): # Search backward.
        while i > 0:
            i2,j2 = g.getLine(s,i-1)
            line = s[i2:j2]
            if line.strip(): i = i2
            else: break # Use the previous line.
    else: # Search forward.
        while j < len(s):
            i,j = g.getLine(s,j)
            line = s[i:j]
            if line.strip(): break
        else: return

    # Select from i to the end of the paragraph.
    self.selectParagraphHelper(w,i)
#@+node:ekr.20050920084036.97:selectParagraphHelper
def selectParagraphHelper (self,w,start):

    '''Select from start to the end of the paragraph.'''

    s = w.getAllText()
    i1,j = g.getLine(s,start)
    while j < len(s):
        i,j2 = g.getLine(s,j)
        line = s[i:j2]
        if line.strip(): j = j2
        else: break

    j = max(start,j-1)
    w.setSelectionRange(i1,j,insert=j)
#@-node:ekr.20050920084036.97:selectParagraphHelper
#@-node:ekr.20050920084036.96:extend-to-paragraph & helper
#@-node:ekr.20050920084036.95:paragraph...
#@+node:ekr.20050920084036.105:region...
@others
#@+node:ekr.20050920084036.108:tabIndentRegion (indent-rigidly)
def tabIndentRegion (self,event):

    '''Insert a hard tab at the start of each line of the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='indent-rigidly')

    s = w.getAllText()
    i1,j1 = w.getSelectionRange()
    i,junk = g.getLine(s,i1)
    junk,j = g.getLine(s,j1)

    lines = g.splitlines(s[i:j])
    n = len(lines)
    lines = g.joinLines(['\t' + line for line in lines])
    s = s[:i] + lines + s[j:]
    w.setAllText(s)

    # Retain original row/col selection.
    w.setSelectionRange(i1,j1+n,insert=j1+n)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.108:tabIndentRegion (indent-rigidly)
#@+node:ekr.20050920084036.109:countRegion
def countRegion (self,event):

    '''Print the number of lines and characters in the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    txt = w.getSelectedText()
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,g.choose(chars==1,'','s')))
#@-node:ekr.20050920084036.109:countRegion
#@+node:ekr.20060417183606:moveLinesDown
def moveLinesDown (self,event):

    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j < len(s):
            next_i,next_j = g.getLine(s,j+1)
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            w.insert(i,next_line+lines)
            w.setSelectionRange(i+n2,i+n2+n,insert=i+n2+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadNext(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadNext()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            s = w.getAllText()
            w.insert(0,lines)
            if not lines.endswith('\n'): w.insert(len(lines),'\n')
            s = w.getAllText()
            w.setSelectionRange(0,n,insert=n)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606:moveLinesDown
#@+node:ekr.20060417183606.1:moveLinesUp
def moveLinesUp (self,event):

    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i > 0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            w.delete(prev_i,j)
            w.insert(prev_i,lines+prev_line)
            w.setSelectionRange(prev_i,prev_i+n,insert=prev_i+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadBack(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadBack()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            s = w.getAllText()
            if not s.endswith('\n'): w.insert('end','\n')
            w.insert('end',lines)
            s = w.getAllText()
            ins = len(s)-len(lines)+n
            w.setSelectionRange(len(s)-len(lines),ins,insert=ins)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606.1:moveLinesUp
#@+node:ekr.20050920084036.110:reverseRegion
def reverseRegion (self,event):

    '''Reverse the order of lines in the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='reverse-region')

    s = w.getAllText()
    i1,j1 = w.getSelectionRange()
    i,junk = g.getLine(s,i1)
    junk,j = g.getLine(s,j1)

    txt = s[i:j]
    aList = txt.split('\n')
    aList.reverse()
    txt = '\n'.join(aList) + '\n'

    w.setAllText(s[:i1] + txt + s[j1:])
    ins = i1 + len(txt) - 1
    w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.110:reverseRegion
#@+node:ekr.20050920084036.111:up/downCaseRegion & helper
def downCaseRegion (self,event):
    '''Convert all characters in the selected text to lower case.'''
    self.caseHelper(event,'low','downcase-region')

def upCaseRegion (self,event):
    '''Convert all characters in the selected text to UPPER CASE.'''
    self.caseHelper(event,'up','upcase-region')

def caseHelper (self,event,way,undoType):

    w = self.editWidget(event)
    if not w or not w.hasSelection(): return

    self.beginCommand(undoType=undoType)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    sel = g.choose(way=='low',s[i:j].lower(),s[i:j].upper())
    # g.trace(repr(sel))
    s = s[:i] + sel + s[j:]
    w.setAllText(s)
    w.setSelectionRange(i,j)

    # w.deleteTextSelection()
    # s = g.choose(way=='low',s.lower(),s.upper())
    # w.insert(i,s)
    # w.setSelectionRange(i,j)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.111:up/downCaseRegion & helper
#@-node:ekr.20050920084036.105:region...
#@+node:ekr.20060309060654:scrolling...
#@+node:ekr.20050920084036.116:scrollUp/Down/extendSelection
def scrollDown (self,event):
    '''Scroll the presently selected pane down one page.'''
    self.scrollHelper(event,'down',extend=False)

def scrollDownExtendSelection (self,event):
    '''Extend the text selection by scrolling the body text down one page.'''
    self.scrollHelper(event,'down',extend=True)

def scrollUp (self,event):
    '''Scroll the presently selected pane up one page.'''
    self.scrollHelper(event,'up',extend=False)

def scrollUpExtendSelection (self,event):
    '''Extend the text selection by scrolling the body text up one page.'''
    self.scrollHelper(event,'up',extend=True)
#@+node:ekr.20060113082917:scrollHelper
def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; gui = g.app.gui
    w = gui.eventWidget(event)
    if not w: return #  This does **not** require a text widget.

    if gui.isTextWidget(w):
        c.widgetWantsFocusNow(w)
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.getInsertPoint()
        s = w.getAllText()
        row,col = g.convertPythonIndexToRowCol(s,ins1)
        # Compute the spot.
        delta = self.measure(w)
        row1 = g.choose(direction=='down',row+delta,row-delta)
        row1 = max(0,row1)
        spot = g.convertRowColToPythonIndex(s,row1,col)
        # g.trace('spot',spot,'row1',row1)
        self.extendHelper(w,extend,spot)
        w.seeInsertPoint()
    elif gui.widget_name(w).startswith('canvas'):
        if direction=='down':
            self.scrollOutlineDownPage()
        else:
            self.scrollOutlineUpPage()
#@-node:ekr.20060113082917:scrollHelper
#@+node:ekr.20050920084036.147:measure
def measure (self,w):

    s = w.getAllText()
    ins = w.getInsertPoint()
    start, junk = g.convertPythonIndexToRowCol(s,ins)
    start += 1 ; delta = 0

    ustart = start - 1
    while ustart >= 1 and w.indexIsVisible('%s.0' % ustart):
        delta += 1 ; ustart -= 1

    ustart = start + 1
    while w.indexIsVisible('%s.0' % ustart):
        delta += 1 ; ustart += 1

    return delta
#@-node:ekr.20050920084036.147:measure
#@-node:ekr.20050920084036.116:scrollUp/Down/extendSelection
#@+node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
def scrollOutlineDownLine (self,event=None):
    '''Scroll the outline pane down one line.'''
    a,b = self.c.frame.canvas.leo_treeBar.get()
    if b < 1.0:
        self.c.frame.tree.canvas.yview_scroll(1,"unit")

def scrollOutlineDownPage (self,event=None):
    '''Scroll the outline pane down one page.'''
    a,b = self.c.frame.canvas.leo_treeBar.get()
    if b < 1.0:
        self.c.frame.tree.canvas.yview_scroll(1,"page")

def scrollOutlineUpLine (self,event=None):
    '''Scroll the outline pane up one line.'''
    a,b = self.c.frame.canvas.leo_treeBar.get()
    if a > 0.0:
        self.c.frame.tree.canvas.yview_scroll(-1,"unit")

def scrollOutlineUpPage (self,event=None):
    '''Scroll the outline pane up one page.'''
    a,b = self.c.frame.canvas.leo_treeBar.get()
    if a > 0.0:
        self.c.frame.tree.canvas.yview_scroll(-1,"page")
#@-node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
#@+node:ekr.20060726154531:scrollOutlineLeftRight
def scrollOutlineLeft (self,event=None):
    '''Scroll the outline left.'''
    self.c.frame.tree.canvas.xview_scroll(1,"unit")

def scrollOutlineRight (self,event=None):
    '''Scroll the outline left.'''
    self.c.frame.tree.canvas.xview_scroll(-1,"unit")
#@-node:ekr.20060726154531:scrollOutlineLeftRight
#@-node:ekr.20060309060654:scrolling...
#@+node:ekr.20050920084036.117:sort...
'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
#@+node:ekr.20050920084036.118:sortLines
def sortLines (self,event,which=None):

    '''Sort lines of the selected text by comparing the entire text of a line.
    A prefix argument means sort in descending order.'''

    c = self.c ; k = c.k
    w = self.editWidget(event)
    if not self._chckSel(event): return

    self.beginCommand(undoType='sort-lines')
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        aList = g.splitLines(s[i:j])
        aList.sort()
        if which: aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.118:sortLines
#@+node:ekr.20050920084036.119:sortColumns
def sortColumns (self,event):

    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    k = self.k
    w = self.editWidget(event)
    if not self._chckSel(event): return
    self.beginCommand(undoType='sort-columns')
    try:
        s = w.getAllText()
        ins = w.getInsertPoint()
        sel_1,sel_2 = w.getSelectionRange()
        sint1,sint2 = g.convertPythonIndexToRowCol(s,sel_1)
        sint3,sint4 = g.convertPythonIndexToRowCol(s,sel_2)
        sint1 += 1 ; sint3 += 1
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        txt = s[i:j]
        columns = [w.get('%s.%s' % (z,sint2),'%s.%s' % (z,sint4))
            for z in xrange(sint1,sint3+1)]
        aList = g.splitLines(txt)
        zlist = zip(columns,aList)
        zlist.sort()
        s = g.joinLines([z[1] for z in zlist])
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_1+len(s),insert=sel_1+len(s))
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.119:sortColumns
#@+node:ekr.20050920084036.120:sortFields
def sortFields (self,event,which=None):

    '''Divide the selected text into lines and sort by comparing the contents of
     one field in each line. Fields are defined as separated by whitespace, so
     the first run of consecutive non-whitespace characters in a line
     constitutes field 1, the second such run constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to sort by
     field 1, etc. A negative argument means sort in descending order. Thus,
     minus 2 means sort by field 2 in reverse-alphabetical order.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-fields')

    s = w.getAllText()
    ins = w.getInsertPoint()
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    i,junk = g.getLine(s,r1)
    junk,j = g.getLine(s,r4)
    txt = s[i:j] # bug reported by pychecker.
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for line in txt:
        f = frx.findall(line)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) < i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    #w.delete('%s linestart' % is1,'%s lineend' % is2)
    w.delete(i,j)
    #i = is1.split('.')
    #int1 = int(i[0])
    int1 = i
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.setInsertPoint(ins)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.120:sortFields
#@-node:ekr.20050920084036.117:sort...
#@+node:ekr.20050920084036.121:swap/transpose...
#@+node:ekr.20060529184652:swapHelper
def swapHelper (self,w,find,ftext,lind,ltext):

    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
#@-node:ekr.20060529184652:swapHelper
#@+node:ekr.20050920084036.122:transposeLines (pass)
def transposeLines (self,event):

    '''Transpose the line containing the cursor with the preceding line.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    if not s.strip(): return

    i,j = g.getLine(s,ins)
    line1 = s[i:j]

    self.beginCommand(undoType='transpose-lines')

    if i == 0: # Transpose the next line.
        i2,j2 = g.getLine(s,j+1)
        line2 = s[i2:j2]
        w.delete(0,j2)
        w.insert(0,line2+line1)
        w.setInsertPoint(j2-1)
    else: # Transpose the previous line.
        i2,j2 = g.getLine(s,i-1)
        line2 = s[i2:j2]
        w.delete(i2,j)
        w.insert(i2,line1+line2)
        w.setInsertPoint(j-1)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.122:transposeLines (pass)
#@+node:ekr.20050920084036.123:swapWords
def swapWords (self,event,swapspots):

    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('swap-words command not ready yet',color='blue')

    s = w.getAllText()

    txt = w.get('insert wordstart','insert wordend') ###
    if not txt: return

    i = w.index('insert wordstart') ###

    self.beginCommand(undoType='swap-words')

    if len(swapspots):
        if i > swapspots[1]:
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif i < swapspots[1]:
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.123:swapWords
#@+node:ekr.20060529184652.1:transposeWords (doesn't work)
def transposeWords (self,event):

    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='transpose-words')
    self.swapWords(event,self.swapSpots)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20060529184652.1:transposeWords (doesn't work)
#@+node:ekr.20050920084036.124:swapCharacters & transeposeCharacters
def swapCharacters (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='swap-characters')

    s = w.getAllText()
    i = w.getInsertPoint()
    if 0 < i < len(s):
        w.setAllText(s[:i-1] + s[i] + s[i-1] + s[i+1:])
        w.setSelectionRange(i,i,insert=i)

    self.endCommand(changed=True,setLabel=True)

transposeCharacters = swapCharacters
#@-node:ekr.20050920084036.124:swapCharacters & transeposeCharacters
#@-node:ekr.20050920084036.121:swap/transpose...
#@+node:ekr.20050920084036.126:tabify & untabify
def tabify (self,event):
    '''Convert 4 spaces to tabs in the selected text.'''
    self.tabifyHelper (event,which='tabify')

def untabify (self,event):
    '''Convert tabs to 4 spaces in the selected text.'''
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    k = self.k ; w = self.editWidget(event)
    if not w or not w.hasSelection(): return

    self.beginCommand(undoType=which)

    i,end = w.getSelectionRange()
    txt = w.getSelectedText()
    if which == 'tabify':
        pattern = re.compile(' {4,4}') # Huh?
        ntxt = pattern.sub('\t',txt)
    else:
        pattern = re.compile('\t')
        ntxt = pattern.sub('    ',txt)
    w.delete(i,end)
    w.insert(i,ntxt)
    n = i + len(ntxt)
    w.setSelectionRange(n,n,insert=n)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.126:tabify & untabify
#@+node:ekr.20061111223516:selectAllText (leoEditCommands)
def selectAllText (self,event):

    c = self.c 
    w = g.app.gui.eventWidget(event) or c.frame.body.bodyCtrl
    return w.selectAllText()
#@-node:ekr.20061111223516:selectAllText (leoEditCommands)
#@-node:ekr.20050920084036.53:editCommandsClass
#@+node:ekr.20050920084036.161:editFileCommandsClass
class editFileCommandsClass (baseEditCommandsClass):

    '''A class to load files into buffers and save buffers to files.'''

    @others
#@+node:ekr.20050920084036.162: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
#@-node:ekr.20050920084036.162: ctor
#@+node:ekr.20050920084036.163: getPublicCommands (editFileCommandsClass)
def getPublicCommands (self):

    k = self.k

    return {
        'delete-file':          self.deleteFile,
        'diff':                 self.diff, 
        'insert-file':          self.insertFile,
        'make-directory':       self.makeDirectory,
        'open-outline-by-name': self.openOutlineByName,
        'remove-directory':     self.removeDirectory,
        'save-file':            self.saveFile
    }
#@-node:ekr.20050920084036.163: getPublicCommands (editFileCommandsClass)
#@+node:ekr.20050920084036.164:deleteFile
def deleteFile (self,event):

    '''Prompt for the name of a file and delete it.'''

    k = self.k ; state = k.getState('delete_file')

    if state == 0:
        prefix = 'Delete File: '
        k.setLabelBlue('%s%s%s' % (prefix,os.getcwd(),os.sep))
        k.getArg(event,'delete_file',1,self.deleteFile,prefix=prefix)
    else:
        k.keyboardQuit(event)
        k.clearState()
        try:
            os.remove(k.arg)
            k.setLabel('Deleted: %s' % k.arg)
        except:
            k.setLabel('Not Deleted: %s' % k.arg)
#@-node:ekr.20050920084036.164:deleteFile
#@+node:ekr.20050920084036.165:diff (revise)
def diff (self,event):

    '''Creates a node and puts the diff between 2 files into it.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    try:
        f, name = self.getReadableTextFile()
        txt1 = f.read() ; f.close()
        f2, name2 = self.getReadableTextFile()
        txt2 = f2.read() ; f2.close()
    except IOError: return

    ### self.switchToBuffer(event,"*diff* of ( %s , %s )" % (name,name2))
    data = difflib.ndiff(txt1,txt2)
    idata = []
    for z in data:
        idata.append(z)
    w.delete(0,'end')
    w.insert(0,''.join(idata))
#@-node:ekr.20050920084036.165:diff (revise)
#@+node:ekr.20050920084036.166:getReadableTextFile
def getReadableTextFile (self):

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Text File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return None, None

    try:
        f = open(fileName,'rt')
        return f, fileName
    except IOError:
        g.es('Can not open',fileName)
        return None,None
#@-node:ekr.20050920084036.166:getReadableTextFile
#@+node:ekr.20050920084036.167:insertFile
def insertFile (self,event):

    '''Prompt for the name of a file and put the selected text into it.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    f, name = self.getReadableTextFile()
    if f:
        txt = f.read()
        f.close()
        w.insert('insert',txt)
        w.seeInsertPoint()
#@-node:ekr.20050920084036.167:insertFile
#@+node:ekr.20050920084036.168:makeDirectory
def makeDirectory (self,event):

    '''Prompt for the name of a directory and create it.'''

    k = self.k ; state = k.getState('make_directory')

    if state == 0:
        prefix = 'Make Directory: '
        k.setLabelBlue('%s%s%s' % (prefix,os.getcwd(),os.sep))
        k.getArg(event,'make_directory',1,self.makeDirectory,prefix=prefix)
    else:
        k.keyboardQuit(event)
        k.clearState()
        try:
            os.mkdir(k.arg)
            k.setLabel("Created: %s" % k.arg)
        except:
            k.setLabel("Not Create: %s" % k.arg)
#@-node:ekr.20050920084036.168:makeDirectory
#@+node:ekr.20060419123128:open-outline-by-name
def openOutlineByName (self,event):

    '''Prompt for the name of a Leo outline and open it.'''

    k = self.k
    k.setLabelBlue('Open Leo Outline: ',protect=True)
    k.getFileName(event,handler=self.openOutlineByNameFinisher)

def openOutlineByNameFinisher (self,event):

    c = self.c ; k = self.k ; fileName = k.arg

    k.resetLabel()
    if fileName and g.os_path_exists(fileName) and not g.os_path_isdir(fileName):
        g.openWithFileName(fileName,c)
#@-node:ekr.20060419123128:open-outline-by-name
#@+node:ekr.20050920084036.169:removeDirectory
def removeDirectory (self,event):

    '''Prompt for the name of a directory and delete it.'''

    k = self.k ; state = k.getState('remove_directory')

    if state == 0:
        prefix = 'Remove Directory: '
        k.setLabelBlue('%s%s%s' % (prefix,os.getcwd(),os.sep))
        k.getArg(event,'remove_directory',1,self.removeDirectory,prefix=prefix)
    else:
        k.keyboardQuit(event)
        k.clearState()
        try:
            os.rmdir(k.arg)
            k.setLabel('Removed: %s' % k.arg)
        except:
            k.setLabel('Not Remove: %s' % k.arg)
#@-node:ekr.20050920084036.169:removeDirectory
#@+node:ekr.20050920084036.170:saveFile
def saveFile (self,event):

    '''Prompt for the name of a file and put the body text of the selected node into it..'''

    w = self.editWidget(event)
    if not w: return

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='save-file',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        s = w.getAllText()
        f = open(fileName,'w')
        f.write(s)
        f.close()
    except IOError:
        g.es('Can not create',fileName)
#@-node:ekr.20050920084036.170:saveFile
#@-node:ekr.20050920084036.161:editFileCommandsClass
#@+node:ekr.20060205164707:helpCommandsClass
class helpCommandsClass (baseEditCommandsClass):

    '''A class to load files into buffers and save buffers to files.'''

    @others
#@+node:ekr.20060205165501:getPublicCommands (helpCommands)
def getPublicCommands (self):

    c = self.c

    return {
        'help-for-minibuffer':      self.helpForMinibuffer,
        'help-for-command':         self.helpForCommand,
        'apropos-autocompletion':   self.aproposAutocompletion,
        'apropos-bindings':         self.aproposBindings,
        'apropos-debugging-commands': self.aproposDebuggingCommands,
        'apropos-find-commands':    self.aproposFindCommands,
        'print-settings':           self.printSettings,
        'python-help':              self.pythonHelp,
    }
#@-node:ekr.20060205165501:getPublicCommands (helpCommands)
#@+node:ekr.20051014170754:helpForMinibuffer
def helpForMinibuffer (self,event=None):

    '''Print a messages telling you how to get started with Leo.'''

    # A bug in Leo: triple quotes puts indentation before each line.
    c = self.c
    s = '''
The mini-buffer is intended to be like the Emacs buffer:

full-command: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a
full command name, then hit <Return> to execute the command. Tab completion
works, but not yet for file names.

quick-command-mode (default shortcut: Alt-x). Like Emacs Control-C. This mode is
defined in leoSettings.leo. It is useful for commonly-used commands.

universal-argument (default shortcut: Alt-u). Like Emacs Ctrl-u. Adds a repeat
count for later command. Ctrl-u 999 a adds 999 a's. Many features remain
unfinished.

keyboard-quit (default shortcut: Ctrl-g) Exits any minibuffer mode and puts
the focus in the body pane.

Use the help-for-command command to see documentation for a particular command.
'''

    s = g.adjustTripleString(s,c.tab_width)
        # Remove indentation from indentation of this function.
    # s = s % (shortcuts[0],shortcuts[1],shortcuts[2],shortcuts[3])

    if not g.app.unitTesting:
        g.es_print(s)
#@+node:ekr.20060205165654:test_helpForMinibuffer
def test_helpForMinibuffer(self):

    c.helpCommands.helpForMinibuffer()
#@-node:ekr.20060205165654:test_helpForMinibuffer
#@-node:ekr.20051014170754:helpForMinibuffer
#@+node:ekr.20060417203717:helpForCommand
def helpForCommand (self,event):

    '''Prompts for a command name and prints the help message for that command.'''

    k = self.k
    k.fullCommand(event,help=True,helpHandler=self.helpForCommandFinisher)

def helpForCommandFinisher (self,commandName):

    c = self.c
    bindings = self.getBindingsForCommand(commandName)
    func = c.commandsDict.get(commandName)
    if func and func.__doc__:
        s = ''.join([
            g.choose(line.strip(),line.lstrip(),'\n')
                for line in g.splitLines(func.__doc__)])
    else:
        s = 'no docstring'
    g.es('%s:%s\n%s\n' % (commandName,bindings,s),color='blue')

def getBindingsForCommand(self,commandName):

    c = self.c ; k = c.k ; d = k.bindingsDict
    keys = d.keys() ; keys.sort()

    data = [] ; n1 = 4 ; n2 = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            if b.commandName == commandName:
                pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
                s1 = pane
                s2 = k.prettyPrintKey(key,brief=True)
                s3 = b.commandName
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)

    data.sort(lambda x,y: cmp(x[1],y[1]))

    return ','.join(['%s %s' % (s1,s2) for s1,s2,s3 in data])
        # g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3))
#@nonl
#@-node:ekr.20060417203717:helpForCommand
#@+node:ekr.20060226131603.1:aproposAutocompletion
def aproposAutocompletion (self,event=None):

    '''Prints a discussion of autocompletion.'''

    c = self.c ; s = '''
This documentation describes both autocompletion and calltips.

Typing a period when @language python is in effect starts autocompletion. Typing
'(' during autocompletion shows the calltip. Typing Return or Control-g
(keyboard-quit) exits autocompletion or calltips.

Autocompletion

Autocompletion shows what may follow a period in code. For example, after typing
g. Leo will show a list of all the global functions in leoGlobals.py.
Autocompletion works much like tab completion in the minibuffer. Unlike the
minibuffer, the presently selected completion appears directly in the body
pane.

A leading period brings up 'Autocomplete Modules'. (The period goes away.) You
can also get any module by typing its name. If more than 25 items would appear
in the Autocompleter tab, Leo shows only the valid starting characters. At this
point, typing an exclamation mark shows the complete list. Thereafter, typing
further exclamation marks toggles between full and abbreviated modes.

If x is a list 'x.!' shows all its elements, and if x is a Python dictionary,
'x.!' shows x.keys(). For example, 'sys.modules.!' Again, further exclamation
marks toggles between full and abbreviated modes.

During autocompletion, typing a question mark shows the docstring for the
object. For example: 'g.app?' shows the docstring for g.app. This doesn't work
(yet) directly for Python globals, but '__builtin__.f?' does. Example:
'__builtin__.pow?' shows the docstring for pow.

Autocompletion works in the Find tab; you can use <Tab> to cycle through the
choices. The 'Completion' tab appears while you are doing this; the Find tab
reappears once the completion is finished.

Calltips

Calltips appear after you type an open parenthesis in code. Calltips shows the
expected arguments to a function or method. Calltips work for any Python
function or method, including Python's global function. Examples:

a)  'g.toUnicode('  gives 'g.toUnicode(s, encoding, reportErrors=False'
b) 'c.widgetWantsFocusNow' gives 'c.widgetWantsFocusNow(w'
c) 'reduce(' gives 'reduce(function, sequence[, initial]) -> value'

The calltips appear directly in the text and the argument list is highlighted so
you can just type to replace it. The calltips appear also in the status line for
reference after you have started to replace the args.

Options

Both autocompletion and calltips are initially enabled or disabled by the
enable_autocompleter_initially and enable_calltips_initially settings in
leoSettings.leo. You may enable or disable these features at any time with these
commands: enable-autocompleter, enable-calltips, disable-autocompleter and
disable-calltips.
'''

    if not g.app.unitTesting:
        # Remove indentation from indentation of this function.
        s = g.adjustTripleString(s,c.tab_width)
        g.es_print(s)
#@+node:ekr.20060226132000:test_aproposAutocompletion
def test_aproposAutocompletion (self):

    c.helpCommands.aproposAutocompletion()
#@-node:ekr.20060226132000:test_aproposAutocompletion
#@-node:ekr.20060226131603.1:aproposAutocompletion
#@+node:ekr.20060205170335:aproposBindings
def aproposBindings (self,event=None):

    '''Prints a discussion of keyboard bindings.'''

    c = self.c
    s = '''
A shortcut specification has the form:

command-name = shortcutSpecifier

or

command-name ! pane = shortcutSpecifier

The first form creates a binding for all panes except the minibuffer. The second
form creates a binding for one or more panes. The possible values for 'pane'
are:

pane    bound panes
----    -----------
all     body,log,tree
body    body
log     log
mini    minibuffer
text    body,log
tree    tree

You may use None as the specifier. Otherwise, a shortcut specifier consists of a
head followed by a tail. The head may be empty, or may be a concatenation of the
following: (All entries in each row are equivalent).

Shift+ Shift-
Alt+ or Alt-
Control+, Control-, Ctrl+ or Ctrl-

Notes:

1. The case of plain letters is significant:  a is not A.

2. The Shift- (or Shift+) prefix can be applied *only* to letters or
multi-letter tails. Leo will ignore (with a warning) the shift prefix applied to
other single letters, e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is *not*
significant.

The following table illustrates these rules.  In each row, the first entry is the key (for k.bindingsDict) and the other entries are equivalents that the user may specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam
'''

    s = g.adjustTripleString(s,c.tab_width)
        # Remove indentation from indentation of this function.

    if not g.app.unitTesting:
        g.es_print(s)
#@+node:ekr.20060205170435:test_apropos_bindings
def test_apropos_bindings (self):

    c.helpCommands.aproposBindings()
#@-node:ekr.20060205170435:test_apropos_bindings
#@-node:ekr.20060205170335:aproposBindings
#@+node:ekr.20070501092655:aproposDebuggingCommands
def aproposDebuggingCommands (self,event=None):

    '''Prints a discussion of of Leo's debugging commands.'''

    c = self.c

    << define s >>

    # Remove indentation from s: a workaround of a Leo bug.
    s = g.adjustTripleString(s,c.tab_width)

    if not g.app.unitTesting:
        g.es_print(s)
#@+node:ekr.20070501092655.1:<< define s >>
s = '''
The following commands are useful for debugging:

collect-garbage:   Invoke the garbage collector.
debug:             Start an external debugger in another process.
disable-gc-trace:  Disable tracing of the garbage collector.
dump-all-objects:  Print a summary of all existing Python objects.
dump-new-objects:  Print a summary of all newly-created Python objects.
enable-gc-trace:   Enable tracing of the garbage collector.
free-tree-widgets: Free all widgets used in Leo's outline pane.
print-focus:       Print information about the requested focus.
print-stats:       Print statistics about existing Python objects.
print-gc-summary:  Print a brief summary of all Python objects.
run-unit-tests:    Run unit tests in the presently selected tree.
verbose-dump-objects: Print a more verbose listing of all existing Python objects.

Leo also has many debugging settings that enable and disable traces.
For details, see the node: @settings-->Debugging in leoSettings.leo.
'''
#@-node:ekr.20070501092655.1:<< define s >>
#@-node:ekr.20070501092655:aproposDebuggingCommands
#@+node:ekr.20060205170335.1:aproposFindCommands
def aproposFindCommands (self, event=None):

    '''Prints a discussion of of Leo's find commands.'''

    c = self.c

    << define s >>

    # Remove indentation from s: a workaround of a Leo bug.
    s = g.adjustTripleString(s,c.tab_width)

    if not g.app.unitTesting:
        g.es_print(s)
#@+node:ekr.20060209082023.1:<< define s >>
s = '''
Important: all minibuffer search commands, with the exception of the isearch (incremental) commands, simply provide a minibuffer interface to Leo's legacy find commands.  This means that all the powerful features of Leo's legacy commands are available to the minibuffer search commands.

Note: all bindings shown are the default bindings for these commands.  You may change any of these bindings using @shortcut nodes in leoSettings.leo.

Settings

leoSettings.leo now contains several settings related to the Find tab:

- @bool show_only_find_tab_options = True

When True (recommended), the Find tab does not show the 'Find', 'Change', 'Change, Then Find', 'Find All' and 'Change All' buttons.

- @bool minibufferSearchesShowFindTab = True

When True, Leo shows the Find tab when executing most of the commands discussed below.  It's not necessary for it to be visible, but I think it provides good feedback about what search-with-present-options does.  YMMY.  When True, the sequence Control-F, Control-G is one way to show the Find Tab.

Basic find commands

- The open-find-tab command makes the Find tab visible.  The Find tab does **not** need to be visible to execute any search command discussed below.

- The hide-find-tab commands hides the Find tab, but retains all the present settings.

- The search-with-present-options command (Control-F) prompts for a search string.  Typing the <Return> key puts the search string in the Find tab and executes a search based on all the settings in the Find tab. This is a recommended default (Control-F) search command.

- The show-search-options command shows the present search options in the status line.  At present, this command also makes the Find tab visible.

Search again commands

- The find-next command (F3) is the same as the search-with-present-options command, except that it uses the search string in the find-tab.  Recommended as the default 'search again' command.

- Similarly, the find-previous command (F2) repeats the command specified by the Find tab,
  but in reverse.

- The find-again is the same as the find-next command if a search pattern is not '<find pattern here>'.
  Otherwise, the find-again is the same as the search-with-present-options command.

Setting find options

- Several minibuffer commands toggle the checkboxes and radio buttons in the Find tab, and thus affect the operation of the search-with-present-options command. Some may want to bind these commands to keys. Others, will prefer to toggle options in a mode.

Here are the commands that toggle checkboxes: toggle-find-ignore-case-option, toggle-find-in-body-option, toggle-find-in-headline-option, toggle-find-mark-changes-option, toggle-find-mark-finds-option, toggle-find-regex-option, toggle-find-reverse-option, toggle-find-word-option, and toggle-find-wrap-around-option.

Here are the commands that set radio buttons: set-find-everywhere, set-find-node-only, and set-find-suboutline-only.

- The enter-find-options-mode (Ctrl-Shift-F) enters a mode in which you may change all checkboxes and radio buttons in the Find tab with plain keys.  As always, you can use the mode-help (Tab) command to see a list of key bindings in effect for the mode.

Search commands that set options as a side effect

The following commands set an option in the Find tab, then work exactly like the search-with-present-options command.

- The search-backward and search-forward commands set the 'Whole Word' checkbox to False.

- The word-search-backward and word-search-forward set the 'Whole Word' checkbox to True.

- The re-search-forward and re-search-backward set the 'Regexp' checkbox to True.

Find all commands

- The find-all command prints all matches in the log pane.

- The clone-find-all command replaces the previous 'Clone Find' checkbox.  It prints all matches in the log pane, and creates a node at the beginning of the outline containing clones of all nodes containing the 'find' string.  Only one clone is made of each node, regardless of how many clones the node has, or of how many matches are found in each node.

Note: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by the find-all and clone-find-all commands.

Search and replace commands

The replace-string prompts for a search string.  Type <Return> to end the search string.  The command will then prompt for the replacement string.  Typing a second <Return> key will place both strings in the Find tab and executes a **find** command, that is, the search-with-present-options command.

So the only difference between the replace-string and search-with-present-options commands is that the replace-string command has the side effect of setting 'change' string in the Find tab.  However, this is an extremely useful side effect, because of the following commands...

- The change command (Ctrl-=) replaces the selected text with the 'change' text in the Find tab.

- The change-then-find (Ctrl--) replaces the selected text with the 'change' text in the Find tab, then executes the find command again.

The find-next, change and change-then-find commands can simulate any kind of query-replace command.  **Important**: Leo presently has separate query-replace and query-replace-regex commands, but they are buggy and 'under-powered'.  Fixing these commands has low priority.

- The change-all command changes all occurrences of the 'find' text with the 'change' text.  Important: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by this command.

Incremental search commands

Leo's incremental search commands are completely separate from Leo's legacy search commands.  At present, incremental search commands do not cross node boundaries: they work only in the body text of single node.

Coming in Leo 4.4b3: the incremental commands will maintain a list of previous matches.  This allows for

a) support for backspace and
b) an incremental-search-again command.

Furthermore, this list makes it easy to detect the end of a wrapped incremental search.

Here is the list of incremental find commands: isearch-backward, isearch-backward-regexp, isearch-forward and
isearch-forward-regexp.'''
#@-node:ekr.20060209082023.1:<< define s >>
#@+node:ekr.20060205170552:test_apropos_find_commands
def test_apropos_find_commands (self):

    # pychecker complains about c.

    c.helpCommands.aproposFindCommands()
#@-node:ekr.20060205170552:test_apropos_find_commands
#@-node:ekr.20060205170335.1:aproposFindCommands
#@+node:ekr.20060602154458:pythonHelp
def pythonHelp (self,event=None):

    '''Prompt for a arg for Python's help function, and put it to the log pane.'''

    c = self.c ; k = c.k ; tag = 'python-help' ; state = k.getState(tag)

    if state == 0:
        c.frame.minibufferWantsFocus()
        k.setLabelBlue('Python help: ',protect=True)
        k.getArg(event,tag,1,self.pythonHelp)
    else:
        k.clearState()
        k.resetLabel()
        s = k.arg.strip()
        if s:
            g.redirectStderr()
            g.redirectStdout()
            try: help(str(s))
            except Exception: pass
            g.restoreStderr()
            g.restoreStdout()
#@-node:ekr.20060602154458:pythonHelp
#@+node:ekr.20070418074444:printSettings
def printSettings (self,event=None):

    g.app.config.printSettings(self.c)
#@-node:ekr.20070418074444:printSettings
#@-node:ekr.20060205164707:helpCommandsClass
#@+node:ekr.20050920084036.171:keyHandlerCommandsClass (add docstrings)
class keyHandlerCommandsClass (baseEditCommandsClass):

    '''User commands to access the keyHandler class.'''

    @others
#@+node:ekr.20050920084036.172: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
#@-node:ekr.20050920084036.172: ctor
#@+node:ekr.20050920084036.173:getPublicCommands (keyHandler)
def getPublicCommands (self):

    k = self.k

    return {
        'auto-complete':            k.autoCompleter.autoComplete,
        'auto-complete-force':      k.autoCompleter.autoCompleteForce,
        'digit-argument':           k.digitArgument,
        'disable-autocompleter':    k.autoCompleter.disableAutocompleter,
        'disable-calltips':         k.autoCompleter.disableCalltips,
        'enable-autocompleter':     k.autoCompleter.enableAutocompleter,
        'enable-calltips':          k.autoCompleter.enableCalltips,
        'exit-named-mode':          k.exitNamedMode,
        'full-command':             k.fullCommand, # For menu.
        'hide-mini-buffer':         k.hideMinibuffer,
        'mode-help':                k.modeHelp,
        'negative-argument':        k.negativeArgument,
        'number-command':           k.numberCommand,
        'number-command-0':         k.numberCommand0,
        'number-command-1':         k.numberCommand1,
        'number-command-2':         k.numberCommand2,
        'number-command-3':         k.numberCommand3,
        'number-command-4':         k.numberCommand4,
        'number-command-5':         k.numberCommand5,
        'number-command-6':         k.numberCommand6,
        'number-command-7':         k.numberCommand7,
        'number-command-8':         k.numberCommand8,
        'number-command-9':         k.numberCommand9,
        'print-bindings':           k.printBindings,
        'print-commands':           k.printCommands,
        'repeat-complex-command':   k.repeatComplexCommand,
        # 'scan-for-autocompleter':   k.autoCompleter.scan,
        'set-command-state':        k.setCommandState,
        'set-insert-state':         k.setInsertState,
        'set-overwrite-state':      k.setOverwriteState,
        'show-calltips':            k.autoCompleter.showCalltips,
        'show-calltips-force':      k.autoCompleter.showCalltipsForce,
        'show-mini-buffer':         k.showMinibuffer,
        'toggle-autocompleter':     k.autoCompleter.toggleAutocompleter,
        'toggle-calltips':          k.autoCompleter.toggleCalltips,
        'toggle-mini-buffer':       k.toggleMinibuffer,
        'toggle-input-state':       k.toggleInputState,
        'universal-argument':       k.universalArgument,
    }
#@-node:ekr.20050920084036.173:getPublicCommands (keyHandler)
#@-node:ekr.20050920084036.171:keyHandlerCommandsClass (add docstrings)
#@+node:ekr.20050920084036.174:killBufferCommandsClass (add docstrings)
class killBufferCommandsClass (baseEditCommandsClass):

    '''A class to manage the kill buffer.'''

    @others
#@+node:ekr.20050920084036.175: ctor & finishCreate
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.reset = False

def finishCreate (self):

    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k

    if self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
#@-node:ekr.20050920084036.175: ctor & finishCreate
#@+node:ekr.20050920084036.176: getPublicCommands
def getPublicCommands (self):

    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
#@-node:ekr.20050920084036.176: getPublicCommands
#@+node:ekr.20050920084036.183:addToKillBuffer
def addToKillBuffer (self,text):

    killKeys =(
        '<Control-k>', '<Control-w>',
        '<Alt-d>', '<Alt-Delete', '<Alt-z>', '<Delete>',
        '<Control-Alt-w>')

    k = self.k
    self.reset = True

    # g.trace(repr(text))

    if self.killBuffer and k.stroke in killKeys:
        self.killBuffer [0] = self.killBuffer [0] + text
    else:
        self.killBuffer.insert(0,text)
#@-node:ekr.20050920084036.183:addToKillBuffer
#@+node:ekr.20050920084036.181:backwardKillSentence
def backwardKillSentence (self,event):

    '''Kill the previous sentence.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.rfind('.',ins)
    if i == -1: return

    undoType='backward-kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,i) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.181:backwardKillSentence
#@+node:ekr.20050920084036.180:backwardKillWord & killWord
def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

#@-node:ekr.20050920084036.180:backwardKillWord & killWord
#@+node:ekr.20051216151811:clearKillRing
def clearKillRing (self,event=None):

    '''Clear the kill ring.'''

    self.killBuffer = []
#@-node:ekr.20051216151811:clearKillRing
#@+node:ekr.20050920084036.185:getClipboard
def getClipboard (self,w):

    __pychecker__ = '--no-argsused' # w not used.

    try:
        ctxt = g.app.gui.getTextFromClipboard()
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except:
        g.es_exception()

    return None
#@-node:ekr.20050920084036.185:getClipboard
#@+node:ekr.20050920084036.184:iterateKillBuffer
def iterateKillBuffer (self):

    while 1:
        if self.killBuffer:
            self.last_clipboard = None
            for z in self.killBuffer:
                if self.reset:
                    self.reset = False
                    break
                yield z
#@-node:ekr.20050920084036.184:iterateKillBuffer
#@+node:ekr.20050920084036.178:kill, killLine
def kill (self,event,frm,to,undoType=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    w.delete(frm,to)
    w.setInsertPoint(frm)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    # g.trace(i,j,ins,len(s),repr(s[i:j]))
    if ins >= len(s) and g.match(s,j-1,'\n'): # Kill the trailing newline.
        i = max(0,len(s)-1)
        j = len(s)
    elif j > i+1 and g.match(s,j-1,'\n'): # Kill the line, but not the newline.
        j -= 1
    else: # Kill the newline.
        pass
    self.kill(event,i,j,undoType='kill-line')
#@-node:ekr.20050920084036.178:kill, killLine
#@+node:ekr.20050920084036.182:killRegion & killRegionSave & helper
def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)

def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    theRange = w.tag_ranges('sel')
    if not theRange: return

    s = w.get(theRange[0],theRange[-1])
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(theRange[0],theRange[-1])
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    # self.removeRKeys(w)
#@-node:ekr.20050920084036.182:killRegion & killRegionSave & helper
#@+node:ekr.20050930095323.1:killSentence
def killSentence (self,event):

    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins)
    if i == -1: return

    undoType='kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,ins) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930095323.1:killSentence
#@+node:ekr.20050930100733:killWs
def killWs (self,event,undoType=None):

    ws = ''
    w = self.editWidget(event)
    if not w: return

    while 1:
        s = w.get('insert')
        if s in (' ','\t'):
            w.delete('insert')
            ws = ws + s
        else:
            break

    if ws:
        if undoType: self.beginCommand(undoType=undoType)
        self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930100733:killWs
#@+node:ekr.20050930091642.1:yank
def yank (self,event):

    '''Insert the next entry in the kill ring at the insert point.'''

    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    i = w.getInsertPoint()
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        self.beginCommand(undoType='yank')
        self.reset = True
        s = clip_text or self.kbiterator.next()
        w.tag_delete('kb')
        w.insert(i,s) # Insert the text, marked with the 'kb' tag.
        w.tag_add('kb',w.toGuiIndex(i),w.toGuiIndex(i+len(s)))
        w.setInsertPoint(i+len(s))
        c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930091642.1:yank
#@+node:ekr.20050930091642.2:yankPop
def yankPop (self,event):

    '''Replaces the just-yanked kill buffer with the contents of the previous kill buffer.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    t,t1 = g.convertPythonIndexToRowCol(s,ins)
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        s = clip_text or self.kbiterator.next()
        r = w.tag_ranges('kb') ###
        if r:
            r1,r2 = r
            r1,r2 = w.toPythonIndex(r1),w.toPythonIndex(r2)
            if r1 == ins:
                w.delete(r1,r2)
        w.tag_delete('kb') ###
        w.insert('insert',s,('kb')) ###
        w.setInsertPoint(ins)
#@-node:ekr.20050930091642.2:yankPop
#@+node:ekr.20050920084036.128:zapToCharacter
def zapToCharacter (self,event):

    '''Kill characters from the insertion point to a given character.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        ch = event and event.char or ' '
        k.resetLabel()
        k.clearState()
        if ch.isspace(): return
        s = w.getAllText()
        ins = w.getInsertPoint()
        i = s.find(ch,ins)
        if i == -1: return
        self.beginCommand(undoType='zap-to-char')
        self.addToKillBuffer(s[ins:i])
        w.setAllText(s[:ins] + s[i:])
        w.setInsertPoint(ins)
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.128:zapToCharacter
#@-node:ekr.20050920084036.174:killBufferCommandsClass (add docstrings)
#@+node:ekr.20050920084036.186:leoCommandsClass (add docstrings)
class leoCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20050920084036.187: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
#@-node:ekr.20050920084036.187: ctor
#@+node:ekr.20050920084036.188:leoCommands.getPublicCommands
def getPublicCommands (self):

    '''(leoCommands) Return a dict of the 'legacy' Leo commands.'''

    k = self.k ; d2 = {}

    << define dictionary d of names and Leo commands >>

    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        d2 [name] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))

    return d2
#@+node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'beautify-all':                 c.beautifyAllPythonCode,
    'beautify':                     c.beautifyPythonCode,
    'cascade-windows':              f.cascade,
    'clear-recent-files':           c.clearRecentFiles,
    'close-window':                 c.close,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'check-python-code':            c.checkPythonCode,
    'check-all-python-code':        c.checkAllPythonCode,
    'check-outline':                c.checkOutline,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'contract-node':                c.contractNode,
    'contract-all':                 c.contractAllHeadlines,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-ancestors-only':        c.expandOnlyAncestorsOfNode,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    'extract-section':              c.extractSection,
    'flatten-outline':              c.flattenOutline,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible':            c.goToLastVisibleNode,
    'goto-line-number':             c.goToLineNumber,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hide-invisibles':              c.hideInvisibles,
    'hoist':                        c.hoist,
    'import-at-file':               c.importAtFile,
    'import-at-root':               c.importAtRoot,
    'import-cweb-files':            c.importCWEBFiles,
    'import-derived-file':          c.importDerivedFile,
    'import-flattened-outline':     c.importFlattenedOutline,
    'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-node':                  c.insertHeadline,
    'insert-body-time':             c.insertBodyTime,
    'insert-headline-time':         f.insertHeadlineTime,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    'mark-changed-roots':           c.markChangedRoots,
    'mark-clones':                  c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-brackets':               c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    'open-compare-window':          c.openCompareWindow,
    'open-find-dialog':             c.showFindPanel, # Deprecated.
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-scripts-leo':             c.openLeoScripts,
    'open-myLeoSettings-leo':       c.openMyLeoSettings,
    'open-online-home':             c.leoHome,
    'open-online-tutorial':         c.leoTutorial,
    'open-offline-tutorial':        f.leoHelp,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    # 'open-test-leo':              c.openTest, # Doesn't work.
    'open-users-guide':             c.leoUsersGuide,
    'open-with':                    c.openWith,
    'outline-to-cweb':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-outline-only':            c.readOutlineOnly,
    'redo':                         c.undoer.redo,
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'resize-to-screen':             f.resizeToScreen,
    'revert':                       c.revert,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-as-unzipped':        c.saveAsUnzipped,
    'save-file-as-zipped':          c.saveAsZipped,
    'save-file-to':                 c.saveTo,
    'settings':                     c.preferences,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'show-invisibles':              c.showInvisibles,
    'sort-children':                c.sortChildren,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-invisibles':            c.toggleShowInvisibles,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unindent-region':              c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
}
#@-node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
#@-node:ekr.20050920084036.188:leoCommands.getPublicCommands
#@-node:ekr.20050920084036.186:leoCommandsClass (add docstrings)
#@+node:ekr.20050920084036.190:macroCommandsClass
class macroCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20050920084036.191: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.lastMacro = None
    self.macs = []
    self.macro = []
    self.namedMacros = {}

    # Important: we must not interfere with k.state in startKbdMacro!
    self.recordingMacro = False
#@-node:ekr.20050920084036.191: ctor
#@+node:ekr.20050920084036.192: getPublicCommands
def getPublicCommands (self):

    return {
        'call-last-keyboard-macro': self.callLastKeyboardMacro,
        'end-kbd-macro':            self.endKbdMacro,
        'name-last-kbd-macro':      self.nameLastKbdMacro,
        'load-file':                self.loadFile,
        'insert-keyboard-macro' :   self.insertKeyboardMacro,
        'start-kbd-macro':          self.startKbdMacro,
    }
#@-node:ekr.20050920084036.192: getPublicCommands
#@+node:ekr.20050920084036.193:Entry points
#@+node:ekr.20050920084036.194:insertKeyboardMacro
def insertKeyboardMacro (self,event):

    '''Save all macros to a file.'''

    k = self.k ; state = k.getState('macro-name')
    prompt = 'Macro name: '

    if state == 0:
        k.setLabelBlue(prompt,protect=True)
        k.getArg(event,'macro-name',1,self.insertKeyboardMacro)
    else:
        ch = event.keysym ; s = s = k.getLabel(ignorePrompt=True)
        g.trace(repr(ch),repr(s))
        if ch == 'Return':
            k.clearState()
            self.saveMacros(event,s)
        elif ch == 'Tab':
            k.setLabel('%s%s' % (
                prompt,self.findFirstMatchFromList(s,self.namedMacros)),
                prompt=prompt,protect=True)
        else:
            k.updateLabel(event)
#@+node:ekr.20050920084036.195:findFirstMatchFromList
def findFirstMatchFromList (self,s,aList=None):

    '''This method finds the first match it can find in a sorted list'''

    k = self.k ; c = k.c

    if aList is not None:
        aList = c.commandsDict.keys()

    pmatches = [item for item in aList if item.startswith(s)]
    pmatches.sort()
    if pmatches:
        mstring = reduce(g.longestCommonPrefix,pmatches)
        return mstring

    return s
#@-node:ekr.20050920084036.195:findFirstMatchFromList
#@-node:ekr.20050920084036.194:insertKeyboardMacro
#@+node:ekr.20050920084036.196:loadFile & helpers
def loadFile (self,event):

    '''Asks for a macro file name to load.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Macro File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName)
        self._loadMacros(f)
    except IOError:
        g.es('Can not open',fileName)
#@+node:ekr.20050920084036.197:_loadMacros
def _loadMacros (self,f):

    '''Loads a macro file into the macros dictionary.'''

    k = self.k
    macros = cPickle.load(f)
    for z in macros:
        k.addToDoAltX(z,macros[z])
#@-node:ekr.20050920084036.197:_loadMacros
#@-node:ekr.20050920084036.196:loadFile & helpers
#@+node:ekr.20050920084036.198:nameLastKbdMacro
def nameLastKbdMacro (self,event):

    '''Prompt for the name to be given to the last recorded macro.'''

    k = self.k ; state = k.getState('name-macro')

    if state == 0:
        k.setLabelBlue('Name of macro: ',protect=True)
        k.getArg(event,'name-macro',1,self.nameLastKbdMacro)
    else:
        k.clearState()
        name = k.arg
        k.addToDoAltX(name,self.lastMacro)
        k.setLabelGrey('Macro defined: %s' % name)
#@-node:ekr.20050920084036.198:nameLastKbdMacro
#@+node:ekr.20050920084036.199:saveMacros & helper
def saveMacros (self,event,macname):

    '''Asks for a file name and saves it.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Save Macros',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = file(fileName,'a+')
        f.seek(0)
        if f:
            self._saveMacros(f,macname)
    except IOError:
        g.es('Can not create',fileName)

#@+node:ekr.20050920084036.200:_saveMacros
def _saveMacros( self, f , name ):
    '''Saves the macros as a pickled dictionary'''
    import cPickle
    fname = f.name
    try:
        macs = cPickle.load( f )
    except:
        macs = {}
    f.close()
    if self.namedMacros.has_key( name ):
        macs[ name ] = self.namedMacros[ name ]
        f = file( fname, 'w' )
        cPickle.dump( macs, f )
        f.close()
#@-node:ekr.20050920084036.200:_saveMacros
#@-node:ekr.20050920084036.199:saveMacros & helper
#@+node:ekr.20050920084036.204:startKbdMacro
def startKbdMacro (self,event):

    '''Start recording a keyboard macro.'''

    k = self.k

    if not self.recordingMacro:
        self.recordingMacro = True
        k.setLabelBlue('Recording keyboard macro...',protect=True)
    else:
        stroke = k.stroke ; keysym = event.keysym
        if stroke == '<Key>' and keysym in ('Control_L','Alt_L','Shift_L'):
            return False
        g.trace('stroke',stroke,'keysym',keysym)
        if stroke == '<Key>' and keysym ==')':
            self.endKbdMacro(event)
            return True
        elif stroke == '<Key>':
            self.macro.append((event.keycode,event.keysym))
            return True
        else:
            self.macro.append((stroke,event.keycode,event.keysym,event.char))
            return True
#@-node:ekr.20050920084036.204:startKbdMacro
#@+node:ekr.20050920084036.206:endKbdMacro
def endKbdMacro (self,event):

    '''Stop recording a keyboard macro.'''

    k = self.k ; self.recordingMacro = False

    if self.macro:
        self.macro = self.macro [: -4]
        self.macs.insert(0,self.macro)
        self.lastMacro = self.macro[:]
        self.macro = []
        k.setLabelGrey('Keyboard macro defined, not named')
    else:
        k.setLabelGrey('Empty keyboard macro')
#@-node:ekr.20050920084036.206:endKbdMacro
#@+node:ekr.20050920084036.202:callLastKeyboardMacro & helper (called from universal command)
def callLastKeyboardMacro (self,event):

    '''Call the last recorded keyboard macro.'''

    w = event and event.widget
    # This does **not** require a text widget.

    if self.lastMacro:
        self._executeMacro(self.lastMacro,w)
#@+node:ekr.20050920084036.203:_executeMacro (test)
def _executeMacro (self,macro,w):

    c = self.c ; k = self.k

    for z in macro:
        if len(z) == 2:
            w.event_generate('<Key>',keycode=z[0],keysym=z[1])
        else:
            meth = g.stripBrackets(z[0])
            bunchList = k.bindingsDict.get(meth,[]) ### Probably should not strip < and >
            if bunchList:
                b = bunchList [0]
                # ev = Tk.Event()
                # ev.widget = w
                # ev.keycode = z [1]
                # ev.keysym = z [2]
                # ev.char = z [3]
                event = g.Bunch(c=c,widget=w,keycode=z[1],keysym=z[2],char=z[3])
                k.masterCommand(event,b.f,'<%s>' % meth)
#@-node:ekr.20050920084036.203:_executeMacro (test)
#@-node:ekr.20050920084036.202:callLastKeyboardMacro & helper (called from universal command)
#@-node:ekr.20050920084036.193:Entry points
#@+node:ekr.20051006065746:Common Helpers
#@+node:ekr.20050920085536.15:addToDoAltX
# Called from loadFile and nameLastKbdMacro.

def addToDoAltX (self,name,macro):

    '''Adds macro to Alt-X commands.'''

    k= self ; c = k.c

    if c.commandsDict.has_key(name):
        return False

    def func (event,macro=macro):
        w = event and event.widget
        # This does **not** require a text widget.
        return self._executeMacro(macro,w)

    c.commandsDict [name] = func
    self.namedMacros [name] = macro
    return True
#@-node:ekr.20050920085536.15:addToDoAltX
#@-node:ekr.20051006065746:Common Helpers
#@-node:ekr.20050920084036.190:macroCommandsClass
#@+node:ekr.20050920084036.207:queryReplaceCommandsClass (limited to single node)
class queryReplaceCommandsClass (baseEditCommandsClass):

    '''A class to handle query replace commands.'''

    @others
#@+node:ekr.20050920084036.208: ctor & init
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    self.regexp = False # True: do query-replace-regexp.  Set in stateHandler.

def init (self):

    self.qQ = None
    self.qR = None
    self.replaced = 0 # The number of replacements.
#@-node:ekr.20050920084036.208: ctor & init
#@+node:ekr.20050920084036.209: getPublicCommands
def getPublicCommands (self):

    return {
        'query-replace':        self.queryReplace,
        'query-replace-regex':  self.queryReplaceRegex,
    }
#@-node:ekr.20050920084036.209: getPublicCommands
#@+node:ekr.20050920084036.210:Entry points
def queryReplace (self,event):

    '''Interactively find and replace text.
    This is not recommended: Leo's other find and change commands are more capable.'''
    self.regexp = False
    self.stateHandler(event)

def queryReplaceRegex (self,event):
    '''Interactively find and replace text using regular expressions.
    This is not recommended: Leo's other find and change commands are more capable.'''
    self.regexp = True
    self.stateHandler(event)
#@-node:ekr.20050920084036.210:Entry points
#@+node:ekr.20051005151838:Helpers
#@+node:ekr.20050920084036.212:doOneReplace
def doOneReplace (self,event):

    w = self.editWidget(event)
    if not w: return

    i = w.tag_ranges('qR')
    w.delete(i[0],i[1])
    w.insert('insert',self.qR)
    self.replaced += 1
#@-node:ekr.20050920084036.212:doOneReplace
#@+node:ekr.20050920084036.219:findNextMatch (query-replace)
def findNextMatch (self,event):

    '''Find the next match and select it.
    Return True if a match was found.
    Otherwise, call quitSearch and return False.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    w.tag_delete('qR')
    if self.regexp:
        << handle regexp >>
    else:
        << handle plain search >>
#@+node:ekr.20051005155611:<< handle regexp >>
try:
    regex = re.compile(self.qQ)
except:
    self.quitSearch(event,'Illegal regular expression')
    return False

txt = w.get('insert','end')
match = regex.search(txt)

if match:
    start = match.start()
    end = match.end()
    length = end - start
    i = w.getInsertPoint()
    w.setInsertPoint(i+start)
    w.tag_add('qR','insert','insert +%sc' % length)
    w.tag_config('qR',background='lightblue')
    txt = w.get('insert','insert +%sc' % length)
    return True
else:
    self.quitSearch(event)
    return False
#@-node:ekr.20051005155611:<< handle regexp >>
#@+node:ekr.20051005160923:<< handle plain search >> (tag_add & tag_config) LATER
i = w.search(self.qQ,'insert',stopindex='end')

if i:
    w.setInsertPoint(i)
    w.tag_add('qR','insert','insert +%sc' % len(self.qQ))
    w.tag_config('qR',background='lightblue')
    return True
else:
    self.quitSearch(event)
    return False
#@-node:ekr.20051005160923:<< handle plain search >> (tag_add & tag_config) LATER
#@-node:ekr.20050920084036.219:findNextMatch (query-replace)
#@+node:ekr.20050920084036.211:getUserResponse
def getUserResponse (self,event):

    w = self.editWidget(event)
    if not w or not hasattr(event,'keysym'): return

    # g.trace(event.keysym)
    if event.keysym == 'y':
        self.doOneReplace(event)
        if not self.findNextMatch(event):
            self.quitSearch(event)
    elif event.keysym in ('q','Return'):
        self.quitSearch(event)
    elif event.keysym == '!':
        while self.findNextMatch(event):
            self.doOneReplace(event)
    elif event.keysym in ('n','Delete'):
        # Skip over the present match.
        i = w.getInsertPoint()
        w.setInsertPoint(i + len(self.qQ))
        if not self.findNextMatch(event):
            self.quitSearch(event)

    w.seeInsertPoint()
#@-node:ekr.20050920084036.211:getUserResponse
#@+node:ekr.20050920084036.220:quitSearch
def quitSearch (self,event,message=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    w.tag_delete('qR')
    k.clearState()
    if message is None:
        message = 'Replaced %d occurences' % self.replaced
    k.setLabelGrey(message)
#@-node:ekr.20050920084036.220:quitSearch
#@+node:ekr.20050920084036.215:stateHandler
def stateHandler (self,event):

    k = self.k ; state = k.getState('query-replace')

    prompt = g.choose(self.regexp,'Query replace regexp','Query replace')

    if state == 0: # Get the first arg.
        self.init()
        k.setLabelBlue(prompt + ': ',protect=True)
        k.getArg(event,'query-replace',1,self.stateHandler)
    elif state == 1: # Get the second arg.
        self.qQ = k.arg
        if len(k.arg) > 0:
            prompt = '%s %s with: ' % (prompt,k.arg)
            k.setLabelBlue(prompt)
            k.getArg(event,'query-replace',2,self.stateHandler)
        else:
            k.resetLabel()
            k.clearState()
    elif state == 2: # Set the prompt and find the first match.
        self.qR = k.arg # Null replacement arg is ok.
        k.setLabelBlue('Query replacing %s with %s\n' % (self.qQ,self.qR) +
            'y: replace, (n or Delete): skip, !: replace all, (q or Return): quit',
            protect=True)
        k.setState('query-replace',3,self.stateHandler)
        self.findNextMatch(event)
    elif state == 3:
        self.getUserResponse(event)
#@-node:ekr.20050920084036.215:stateHandler
#@-node:ekr.20051005151838:Helpers
#@-node:ekr.20050920084036.207:queryReplaceCommandsClass (limited to single node)
#@+node:ekr.20050920084036.221:rectangleCommandsClass
class rectangleCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20050920084036.222: ctor & finishCreate
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.theKillRectangle = [] # Do not re-init this!
    self.stringRect = None

def finishCreate(self):

    baseEditCommandsClass.finishCreate(self)

    self.commandsDict = {
        'c': ('clear-rectangle',    self.clearRectangle),
        'd': ('delete-rectangle',   self.deleteRectangle),
        'k': ('kill-rectangle',     self.killRectangle),
        'o': ('open-rectangle',     self.openRectangle),
        'r': ('copy-rectangle-to-register',
            self.c.registerCommands.copyRectangleToRegister),
        't': ('string-rectangle',   self.stringRectangle),
        'y': ('yank-rectangle',     self.yankRectangle),
    }
#@-node:ekr.20050920084036.222: ctor & finishCreate
#@+node:ekr.20051004112630:check
def check (self,event,warning='No rectangle selected'):

    '''Return True if there is a selection.
    Otherwise, return False and issue a warning.'''

    return self._chckSel(event,warning)
#@-node:ekr.20051004112630:check
#@+node:ekr.20050920084036.223:getPublicCommands
def getPublicCommands (self):

    return {
        'clear-rectangle':  self.clearRectangle,
        'close-rectangle':  self.closeRectangle,
        'delete-rectangle': self.deleteRectangle,
        'kill-rectangle':   self.killRectangle,
        'open-rectangle':   self.openRectangle,
        'string-rectangle': self.stringRectangle,
        'yank-rectangle':   self.yankRectangle,
    }
#@-node:ekr.20050920084036.223:getPublicCommands
#@+node:ekr.20051215103053:beginCommand & beginCommandWithEvent (rectangle)
def beginCommand (self,undoType='Typing'):

    w = baseEditCommandsClass.beginCommand(self,undoType)
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    return w,r1,r2,r3,r4


def beginCommandWithEvent (self,event,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    w = baseEditCommandsClass.beginCommandWithEvent(self,event,undoType)
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    return w,r1,r2,r3,r4
#@-node:ekr.20051215103053:beginCommand & beginCommandWithEvent (rectangle)
#@+node:ekr.20050920084036.224:Entries (rectangleCommandsClass)
#@+node:ekr.20050920084036.225:clearRectangle
def clearRectangle (self,event):

    '''Clear the rectangle defined by the start and end of selected text.'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('clear-rectangle')

    # Change the text.
    fill = ' ' *(r4-r2)
    for r in xrange(r1,r3+1):
        w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))
        w.insert('%s.%s' % (r,r2),fill)

    w.setSelectionRange('%s.%s'%(r1,r2),'%s.%s'%(r3,r2+len(fill)))

    self.endCommand()
#@-node:ekr.20050920084036.225:clearRectangle
#@+node:ekr.20050920084036.226:closeRectangle
def closeRectangle (self,event):

    '''Delete the rectangle if it contains nothing but whitespace..'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('close-rectangle')

    # Return if any part of the selection contains something other than whitespace.
    for r in xrange(r1,r3+1):
        s = w.get('%s.%s' % (r,r2),'%s.%s' % (r,r4))
        if s.strip(): return

    # Change the text.
    for r in xrange(r1,r3+1):
        w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))

    i = '%s.%s' % (r1,r2)
    j = '%s.%s' % (r3,r2)
    w.setSelectionRange(i,j,insert=j)

    self.endCommand()
#@-node:ekr.20050920084036.226:closeRectangle
#@+node:ekr.20050920084036.227:deleteRectangle
def deleteRectangle (self,event):

    '''Delete the rectangle defined by the start and end of selected text.'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('delete-rectangle')

    for r in xrange(r1,r3+1):
        w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))

    i = '%s.%s' % (r1,r2)
    j = '%s.%s' % (r3,r2)
    w.setSelectionRange(i,j,insert=j)

    self.endCommand()
#@-node:ekr.20050920084036.227:deleteRectangle
#@+node:ekr.20050920084036.228:killRectangle
def killRectangle (self,event):

    '''Kill the rectangle defined by the start and end of selected text.'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('kill-rectangle')

    self.theKillRectangle = []

    for r in xrange(r1,r3+1):
        s = w.get('%s.%s' % (r,r2),'%s.%s' % (r,r4))
        self.theKillRectangle.append(s)
        w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))

    # g.trace('killRect',repr(self.theKillRectangle))

    if self.theKillRectangle:
        ins = '%s.%s' % (r,r2)
        w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand()
#@-node:ekr.20050920084036.228:killRectangle
#@+node:ekr.20050920084036.230:openRectangle
def openRectangle (self,event):

    '''Insert blanks in the rectangle defined by the start and end of selected text.
    This pushes the previous contents of the rectangle rightward.'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('open-rectangle')

    fill = ' ' * (r4-r2)
    for r in xrange(r1,r3+1):
        w.insert('%s.%s' % (r,r2),fill)

    i = '%s.%s' % (r1,r2)
    j = '%s.%s' % (r3,r2+len(fill))
    w.setSelectionRange(i,j,insert=j)

    self.endCommand()
#@-node:ekr.20050920084036.230:openRectangle
#@+node:ekr.20050920084036.232:stringRectangle
def stringRectangle (self,event):

    '''Prompt for a string, then replace the contents of a rectangle with a string on each line.'''

    c = self.c ; k = self.k ; state = k.getState('string-rect')
    if g.app.unitTesting:
        state = 1 ; k.arg = 's...s' # This string is known to the unit test.
        w = self.editWidget(event)
        self.stringRect = self.getRectanglePoints(w)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w or not self.check(event): return
        self.stringRect = self.getRectanglePoints(w)
        k.setLabelBlue('String rectangle: ',protect=True)
        k.getArg(event,'string-rect',1,self.stringRectangle)
    else:
        k.clearState()
        k.resetLabel()
        c.bodyWantsFocus()
        w = self.w
        self.beginCommand('string-rectangle')
        r1, r2, r3, r4 = self.stringRect
        for r in xrange(r1,r3+1):
            w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))
            w.insert('%s.%s' % (r,r2),k.arg)
        w.setSelectionRange('%d.%d' % (r1,r2),'%d.%d' % (r3,r2+len(k.arg)))

        self.endCommand()
#@nonl
#@-node:ekr.20050920084036.232:stringRectangle
#@+node:ekr.20050920084036.229:yankRectangle
def yankRectangle (self,event,killRect=None):

    '''Yank into the rectangle defined by the start and end of selected text.'''

    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return

    killRect = killRect or self.theKillRectangle
    if g.app.unitTesting:
        # This value is used by the unit test.
        killRect = ['Y1Y','Y2Y','Y3Y','Y4Y']
    elif not killRect:
        k.setLabelGrey('No kill rect') ; return

    w,r1,r2,r3,r4 = self.beginCommand('yank-rectangle')

    n = 0
    for r in xrange(r1,r3+1):
        # g.trace(n,r,killRect[n])
        if n >= len(killRect): break
        w.delete('%s.%s' % (r,r2), '%s.%s' % (r,r4))
        w.insert('%s.%s' % (r,r2), killRect[n])
        n += 1

    i = '%s.%s' % (r1,r2)
    j = '%s.%s' % (r3,r2+len(killRect[n-1]))
    w.setSelectionRange(i,j,insert=j)

    self.endCommand()
#@-node:ekr.20050920084036.229:yankRectangle
#@-node:ekr.20050920084036.224:Entries (rectangleCommandsClass)
#@-node:ekr.20050920084036.221:rectangleCommandsClass
#@+node:ekr.20050920084036.234:registerCommandsClass
class registerCommandsClass (baseEditCommandsClass):

    '''A class to represent registers a-z and the corresponding Emacs commands.'''

    @others
#@+node:ekr.20051004095209:Birth
#@+node:ekr.20050920084036.235: ctor, finishCreate & init
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.methodDict, self.helpDict = self.addRegisterItems()
    self.init()

def finishCreate (self):

    baseEditCommandsClass.finishCreate(self) # finish the base class.

    if self.k.useGlobalRegisters:
        self.registers = leoKeys.keyHandlerClass.global_registers
    else:
        self.registers = {}

def init (self):

    self.method = None 
    self.registerMode = 0 # Must be an int.
#@-node:ekr.20050920084036.235: ctor, finishCreate & init
#@+node:ekr.20050920084036.247: getPublicCommands
def getPublicCommands (self):

    return {
        'append-to-register':           self.appendToRegister,
        'copy-rectangle-to-register':   self.copyRectangleToRegister,
        'copy-to-register':             self.copyToRegister,
        'increment-register':           self.incrementRegister,
        'insert-register':              self.insertRegister,
        'jump-to-register':             self.jumpToRegister,
        # 'number-to-register':           self.numberToRegister,
        'point-to-register':            self.pointToRegister,
        'prepend-to-register':          self.prependToRegister,
        'view-register':                self.viewRegister,
    }
#@-node:ekr.20050920084036.247: getPublicCommands
#@+node:ekr.20050920084036.252:addRegisterItems
def addRegisterItems( self ):

    methodDict = {
        '+':        self.incrementRegister,
        ' ':        self.pointToRegister,
        'a':        self.appendToRegister,
        'i':        self.insertRegister,
        'j':        self.jumpToRegister,
        # 'n':        self.numberToRegister,
        'p':        self.prependToRegister,
        'r':        self.copyRectangleToRegister,
        's':        self.copyToRegister,
        'v' :       self.viewRegister,
    }    

    helpDict = {
        's':    'copy to register',
        'i':    'insert from register',
        '+':    'increment register',
        'n':    'number to register',
        'p':    'prepend to register',
        'a':    'append to register',
        ' ':    'point to register',
        'j':    'jump to register',
        'r':    'rectangle to register',
        'v':    'view register',
    }

    return methodDict, helpDict
#@-node:ekr.20050920084036.252:addRegisterItems
#@-node:ekr.20051004095209:Birth
#@+node:ekr.20051004123217:checkBodySelection
def checkBodySelection (self,warning='No text selected'):

    return self._chckSel(event=None,warning=warning)
#@-node:ekr.20051004123217:checkBodySelection
#@+node:ekr.20050920084036.236:Entries...
#@+node:ekr.20050920084036.238:appendToRegister
def appendToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('append-to-reg')

    if state == 0:
        k.setLabelBlue('Append to register: ',protect=True)
        k.setState('append-to-reg',1,self.appendToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = val + w.get('sel.first','sel.last')
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.238:appendToRegister
#@+node:ekr.20050920084036.237:prependToRegister
def prependToRegister (self,event):

    '''Prompt for a register name and prepend the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('prepend-to-reg')

    if state == 0:
        k.setLabelBlue('Prepend to register: ',protect=True)
        k.setState('prepend-to-reg',1,self.prependToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = w.get('sel.first','sel.last') + val
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.237:prependToRegister
#@+node:ekr.20050920084036.239:copyRectangleToRegister
def copyRectangleToRegister (self,event):

    '''Prompt for a register name and append the rectangle defined by selected
    text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-rect-to-reg')

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        k.commandName = 'copy-rectangle-to-register'
        k.setLabelBlue('Copy Rectangle To Register: ',protect=True)
        k.setState('copy-rect-to-reg',1,self.copyRectangleToRegister)
    elif self.checkBodySelection('No rectangle selected'):
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            w = self.w
            c.widgetWantsFocusNow(w)
            r1, r2, r3, r4 = self.getRectanglePoints(w)
            rect = []
            while r1 <= r3:
                txt = w.get('%s.%s' % (r1,r2),'%s.%s' % (r1,r4))
                rect.append(txt)
                r1 = r1 + 1
            self.registers [key] = rect
            k.setLabelGrey('Register %s = %s' % (key,repr(rect)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.239:copyRectangleToRegister
#@+node:ekr.20050920084036.240:copyToRegister
def copyToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-to-reg')

    if state == 0:
        k.commandName = 'copy-to-register'
        k.setLabelBlue('Copy to register: ',protect=True)
        k.setState('copy-to-reg',1,self.copyToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                key = event.keysym.lower()
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                try:
                    val = w.get('sel.first','sel.last')
                except Exception:
                    g.es_exception()
                    val = ''
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.240:copyToRegister
#@+node:ekr.20050920084036.241:incrementRegister
def incrementRegister (self,event):

    '''Prompt for a register name and increment its value if it has a numeric value.'''

    c = self.c ; k = self.k ; state = k.getState('increment-reg')

    if state == 0:
        k.setLabelBlue('Increment register: ',protect=True)
        k.setState('increment-reg',1,self.incrementRegister)
    else:
        k.clearState()
        if self._checkIfRectangle(event):
            pass # Error message is in the label.
        elif event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key,0)
            try:
                val = str(int(val)+1)
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            except ValueError:
                k.setLabelGrey("Can't increment register %s = %s" % (key,val))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.241:incrementRegister
#@+node:ekr.20050920084036.242:insertRegister
def insertRegister (self,event):

    '''Prompt for a register name and and insert the value of another register into its contents.'''

    c = self.c ; k = self.k ; state = k.getState('insert-reg')

    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ',protect=True)
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.rectangleCommands.yankRectangle(val)
                else:
                    w.insert('insert',val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.242:insertRegister
#@+node:ekr.20050920084036.243:jumpToRegister
def jumpToRegister (self,event):

    '''Prompt for a register name and set the insert point to the value in its register.'''

    c = self.c ; k = self.k ; state = k.getState('jump-to-reg')

    if state == 0:
        k.setLabelBlue('Jump to register: ',protect=True)
        k.setState('jump-to-reg',1,self.jumpToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            if self._checkIfRectangle(event): return
            key = event.keysym.lower()
            val = self.registers.get(key)
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            if val:
                try:
                    w.setInsertPoint(val)
                    k.setLabelGrey('At %s' % repr(val))
                except Exception:
                    k.setLabelGrey('Register %s is not a valid location' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.243:jumpToRegister
#@+node:ekr.20050920084036.244:numberToRegister (not used)
@
C-u number C-x r n reg
    Store number into register reg (number-to-register).
C-u number C-x r + reg
    Increment the number in register reg by number (increment-register).
C-x r g reg
    Insert the number from register reg into the buffer.
@c

def numberToRegister (self,event):

    k = self.k ; state = k.getState('number-to-reg')

    if state == 0:
        k.commandName = 'number-to-register'
        k.setLabelBlue('Number to register: ',protect=True)
        k.setState('number-to-reg',1,self.numberToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            # self.registers[event.keysym.lower()] = str(0)
            k.setLabelGrey('number-to-register not ready yet.')
        else:
            k.setLabelGrey('Register must be a letter')
#@-node:ekr.20050920084036.244:numberToRegister (not used)
#@+node:ekr.20050920084036.245:pointToRegister
def pointToRegister (self,event):

    '''Prompt for a register name and put a value indicating the insert point in the register.'''

    c = self.c ; k = self.k ; state = k.getState('point-to-reg')

    if state == 0:
        k.commandName = 'point-to-register'
        k.setLabelBlue('Point to register: ',protect=True)
        k.setState('point-to-reg',1,self.pointToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = w.getInsertPoint()
            self.registers[key] = val
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.245:pointToRegister
#@+node:ekr.20050920084036.246:viewRegister
def viewRegister (self,event):

    '''Prompt for a register name and print its contents.'''

    c = self.c ; k = self.k ; state = k.getState('view-reg')

    if state == 0:
        k.commandName = 'view-register'
        k.setLabelBlue('View register: ',protect=True)
        k.setState('view-reg',1,self.viewRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key)
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.246:viewRegister
#@-node:ekr.20050920084036.236:Entries...
#@-node:ekr.20050920084036.234:registerCommandsClass
#@+node:ekr.20051023094009:Search classes
#@+node:ekr.20060123125256:class minibufferFind( (the findHandler)
class minibufferFind (baseEditCommandsClass):

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others
#@+node:ekr.20060123125317.2: ctor (minibufferFind)
def __init__(self,c,finder):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    # g.trace('minibufferFind: finder',finder)

    self.c = c
    self.k = k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []

    commandName = 'replace-string'
    s = k.getShortcutForCommandName(commandName)
    s = k.prettyPrintKey(s)
    s = k.shortcutFromSetting(s)
    self.replaceStringShortcut = s
#@-node:ekr.20060123125317.2: ctor (minibufferFind)
#@+node:ekr.20060124140114: Options (minibufferFind)
#@+node:ekr.20060124123133:setFindScope
def setFindScope(self,where):

    '''Set the find-scope radio buttons.

    `where` must be in ('node-only','entire-outline','suboutline-only'). '''

    h = self.finder

    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.svarDict['radio-search-scope'].get()
        if var:
            h.svarDict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
#@-node:ekr.20060124123133:setFindScope
#@+node:ekr.20060124122844:get/set/toggleOption (minibufferFind)
# This redirection is required to remove gui-dependencies.

def getOption (self,ivar):          return self.finder.getOption(ivar)
def setOption (self,ivar,val):      self.finder.setOption(ivar,val)
def toggleOption (self,ivar):       self.finder.toggleOption(ivar)
#@-node:ekr.20060124122844:get/set/toggleOption (minibufferFind)
#@+node:ekr.20060125074939:showFindOptions
def showFindOptions (self):

    '''Show the present find options in the status line.'''

    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')

    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )

    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
#@-node:ekr.20060125074939:showFindOptions
#@+node:ekr.20060205105950:setupChangePattern
def setupChangePattern (self,pattern):

    h = self.finder ; w = h.change_ctrl

    s = g.toUnicode(pattern,g.app.tkEncoding)

    w.delete(0,'end')
    w.insert(0,s)

    h.update_ivars()
#@-node:ekr.20060205105950:setupChangePattern
#@+node:ekr.20060125091234:setupSearchPattern
def setupSearchPattern (self,pattern):

    h = self.finder ; w = h.find_ctrl

    s = g.toUnicode(pattern,g.app.tkEncoding)

    w.delete(0,'end')
    w.insert(0,s)

    h.update_ivars()
#@-node:ekr.20060125091234:setupSearchPattern
#@-node:ekr.20060124140114: Options (minibufferFind)
#@+node:ekr.20060210180352:addChangeStringToLabel
def addChangeStringToLabel (self,protect=True):

    c = self.c ; k = c.k ; h = self.finder ; w = h.change_ctrl

    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()

    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
#@-node:ekr.20060210180352:addChangeStringToLabel
#@+node:ekr.20060210164421:addFindStringToLabel
def addFindStringToLabel (self,protect=True):

    c = self.c ; k = c.k ; h = self.finder ; w = h.find_ctrl

    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
#@-node:ekr.20060210164421:addFindStringToLabel
#@+node:ekr.20070105123800:changeAll
def changeAll (self,event):

    k = self.k ; tag = 'change-all' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Change All From: ',protect=True)
        k.getArg(event,tag,1,self.changeAll)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = 'Change All: %s With: ' % (self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,tag,2,self.changeAll,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg,changeAll=True)

#@-node:ekr.20070105123800:changeAll
#@+node:ekr.20060128080201:cloneFindAll
def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
#@-node:ekr.20060128080201:cloneFindAll
#@+node:ekr.20060204120158:findAgain
def findAgain (self,event):

    f = self.finder

    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
#@-node:ekr.20060204120158:findAgain
#@+node:ekr.20060209064140:findAll
def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
#@-node:ekr.20060209064140:findAll
#@+node:ekr.20060205105950.1:generalChangeHelper
def generalChangeHelper (self,find_pattern,change_pattern,changeAll=False):

    # g.trace(repr(change_pattern))

    c = self.c

    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()

    if changeAll:
         self.finder.changeAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@-node:ekr.20060205105950.1:generalChangeHelper
#@+node:ekr.20060124181213.4:generalSearchHelper
def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):

    c = self.c

    self.setupSearchPattern(pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if findAll:
         self.finder.findAllCommand()
    elif cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@-node:ekr.20060124181213.4:generalSearchHelper
#@+node:ekr.20060210174441:lastStateHelper
def lastStateHelper (self):

    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
#@-node:ekr.20060210174441:lastStateHelper
#@+node:ekr.20050920084036.113:replaceString
def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
#@-node:ekr.20050920084036.113:replaceString
#@+node:ekr.20060124140224.3:reSearchBackward/Forward
def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060124140224.3:reSearchBackward/Forward
#@+node:ekr.20060124140224.1:seachForward/Backward
def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060124140224.1:seachForward/Backward
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20060124134356:setupArgs
def setupArgs (self,forward=False,regexp=False,word=False):

    h = self.finder ; k = self.k

    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)

    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
#@-node:ekr.20060124134356:setupArgs
#@+node:ekr.20060210173041:stateZeroHelper
def stateZeroHelper (self,event,tag,prefix,handler,escapes=[]):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w: return

    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)

    # g.trace(escapes,g.callers())
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
#@-node:ekr.20060210173041:stateZeroHelper
#@+node:ekr.20060224171851:updateChange/FindList
def updateChangeList (self,s):

    if s not in self.changeTextList:
        self.changeTextList.append(s)

def updateFindList (self,s):

    if s not in self.findTextList:
        self.findTextList.append(s)
#@-node:ekr.20060224171851:updateChange/FindList
#@+node:ekr.20060124140224.2:wordSearchBackward/Forward
def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060124140224.2:wordSearchBackward/Forward
#@-node:ekr.20060123125256:class minibufferFind( (the findHandler)
#@+node:ekr.20050920084036.257:class searchCommandsClass
class searchCommandsClass (baseEditCommandsClass):

    '''Implements many kinds of searches.'''

    @others
#@+node:ekr.20050920084036.258: ctor (searchCommandsClass)
def __init__ (self,c):

    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.findTabHandler = None
    self.minibufferFindHandler = None
    self.inited = False

    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None

    # For isearch commands.
    self.ifinder = leoFind.leoFind(c,title='ifinder')
    self.isearch_v = None # vnode of last isearch.
    self.isearch_stack = [] # A stack of previous matches: entries are: (sel,insert)
    self.ignoreCase = None
    self.forward = None
    self.regexp = None
#@-node:ekr.20050920084036.258: ctor (searchCommandsClass)
#@+node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
def getPublicCommands (self):

    return {
        'clone-find-all':                       self.cloneFindAll,

        'find-all':                             self.findAll,
        'change-all':                           self.changeAll,

        # Thin wrappers on Find tab
        'change':                               self.findTabChange,
        'change-then-find':                     self.findTabChangeThenFind,
        'find-next':                            self.findTabFindNext,
        'find-prev':                            self.findTabFindPrev,

        'hide-find-tab':                        self.hideFindTab,

        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
        'isearch-with-present-options':         self.isearchWithPresentOptions,

        'open-find-tab':                        self.openFindTab,

        'replace-string':                       self.replaceString,

        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.

        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,

        'show-find-options':                    self.showFindOptions,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,

        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
#@-node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
#@+node:ekr.20060123131421:Top-level methods
#@+node:ekr.20051020120306:openFindTab
def openFindTab (self,event=None,show=True):

    '''Open the Find tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    wasOpen = self.inited

    if self.inited:
        log.selectTab(tabName)
    else:
        self.inited = True
        log.selectTab(tabName,createText=False)
        f = log.frameDict.get(tabName)
        self.findTabHandler = g.app.gui.createFindTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
#@-node:ekr.20051020120306:openFindTab
#@+node:ekr.20051022212004:Find Tab commands
# Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):
    '''Execute the 'Change' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):
    '''Execute the 'Replace, Find' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindAll(self,event=None):
    '''Execute the 'Find All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    '''Execute the 'Find Next' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    '''Execute the 'Find Previous' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()

def hideFindTab (self,event=None):
    '''Hide the Find tab.'''
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')
#@-node:ekr.20051022212004:Find Tab commands
#@+node:ekr.20060124115801:getHandler
def getHandler(self,show=False):

    '''Return the minibuffer handler, creating it if necessary.'''

    c = self.c

    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.

    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler
#@-node:ekr.20060124115801:getHandler
#@+node:ekr.20060123115459:Find options wrappers
def setFindScopeEveryWhere (self, event):
    '''Set the 'Entire Outline' radio button in the Find tab.'''
    return self.setFindScope('entire-outline')

def setFindScopeNodeOnly  (self, event):
    '''Set the 'Node Only' radio button in the Find tab.'''
    return self.setFindScope('node-only')

def setFindScopeSuboutlineOnly (self, event):
    '''Set the 'Suboutline Only' radio button in the Find tab.'''
    return self.setFindScope('suboutline-only')

def showFindOptions (self,event):
    '''Show all Find options in the minibuffer label area.'''
    self.getHandler().showFindOptions()

def toggleIgnoreCaseOption     (self, event):
    '''Toggle the 'Ignore Case' checkbox in the Find tab.'''
    return self.toggleOption('ignore_case')

def toggleMarkChangesOption (self, event):
    '''Toggle the 'Mark Changes' checkbox in the Find tab.'''
    return self.toggleOption('mark_changes')
def toggleMarkFindsOption (self, event):
    '''Toggle the 'Mark Finds' checkbox in the Find tab.'''
    return self.toggleOption('mark_finds')
def toggleRegexOption (self, event):
    '''Toggle the 'Regexp' checkbox in the Find tab.'''
    return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event):
    '''Toggle the 'Reverse' checkbox in the Find tab.'''
    return self.toggleOption('reverse')

def toggleSearchBodyOption (self, event):
    '''Set the 'Search Body' checkbox in the Find tab.'''
    return self.toggleOption('search_body')

def toggleSearchHeadlineOption (self, event):
    '''Toggle the 'Search Headline' checkbox in the Find tab.'''
    return self.toggleOption('search_headline')

def toggleWholeWordOption (self, event):
    '''Toggle the 'Whole Word' checkbox in the Find tab.'''
    return self.toggleOption('whole_word')

def toggleWrapSearchOption (self, event):
    '''Toggle the 'Wrap Around' checkbox in the Find tab.'''
    return self.toggleOption('wrap')

def setFindScope (self, where):  self.getHandler().setFindScope(where)
def toggleOption (self, ivar):   self.getHandler().toggleOption(ivar)
#@-node:ekr.20060123115459:Find options wrappers
#@+node:ekr.20060124093828:Find wrappers
def changeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    self.getHandler().changeAll(event)

def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type <Return> to end the search string. The
    command will then prompt for the replacement string. Typing a second
    <Return> key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Set the 'Regexp' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Set the 'Regexp' checkbox to True, then do search-with-present-options.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Set the 'Word Search' checkbox to False and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Set the 'Word Search' checkbox to False, then do search-with-present-options.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Set the 'Word Search' checkbox to True, then do search-with-present-options.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Set the Word Search' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the <Return> key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)
#@-node:ekr.20060124093828:Find wrappers
#@+node:ekr.20060204120158.2:findAgain
def findAgain (self,event):

    '''The find-again command is the same as the find-next command
    if the search pattern in the Find tab is not '<find pattern here>'
    Otherwise, the find-again is the same as the search-with-present-options command.'''

    h = self.getHandler()

    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to search-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)
#@-node:ekr.20060204120158.2:findAgain
#@-node:ekr.20060123131421:Top-level methods
#@+node:ekr.20050920084036.261:incremental search...
def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=False)

def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=False)

def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=True)

def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=True)

def isearchWithPresentOptions (self,event):
    '''Begin an incremental regexp search using the regexp and reverse options from the find panel.'''
    self.startIncremental(event,forward=None,ignoreCase=None,regexp=None)
#@+node:ekr.20060420144640:iSearchBackspace
def iSearchBackspace (self):

    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.w

    if not self.isearch_stack:
        ins = w.getInsertPoint()
        self.endSearch(ins,ins)
        return 

    gui.set_focus(c,w)
    pattern = k.getLabel(ignorePrompt=True)
    self.scolorizer(event=None,pattern=pattern)

    sel,ins = self.isearch_stack.pop()

    if sel:
        i,j = sel
        w.setSelectionRange(i,j,insert=ins)
    else:
        w.setInsertPoint(ins)

    w.seeInsertPoint()

    if not self.isearch_stack:
        self.endSearch(ins,ins)
#@-node:ekr.20060420144640:iSearchBackspace
#@+node:ekr.20050920084036.262:startIncremental
def startIncremental (self,event,forward,ignoreCase,regexp):

    c = self.c ; k = self.k ; w = self.w

    # None is a signal to get the option from the find tab.
    if forward is None or regexp is None:
        self.openFindTab(show=False)
        if not self.minibufferFindHandler:
            self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)
        getOption = self.minibufferFindHandler.getOption
        # g.trace('reverse',getOption('reverse'))
        # g.trace('pattern',getOption('pattern_match'))
    else:
        getOption = lambda a: False # The value isn't used.

    self.event = event
    self.forward    = g.choose(forward is None,not getOption('reverse'),forward)
    self.ignoreCase = g.choose(ignoreCase is None,getOption('ignore_case'),ignoreCase)
    self.regexp     = g.choose(regexp  is None,getOption('pattern_match'),regexp)
    # Note: the word option can't be used with isearches!

    self.ins1 = ins = w.getInsertPoint()
    sel = w.getSelectionRange() or (ins,ins),
    self.isearch_stack = [(sel,ins),]

    k.setLabelBlue('Isearch%s%s%s: ' % (
            g.choose(self.forward,'',' Backward'),
            g.choose(self.regexp,' Regexp',''),
            g.choose(self.ignoreCase,' NoCase',''),
        ),protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()
#@-node:ekr.20050920084036.262:startIncremental
#@+node:ekr.20050920084036.264:iSearchStateHandler
# Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w

    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return

    c.bodyWantsFocusNow()
    if keysym == 'Return':
        i,j = w.getSelectionRange()
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
    elif keysym == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif ch:
        k.updateLabel(event)
        self.iSearchHelper(event)
        self.scolorizer(event)
#@-node:ekr.20050920084036.264:iSearchStateHandler
#@+node:ekr.20050920084036.265:scolorizer LATER
def scolorizer (self,event,pattern=None):

    '''Colorizer for incremental searches.'''

    k = self.k ; w = self.w
    s = pattern or k.getLabel(ignorePrompt=True)
    # g.trace(repr(s))
    w.tag_delete('color','color1')
    if not s: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    ind = 0
    index = w.getInsertPoint()
    index2 = index + len(s)
    # g.trace(index,index2)
    # Colorize in the forward direction, regardless of the kind of search.
    while ind:
        try:
            ind = w.search(s,ind,stopindex='end',regexp=self.regexp)
        except: break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(s))
            # g.trace(ind)
            if ind in (index,index2):
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
#@-node:ekr.20050920084036.265:scolorizer LATER
#@+node:ekr.20050920084036.263:iSearchHelper
def iSearchHelper (self,event):

    '''Move the cursor to position that matches the pattern in the miniBuffer.
    isearches do not cross node boundaries.'''

    c = self.c ; gui = g.app.gui ; k = self.k ; w = self.w
    p = c.currentPosition() ;
    self.searchString = pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    s = w.getAllText()

    if self.isearch_v != p.v:
        self.isearch_v = p.v
        self.isearch_stack = []

    sel = w.getSelectionRange()
    startindex = insert = w.getInsertPoint()

    if self.forward:
        i1 = startindex
        j1 = len(s)
    else:
        i1 = 0
        j1 = min(len(s),startindex + len(pattern))

    i,j = self.ifinder.searchHelper(s,i1,j1,pattern,
        backwards=not self.forward,
        nocase=self.ignoreCase,
        regexp=self.regexp,
        word=False, # Incremental word-matches are not possible!
        swapij=False)

    if i != -1:
        self.isearch_stack.append((sel,insert),)
        # g.trace(i1,j1,i,j,pos,newpos)
        gui.set_focus(c,w)
        w.setSelectionRange(i,j,insert=i)
#@-node:ekr.20050920084036.263:iSearchHelper
#@+node:ekr.20060203072636:endSearch
def endSearch (self,i,j):

    w = self.w
    w.tag_delete('color','color1')

    insert = g.choose(self.forward,'sel.end','sel.start')
    w.setSelectionRange(i,j,insert=insert)

    self.k.keyboardQuit(event=None)
#@nonl
#@-node:ekr.20060203072636:endSearch
#@-node:ekr.20050920084036.261:incremental search...
#@-node:ekr.20050920084036.257:class searchCommandsClass
#@-node:ekr.20051023094009:Search classes
#@+node:ekr.20051025071455:Spell classes
@others
#@+node:ekr.20051025071455.1:class spellCommandsClass
class spellCommandsClass (baseEditCommandsClass):

    '''Commands to support the Spell Tab.'''

    @others
#@+node:ekr.20051025080056:ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.handler = None

    # All the work happens when we first open the frame.
#@-node:ekr.20051025080056:ctor
#@+node:ekr.20051025080420:getPublicCommands (searchCommandsClass)
def getPublicCommands (self):

    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
#@-node:ekr.20051025080420:getPublicCommands (searchCommandsClass)
#@+node:ekr.20051025080633:openSpellTab
def openSpellTab (self,event=None):

    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        self.handler = spellTabHandler(c,tabName)
        if not self.handler.loaded:
            log.deleteTab(tabName,force=True)
#@+node:ekr.20051025080420.1:commands...
# Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()

def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()

def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
#@-node:ekr.20051025080420.1:commands...
#@-node:ekr.20051025080633:openSpellTab
#@-node:ekr.20051025071455.1:class spellCommandsClass
#@+node:ekr.20051025071455.18:class spellTabHandler (leoFind.leoFind)
class spellTabHandler (leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""

    @others
#@+node:ekr.20051025071455.19:Birth & death
#@+node:ekr.20051025071455.20:spellTabHandler.__init__
def __init__(self,c,tabName):

    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = g.app.gui.plainTextWidget(c.frame.top)
        # A text widget for scanning.
        # Must have a parent frame even though it is not packed.

    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.tab = g.app.gui.createSpellTab(c,self,tabName)
#@-node:ekr.20051025071455.20:spellTabHandler.__init__
#@+node:ekr.20051025094004:init_aspell
def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"..","plugins",'spellpyx.txt'))

    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = AspellClass(c,dictionaryFileName,self.local_language_code)

    if self.aspell.aspell:
        self.dictionary = self.readDictionary(dictionaryFileName)
    else:
        self.dictionary = False
        # g.es_print('Can not open Aspell',color='red')

    return self.aspell.aspell
#@-node:ekr.20051025094004:init_aspell
#@+node:ekr.20051025071455.16:readDictionary
def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary

    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""

    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
#@-node:ekr.20051025071455.16:readDictionary
#@-node:ekr.20051025071455.19:Birth & death
#@+node:ekr.20051025071455.36:Commands
#@+node:ekr.20051025071455.37:add
def add(self,event=None):
    """Add the selected suggestion to the dictionary."""

    if not self.currentWord: return

    # g.trace(self.currentWord)

    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
#@-node:ekr.20051025071455.37:add
#@+node:ekr.20051025071455.38:change (spellTab)
def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; w = body.bodyCtrl

    selection = self.tab.getSuggestion()
    if selection:
        start,end = oldSel = w.getSelectionRange()
        if start:
            if start > end: start,end = end,start
            w.delete(start,end)
            w.insert(start,selection)
            w.setSelectionRange(start,start+len(selection))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
#@-node:ekr.20051025071455.38:change (spellTab)
#@+node:ekr.20051025071455.40:find & helpers
def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Copy the working selection range to the body pane
        start, end = self.workCtrl.getSelectionRange()
        w.setSelectionRange(start,end)
        w.see(start)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
#@+node:ekr.20051025071455.45:findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""

    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None

    try:
        while 1:
            # g.trace('p',p and p.headString())
            p, word = self.findNextWord(p)
            if not p or not word:
                alts = None
                break
            << Skip word if ignored or in local dictionary >>
            alts = aspell.processWord(word)
            if alts:
                w = c.frame.body.bodyCtrl
                i,j = w.getSelectionRange()
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                w.setSelectionRange(i,j,insert=j)
                break
    except:
        g.es_exception()
    return alts, word
#@+node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
#@-node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
#@-node:ekr.20051025071455.45:findNextMisspelledWord
#@+node:ekr.20051025071455.47:findNextWord
def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    c = self.c ; p = p.copy()
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i < len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.headString(),'i',i,'len(s)',len(s))
        if i < len(s):
            # A non-empty word has been found.
            j = i
            while j < len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            return p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.bodyString())
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
    return None,None
#@nonl
#@-node:ekr.20051025071455.47:findNextWord
#@-node:ekr.20051025071455.40:find & helpers
#@+node:ekr.20051025121408:hide
def hide (self,event=None):

    self.c.frame.log.selectTab('Log')

    for message in self.messages:
        g.es(message,color='blue')

    self.messages = []
#@-node:ekr.20051025121408:hide
#@+node:ekr.20051025071455.41:ignore
def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""

    if not self.currentWord: return

    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
#@-node:ekr.20051025071455.41:ignore
#@-node:ekr.20051025071455.36:Commands
#@-node:ekr.20051025071455.18:class spellTabHandler (leoFind.leoFind)
#@+node:ekr.20051025071455.6:class AspellClass
class AspellClass:

    """A wrapper class for Aspell spell checker"""

    @others
#@+node:ekr.20051025071455.7:Birth & death
#@+node:ekr.20051025071455.8:__init__
def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = g.os_path_abspath(c.config.getString('aspell_dir'))
    self.aspell_bin_dir = g.os_path_abspath(c.config.getString('aspell_bin_dir'))

    self.local_language_code = local_language_code or 'en'
    self.local_dictionary_file = g.os_path_abspath(local_dictionary_file)
    self.local_dictionary = "%s.wl" % os.path.splitext(self.local_dictionary_file) [0]

    # g.trace('code',self.local_language_code,'dict',self.local_dictionary_file)
    # g.trace('dir',self.aspell_dir,'bin_dir',self.aspell_bin_dir)

    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    self.use_ctypes = g.CheckVersion(version,'2.5')
    self.aspell = self.sc = None

    if self.use_ctypes:
        self.getAspellWithCtypes()
    else:
        self.getAspell()

#@-node:ekr.20051025071455.8:__init__
#@+node:ekr.20061017125710:getAspell
def getAspell (self):

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=__name__,verbose=True)

    self.aspell = aspell
    self.sc = aspell and aspell.spell_checker(prefix=self.aspell_dir,lang=self.local_language_code)
#@-node:ekr.20061017125710:getAspell
#@+node:ekr.20061018111331:getAspellWithCtypes
def getAspellWithCtypes (self):

    import ctypes
    import ctypes.util
    c_int, c_char_p = ctypes.c_int, ctypes.c_char_p

    try:
        if sys.platform.startswith('win'):
            path = g.os_path_join(self.aspell_bin_dir, "aspell-15.dll")
            self.aspell = aspell = ctypes.CDLL(path)
        else:
            path = 'aspell'
            libname = ctypes.util.find_library(path)
            assert(libname)
            self.aspell = aspell = ctypes.CDLL(libname)
    except Exception:
        if not sys.platform.startswith('win'):
            g.es_exception()
        g.es('Can not load %s' % (path),color='blue')
        self.aspell = None
        self.check = None
        self.sc = None
        return

    << define and configure aspell entry points >>

    # Remember these functions (bound methods).
    # No other ctypes data is known outside this method.
    self.check = check
    self.spell_checker = spell_checker
    self.string_enumeration_next = string_enumeration_next
    self.suggest = suggest
    self.word_list_elements = word_list_elements
    self.word_list_size = word_list_size
#@+node:ekr.20061018111933:<< define and configure aspell entry points >>
# new_aspell_config
new_aspell_config = aspell.new_aspell_config 
new_aspell_config.restype = c_int

# aspell_config_replace
aspell_config_replace = aspell.aspell_config_replace 
aspell_config_replace.argtypes = [c_int, c_char_p, c_char_p] 

# aspell_config_retrieve
aspell_config_retrieve = aspell.aspell_config_retrieve 
aspell_config_retrieve.restype = c_char_p  
aspell_config_retrieve.argtypes = [c_int, c_char_p] 

# aspell_error_message
aspell_error_message = aspell.aspell_error_message 
aspell_error_message.restype = c_char_p  

sc = new_aspell_config()
if 0:
    print sc 
    print aspell_config_replace(sc, "prefix", aspell_dir) #1/0 
    print 'prefix', aspell_dir, `aspell_config_retrieve(sc, "prefix")`
    print aspell_config_retrieve(sc, "lang")
    print aspell_config_replace(sc, "lang",self.local_language_code)
    print aspell_config_retrieve(sc, "lang")

possible_err = aspell.new_aspell_speller(sc)
aspell.delete_aspell_config(c_int(sc))

# Rudimentary error checking, needs more.  
if aspell.aspell_error_number(possible_err) != 0:
    print 'err', aspell_error_message(possible_err)
    spell_checker = None
else: 
    spell_checker = aspell.to_aspell_speller(possible_err)

if not spell_checker:
    raise Exception('aspell checker not enabled')

word_list_size = aspell.aspell_word_list_size
word_list_size.restype = c_int
word_list_size.argtypes = [c_int,]

# word_list_elements
word_list_elements = aspell.aspell_word_list_elements
word_list_elements.restype = c_int
word_list_elements.argtypes = [c_int,]

# string_enumeration_next
string_enumeration_next = aspell.aspell_string_enumeration_next
string_enumeration_next.restype = c_char_p
string_enumeration_next.argtypes = [c_int,]

# check
check = aspell.aspell_speller_check
check.restype = c_int 
check.argtypes = [c_int, c_char_p, c_int]

# suggest
suggest = aspell.aspell_speller_suggest
suggest.restype = c_int 
suggest.argtypes = [c_int, c_char_p, c_int]
#@nonl
#@-node:ekr.20061018111933:<< define and configure aspell entry points >>
#@-node:ekr.20061018111331:getAspellWithCtypes
#@-node:ekr.20051025071455.7:Birth & death
#@+node:ekr.20051025071455.10:processWord
def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    & «original» «count» «offset»: «miss», «miss», ... 
    None: 
    # «original» «offset» 
    simplifyed to not create the string then make a list from it
    """

    # g.trace('word',word)

    if not self.aspell:
        g.trace('aspell not installed')
        return None
    elif self.use_ctypes:
        if self.check(self.spell_checker,word,len(word)):
            return None
        else:
            return self.suggestions(word)
    else:
        if self.sc.check(word):
            return None
        else:
            return self.sc.suggest(word)
#@-node:ekr.20051025071455.10:processWord
#@+node:ekr.20061018101455.4:suggestions
def suggestions(self,word):

    "return list of words found"

    aList = []
    sw = self.suggest(self.spell_checker, word, len(word))

    if self.word_list_size(sw):
        ewords = self.word_list_elements(sw)
        while 1: 
            x = self.string_enumeration_next(ewords)
            if x is None: break
            aList.append(x)
    return aList
#@nonl
#@-node:ekr.20061018101455.4:suggestions
#@+node:ekr.20051025071455.11:updateDictionary
def updateDictionary(self):

    """Update the aspell dictionary from a list of words.

    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl < %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es_print("Unable to update local aspell dictionary: %s" % err)
        return False
#@-node:ekr.20051025071455.11:updateDictionary
#@-node:ekr.20051025071455.6:class AspellClass
#@-node:ekr.20051025071455:Spell classes
#@+node:ekr.20050922104213:<< define classesList >>
classesList = [
    ('abbrevCommands',      abbrevCommandsClass),
    ('bufferCommands',      bufferCommandsClass),
    ('editCommands',        editCommandsClass),
    ('chapterCommands',     chapterCommandsClass),
    ('controlCommands',     controlCommandsClass),
    ('debugCommands',       debugCommandsClass),
    ('editFileCommands',    editFileCommandsClass),
    ('helpCommands',        helpCommandsClass),
    ('keyHandlerCommands',  keyHandlerCommandsClass),
    ('killBufferCommands',  killBufferCommandsClass),
    ('leoCommands',         leoCommandsClass),
    ('macroCommands',       macroCommandsClass),
    ('queryReplaceCommands',queryReplaceCommandsClass),
    ('rectangleCommands',   rectangleCommandsClass),
    ('registerCommands',    registerCommandsClass),
    ('searchCommands',      searchCommandsClass),
    ('spellCommands',       spellCommandsClass),
]
#@-node:ekr.20050922104213:<< define classesList >>
#@-node:ekr.20050710142719:@thin leoEditCommands.py
#@+node:ekr.20031218072017.3018:@thin leoFileCommands.py
@language python
@tabwidth -4
@pagewidth 80

<< imports >>

<< define exception classes >>

if sys.platform != 'cli':
    << define sax classes >>

class baseFileCommands:
    """A base class for the fileCommands subcommander."""
    @others

class fileCommands (baseFileCommands):
    """A class creating the fileCommands subcommander."""
    pass
#@nonl
#@+node:ekr.20050405141130:<< imports >>
import leoGlobals as g

if g.app and g.app.use_psyco:
    # print "enabled psyco classes",__file__
    try: from psyco.classes import *
    except ImportError: pass

import leoNodes

import binascii
import cStringIO
import os
import pickle
import string
import sys
import zipfile

try:
    # IronPython has problems with this.
    import xml.sax
    import xml.sax.saxutils
except Exception:
    pass

# The following is sometimes used.
__pychecker__ = '--no-import'
import time
#@nonl
#@-node:ekr.20050405141130:<< imports >>
#@+node:ekr.20060918164811:<< define exception classes >>
class BadLeoFile(Exception):
    def __init__(self, message):
        self.message = message
        Exception.__init__(self,message) # Init the base class.
    def __str__(self):
        return "Bad Leo File:" + self.message

class invalidPaste(Exception):
    pass
#@nonl
#@-node:ekr.20060918164811:<< define exception classes >>
#@+node:ekr.20060919145406:<< define sax classes >>
@others
#@nonl
#@+node:ekr.20060919110638.19:class saxContentHandler (XMLGenerator)
class saxContentHandler (xml.sax.saxutils.XMLGenerator):

    '''A sax content handler class that reads Leo files.'''

    @others
#@nonl
#@+node:ekr.20060919110638.20: __init__ & helpers
def __init__ (self,c,fileName,silent):

    self.c = c
    self.fileName = fileName
    self.silent = silent

    # Init the base class.
    xml.sax.saxutils.XMLGenerator.__init__(self)

    << define dispatch dict >>

    self.printElements = [] # 'all', 'v'

    # Global attributes of the .leo file...
    # self.body_outline_ratio = '0.5'
    self.global_window_position = {}
    self.encoding = 'utf-8' 

    # Semantics...
    self.content = None
    self.currentNode = None
    self.elementStack = []
    self.errors = 0
    self.tnxToListDict = {} # Keys are tnx's (strings), values are *lists* of saxNodeClass objects.
    self.level = 0
    self.node = None
    self.nodeList = [] # List of saxNodeClass objects with the present tnode.
    self.nodeStack = []
    self.rootNode = None
    self.topNode = None
#@nonl
#@+node:ekr.20060919110638.21:<< define dispatch dict >>
# There is no need for an 'end' method if all info is carried in attributes.

self.dispatchDict = {
    'find_panel_settings':         (None,None),
    'globals':                     (self.startGlobals,None),
    'global_log_window_position':  (None,None), # The position of the log window is no longer used.
    'global_window_position':      (self.startWinPos,None),
    'leo_file':                    (None,None),
    'leo_header':                  (self.startLeoHeader,None),
    'preferences':                 (None,None),
    't':                           (self.startTnode,self.endTnode),
    'tnodes':                      (None,None),
    'v':                           (self.startVnode,self.endVnode),
    'vh':                          (self.startVH,self.endVH),
    'vnodes':                      (self.startVnodes,None), # Causes window to appear.
}
#@nonl
#@-node:ekr.20060919110638.21:<< define dispatch dict >>
#@-node:ekr.20060919110638.20: __init__ & helpers
#@+node:ekr.20060919110638.29: Do nothing
def endElementNS(self,name,qname):
    __pychecker__ = '--no-argsused'
    g.trace(name)

def endDocument(self):
    pass

def ignorableWhitespace(self,whitespace):
    __pychecker__ = '--no-argsused'
    pass

def skippedEntity(self,name):
    __pychecker__ = '--no-argsused'
    g.trace(name)

def startElementNS(self,name,qname,attrs):
    __pychecker__ = '--no-argsused'
    g.trace(name)

def startDocument(self):
    pass
#@nonl
#@-node:ekr.20060919110638.29: Do nothing
#@+node:ekr.20060919134313: Utils
#@+node:ekr.20060919110638.23:attrsToList
def attrsToList (self,attrs):

    '''Convert the attributes to a list of g.Bunches.

    attrs: an Attributes item passed to startElement.'''

    if 1:
        for name in attrs.getNames():
            val = attrs.getValue(name)
            if type(val) != type(u''):
                g.trace('Non-unicode attribute',name,val)

    # g.trace(g.listToString([repr() for name in attrs.getNames()]))

    return [
        g.Bunch(name=name,val=attrs.getValue(name))
            for name in attrs.getNames()]
#@nonl
#@-node:ekr.20060919110638.23:attrsToList
#@+node:ekr.20060919110638.26:error
def error (self, message):

    print
    print
    print 'XML error: %s' % (message)
    print

    self.errors += 1
#@nonl
#@-node:ekr.20060919110638.26:error
#@+node:ekr.20060919110638.27:inElement
def inElement (self,name):

    return self.elementStack and name in self.elementStack
#@nonl
#@-node:ekr.20060919110638.27:inElement
#@+node:ekr.20060919110638.28:printStartElement
def printStartElement(self,name,attrs):

    indent = '\t' * self.level or ''

    if attrs.getLength() > 0:
        print '%s<%s %s>' % (
            indent,
            self.clean(name).strip(),
            self.attrsToString(attrs,sep=' ')),
    else:
        print '%s<%s>' % (
            indent,
            self.clean(name).strip()),

    if name.lower() in ['v','t','vnodes','tnodes',]:
        print
#@nonl
#@+node:ekr.20060919110638.24:attrsToString
def attrsToString (self,attrs,sep='\n'):

    '''Convert the attributes to a string.

    attrs: an Attributes item passed to startElement.

    sep: the separator charater between attributes.'''

    result = [
        '%s="%s"' % (bunch.name,bunch.val)
        for bunch in self.attrsToList(attrs)
    ]

    return sep.join(result)
#@nonl
#@-node:ekr.20060919110638.24:attrsToString
#@+node:ekr.20060919110638.25:clean
def clean(self,s):

    return g.toEncodedString(s,"ascii")
#@nonl
#@-node:ekr.20060919110638.25:clean
#@-node:ekr.20060919110638.28:printStartElement
#@-node:ekr.20060919134313: Utils
#@+node:ekr.20060919110638.30:characters
def characters(self,content):

    if content and type(content) != type(u''):
        g.trace('Non-unicode content',repr(content))

    content = content.replace('\r','')
    if not content: return

    elementName = self.elementStack and self.elementStack[-1].lower() or '<no element name>'

    if elementName in ('t','vh'):
        # if elementName == 'vh': g.trace(elementName,repr(content))
        self.content.append(content)

    elif content.strip():
        print 'unexpected content:',elementName,repr(content)
#@nonl
#@-node:ekr.20060919110638.30:characters
#@+node:ekr.20060919110638.31:endElement & helpers
def endElement(self,name):

    name = name.lower()
    if name in self.printElements or 'all' in self.printElements:
        indent = '\t' * (self.level-1) or ''
        print '%s</%s>' % (indent,self.clean(name).strip())

    data = self.dispatchDict.get(name)

    if data is None:
        if 0:
            g.trace('unknown element',name)
    else:
        junk,func = data
        if func:
            func()

    name2 = self.elementStack.pop()
    assert name == name2
#@nonl
#@+node:ekr.20060919110638.32:endTnode
def endTnode (self):

    for node in self.nodeList:
        node.bodyString = ''.join(self.content)

    self.content = []
#@nonl
#@-node:ekr.20060919110638.32:endTnode
#@+node:ekr.20060919110638.33:endVnode
def endVnode (self):

    self.level -= 1
    self.node = self.nodeStack.pop()
#@nonl
#@-node:ekr.20060919110638.33:endVnode
#@+node:ekr.20060919110638.34:endVH
def endVH (self):

    if self.node:
        self.node.headString = ''.join(self.content)

    self.content = []
#@nonl
#@-node:ekr.20060919110638.34:endVH
#@-node:ekr.20060919110638.31:endElement & helpers
#@+node:ekr.20060919110638.45:getters
def getCurrentNode (self):
    return self.currentNode

def getRootNode (self):
    return self.rootNode

def getTopNode (self):
    return self.topNode
#@nonl
#@-node:ekr.20060919110638.45:getters
#@+node:ekr.20061004054323:processingInstruction (stylesheet)
def processingInstruction (self,target,data):

    if target == 'xml-stylesheet':
        self.c.frame.stylesheet = data
        if not self.silent:
            g.es('%s: %s' % (target,data),color='blue')
    else:
        g.trace(target,data)
#@nonl
#@-node:ekr.20061004054323:processingInstruction (stylesheet)
#@+node:ekr.20060919110638.35:startElement & helpers
def startElement(self,name,attrs):

    name = name.lower()
    if name in self.printElements or 'all' in self.printElements:
        self.printStartElement(name,attrs)

    self.elementStack.append(name)

    data = self.dispatchDict.get(name)

    if data is None:
        if 0:
            g.trace('unknown element',name)
    else:
        func,junk = data
        if func:
            func(attrs)
#@nonl
#@+node:ekr.20060919110638.36:getPositionAttributes
def getPositionAttributes (self,attrs):

    d = {}

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val
        if name in ('top','left','width','height'):
            try:
                d[name] = int(val)
            except ValueError:
                d[name] = 100 # A reasonable emergency default.
        else:
            g.trace(name,len(val))

    return d
#@nonl
#@-node:ekr.20060919110638.36:getPositionAttributes
#@+node:ekr.20060919110638.37:startGlobals
def startGlobals (self,attrs):

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val

        if name == 'body_outline_ratio':
            # self.body_outline_ratio = val
            self.c.ratio = val
            # g.trace(name,val)
        elif 0:
            g.trace(name,len(val))
#@nonl
#@-node:ekr.20060919110638.37:startGlobals
#@+node:ekr.20060919110638.38:startWinPos
def startWinPos (self,attrs):

    self.global_window_position = self.getPositionAttributes(attrs)
#@nonl
#@-node:ekr.20060919110638.38:startWinPos
#@+node:ekr.20060919110638.39:startLeoHeader
def startLeoHeader (self,attrs):
    __pychecker__ = '--no-argsused'
    self.tnxToListDict = {}
#@-node:ekr.20060919110638.39:startLeoHeader
#@+node:ekr.20060919110638.40:startVH
def startVH (self,attrs):

    __pychecker__ = '--no-argsused'

    self.content = []
#@nonl
#@-node:ekr.20060919110638.40:startVH
#@+node:ekr.20060919112118:startVnodes
def startVnodes (self,attrs):

    __pychecker__ = '--no-argsused'

    c = self.c ; d = self.global_window_position

    w = d.get('width',700)
    h = d.get('height',500)
    x = d.get('left',50)
    y = d.get('top',50)
    # g.trace(d,w,h,x,y)

    # Redraw the window before writing into it.
    c.frame.setTopGeometry(w,h,x,y)
    c.frame.deiconify()
    c.frame.lift()
    c.frame.update()

    # Causes window to appear.
    # g.trace('ratio',c.frame.ratio,c.frame.secondary_ratio)
    c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
    if not self.silent:
        g.es("reading: " + self.fileName)
#@nonl
#@-node:ekr.20060919112118:startVnodes
#@+node:ekr.20060919110638.41:startTnode
def startTnode (self,attrs):

    if not self.inElement('tnodes'):
        self.error('<t> outside <tnodes>')

    self.content = []

    self.tnodeAttributes(attrs)
#@nonl
#@+node:ekr.20060919110638.42:tnodeAttributes
def tnodeAttributes (self,attrs):

    # The tnode must have a tx attribute to associate content with the proper node.

    node = self.node
    self.nodeList = []

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val
        if name == 'tx':
            self.nodeList = self.tnxToListDict.get(val,[])
            if not self.nodeList:
                self.error('Bad leo file: no node for <t tx=%s>' % (val))
        else:
            node.tnodeAttributes[name] = val

    if not self.nodeList:
        self.error('Bad leo file: no tx attribute for tnode')
#@nonl
#@-node:ekr.20060919110638.42:tnodeAttributes
#@-node:ekr.20060919110638.41:startTnode
#@+node:ekr.20060919110638.43:startVnode
def startVnode (self,attrs):

    if not self.inElement('vnodes'):
        self.error('<v> outside <vnodes>')

    if self.rootNode:
        parent = self.node
    else:
        self.rootNode = parent = saxNodeClass() # The dummy parent node.
        parent.headString = 'dummyNode'

    self.node = saxNodeClass()

    parent.children.append(self.node)
    self.vnodeAttributes(attrs)
    self.nodeStack.append(parent)

    return parent
#@nonl
#@+node:ekr.20060919110638.44:vnodeAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded and descendentTnodeUnknownAttributes.

def vnodeAttributes (self,attrs):

    node = self.node

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val
        if name == 't':
            aList = self.tnxToListDict.get(val,[])
            aList.append(self.node)
            self.tnxToListDict[val] = aList
            node.tnx = str(val) # nodeIndices.toString returns a string.
        else:
            node.attributes[name] = val
#@nonl
#@-node:ekr.20060919110638.44:vnodeAttributes
#@-node:ekr.20060919110638.43:startVnode
#@-node:ekr.20060919110638.35:startElement & helpers
#@-node:ekr.20060919110638.19:class saxContentHandler (XMLGenerator)
#@+node:ekr.20060919110638.15:class saxNodeClass
class saxNodeClass:

    '''A class representing one <v> element.

    Use getters to access the attributes, properties and rules of this mode.'''

    @others
#@nonl
#@+node:ekr.20060919110638.16: node.__init__
def __init__ (self):

    self.attributes = {}
    self.bodyString = ''
    self.headString = ''
    self.children = []
    self.tnodeAttributes = {}
    self.tnodeList = []
    self.tnx = None
#@nonl
#@-node:ekr.20060919110638.16: node.__init__
#@+node:ekr.20060919110638.17: node.__str__ & __repr__
def __str__ (self):

    return '<v: %s>' % self.headString

__repr__ = __str__
#@nonl
#@-node:ekr.20060919110638.17: node.__str__ & __repr__
#@+node:ekr.20060919110638.18:node.dump
def dump (self):

    print
    print 'node: tnx: %s body: %d %s' % (self.tnx,len(self.bodyString),self.headString)
    print 'children:',g.listToString([child for child in self.children])
    print 'attrs:',self.attributes.values()
#@nonl
#@-node:ekr.20060919110638.18:node.dump
#@-node:ekr.20060919110638.15:class saxNodeClass
#@-node:ekr.20060919145406:<< define sax classes >>
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.use_new_positions = False

    # New positions require the sax-based read code.
    self.use_sax = self.use_new_positions or c.config.getBool('use_sax_based_read')

    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5
    if self.use_sax:
        self.currentVnode = None
        self.rootVnode = None
    else:
        self.fileBuffer = None
        self.fileIndex = 0
        self.currentVnodeStack = [] # A stack of vnodes giving the current position.
        self.topVnodeStack     = [] # A stack of vnodes giving the top position.
        self.topPosition = None
    # For writing
    self.read_only = False
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@nonl
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20031218072017.3020:Reading
#@+node:ekr.20060919104836: Top-level
#@+node:ekr.20031218072017.1559:getLeoOutlineFromClipboard & helpers
def getLeoOutlineFromClipboard (self,s,reassignIndices=True):

    '''Read a Leo outline from string s in clipboard format.'''

    try:
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=True)
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=False)
    except invalidPaste:
        v = None
        g.es("Invalid Paste As Clone",color="blue")
    except BadLeoFile:
        v = None
        g.es("The clipboard is not valid ",color="blue")

    return v

getLeoOutline = getLeoOutlineFromClipboard # for compatibility
#@nonl
#@+node:ekr.20031218072017.1557:finishPaste
def finishPaste(self,reassignIndices=True):

    """Finish pasting an outline from the clipboard.

    Retain clone links if reassignIndices is False."""

    c = self.c
    current = c.currentPosition()
    if reassignIndices:
        << reassign tnode indices >>
    c.selectPosition(current)
    return current
#@+node:ekr.20031218072017.1558:<< reassign tnode indices >>
@ putLeoOutline calls assignFileIndices (when copying nodes) so that vnode can be associated with tnodes.
However, we must _reassign_ the indices here so that no "False clones" are created.
@c

nodeIndices = g.app.nodeIndices

current.clearVisitedInTree()

for p in current.self_and_subtree_iter():
    t = p.v.t
    if not t.isVisited():
        t.setVisited()
        # New in Leo 4.4.2 b2: use gnx's.  maxTnodeIndex is no longer used.
        t.fileIndex = nodeIndices.getNewIndex()
        # g.trace(t.fileIndex)
#@nonl
#@-node:ekr.20031218072017.1558:<< reassign tnode indices >>
#@-node:ekr.20031218072017.1557:finishPaste
#@+node:ekr.20060826052453.1:getLeoOutlineHelper
def getLeoOutlineHelper (self,s,reassignIndices,checking):

    self.checking = checking
    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.descendentUnknownAttributesDictList = []
    v = None

    self.tnodesDict = {}
    if not reassignIndices:
        << recreate tnodesDict >>
    try:
        self.getXmlVersionTag()
        self.getXmlStylesheetTag()
        self.getTag("<leo_file>")
        self.getClipboardHeader()
        self.getDummyElements()
        self.getVnodes(reassignIndices)
        self.getTnodes()
        self.getTag("</leo_file>")
        if not checking:
            v = self.finishPaste(reassignIndices)
    finally:
        self.fileBuffer = None ; self.fileIndex = 0
        self.usingClipboard = False
        self.tnodesDict = {}
    return v
#@nonl
#@+node:EKR.20040610134756:<< recreate tnodesDict >>
nodeIndices = g.app.nodeIndices

self.tnodesDict = {}

for t in self.c.all_unique_tnodes_iter():
    tref = t.fileIndex
    if nodeIndices.isGnx(tref):
        tref = nodeIndices.toString(tref)
    self.tnodesDict[tref] = t

if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]
#@-node:EKR.20040610134756:<< recreate tnodesDict >>
#@-node:ekr.20060826052453.1:getLeoOutlineHelper
#@+node:ekr.20031218072017.3022:getClipboardHeader
def getClipboardHeader (self):

    if self.getOpenTag("<leo_header"):
        return # <leo_header> or <leo_header/> has been seen.

    while 1:
        if self.matchTag("file_format="):
            self.getDquote() ; self.getLong() ; self.getDquote()
        elif self.matchTag("tnodes="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("max_tnode_index="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("></leo_header>"): # new in 4.2: allow this form.
            break
        else:
            self.getTag("/>")
            break
#@nonl
#@-node:ekr.20031218072017.3022:getClipboardHeader
#@-node:ekr.20031218072017.1559:getLeoOutlineFromClipboard & helpers
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # May be set when reading @file nodes.
    << warn on read-only files >>
    self.checking = False
    self.mFileName = c.mFileName
    self.initReadIvars()
    c.loading = True # disable c.changed

    try:
        ok = True
        # t1 = time.clock()
        if self.use_sax:
            v = self.readSaxFile(theFile,fileName,silent)
            if v: # v == None for minimal .leo files.
                c.setRootVnode(v)
                self.rootVnode = v
            else:
                self.rootVnode = c.rootPosition().v
        else:
            self.getAllLeoElements(fileName,silent)
        # t2 = time.clock()
        # g.trace('time',t2-t1)
    except BadLeoFile, message:
        if not silent:
            g.es_exception()
            g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    # New in Leo 4.2.2: before reading derived files.
    if self.use_sax:
        self.resolveTnodeLists()
    if ok and readAtFileNodesFlag:
        # Redraw before reading the @file nodes so the screen isn't blank.
        # This is important for big files like LeoPy.leo.
        c.redraw_now()
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    # Do this after reading derived files.
    if readAtFileNodesFlag:
        # The descendent nodes won't exist unless we have read the @thin nodes!
        self.restoreDescendentAttributes()
    if self.use_sax:
        self.setPositionsFromVnodes()
    else:
        if not self.usingClipboard:
            self.setPositionsFromStacks()
        if not c.currentPosition():
            c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    self.initReadIvars()
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False

if self.read_only:
    g.es("read only: " + fileName,color="red")
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@+node:ekr.20031218072017.2009:newTnode
def newTnode(self,index):

    if self.tnodesDict.has_key(index):
        g.es("bad tnode index: %s. Using empty text." % str(index))
        return leoNodes.tnode()
    else:
        # Create the tnode.  Use the _original_ index as the key in tnodesDict.
        t = leoNodes.tnode()
        self.tnodesDict[index] = t

        if type(index) not in (type(""),type(u"")):
            g.es("newTnode: unexpected index type:",type(index),index,color="red")

        # Convert any pre-4.1 index to a gnx.
        theId,time,n = gnx = g.app.nodeIndices.scanGnx(index,0)
        if time != None:
            t.setFileIndex(gnx)

        return t
#@-node:ekr.20031218072017.2009:newTnode
#@+node:ekr.20031218072017.3029:readAtFileNodes (leoAtFile)
def readAtFileNodes (self):

    c = self.c ; p = c.currentPosition()

    c.beginUpdate()
    try:
        c.atFileCommands.readAll(p,partialFlag=True)
    finally:
        c.endUpdate()

    # Force an update of the body pane.
    c.setBodyString(p,p.bodyString())
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20031218072017.3029:readAtFileNodes (leoAtFile)
#@+node:ekr.20031218072017.2297:open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    if not self.use_sax:
        << read the entire file into the buffer >>
        theFile.close()
        self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    ok, ratio = self.getLeoFile(
        theFile,fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    if not self.use_sax: # Delete the file buffer
        self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20070412103240:<< read the entire file into the buffer >>
isZipped = zipfile.is_zipfile(fileName)

if isZipped:
    aList = theFile.infolist()
    contentsName = aList[0].filename
    self.fileBuffer = theFile.read(contentsName)
else:
    self.fileBuffer = theFile.read()
#@-node:ekr.20070412103240:<< read the entire file into the buffer >>
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.2297:open (leoFileCommands)
#@+node:ekr.20031218072017.3030:readOutlineOnly
def readOutlineOnly (self,theFile,fileName):

    c = self.c
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    c.beginUpdate()
    try:
        ok, ratio = self.getLeoFile(theFile,fileName,readAtFileNodesFlag=False)
    finally:
        c.endUpdate()
    c.frame.deiconify()
    vflag,junk,secondary_ratio = self.frame.initialRatios()
    c.frame.resizePanesToRatio(ratio,secondary_ratio)
    if 0: # 1/30/04: this is useless.
        # This should be done after the pane size has been set.
        if self.topPosition:
            c.frame.tree.setTopPosition(self.topPosition)
            c.redraw_now()
    # delete the file buffer
    self.fileBuffer = ""
    return ok
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.3030:readOutlineOnly
#@-node:ekr.20060919104836: Top-level
#@+node:ekr.20060919133249:Common
# Methods common to both the sax and non-sax code.
#@nonl
#@+node:ekr.20031218072017.2004:canonicalTnodeIndex
def canonicalTnodeIndex(self,index):

    """Convert Tnnn to nnn, leaving gnx's unchanged."""

    # index might be Tnnn, nnn, or gnx.
    theId,time,n = g.app.nodeIndices.scanGnx(index,0)
    if time == None: # A pre-4.1 file index.
        if index[0] == "T":
            index = index[1:]

    return index
#@-node:ekr.20031218072017.2004:canonicalTnodeIndex
#@+node:ekr.20040701065235.1:getDescendentAttributes
def getDescendentAttributes (self,s,tag=""):

    '''s is a list of gnx's, separated by commas from a <v> or <t> element.
    Parses s into a list.

    This is used to record marked and expanded nodes.
    '''

    __pychecker__ = '--no-argsused' # tag used only for debugging.

    gnxs = s.split(',')
    result = [gnx for gnx in gnxs if len(gnx) > 0]
    # g.trace(tag,result)
    return result
#@-node:ekr.20040701065235.1:getDescendentAttributes
#@+node:EKR.20040627114602:getDescendentUnknownAttributes
# Only @thin vnodes have the descendentTnodeUnknownAttributes field.
# The question is: what are we to do about this?

def getDescendentUnknownAttributes (self,s):

    try:
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except (TypeError,pickle.UnpicklingError,ImportError):
        g.trace('Can not unpickle',s)
        return None
#@-node:EKR.20040627114602:getDescendentUnknownAttributes
#@+node:ekr.20060919142200.1:initReadIvars
def initReadIvars (self):

    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
#@nonl
#@-node:ekr.20060919142200.1:initReadIvars
#@+node:EKR.20040627120120:restoreDescendentAttributes
def restoreDescendentAttributes (self):

    c = self.c ; verbose = True 

    for resultDict in self.descendentUnknownAttributesDictList:
        for gnx in resultDict.keys():
            tref = self.canonicalTnodeIndex(gnx)
            t = self.tnodesDict.get(tref)
            if t:
                t.unknownAttributes = resultDict[gnx]
                t._p_changed = 1
            elif verbose:
                g.trace('can not find tnode (duA): gnx = %s' % gnx,color='red')
    marks = {} ; expanded = {}
    for gnx in self.descendentExpandedList:
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(gnx)
        if t: expanded[t]=t
        elif verbose:
            g.trace('can not find tnode (expanded): gnx = %s, tref: %s' % (gnx,tref),color='red')

    for gnx in self.descendentMarksList:
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(gnx)
        if t: marks[t]=t
        elif verbose:
            g.trace('can not find tnode (marks): gnx = %s tref: %s' % (gnx,tref),color='red')

    if marks or expanded:
        # g.trace('marks',len(marks),'expanded',len(expanded))
        for p in c.all_positions_iter():
            if marks.get(p.v.t):
                p.v.initMarkedBit()
                    # This was the problem: was p.setMark.
                    # There was a big performance bug in the mark hook in the Node Navigator plugin.
            if expanded.get(p.v.t):
                p.expand()
#@-node:EKR.20040627120120:restoreDescendentAttributes
#@-node:ekr.20060919133249:Common
#@+node:ekr.20031218072017.3021:Non-sax
#@+node:ekr.20040326052245:convertStackToPosition
def convertStackToPosition (self,stack):

    c = self.c ; p2 = None
    if not stack: return None

    for p in c.allNodes_iter():
        if p.v == stack[0]:
            p2 = p.copy()
            for n in xrange(len(stack)):
                if not p2: break
                # g.trace("compare",n,p2.v,stack[n])
                if p2.v != stack[n]:
                    p2 = None
                elif n + 1 == len(stack):
                    break
                else:
                    p2.moveToParent()
            if p2:
                return p

    return None
#@-node:ekr.20040326052245:convertStackToPosition
#@+node:ekr.20031218072017.1243:get, match & skip (basic)
#@+node:ekr.20031218072017.1244:get routines (basic)
#@+node:EKR.20040526204706:getBool
def getBool (self):

    self.skipWs() # guarantees at least one more character.
    ch = self.fileBuffer[self.fileIndex]
    if ch == '0':
        self.fileIndex += 1 ; return False
    elif ch == '1':
        self.fileIndex += 1 ; return True
    else:
        raise BadLeoFile("expecting bool constant")
#@-node:EKR.20040526204706:getBool
#@+node:EKR.20040526204706.1:getDouble
def getDouble (self):

    self.skipWs()
    i = self.fileIndex ; buf = self.fileBuffer
    floatChars = 'eE.+-'
    n = len(buf)
    while i < n and (buf[i].isdigit() or buf[i] in floatChars):
        i += 1
    if i == self.fileIndex:
        raise BadLeoFile("expecting float constant")
    val = float(buf[self.fileIndex:i])
    self.fileIndex = i
    return val
#@-node:EKR.20040526204706.1:getDouble
#@+node:EKR.20040526204706.2:getDqBool
def getDqBool (self):

    self.getDquote()
    val = self.getBool()
    self.getDquote()
    return val
#@-node:EKR.20040526204706.2:getDqBool
#@+node:EKR.20040526204706.3:getDqString
def getDqString (self):

    self.getDquote()
    i = self.fileIndex
    self.fileIndex = j = string.find(self.fileBuffer,'"',i)
    if j == -1: raise BadLeoFile("unterminated double quoted string")
    s = self.fileBuffer[i:j]
    self.getDquote()
    return s
#@-node:EKR.20040526204706.3:getDqString
#@+node:EKR.20040526204706.4:getDquote
def getDquote (self):

    self.getTag('"')
#@-node:EKR.20040526204706.4:getDquote
#@+node:ekr.20031218072017.3024:getEscapedString
def getEscapedString (self):

    # The next '<' begins the ending tag.
    i = self.fileIndex
    self.fileIndex = j = string.find(self.fileBuffer,'<',i)
    if j == -1:
        print self.fileBuffer[i:]
        raise BadLeoFile("unterminated escaped string")
    else:
        # Allocates memory
        return self.xmlUnescape(self.fileBuffer[i:j])
#@-node:ekr.20031218072017.3024:getEscapedString
#@+node:EKR.20040526204706.5:getIndex
def getIndex (self):

    val = self.getLong()
    if val < 0: raise BadLeoFile("expecting index")
    return val
#@-node:EKR.20040526204706.5:getIndex
#@+node:EKR.20040526204706.6:getLong
def getLong (self):

    self.skipWs() # guarantees at least one more character.
    i = self.fileIndex
    if self.fileBuffer[i] == u'-':
        i += 1
    n = len(self.fileBuffer)
    while i < n and self.fileBuffer[i].isdigit():
        i += 1
    if i == self.fileIndex:
        raise BadLeoFile("expecting int constant")
    val = int(self.fileBuffer[self.fileIndex:i])
    self.fileIndex = i
    return val
#@-node:EKR.20040526204706.6:getLong
#@+node:EKR.20040526204706.7:getOpenTag
def getOpenTag (self,tag):

    """
    Look ahead for collapsed tag: tag may or may not end in ">"
    Skips tag and /> if found, otherwise does not alter index.
    Returns True if the closing part was found.
    Throws BadLeoFile if the tag does not exist.
    """

    if tag[-1] == ">":
        # Only the tag itself or a collapsed tag are valid.
        if self.matchTag(tag):
            return False # Not a collapsed tag.
        elif self.matchTag(tag[:-1]):
            # It must be a collapsed tag.
            self.skipWs()
            if self.matchTag("/>"):
                return True
        print "getOpenTag(", tag, ") failed:"
        raise BadLeoFile("expecting" + tag)
    else:
        # The tag need not be followed by "/>"
        if self.matchTag(tag):
            old_index = self.fileIndex
            self.skipWs()
            if self.matchTag("/>"):
                return True
            else:
                self.fileIndex = old_index
                return False
        else:
            print "getOpenTag(", tag, ") failed:"
            raise BadLeoFile("expecting" + tag)
#@-node:EKR.20040526204706.7:getOpenTag
#@+node:EKR.20040526204706.8:getStringToTag
def getStringToTag (self,tag):

    buf = self.fileBuffer
    blen = len(buf) ; tlen = len(tag)
    i = j = self.fileIndex
    while i < blen:
        if tag == buf[i:i+tlen]:
            self.fileIndex = i
            return buf[j:i]
        else: i += 1
    raise BadLeoFile("expecting string terminated by " + tag)
    return ""
#@-node:EKR.20040526204706.8:getStringToTag
#@+node:EKR.20040526204706.9:getTag
def getTag (self,tag):

    """
    Look ahead for closing />
    Return True if found.
    """

    if self.matchTag(tag):
        return
    else:
        print "getTag(", tag, ") failed:"
        raise BadLeoFile("expecting" + tag)
#@-node:EKR.20040526204706.9:getTag
#@+node:EKR.20040526204036:getUnknownTag
def getUnknownTag(self):

    self.skipWsAndNl() # guarantees at least one more character.
    tag = self.getStringToTag('=')
    if not tag:
        print "getUnknownTag failed"
        raise BadLeoFile("unknown tag not followed by '='")

    self.fileIndex += 1
    val = self.getDqString()
    # g.trace(tag,val)
    return tag,val
#@-node:EKR.20040526204036:getUnknownTag
#@-node:ekr.20031218072017.1244:get routines (basic)
#@+node:ekr.20031218072017.1245:match routines
def matchChar (self,ch):
    self.skipWs() # guarantees at least one more character.
    if ch == self.fileBuffer[self.fileIndex]:
        self.fileIndex += 1 ; return True
    else: return False

# Warning: does not check for end-of-word,
# so caller must match prefixes first.
def matchTag (self,tag):
    self.skipWsAndNl() # guarantees at least one more character.
    i = self.fileIndex
    if tag == self.fileBuffer[i:i+len(tag)]:
        self.fileIndex += len(tag)
        return True
    else:
        return False

def matchTagWordIgnoringCase (self,tag):
    self.skipWsAndNl() # guarantees at least one more character.
    i = self.fileIndex
    tag = string.lower(tag)
    j = g.skip_c_id(self.fileBuffer,i)
    word = self.fileBuffer[i:j]
    word = string.lower(word)
    if tag == word:
        self.fileIndex += len(tag)
        return True
    else:
        return False
#@-node:ekr.20031218072017.1245:match routines
#@+node:ekr.20031218072017.3027:skipWs
def skipWs (self):

    while self.fileIndex < len(self.fileBuffer):
        ch = self.fileBuffer[self.fileIndex]
        if ch == ' ' or ch == '\t':
            self.fileIndex += 1
        else: break

    # The caller is entitled to get the next character.
    if  self.fileIndex >= len(self.fileBuffer):
        raise BadLeoFile("")
#@-node:ekr.20031218072017.3027:skipWs
#@+node:ekr.20031218072017.3028:skipWsAndNl
def skipWsAndNl (self):

    while self.fileIndex < len(self.fileBuffer):
        ch = self.fileBuffer[self.fileIndex]
        if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n':
            self.fileIndex += 1
        else: break

    # The caller is entitled to get the next character.
    if  self.fileIndex >= len(self.fileBuffer):
        raise BadLeoFile("")
#@-node:ekr.20031218072017.3028:skipWsAndNl
#@+node:ekr.20031218072017.3031:xmlUnescape
def xmlUnescape(self,s):

    if s:
        s = string.replace(s, '\r', '')
        s = string.replace(s, "&lt;", '<')
        s = string.replace(s, "&gt;", '>')
        s = string.replace(s, "&amp;", '&')
    return s
#@-node:ekr.20031218072017.3031:xmlUnescape
#@-node:ekr.20031218072017.1243:get, match & skip (basic)
#@+node:ekr.20031218072017.1555:getAllLeoElements
def getAllLeoElements (self,fileName,silent):
    c = self.c

    self.getXmlVersionTag()
    self.getXmlStylesheetTag()

    self.getTag("<leo_file>") # Must match exactly.
    self.getLeoHeader()
    self.getGlobals()
    self.getPrefs()
    self.getFindPanelSettings()

    # Causes window to appear.
    c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
    if not silent:
        g.es("reading: " + fileName)

    self.getVnodes()
    self.getTnodes()
    self.getCloneWindows()
    self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:getAllLeoElements
#@+node:ekr.20031218072017.3023:getCloneWindows
# For compatibility with old file formats.

def getCloneWindows (self):

    if not self.matchTag("<clone_windows>"):
        return # <clone_windows/> seen.

    while self.matchTag("<clone_window vtag=\"V"):
        self.getLong() ; self.getDquote() ; self.getTag(">")
        if not self.getOpenTag("<global_window_position"):
            self.getTag("<global_window_position")
            self.getPosition()
            self.getTag("/>")
        self.getTag("</clone_window>")
    self.getTag("</clone_windows>")
#@-node:ekr.20031218072017.3023:getCloneWindows
#@+node:ekr.20061209141653:getDummyElements
def getDummyElements (self):

    # New in Leo 4.4.3: Ignore the dummy elements that allow
    # Pasted Leo outlines to be valid .leo files.
    while 1:
        for tag in ('<globals','<preferences','<find_panel_settings'):
            if self.matchTag(tag) and self.matchTag('/>'):
                break
        else:
            break
#@-node:ekr.20061209141653:getDummyElements
#@+node:ekr.20031218072017.2064:getFindPanelSettings
def getFindPanelSettings (self):

    if self.getOpenTag("<find_panel_settings"):
        return # <find_panel_settings/> seen.

    # New in 4.3: ignore all pre-4.3 find settings.
    while 1:
        if   self.matchTag("batch="):           self.getDqBool()
        elif self.matchTag("ignore_case="):     self.getDqBool()
        elif self.matchTag("mark_changes="):    self.getDqBool()
        elif self.matchTag("mark_finds="):      self.getDqBool()
        elif self.matchTag("node_only="):       self.getDqBool()
        elif self.matchTag("pattern_match="):   self.getDqBool()
        elif self.matchTag("reverse="):         self.getDqBool()
        elif self.matchTag("script_change="):   self.getDqBool()
        elif self.matchTag("script_search="):   self.getDqBool()
        elif self.matchTag("search_headline="): self.getDqBool()
        elif self.matchTag("search_body="):     self.getDqBool()
        elif self.matchTag("selection_only="):  self.getDqBool()
        elif self.matchTag("suboutline_only="): self.getDqBool()
        elif self.matchTag("whole_word="):      self.getDqBool()
        elif self.matchTag("wrap="):            self.getDqBool()
        elif self.matchTag(">"): break
        else: self.getUnknownTag() # Ignore all other tags.
    # Allow only <find_string> or <find_string/>
    if self.getOpenTag("<find_string>"): 
        pass
    else:
        self.getEscapedString() ; self.getTag("</find_string>")
    # Allow only <change_string> or <change_string/>
    if self.getOpenTag("<change_string>"): 
        pass
    else:
        self.getEscapedString() ; self.getTag("</change_string>")
    self.getTag("</find_panel_settings>")
#@-node:ekr.20031218072017.2064:getFindPanelSettings
#@+node:ekr.20031218072017.2306:getGlobals
def getGlobals (self):

    if self.getOpenTag("<globals"):
        # <globals/> seen: set reasonable defaults:
        self.ratio = 0.5
        y,x,h,w = 50,50,500,700
    else:
        self.getTag("body_outline_ratio=\"")
        self.ratio = self.getDouble() ; self.getDquote() ; self.getTag(">")

        self.getTag("<global_window_position")
        y,x,h,w = self.getPosition()
        self.getTag("/>")

        self.getTag("<global_log_window_position")
        self.getPosition()
        self.getTag("/>") # no longer used.

        self.getTag("</globals>")

    # Redraw the window before writing into it.
    self.frame.setTopGeometry(w,h,x,y)
    self.frame.deiconify()
    self.frame.lift()
    self.frame.update()
#@-node:ekr.20031218072017.2306:getGlobals
#@+node:ekr.20031218072017.1970:getLeoHeader
def getLeoHeader (self):

    if self.getOpenTag("<leo_header"):
        return # <leo_header/> seen.

    # New in version 1.7: attributes may appear in any order.
    while 1:
        if self.matchTag("file_format="):
            self.getDquote() ; self.getLong() ; self.getDquote()
        elif self.matchTag("tnodes="):
            self.getDquote() ; self.getLong() ; self.getDquote()
        elif self.matchTag("max_tnode_index="):
            self.getDquote() ; self.getLong() ; self.getDquote()
        elif self.matchTag("clone_windows="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used.
        elif self.matchTag("></leo_header>"): # new in 4.2: allow this form.
            break
        else:
            self.getTag("/>")
            break
#@-node:ekr.20031218072017.1970:getLeoHeader
#@+node:ekr.20031218072017.3025:getPosition
def getPosition (self):

    top = left = height = width = 0
    # New in version 1.7: attributes may appear in any order.
    while 1:
        if self.matchTag("top=\""):
            top = self.getLong() ; self.getDquote()
        elif self.matchTag("left=\""):
            left = self.getLong() ; self.getDquote()
        elif self.matchTag("height=\""):
            height = self.getLong() ; self.getDquote()
        elif self.matchTag("width=\""):
            width = self.getLong() ; self.getDquote()
        else: break
    return top, left, height, width
#@-node:ekr.20031218072017.3025:getPosition
#@+node:ekr.20031218072017.2062:getPrefs
# Note: Leo 4.3 does not write these settings to local .leo files.
# Instead, corresponding settings are contained in leoConfig.leo files.

def getPrefs (self):

    c = self.c

    if self.getOpenTag("<preferences"):
        return # <preferences/> seen

    table = (
        ("allow_rich_text",None,None), # Ignored.
        ("tab_width","tab_width",self.getLong),
        ("page_width","page_width",self.getLong),
        ("tangle_bat","tangle_batch_flag",self.getBool),
        ("untangle_bat","untangle_batch_flag",self.getBool),
        ("output_doc_chunks","output_doc_flag",self.getBool),
        ("noweb_flag",None,None), # Ignored.
        ("extended_noweb_flag",None,None), # Ignored.
        ("defaultTargetLanguage","target_language",self.getTargetLanguage),
        ("use_header_flag","use_header_flag",self.getBool))

    done = False
    while 1:
        found = False
        for tag,var,f in table:
            if self.matchTag("%s=" % tag):
                if var:
                    self.getDquote() ; val = f() ; self.getDquote()
                    setattr(c,var,val)
                    # g.trace(var,val)
                else:
                    self.getDqString()
                found = True ; break
        if not found:
            if self.matchTag("/>"):
                done = True ; break
            if self.matchTag(">"):
                break
            else: # New in 4.1: ignore all other tags.
                self.getUnknownTag()

    if not done:
        while 1:
            if self.matchTag("<defaultDirectory>"):
                # New in version 0.16.
                c.tangle_directory = self.getEscapedString()
                self.getTag("</defaultDirectory>")
                if not g.os_path_exists(c.tangle_directory):
                    g.es("default tangle directory not found:" + c.tangle_directory)
            elif self.matchTag("<TSyntaxMemo_options>"):
                self.getEscapedString() # ignored
                self.getTag("</TSyntaxMemo_options>")
            else: break
        self.getTag("</preferences>")
#@+node:ekr.20031218072017.2063:getTargetLanguage
def getTargetLanguage (self):

    # Must match longer tags before short prefixes.
    for name in g.app.language_delims_dict.keys():
        if self.matchTagWordIgnoringCase(name):
            language = name.replace("/","")
            # self.getDquote()
            return language

    return "c" # default
#@-node:ekr.20031218072017.2063:getTargetLanguage
#@-node:ekr.20031218072017.2062:getPrefs
#@+node:ekr.20031218072017.3026:getSize (not used!)
def getSize (self):

    # New in version 1.7: attributes may appear in any order.
    height = 0 ; width = 0
    while 1:
        if self.matchTag("height=\""):
            height = self.getLong() ; self.getDquote()
        elif self.matchTag("width=\""):
            width = self.getLong() ; self.getDquote()
        else: break
    return height, width
#@-node:ekr.20031218072017.3026:getSize (not used!)
#@+node:ekr.20031218072017.1561:getTnode (changed for 4.4)
def getTnode (self):

    # we have already matched <t.
    index = -1 ; attrDict = {}

    # New in Leo 4.4: support collapsed tnodes.
    if self.matchTag('/>'): # A collapsed tnode.
        return

    # Attributes may appear in any order.
    while 1:
        if self.matchTag("tx="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            index = self.getDqString()
        elif self.matchTag("rtf=\"1\""): pass # ignored
        elif self.matchTag("rtf=\"0\""): pass # ignored
        elif self.matchTag(">"):         break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("tnode")
            if attr: attrDict[attr] = val

    # index might be Tnnn, nnn, or gnx.
    theId,time,n = g.app.nodeIndices.scanGnx(index,0)
    if time == None: # A pre-4.1 file index.
        if index[0] == "T":
            index = index[1:]

    index = self.canonicalTnodeIndex(index)
    t = self.tnodesDict.get(index)
    << handle unknown attributes >>
    if t:
        s = self.getEscapedString()
        t.setTnodeText(s,encoding=self.leo_file_encoding)
    else:
        g.es("no tnode with index: %s.  The text will be discarded" % str(index))
    self.getTag("</t>")
#@+node:ekr.20031218072017.1564:<< handle unknown attributes >>
keys = attrDict.keys()
if keys:
    t.unknownAttributes = attrDict
    t._p_changed = 1
    if 0: # For debugging.
        s = "unknown attributes for tnode"
        g.es_print(s, color = "blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            g.es_print(s)
#@-node:ekr.20031218072017.1564:<< handle unknown attributes >>
#@-node:ekr.20031218072017.1561:getTnode (changed for 4.4)
#@+node:ekr.20031218072017.2008:getTnodeList (4.0,4.2)
def getTnodeList (self,s):

    """Parse a list of tnode indices in string s."""

    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!

    fc = self ; 

    indexList = s.split(',') # The list never ends in a comma.
    tnodeList = []
    for index in indexList:
        index = self.canonicalTnodeIndex(index)
        t = fc.tnodesDict.get(index)
        if not t:
            # Not an error: create a new tnode and put it in fc.tnodesDict.
            # g.trace("not allocated: %s" % index)
            t = self.newTnode(index)
        tnodeList.append(t)

    # if tnodeList: g.trace(len(tnodeList))
    return tnodeList
#@-node:ekr.20031218072017.2008:getTnodeList (4.0,4.2)
#@+node:ekr.20031218072017.1560:getTnodes
def getTnodes (self):

    # A slight change: we require a tnodes element.  But Leo always writes this.
    if self.getOpenTag("<tnodes>"):
        return # <tnodes/> seen.

    while self.matchTag("<t"):
            self.getTnode()

    self.getTag("</tnodes>")
#@-node:ekr.20031218072017.1560:getTnodes
#@+node:EKR.20040526204036.1:getUa (non-sax)
# changed for 4.3.

def getUa(self,nodeType):

    """Parse an unknown attribute in a <v> or <t> element."""

    __pychecker__ = '--no-argsused' # nodeType not used: good for debugging.

    # New in 4.2.  The unknown tag has been pickled and hexlify'd.
    attr,val = self.getUnknownTag()
    # g.trace(attr,repr(val))
    if not attr:
        return None,None

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_') and type(val) == type(''):
        # g.trace(attr,val)
        return attr,val

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except TypeError:
        # Assume that Leo 4.1 wrote the attribute.
        # g.trace('4.1 val:',val2)
        return attr,val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return attr,val2
    except (pickle.UnpicklingError,ImportError):
        return attr,val
#@-node:EKR.20040526204036.1:getUa (non-sax)
#@+node:ekr.20031218072017.1566:getVnode & helpers
# changed for 4.2 & 4.4
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = '' ; tnodeList = None ; attrDict = {}

    # we have already matched <v.

    # New in Leo 4.4: support collapsed tnodes.
    if self.matchTag('/>'): # A collapsed vnode.
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        if self.checking: return None
        else: return v

    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2, deprecated for 4.3?
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2.
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
        if v: # Bug fix: 4/18/05: The headline may change during paste as clone.
            v.initHeadString(headline,encoding=self.leo_file_encoding)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        if not self.checking:
            skip = skip or skip2
            if tnodeList:
                v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.

    if not self.checking:
        << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if not self.checking:
        << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]

index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]

if setExpanded:
    v.initExpandedBit()

if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)

if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@+node:ekr.20031218072017.1860:createVnode
# (changed for 4.2) sets skip

def createVnode (self,parent,back,tref,headline,attrDict):

    # g.trace(parent,headline)
    v = None ; c = self.c
    # Shared tnodes are placed in the file even if empty.
    if tref == -1:
        t = leoNodes.tnode()
    else:
        tref = self.canonicalTnodeIndex(tref)
        t = self.tnodesDict.get(tref)
        if not t:
            t = self.newTnode(tref)

    if self.checking: return None,False

    if back: # create v after back.
        v = back.insertAfter(t)
    elif parent: # create v as the parent's first child.
        v = parent.insertAsNthChild(0,t)
    else: # create a root vnode
        v = leoNodes.vnode(t)
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.

    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v) # New in 4.2.

    skip = len(v.t.vnodeList) > 1
    v.initHeadString(headline,encoding=self.leo_file_encoding)
    << handle unknown vnode attributes >>
    # g.trace(skip,tref,v,v.t,len(v.t.vnodeList))
    return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
    v.unknownAttributes = attrDict
    v._p_changed = 1

    if 0: # For debugging.
        s = "unknown attributes for " + v.headString()
        g.es_print(s,color="blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            g.es_print(s)
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode
#@+node:ekr.20040326063413:getExistingVnode
def getExistingVnode (self,tref,headline):

    assert(tref > -1)
    tref = self.canonicalTnodeIndex(tref)
    t = self.tnodesDict.get(tref)
    try:
        return t.vnodeList[0]
    except (IndexError,AttributeError):
        g.es("Missing vnode:",headline,color="red")
        g.es("Probably an outline topology error.")
        return None
#@-node:ekr.20040326063413:getExistingVnode
#@-node:ekr.20031218072017.1566:getVnode & helpers
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self,reassignIndices=True):

    c = self.c

    if self.getOpenTag("<vnodes>"):
        return # <vnodes/> seen.

    self.forbiddenTnodes = []
    back = parent = None # This routine _must_ work on vnodes!
    self.currentVnodeStack = []
    self.topVnodeStack = []

    if self.usingClipboard:
        oldRoot = c.rootPosition()
        oldCurrent = c.currentPosition()
        if not reassignIndices:
            << set self.forbiddenTnodes to tnodes than must not be pasted >>

    while self.matchTag("<v"):
        append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
        append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if self.usingClipboard and not self.checking:
        # Link in the pasted nodes after the current position.
        newRoot = c.rootPosition()
        c.setRootPosition(oldRoot)
        newRoot.v.linkAfter(oldCurrent.v)
        newCurrent = oldCurrent.copy()
        newCurrent.v = newRoot.v
        c.setCurrentPosition(newCurrent)

    self.getTag("</vnodes>")
#@+node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
self.forbiddenTnodes = []

for p in oldCurrent.self_and_parents_iter():
    if p.v.t not in self.forbiddenTnodes:
        self.forbiddenTnodes.append(p.v.t)

# g.trace("forbiddenTnodes",self.forbiddenTnodes)
#@-node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20031218072017.1249:getXmlStylesheetTag
def getXmlStylesheetTag (self):

    """Parses the optional xml stylesheet string, and sets the corresponding config option.

    For example, given: <?xml_stylesheet s?> the config option is s."""

    c = self.c
    tag = "<?xml-stylesheet "

    if self.matchTag(tag):
        s = self.getStringToTag("?>")
        # print "reading:", tag + s + "?>"
        c.frame.stylesheet = s
        self.getTag("?>")
#@-node:ekr.20031218072017.1249:getXmlStylesheetTag
#@+node:ekr.20031218072017.1468:getXmlVersionTag
# Parses the encoding string, and sets self.leo_file_encoding.

def getXmlVersionTag (self):

    self.getTag(g.app.prolog_prefix_string)
    encoding = self.getDqString()
    self.getTag(g.app.prolog_postfix_string)

    if g.isValidEncoding(encoding):
        self.leo_file_encoding = encoding
        # g.trace('self.leo_file_encoding:',encoding, color="blue")
    else:
        g.es("invalid encoding in .leo file: " + encoding, color="red")
#@-node:ekr.20031218072017.1468:getXmlVersionTag
#@+node:ekr.20040326054052:setPositionsFromStacks (silly)
def setPositionsFromStacks (self):

    c = self.c

    current = self.convertStackToPosition(self.currentVnodeStack)

    if current:
        # g.trace('using convertStackToPosition',current)
        c.setCurrentPosition(current)
    else:
        # g.trace(self.currentVnodeStack)
        c.setCurrentPosition(c.rootPosition())

    # At present this is useless: the drawing code doesn't set the top position properly.
    if 0:
        top = self.convertStackToPosition(self.topVnodeStack)
        if top:
            c.setTopPosition(top)
#@nonl
#@-node:ekr.20040326054052:setPositionsFromStacks (silly)
#@-node:ekr.20031218072017.3021:Non-sax
#@+node:ekr.20060919104530:Sax
#@+node:ekr.20060919110638.4:createSaxVnodes & helpers
def createSaxVnodes (self, dummyRoot):

    '''**Important**: this method and its helpers are low-level code
    corresponding to link/unlink methods in leoNodes.py.
    Modify this with extreme care.'''

    children = self.createSaxChildren(dummyRoot,parent_v = None)
    firstChild = children and children[0]

    return firstChild
#@nonl
#@+node:ekr.20060919110638.5:createSaxChildren
# node is a saxNodeClass object, parent_v is a vnode.

def createSaxChildren (self, node, parent_v):

    result = []

    for child in node.children:
        tnx = child.tnx
        t = self.tnodesDict.get(tnx)
        if t:
            # A clone.  Create a new clone node, but share the subtree, i.e., the tnode.
            v = self.createSaxVnode(child,parent_v,t=t)
            # g.trace('clone',id(child),child.headString,'t',v.t)
        else:
            v = self.createSaxVnodeTree(child,parent_v)
        result.append(v)

    self.linkSiblings(result)
    if parent_v: self.linkParentAndChildren(parent_v,result)
    return result
#@nonl
#@-node:ekr.20060919110638.5:createSaxChildren
#@+node:ekr.20060919110638.6:createSaxVnodeTree
def createSaxVnodeTree (self,node,parent_v):

    v = self.createSaxVnode(node,parent_v)

    self.createSaxChildren(node,v)

    return v
#@nonl
#@-node:ekr.20060919110638.6:createSaxVnodeTree
#@+node:ekr.20060919110638.7:createSaxVnode
def createSaxVnode (self,node,parent_v,t=None):

    h = node.headString
    b = node.bodyString

    if not t:
        t = leoNodes.tnode(bodyString=b,headString=h)
        if node.tnx:
            t.fileIndex = g.app.nodeIndices.scanGnx(node.tnx,0)
    v = leoNodes.vnode(t)
    v.t.vnodeList.append(v)
    v._parent = parent_v

    index = self.canonicalTnodeIndex(node.tnx)
    self.tnodesDict [index] = t

    # g.trace('tnx','%-22s' % (index),'v',id(v),'v.t',id(v.t),'body','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(node,v)
    self.handleTnodeSaxAttributes(node,t)

    return v
#@nonl
#@+node:ekr.20060919110638.8:handleTnodeSaxAttributes
def handleTnodeSaxAttributes (self,node,t):

    d = node.tnodeAttributes

    aDict = {}
    for key in d.keys():
        val = d.get(key)
        val2 = self.getSaxUa(key,val)
        aDict[key] = val2

    if aDict:
        # g.trace('uA',aDict)
        t.unknownAttributes = aDict
#@nonl
#@-node:ekr.20060919110638.8:handleTnodeSaxAttributes
#@+node:ekr.20061004053644:handleVnodeSaxAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded and descendentTnodeUnknownAttributes.

def handleVnodeSaxAttributes (self,node,v):

    d = node.attributes
    s = d.get('a')
    if s:
        # g.trace('%s a=%s %s' % (id(node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnode list will be resolved later.
        # g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes') # Correct: only tnode have descendent uA's.
    if s: 
        aDict = self.getDescendentUnknownAttributes(s)
        if aDict:
            # g.trace('descendentUaDictList',aDict)
            self.descendentUnknownAttributesDictList.append(aDict)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d.keys():
        if key in self.nativeVnodeAttributes:
            if 0: g.trace('****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # g.trace('uA',aDict)
        v.unknownAttributes = aDict
#@nonl
#@-node:ekr.20061004053644:handleVnodeSaxAttributes
#@-node:ekr.20060919110638.7:createSaxVnode
#@+node:ekr.20060919110638.9:linkParentAndChildren
def linkParentAndChildren (self, parent_v, children):

    # if children: g.trace(parent_v,len(children))

    firstChild_v = children and children[0] or None

    parent_v.t._firstChild = firstChild_v

    for child in children:
        child._parent = parent_v

    v = parent_v
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
#@nonl
#@-node:ekr.20060919110638.9:linkParentAndChildren
#@+node:ekr.20060919110638.10:linkSiblings
def linkSiblings (self, sibs):

    '''Set the v._back and v._next links for all vnodes v in sibs.'''

    n = len(sibs)

    for i in xrange(n):
        v = sibs[i]
        v._back = (i-1 >= 0 and sibs[i-1]) or None
        v._next = (i+1 <  n and sibs[i+1]) or None
#@nonl
#@-node:ekr.20060919110638.10:linkSiblings
#@-node:ekr.20060919110638.4:createSaxVnodes & helpers
#@+node:ekr.20060919110638.2:dumpSaxTree
def dumpSaxTree (self,root,dummy):

    if not root:
        print 'dumpSaxTree: empty tree'
        return
    if not dummy:
        root.dump()
    for child in root.children:
        self.dumpSaxTree(child,dummy=False)
#@nonl
#@-node:ekr.20060919110638.2:dumpSaxTree
#@+node:ekr.20061003093021:getSaxUa
def getSaxUa(self,attr,val):

    """Parse an unknown attribute in a <v> or <t> element.
    The unknown tag has been pickled and hexlify'd.
    """

    try:
        val = str(val)
    except UnicodeError:
        g.es_print('Unexpected exception converting hexlified string to string')
        g.es_exception()

    # g.trace(attr,repr(val))

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_') and type(val) == type(''):
        # g.trace(attr,val)
        return val

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except TypeError:
        # Assume that Leo 4.1 wrote the attribute.
        g.trace('can not unhexlify',val)
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return val2
    except (pickle.UnpicklingError,ImportError):
        g.trace('can not unpickle',val)
        return val
#@-node:ekr.20061003093021:getSaxUa
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent):

    c = self.c

    try:
        # Use cStringIo to avoid a crash in sax when inputFileName has unicode characters.
        s = theFile.read()
        theFile = cStringIO.StringIO(s)
        # g.trace(repr(inputFileName))
        node = None
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('Error parsing %s' % (inputFileName),color='red')
        g.es_exception()
    except Exception:
        g.es_print('Unexpected exception parsing %s' % (inputFileName),color='red')
        g.es_exception()

    return node
#@nonl
#@-node:ekr.20060919110638.14:parse_leo_file
#@+node:ekr.20060919110638.3:readSaxFile
def readSaxFile (self,theFile,fileName,silent):

    c = self.c

    # Pass one: create the intermediate nodes.
    self.dummyRoot = dummyRoot = self.parse_leo_file(theFile,fileName,silent=silent)

    # self.dumpSaxTree(dummyRoot,dummy=True)

    # Pass two: create the tree of vnodes and tnodes from the intermediate nodes.
    v = dummyRoot and self.createSaxVnodes(dummyRoot)
    return v
#@nonl
#@-node:ekr.20060919110638.3:readSaxFile
#@+node:ekr.20060919110638.11:resolveTnodeLists
def resolveTnodeLists (self):

    c = self.c

    for p in c.allNodes_iter():
        if hasattr(p.v,'tempTnodeList'):
            # g.trace(p.v.headString())
            result = []
            for tnx in p.v.tempTnodeList:
                index = self.canonicalTnodeIndex(tnx)
                t = self.tnodesDict.get(index)
                if t:
                    # g.trace(tnx,t)
                    result.append(t)
                else:
                    g.trace('No tnode for %s' % tnx)
            p.v.t.tnodeList = result
            delattr(p.v,'tempTnodeList')
#@nonl
#@-node:ekr.20060919110638.11:resolveTnodeLists
#@+node:ekr.20060919110638.13:setPositionsFromVnodes & helper
def setPositionsFromVnodes (self):

    c = self.c ; p = c.rootPosition()

    current = None
    d = hasattr(p.v,'unknownAttributes') and p.v.unknownAttributes
    if d:
        s = d.get('str_leo_pos')
        if s:
            current = self.archivedPositionToPosition(s)

    c.setCurrentPosition(current or c.rootPosition())
#@nonl
#@+node:ekr.20061006104837.1:archivedPositionToPosition
def archivedPositionToPosition (self,s):

    c = self.c
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        g.trace('oops: bad archived position:',aList)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level < len(aList):
        i = aList[level]
        while i > 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                g.trace('oops: bad archived position:',aList)
                return None
        level += 1
        if level < len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.headString())
    return p
#@nonl
#@-node:ekr.20061006104837.1:archivedPositionToPosition
#@-node:ekr.20060919110638.13:setPositionsFromVnodes & helper
#@-node:ekr.20060919104530:Sax
#@-node:ekr.20031218072017.3020:Reading
#@+node:ekr.20031218072017.3032:Writing
#@+node:ekr.20070413045221.2:Top-level  (leoFileCommands)
#@+node:ekr.20031218072017.1720:save (fileCommands)
def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,p=v,v=v,fileName=fileName)
    # redraw_flag = g.app.gui.guiName() == 'tkinter'
    if ok is None:
        c.beginUpdate()
        try:
            c.endEditing()# Set the current headline text.
            self.setDefaultDirectoryForNewFiles(fileName)
            ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
            if ok:
                c.setChanged(False) # Clears all dirty bits.
                self.putSavedMessage(fileName)
                if c.config.save_clears_undo_buffer:
                    g.es("clearing undo")
                    c.undoer.clearUndoState()
        finally:
            c.endUpdate() # We must redraw in order to clear dirty node icons.
    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
    return ok
#@-node:ekr.20031218072017.1720:save (fileCommands)
#@+node:ekr.20031218072017.3043:saveAs
def saveAs(self,fileName):

    c = self.c ; v = c.currentVnode()

    if not g.doHook("save1",c=c,p=v,v=v,fileName=fileName):
        c.beginUpdate()
        try:
            c.endEditing() # Set the current headline text.
            self.setDefaultDirectoryForNewFiles(fileName)
            if self.write_Leo_file(fileName,False): # outlineOnlyFlag
                c.setChanged(False) # Clears all dirty bits.
                self.putSavedMessage(fileName)
        finally:
            c.endUpdate() # We must redraw in order to clear dirty node icons.
    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
#@-node:ekr.20031218072017.3043:saveAs
#@+node:ekr.20031218072017.3044:saveTo
def saveTo (self,fileName):

    c = self.c ; v = c.currentVnode()

    if not g.doHook("save1",c=c,p=v,v=v,fileName=fileName):
        c.beginUpdate()
        try:
            c.endEditing()# Set the current headline text.
            self.setDefaultDirectoryForNewFiles(fileName)
            self.write_Leo_file(fileName,False) # outlineOnlyFlag
            self.putSavedMessage(fileName)
        finally:
            c.endUpdate() # We must redraw in order to clear dirty node icons.
    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
#@-node:ekr.20031218072017.3044:saveTo
#@+node:ekr.20070413061552:putSavedMessage
def putSavedMessage (self,fileName):

    c = self.c

    zipMark = g.choose(c.isZipped,'[zipped] ','')

    g.es("saved: %s%s" % (zipMark,g.shortFileName(fileName)))
#@nonl
#@-node:ekr.20070413061552:putSavedMessage
#@-node:ekr.20070413045221.2:Top-level  (leoFileCommands)
#@+node:ekr.20031218072017.1570:assignFileIndices & compactFileIndices
def assignFileIndices (self):

    """Assign a file index to all tnodes"""

    c = self.c ; nodeIndices = g.app.nodeIndices

    nodeIndices.setTimestamp() # This call is fairly expensive.

    # Assign missing gnx's, converting ints to gnx's.
    # Always assign an (immutable) index, even if the tnode is empty.
    for p in c.allNodes_iter():
        try: # Will fail for None or any pre 4.1 file index.
            theId,time,n = p.v.t.fileIndex
        except TypeError:
            # Don't convert to string until the actual write.
            p.v.t.fileIndex = nodeIndices.getNewIndex()

    if 0: # debugging:
        for p in c.allNodes_iter():
            g.trace(p.v.t.fileIndex)

# Indices are now immutable, so there is no longer any difference between these two routines.
compactFileIndices = assignFileIndices
#@-node:ekr.20031218072017.1570:assignFileIndices & compactFileIndices
#@+node:ekr.20050404190914.2:deleteFileWithMessage
def deleteFileWithMessage(self,fileName,kind):

    __pychecker__ = '--no-argsused' # kind unused: retained for debugging.

    try:
        os.remove(fileName)

    except Exception:
        if self.read_only:
            g.es("read only",color="red")
        g.es("exception deleting backup file:" + fileName)
        g.es_exception(full=False)
        return False
#@+node:ekr.20050404212949:test_fc_deleteFileWithMessage
def test_fc_deleteFileWithMessage(self):

    # pychecker complains about c.

    fc=c.fileCommands # Self is a dummy argument.
    fc.deleteFileWithMessage('xyzzy','test')

if 0: # one-time test of es statements.
    fileName = 'fileName' ; kind = 'kind'
    g.es("read only",color="red")
    g.es("exception deleting %s file: %s" % (fileName,kind))
    g.es("exception deleting backup file:" + fileName)
#@-node:ekr.20050404212949:test_fc_deleteFileWithMessage
#@-node:ekr.20050404190914.2:deleteFileWithMessage
#@+node:ekr.20031218072017.1470:put
def put (self,s):

    '''Put string s to self.outputFile. All output eventually comes here.'''

    # Improved code: self.outputFile (a cStringIO object) always exists.
    if s:
        self.putCount += 1
        s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
        self.outputFile.write(s)

def put_dquote (self):
    self.put('"')

def put_dquoted_bool (self,b):
    if b: self.put('"1"')
    else: self.put('"0"')

def put_flag (self,a,b):
    if a:
        self.put(" ") ; self.put(b) ; self.put('="1"')

def put_in_dquotes (self,a):
    self.put('"')
    if a: self.put(a) # will always be True if we use backquotes.
    else: self.put('0')
    self.put('"')

def put_nl (self):
    self.put("\n")

def put_tab (self):
    self.put("\t")

def put_tabs (self,n):
    while n > 0:
        self.put("\t")
        n -= 1
#@nonl
#@-node:ekr.20031218072017.1470:put
#@+node:ekr.20040324080819.1:putLeoFile & helpers
def putLeoFile (self):

    self.putProlog()
    self.putHeader()
    self.putGlobals()
    self.putPrefs()
    self.putFindSettings()
    #start = g.getTime()
    self.putVnodes()
    #start = g.printDiffTime("vnodes ",start)
    self.putTnodes()
    #start = g.printDiffTime("tnodes ",start)
    self.putPostlog()
#@nonl
#@+node:ekr.20031218072017.3035:putFindSettings
def putFindSettings (self):

    # New in 4.3:  These settings never get written to the .leo file.
    self.put("<find_panel_settings/>")
    self.put_nl()
#@-node:ekr.20031218072017.3035:putFindSettings
#@+node:ekr.20031218072017.3037:putGlobals
# Changed for Leo 4.0.

def putGlobals (self):

    c = self.c
    self.put("<globals")
    << put the body/outline ratio >>
    self.put(">") ; self.put_nl()
    << put the position of this frame >>
    << put the position of the log window >>
    self.put("</globals>") ; self.put_nl()
#@+node:ekr.20031218072017.3038:<< put the body/outline ratio >>
# Puts an innumerate number of digits

self.put(" body_outline_ratio=")
self.put_in_dquotes(str(c.frame.ratio))
#@-node:ekr.20031218072017.3038:<< put the body/outline ratio >>
#@+node:ekr.20031218072017.3039:<< put the position of this frame >>
width,height,left,top = c.frame.get_window_info()

self.put_tab()
self.put("<global_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3039:<< put the position of this frame >>
#@+node:ekr.20031218072017.3040:<< put the position of the log window >>
top = left = height = width = 0 # no longer used
self.put_tab()
self.put("<global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3040:<< put the position of the log window >>
#@-node:ekr.20031218072017.3037:putGlobals
#@+node:ekr.20031218072017.3041:putHeader
def putHeader (self):

    tnodes = 0 ; clone_windows = 0 # Always zero in Leo2.

    self.put("<leo_header")
    self.put(" file_format=") ; self.put_in_dquotes("2")
    self.put(" tnodes=") ; self.put_in_dquotes(str(tnodes))
    self.put(" max_tnode_index=") ; self.put_in_dquotes(str(0))
    self.put(" clone_windows=") ; self.put_in_dquotes(str(clone_windows))
    self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3041:putHeader
#@+node:ekr.20031218072017.3042:putPostlog
def putPostlog (self):

    self.put("</leo_file>") ; self.put_nl()
#@-node:ekr.20031218072017.3042:putPostlog
#@+node:ekr.20031218072017.2066:putPrefs
def putPrefs (self):

    # New in 4.3:  These settings never get written to the .leo file.
    self.put("<preferences/>")
    self.put_nl()
#@-node:ekr.20031218072017.2066:putPrefs
#@+node:ekr.20031218072017.1246:putProlog & helpers
def putProlog (self):

    c = self.c

    self.putXMLLine()

    if c.config.stylesheet or c.frame.stylesheet:
        self.putStyleSheetLine()

    self.put("<leo_file>") ; self.put_nl()
#@+node:ekr.20031218072017.1247:putXMLLine
def putXMLLine (self):

    '''Put the **properly encoded** <?xml> element.'''

    # Use self.leo_file_encoding encoding.
    self.put('%s"%s"%s\n' % (
        g.app.prolog_prefix_string,
        self.leo_file_encoding,
        g.app.prolog_postfix_string))
#@nonl
#@-node:ekr.20031218072017.1247:putXMLLine
#@+node:ekr.20031218072017.1248:putStyleSheetLine
def putStyleSheetLine (self):

    c = self.c

    # The stylesheet in the .leo file takes precedence over the default stylesheet.
    self.put("<?xml-stylesheet ")
    self.put(c.frame.stylesheet or c.config.stylesheet)
    self.put("?>")
    self.put_nl()
#@nonl
#@-node:ekr.20031218072017.1248:putStyleSheetLine
#@-node:ekr.20031218072017.1246:putProlog & helpers
#@+node:ekr.20031218072017.1577:putTnode
def putTnode (self,t):

    # New in Leo 4.4.2 b2: call put just once.
    gnx = g.app.nodeIndices.toString(t.fileIndex)
    ua = hasattr(t,'unknownAttributes') and self.putUnknownAttributes(t) or ''
    body = t.bodyString and xml.sax.saxutils.escape(t.bodyString) or ''
    self.put('<t tx="%s"%s>%s</t>\n' % (gnx,ua,body))
#@nonl
#@-node:ekr.20031218072017.1577:putTnode
#@+node:ekr.20031218072017.1575:putTnodes
def putTnodes (self):

    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("<tnodes>\n")
    << write only those tnodes that were referenced >>
    self.put("</tnodes>\n")
#@+node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
if self.usingClipboard: # write the current tree.
    theIter = c.currentPosition().self_and_subtree_iter()
else: # write everything
    theIter = c.allNodes_iter()

# Populate tnodes
tnodes = {}

for p in theIter:
    index = p.v.t.fileIndex
    assert(index)
    tnodes[index] = p.v.t

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
    # g.trace(index)
    t = tnodes.get(index)
    assert(t)
    # Write only those tnodes whose vnodes were written.
    if t.isWriteBit(): # 5/3/04
        self.putTnode(t)
#@nonl
#@-node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
#@-node:ekr.20031218072017.1575:putTnodes
#@+node:EKR.20040526202501:putUnknownAttributes & helper
def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        return ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
#@nonl
#@+node:ekr.20050418161620.2:putUaHelper
def putUaHelper (self,torv,key,val):

    '''Put attribute whose name is key and value is val to the output stream.'''

    # g.trace(key,repr(val),g.callers())

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if key.startswith('str_'):
        if type(val) == type(''):
            attr = ' %s="%s"' % (key,xml.sax.saxutils.escape(val))
            return attr
        else:
            g.es("ignoring non-string attribute %s in %s" % (
                key,torv),color="blue")
            return ''
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
        python23 = g.CheckVersion(version,'2.3')
        try:
            if python23:
                # Protocol argument is new in Python 2.3
                # Use protocol 1 for compatibility with bin.
                s = pickle.dumps(val,protocol=1)
            else:
                s = pickle.dumps(val,bin=True)
            attr = ' %s="%s"' % (key,binascii.hexlify(s))
            return attr
        except Exception:
            g.es('putUaHelper: unexpected pickling exception',color='red')
            g.es_exception()
            return ''
    except pickle.PicklingError:
        # New in 4.2 beta 1: keep going after error.
        g.es("ignoring non-pickleable attribute %s in %s" % (
            key,torv),color="blue")
        return ''
#@-node:ekr.20050418161620.2:putUaHelper
#@-node:EKR.20040526202501:putUnknownAttributes & helper
#@+node:ekr.20031218072017.1579:putVnodes & helpers
def putVnodes (self):

    """Puts all <v> elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("<vnodes>\n")

    # Make only one copy for all calls.
    self.currentPosition = c.currentPosition() 
    self.rootPosition    = c.rootPosition()
    self.topPosition     = c.topPosition()

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings_iter():
            # New in Leo 4.4.2 b2 An optimization:
            self.putVnode(p,isIgnore=p.isAtIgnoreNode()) # Write the next top-level node.

    self.put("</vnodes>\n")
#@nonl
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)
    << Set gnx = tnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append tnodeList and unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s><vh>%s</vh>' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        << issue informational messages >>
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('</v>\n')
    else:
        fc.put('%s</v>\n' % v_head) # Call put only once.
#@nonl
#@+node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
# New in Leo 4.4.3
if not v.t.fileIndex:
    g.trace('*** missing t.fileIndex','v',repr(v))
    # c.dumpOutline() # Can be called inside pdb.
    if 1:
        # Print the @chapters tree
        c.chapterController.printChaptersTree()
    v.t.fileIndex = g.app.nodeIndices.getNewIndex()

gnx = g.app.nodeIndices.toString(v.t.fileIndex)
if forceWrite or self.usingClipboard:
    v.t.setWriteBit() # 4.2: Indicate we wrote the body text.

# old code.
# if v.t.fileIndex:
    # gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    # if forceWrite or self.usingClipboard:
        # v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
# else:
    # g.trace(v.t.fileIndex,v)
    # g.es("error writing file(bad v.t.fileIndex)!")
    # g.es("try using the Save To command")
#@-node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
#@+node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
if v.isExpanded(): attr += "E"
if v.isMarked():   attr += "M"
if v.isOrphan():   attr += "O"

# No longer a bottleneck now that we use p.equal rather than p.__cmp__
# Almost 30% of the entire writing time came from here!!!
if not self.use_sax:
    if p.equal(self.topPosition):     attr += "T" # was a bottleneck
    if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr:
    attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if self.use_sax and p.equal(self.rootPosition):
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    d['str_leo_pos'] = ','.join(aList)
    # g.trace(aList,d)
    v.unknownAttributes = d
#@nonl
#@-node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
#@+node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

# Debugging.
# if v.isAnyAtFileNode():
    # if hasattr(v.t,"tnodeList"):
        # g.trace(v.headString(),len(v.t.tnodeList))
    # else:
        # g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))
#@nonl
#@-node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
#@+node:ekr.20040702085529:<< issue informational messages >>
if isOrphan and isThin:
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

# For testing.
# if p.isAtIgnoreNode():
     # for p2 in p.self_and_subtree_iter():
            # if p2.isAtThinFileNode():
                # g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@-node:ekr.20040702085529:<< issue informational messages >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.2002:putTnodeList (4.0,4.2)
def putTnodeList (self,v):

    """Put the tnodeList attribute of a tnode."""

    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!
    nodeIndices = g.app.nodeIndices
    tnodeList = v.t.tnodeList
    if tnodeList:
        # g.trace("%4d" % len(tnodeList),v)
        for t in tnodeList:
            try: # Will fail for None or any pre 4.1 file index.
                theId,time,n = t.fileIndex
            except:
                g.trace("assigning gnx for ",v,t)
                gnx = nodeIndices.getNewIndex()
                v.t.setFileIndex(gnx) # Don't convert to string until the actual write.
        s = ','.join([nodeIndices.toString(t.fileIndex) for t in tnodeList])
        return ' tnodeList="%s"' % (s)
    else:
        return ''
#@nonl
#@-node:ekr.20031218072017.2002:putTnodeList (4.0,4.2)
#@+node:ekr.20040701065235.2:putDescendentAttributes
def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create a list of all tnodes whose vnodes are marked or expanded
    if 1: # New in Leo 4.4.2 b2.
        # Put each tnode in the list only once.
        # This should have been done long ago.
        marks = [] ; expanded = []
        for p in p.subtree_iter():
            t = p.v.t
            if p.isMarked() and p.v.t not in marks:
                marks.append(t)
            if p.hasChildren() and p.isExpanded() and t not in expanded:
                expanded.append(t)

        result = []
        for theList,tag in ((marks,"marks"),(expanded,"expanded")):
            if theList:
                sList = []
                for t in theList:
                    gnx = t.fileIndex
                    sList.append("%s," % nodeIndices.toString(gnx))
                s = string.join(sList,'')
                # g.trace(tag,[str(p.headString()) for p in theList])
                result.append('\n%s="%s"' % (tag,s))
    else:
        marks = [] ; expanded = []
        for p in p.subtree_iter():
            if p.isMarked() and not p in marks:
                marks.append(p.copy())
            if p.hasChildren() and p.isExpanded() and not p in expanded:
                expanded.append(p.copy())

        result = []
        for theList,tag in ((marks,"marks"),(expanded,"expanded")):
            if theList:
                sList = []
                for p in theList:
                    gnx = p.v.t.fileIndex
                    sList.append("%s," % nodeIndices.toString(gnx))
                s = string.join(sList,'')
                # g.trace(tag,[str(p.headString()) for p in theList])
                result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
#@nonl
#@-node:ekr.20040701065235.2:putDescendentAttributes
#@+node:EKR.20040627113418:putDescendentUnknownAttributes
def putDescendentUnknownAttributes (self,p):

    # pychecker complains about dumps.

    # The bin param doesn't exist in Python 2.3;
    # the protocol param doesn't exist in earlier versions of Python.
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    python23 = g.CheckVersion(version,'2.3')

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = []
    tnodesData = []
    for p2 in p.subtree_iter():
        t = p2.v.t
        if hasattr(t,"unknownAttributes"):
            if t not in tnodes :
                # g.trace(p2.headString(),t)
                tnodes.append(t) # Bug fix: 10/4/06.
                tnodesData.append((p2,t),)

    # Create a list of pairs (t,d) where d contains only pickleable entries.
    data = []
    for p,t in tnodesData:
        if type(t.unknownAttributes) != type({}):
             g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
        else:
            # Create a new dict containing only entries that can be pickled.
            d = dict(t.unknownAttributes) # Copy the dict.

            for key in d.keys():
                try:
                    # We don't actually save the pickled values here.
                    if python23:
                        pickle.dumps(d[key],protocol=1) # Requires Python 2.3
                    else:
                        pickle.dumps(d[key],bin=True) # Requires earlier versions of Python.
                except pickle.PicklingError:
                    del d[key]
                    g.es("ignoring bad unknownAttributes key %s in %s" % (
                        key,p),color="blue")
                except Exception:
                    del d[key]
                    g.es('putDescendentUnknownAttributes: unexpected pickling exception',color='red')
                    g.es_exception()
            data.append((t,d),)

    # Create resultDict, an enclosing dict to hold all the data.
    resultDict = {}
    nodeIndices = g.app.nodeIndices
    for t,d in data:
        gnx = nodeIndices.toString(t.fileIndex)
        resultDict[gnx]=d

    if 0:
        print "resultDict..."
        for key in resultDict:
            print repr(key),repr(resultDict.get(key))

    # Pickle and hexlify resultDict.
    if resultDict:
        try:
            tag = "descendentTnodeUnknownAttributes"
            if python23:
                s = pickle.dumps(resultDict,protocol=1) # Requires Python 2.3
                # g.trace('protocol=1')
            else:
                s = pickle.dumps(resultDict,bin=True) # Requires Earlier version of Python.
                # g.trace('bin=True')
            field = ' %s="%s"' % (tag,binascii.hexlify(s))
            return field
        except pickle.PicklingError:
            g.trace("putDescendentUnknownAttributes can't happen 1",color="red")
        except Exception:
            g.es("putDescendentUnknownAttributes can't happen 2",color='red')
            g.es_exception()
    return ''
#@-node:EKR.20040627113418:putDescendentUnknownAttributes
#@-node:ekr.20031218072017.1579:putVnodes & helpers
#@-node:ekr.20040324080819.1:putLeoFile & helpers
#@+node:ekr.20031218072017.1573:putLeoOutline (to clipboard) & helper
# Writes a Leo outline to s in a format suitable for pasting to the clipboard.

def putLeoOutline (self):

    self.outputFile = g.fileLikeObject()
    self.usingClipboard = True
    self.assignFileIndices() # 6/11/03: Must do this for 3.x code.
    self.putProlog()
    self.putClipboardHeader()
    self.putVnodes()
    self.putTnodes()
    self.putPostlog()
    s = self.outputFile.getvalue()
    self.outputFile = None
    self.usingClipboard = False
    return s
#@+node:ekr.20031218072017.1971:putClipboardHeader
def putClipboardHeader (self):

    c = self.c ; tnodes = 0
    << count the number of tnodes >>
    self.put('<leo_header file_format="1" tnodes=')
    self.put_in_dquotes(str(tnodes))
    self.put(" max_tnode_index=")
    self.put_in_dquotes(str(tnodes))
    self.put("/>") ; self.put_nl()

    # New in Leo 4.4.3: Add dummy elements so copied nodes form a valid .leo file.
    self.put('<globals/>\n')
    self.put('<preferences/>\n')
    self.put('<find_panel_settings/>\n')
#@+node:ekr.20031218072017.1972:<< count the number of tnodes >>
c.clearAllVisited()

for p in c.currentPosition().self_and_subtree_iter():
    t = p.v.t
    if t and not t.isWriteBit():
        t.setWriteBit()
        tnodes += 1
#@-node:ekr.20031218072017.1972:<< count the number of tnodes >>
#@-node:ekr.20031218072017.1971:putClipboardHeader
#@-node:ekr.20031218072017.1573:putLeoOutline (to clipboard) & helper
#@+node:ekr.20060919064401:putToOPML
# All elements and attributes prefixed by ':' are leo-specific.
# All other elements and attributes are specified by the OPML 1 spec.

def putToOPML (self):

    '''Should be overridden by the opml plugin.'''

    return None
#@nonl
#@-node:ekr.20060919064401:putToOPML
#@+node:ekr.20031218072017.3045:setDefaultDirectoryForNewFiles
def setDefaultDirectoryForNewFiles (self,fileName):

    """Set c.openDirectory for new files for the benefit of leoAtFile.scanAllDirectives."""

    c = self.c

    if not c.openDirectory or len(c.openDirectory) == 0:
        theDir = g.os_path_dirname(fileName)

        if len(theDir) > 0 and g.os_path_isabs(theDir) and g.os_path_exists(theDir):
            c.openDirectory = theDir
#@-node:ekr.20031218072017.3045:setDefaultDirectoryForNewFiles
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False,toOPML=False):

    c = self.c
    self.putCount = 0
    self.toString = toString
    self.assignFileIndices()
    theActualFile = None
    toZip = False
    if not outlineOnlyFlag or toOPML:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        << write all @file nodes >>
    << return if the .leo file is read-only >>
    try:
        << create backup file >>
        self.mFileName = fileName
        if toOPML:
            << ensure that filename ends with .opml >>
        self.outputFile = cStringIO.StringIO()
        << create theActualFile >>
        # t1 = time.clock()
        if toOPML:
            self.putToOPML()
        else:
            self.putLeoFile()
        # t2 = time.clock()
        s = self.outputFile.getvalue()
        # g.trace(self.leo_file_encoding)
        if toZip:
            self.writeZipFile(s)
        elif toString:
            # For support of chapters plugin.
            g.app.write_Leo_file_string = s
        else:
            theActualFile.write(s)
            theActualFile.close()
            << delete backup file >>
            # t3 = time.clock()
            # g.es_print('len %d, putCount %d' % (len(s),self.putCount)) # 'put',t2-t1,'write&close',t3-t2)
        self.outputFile = None
        self.toString = False
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=True)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        if backupName:
            << delete fileName >>
            << rename backupName to fileName >>
        self.toString = False
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
backupName = None

# rename fileName to fileName.bak if fileName exists.
if not toString and g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(c,fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
#@nonl
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20060919070145:<< ensure that filename ends with .opml >>
if not self.mFileName.endswith('opml'):
    self.mFileName = self.mFileName + '.opml'
fileName = self.mFileName
#@nonl
#@-node:ekr.20060919070145:<< ensure that filename ends with .opml >>
#@+node:ekr.20060929103258:<< create theActualFile >>
if toString:
    theActualFile = None
elif c.isZipped:
    self.toString = toString = True
    theActualFile = None
    toZip = True
else:
    theActualFile = open(fileName, 'wb')
#@-node:ekr.20060929103258:<< create theActualFile >>
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@+node:ekr.20050405103712:<< delete fileName >>
if fileName and g.os_path_exists(fileName):

    self.deleteFileWithMessage(fileName,'')
#@-node:ekr.20050405103712:<< delete fileName >>
#@+node:ekr.20050405103712.1:<< rename backupName to fileName >>
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(c,backupName,fileName)
#@-node:ekr.20050405103712.1:<< rename backupName to fileName >>
#@+node:ekr.20070412095520:writeZipFile
def writeZipFile (self,s):

    # The name of the file in the archive.
    contentsName = g.toEncodedString(
        g.shortFileName(self.mFileName),
        self.leo_file_encoding,reportErrors=True)

    # The name of the archive itself.
    fileName = g.toEncodedString(
        self.mFileName,
        self.leo_file_encoding,reportErrors=True)

    # Write the archive.
    theFile = zipfile.ZipFile(fileName,'w',zipfile.ZIP_DEFLATED)
    theFile.writestr(contentsName,s)
    theFile.close()
#@-node:ekr.20070412095520:writeZipFile
#@-node:ekr.20031218072017.3046:write_Leo_file
#@+node:ekr.20031218072017.2012:writeAtFileNodes
def writeAtFileNodes (self,event=None):

    '''Write all @file nodes in the selected outline.'''

    c = self.c

    self.assignFileIndices()
    changedFiles = c.atFileCommands.writeAll(writeAtFileNodesFlag=True)
    assert(changedFiles != None)
    if changedFiles:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to set or clear tnodeList.
#@-node:ekr.20031218072017.2012:writeAtFileNodes
#@+node:ekr.20031218072017.1666:writeDirtyAtFileNodes
def writeDirtyAtFileNodes (self,event=None):

    '''Write all changed @file Nodes.'''

    c = self.c

    self.assignFileIndices() # 4/3/04
    changedFiles = c.atFileCommands.writeAll(writeDirtyAtFileNodesFlag=True)
    if changedFiles:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to set or clear tnodeList.
#@-node:ekr.20031218072017.1666:writeDirtyAtFileNodes
#@+node:ekr.20031218072017.2013:writeMissingAtFileNodes
def writeMissingAtFileNodes (self,event=None):

    '''Write all missing @file nodes.'''

    c = self.c ; v = c.currentVnode()

    if v:
        at = c.atFileCommands
        self.assignFileIndices() # 4/3/04
        changedFiles = at.writeMissing(v)
        assert(changedFiles != None)
        if changedFiles:
            g.es("auto-saving outline",color="blue")
            c.save() # Must be done to set or clear tnodeList.
#@-node:ekr.20031218072017.2013:writeMissingAtFileNodes
#@+node:ekr.20031218072017.3050:writeOutlineOnly
def writeOutlineOnly (self,event=None):

    '''Write the entire outline without writing any derived files.'''

    c = self.c
    c.endEditing()
    self.write_Leo_file(self.mFileName,True) # outlineOnlyFlag
#@-node:ekr.20031218072017.3050:writeOutlineOnly
#@-node:ekr.20031218072017.3032:Writing
#@-node:ekr.20031218072017.3018:@thin leoFileCommands.py
#@+node:ekr.20031218072017.3093:@thin leoGlobals.py
@first # -*- coding: utf-8 -*-

"""Global constants, variables and utility functions used throughout Leo."""

@language python
@tabwidth -4
@pagewidth 80

### from __future__ import generators # To make the code work in Python 2.2.

__pychecker__ = '--no-import --no-reimportself --no-reimport\
     --no-constCond --no-constant1'
    # Disable all import warnings: This module must do strange things with imports. 
    # Disable checks for constant conditionals.

<< imports >>
<< define general constants >>
<< define global data structures >>

app = None # The singleton app object.

@others
#@+node:ekr.20050208101229:<< imports >>
import leoGlobals as g # So code can use g below.

if 0: # Don't import this here: it messes up Leo's startup code.
    import leoTest
try:
    import gc
except ImportError:
    gc = None

if 0: # Do NOT import pdb here!  We shall define pdb as a _function_ below.
    import pdb

import exceptions
import operator
import re
import sys
import time
import zipfile

# These do not exist in IronPython.
# However, it *is* valid for IronPython to use the Python 2.4 libs!
import difflib
import filecmp
import gettext
import os
import shutil
import string
import tempfile
import traceback
import types

# print '(types.FrameType)',repr(types.FrameType)
# print '(types.StringTypes)',repr(types.StringTypes)
#@-node:ekr.20050208101229:<< imports >>
#@+node:ekr.20031218072017.3094:<< define general constants >>
body_newline = '\n'
body_ignored_newline = '\r'
#@-node:ekr.20031218072017.3094:<< define general constants >>
#@+node:EKR.20040610094819:<< define global data structures >>
# Visible externally so plugins may add to the list of directives.

globalDirectiveList = [
    "color", "comment", "encoding", "header", "ignore", "killcolor",
    "language", "lineending", "nocolor", "noheader", "nowrap",
    "pagewidth", "path", "quiet", "root", "silent",
    "tabwidth", "terse", "unit", "verbose", "wrap"]
#@-node:EKR.20040610094819:<< define global data structures >>
#@+node:ekr.20050328133058:g.createStandAloneTkApp
# This must be defined in leoGlobals: g.app.gui doesn't exist yet.

def createStandAloneTkApp(pluginName=''):

    '''Create a Tk version of the g.app object for 'stand-alone' plugins.'''

    if not g.app:
        # Important: these references do not make Leo's core gui-dependent.
        # In other words, this function is called only when Tkinter should be the gui.
        import Tkinter as Tk
        Pmw = g.importExtension('Pmw',pluginName=pluginName,verbose=True)
        if Tk and Pmw:
            import leoApp, leoGui
            g.app = leoApp.LeoApp()
            g.app.root = Tk.Tk()
            Pmw.initialise(g.app.root)
            g.app.gui = leoGui.nullGui('<stand-alone app gui>')
            g.computeStandardDirectories()
    return g.app
#@-node:ekr.20050328133058:g.createStandAloneTkApp
#@+node:ekr.20031218072017.3095:Checking Leo Files...
#@+node:ekr.20031218072017.822:createTopologyList
def createTopologyList (c,root=None,useHeadlines=False):

    """Creates a list describing a node and all its descendents"""

    if not root: root = c.rootPosition()
    v = root
    if useHeadlines:
        aList = [(v.numberOfChildren(),v.headString()),]
    else:
        aList = [v.numberOfChildren()]
    child = v.firstChild()
    while child:
        aList.append(g.createTopologyList(c,child,useHeadlines))
        child = child.next()
    return aList
#@-node:ekr.20031218072017.822:createTopologyList
#@-node:ekr.20031218072017.3095:Checking Leo Files...
#@+node:ekr.20031218072017.3099:Commands & Directives
#@+node:ekr.20050304072744:Compute directories... (leoGlobals)
#@+node:ekr.20041117155521:computeGlobalConfigDir
def computeGlobalConfigDir():

    # Suppresses warning about sys.leo_config_directory
    #__pychecker__ = '--limit = 0'
    #__pychecker__ = '--no-classattr --no-objattrs'

    import leoGlobals as g

    encoding = g.startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")

    if theDir:
        theDir = g.os_path_abspath(theDir)

    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None

    return theDir
#@-node:ekr.20041117155521:computeGlobalConfigDir
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():

    """Returns the user's home directory."""

    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
#@-node:ekr.20041117151301:computeHomeDir
#@+node:ekr.20060416113431:computeLeoDir
def computeLeoDir ():

    loadDir = g.app.loadDir

    g.app.leoDir = theDir = g.os_path_dirname(loadDir)

    if theDir not in sys.path:
        sys.path.append(theDir)

    if 0: # This is required so we can do import leo (as a package)
        theParentDir = g.os_path_dirname(theDir)
        if theParentDir not in sys.path:
            sys.path.append(theParentDir)
#@-node:ekr.20060416113431:computeLeoDir
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():

    """Returns the directory containing leo.py."""

    import leoGlobals as g
    import sys

    try:
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__ # was leo.__file__
        if sys.platform=='win32':
            if len(path) > 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        encoding = g.startupEncoding()
        path = g.os_path_abspath(path,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None

        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        raise
        #import traceback ; traceback.print_exc()
        #return None
#@-node:ekr.20031218072017.1937:computeLoadDir
#@+node:ekr.20050328133444:computeStandardDirectories
def computeStandardDirectories():

    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''

    if 0:
        import sys
        for s in sys.path: g.trace(s)

    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.

    g.app.leoDir = g.computeLeoDir()

    g.app.homeDir = g.computeHomeDir()

    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))

    g.app.globalConfigDir = g.computeGlobalConfigDir()

    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))

    g.app.user_xresources_path = g.os_path_join(g.app.homeDir,'.leo_xresources')
#@-node:ekr.20050328133444:computeStandardDirectories
#@+node:ekr.20041117151301.1:startupEncoding
def startupEncoding ():

    import leoGlobals as g
    import sys

    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding

    return encoding
#@-node:ekr.20041117151301.1:startupEncoding
#@-node:ekr.20050304072744:Compute directories... (leoGlobals)
#@+node:ekr.20031218072017.1380:Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:

        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1382:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    # g.trace(g.callers())

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:set_delims_from_language
#@+node:ekr.20031218072017.1383:set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.

    This code can be called from @language logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)

    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1

    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
#@-node:ekr.20031218072017.1383:set_delims_from_string
#@+node:ekr.20031218072017.1384:set_language
def set_language(s,i,issue_errors_flag=False):

    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3

    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,
#@-node:ekr.20031218072017.1384:set_language
#@-node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1385:g.findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(c,name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return c.nullPosition()
#@-node:ekr.20031218072017.1385:g.findReference
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):

    """Scans root for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set theDict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set theDict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return theDict
#@+node:ekr.20031218072017.1261:<< set theDict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]

global globalDirectiveList

if word in globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
#@-node:ekr.20031218072017.1261:<< set theDict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@-node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (c=None,name=None):

    '''Convert the name of a line ending to the line ending itself.

    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''

    # g.trace(c,name,c.config.output_newline)
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:ekr.20031218072017.1387:scanAtEncodingDirective
def scanAtEncodingDirective(s,theDict):

    """Scan the @encoding directive at s[theDict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = theDict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None
#@-node:ekr.20031218072017.1387:scanAtEncodingDirective
#@+node:ekr.20031218072017.1388:scanAtLineendingDirective
def scanAtLineendingDirective(s,theDict):

    """Scan the @lineending directive at s[theDict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = theDict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(name=e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None
#@-node:ekr.20031218072017.1388:scanAtLineendingDirective
#@+node:ekr.20031218072017.1389:scanAtPagewidthDirective
def scanAtPagewidthDirective(s,theDict,issue_error_flag=False):

    """Scan the @pagewidth directive at s[theDict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """

    k = theDict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val > 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
#@-node:ekr.20031218072017.1389:scanAtPagewidthDirective
#@+node:ekr.20031218072017.1390:scanAtTabwidthDirective
def scanAtTabwidthDirective(s,theDict,issue_error_flag=False):

    """Scan the @tabwidth directive at s[theDict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """

    k = theDict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None
#@-node:ekr.20031218072017.1390:scanAtTabwidthDirective
#@+node:ekr.20070302160802:scanColorDirectives (new in Leo 4.4.3)
def scanColorDirectives(c,p):

    '''Return the language in effect at position p.'''

    if c is None: return # c may be None for testing.

    language = c.target_language and c.target_language.lower() or 'python'
    p = p.copy()
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        d = g.get_directives_dict(s)
        i = d.get('language')
        if i is not None:
            language,junk,junk,junk = g.set_language(s,i)
            break

    return language
#@-node:ekr.20070302160802:scanColorDirectives (new in Leo 4.4.3)
#@+node:ekr.20040715155607:scanForAtIgnore
def scanForAtIgnore(c,p):

    """Scan position p and its ancestors looking for @ignore directives."""

    if g.app.unitTesting:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False
#@-node:ekr.20040715155607:scanForAtIgnore
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):

    """Scan position p and its ancestors looking for @settings nodes."""

    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@-node:ekr.20041123094807:g.scanForAtSettings
#@+node:ekr.20040712084911.1:scanForAtLanguage
def scanForAtLanguage(c,p):

    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""

    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language
#@-node:ekr.20040712084911.1:scanForAtLanguage
#@+node:ekr.20031218072017.1391:g.scanDirectives
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):

    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
if c.target_language:
    c.target_language = c.target_language.lower()
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):

    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c) # returns "" on error.
        path = g.os_path_join(base,path)
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):

    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:g.scanDirectives
#@-node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.3100:wrap_lines
@ Important note: this routine need not deal with leading whitespace.  Instead, the caller should simply reduce pageWidth by the width of leading whitespace wanted, then add that whitespace to the lines returned here.

The key to this code is the invarient that line never ends in whitespace.
@c

def wrap_lines (lines,pageWidth,firstLineWidth=None):

    """Returns a list of lines, consisting of the input lines wrapped to the given pageWidth."""

    if pageWidth < 10:
        pageWidth = 10

    # First line is special
    if not firstLineWidth:
        firstLineWidth = pageWidth
    if firstLineWidth < 10:
        firstLineWidth = 10
    outputLineWidth = firstLineWidth

    # g.trace(lines)
    result = [] # The lines of the result.
    line = "" # The line being formed.  It never ends in whitespace.
    for s in lines:
        i = 0
        while i < len(s):
            assert(len(line) <= outputLineWidth) # DTHEIN 18-JAN-2004
            j = g.skip_ws(s,i)   # ;   ws = s[i:j]
            k = g.skip_non_ws(s,j) ; word = s[j:k]
            assert(k>i)
            i = k
            # DTHEIN 18-JAN-2004: wrap at exactly the text width, 
            # not one character less
            # 
            wordLen = len(word)
            if len(line) > 0 and wordLen > 0: wordLen += len(" ")
            if wordLen + len(line) <= outputLineWidth:
                if wordLen > 0:
                    << place blank and word on the present line >>
                else: pass # discard the trailing whitespace.
            else:
                << place word on a new line >>
    if len(line) > 0:
        result.append(line)
    # g.trace(result)
    return result
#@+node:ekr.20031218072017.3101:<< place blank and word on the present line >>
if len(line) == 0:
    # Just add the word to the start of the line.
    line = word
else:
    # Add the word, preceeded by a blank.
    line = " ".join([line,word]) # DTHEIN 18-JAN-2004: better syntax
#@-node:ekr.20031218072017.3101:<< place blank and word on the present line >>
#@+node:ekr.20031218072017.3102:<< place word on a new line >>
# End the previous line.
if len(line) > 0:
    result.append(line)
    outputLineWidth = pageWidth # DTHEIN 3-NOV-2002: width for remaining lines

# Discard the whitespace and put the word on a new line.
line = word

# Careful: the word may be longer than pageWidth.
if len(line) > pageWidth: # DTHEIN 18-JAN-2004: line can equal pagewidth
    result.append(line)
    outputLineWidth = pageWidth # DTHEIN 3-NOV-2002: width for remaining lines
    line = ""
#@-node:ekr.20031218072017.3102:<< place word on a new line >>
#@-node:ekr.20031218072017.3100:wrap_lines
#@-node:ekr.20031218072017.3099:Commands & Directives
#@+node:ekr.20031218072017.3104:Debugging, Dumping, Timing, Tracing & Sherlock
#@+node:ekr.20031218072017.3105:alert
def alert(message):

    g.es(message)

    import tkMessageBox
    tkMessageBox.showwarning("Alert", message)
#@-node:ekr.20031218072017.3105:alert
#@+node:ekr.20051023083258:callers
def callers (n=8,excludeCaller=True,files=False):

    '''Return a list containing the callers of the function that called g.callerList.

    By default, the function that called g.callerList is not on the list,
    which is what is wanted when using g.trace.'''

    result = [] ; first = True
    while n > 0:
        s = g._callerName(n,files=files)
        if s.endswith('callers'):
            if excludeCaller and result:
                del result [-1]
            break
        elif s:
            if first and files:
                first = False ; s = '\n' + s
            result.append(s)
        n -= 1

    sep = g.choose(files,'\n',',')
    return sep.join(result)
#@-node:ekr.20051023083258:callers
#@+node:ekr.20031218072017.3107:_callerName
def _callerName (n=1,files=False):

    try: # get the function name from the call stack.
        f1 = sys._getframe(n) # The stack frame, n levels up.
        code1 = f1.f_code # The code object
        if files:
            return '%s:%s' % (g.shortFilename(code1.co_filename),code1.co_name)
        else:
            return code1.co_name # The code name
    except ValueError:
        return '' # The stack is not deep enough.
    except:
        g.es_exception()
        return '' # "<no caller name>"
#@-node:ekr.20031218072017.3107:_callerName
#@+node:ekr.20041105091148:g.pdb & test
def pdb ():

    """Fall into pdb."""

    import pdb # Required: we have just defined pdb as a function!

    pdb.set_trace()
#@+node:ekr.20050221092824:test_g_pdb
def test_g_pdb():

    import sys

    # Not a good unit test; it probably will never fail.
    def aFunction(): pass
    assert type(g.pdb)==type(aFunction), 'wrong type for g.pdb: %s' % type(g.pdb)

    class myStdout:
        def write(self,s):
            pass # g.es('From pdb:',s)

    class myStdin:
        def readline (self):
            return 'c' # Return 'c' (continue) for all requests for input.

    def restore():
        sys.stdout,sys.stdin = sys.__stdout__,sys.__stdin__

    try:
        sys.stdin = myStdin() # Essential
        sys.stdout=myStdout() # Optional
        g.pdb()
        restore()
        # assert False,'test of reraising'
    except Exception:
        restore()
        raise
#@-node:ekr.20050221092824:test_g_pdb
#@-node:ekr.20041105091148:g.pdb & test
#@+node:ekr.20031218072017.3108:Dumps
#@+node:ekr.20031218072017.3109:dump
def dump(s):

    out = ""
    for i in s:
        out += str(ord(i)) + ","
    return out

def oldDump(s):

    out = ""
    for i in s:
        if i=='\n':
            out += "[" ; out += "n" ; out += "]"
        if i=='\t':
            out += "[" ; out += "t" ; out += "]"
        elif i==' ':
            out += "[" ; out += " " ; out += "]"
        else: out += i
    return out
#@-node:ekr.20031218072017.3109:dump
#@+node:ekr.20060917120951:es_dump
def es_dump (s,n = 30,title=None):

    if title:
        g.es_print(title)

    i = 0
    while i < len(s):
        g.es_print(''.join(['%2x ' % (ord(ch)) for ch in s[i:i+n]]))
        i += n
#@nonl
#@-node:ekr.20060917120951:es_dump
#@+node:ekr.20031218072017.3110:es_error
def es_error (s,color=None):

    if color is None and g.app.config: # May not exist during initialization.
        color = g.app.config.getColor(None,"log_error_color")

    g.es(s,color=color)
#@-node:ekr.20031218072017.3110:es_error
#@+node:ekr.20031218072017.3111:es_event_exception
def es_event_exception (eventName,full=False):

    g.es("exception handling ", eventName, " event")
    typ,val,tb = sys.exc_info()

    if full:
        errList = traceback.format_exception(typ,val,tb)
    else:
        errList = traceback.format_exception_only(typ,val)

    for i in errList:
        g.es(i)

    if not g.stdErrIsRedirected(): # 2/16/04
        traceback.print_exc()
#@-node:ekr.20031218072017.3111:es_event_exception
#@+node:ekr.20031218072017.3112:es_exception & test
def es_exception (full=True,c=None,color="red"):

    __pychecker__ = '--no-argsused' # c not used. retained for compatibility.

    typ,val,tb = sys.exc_info()

    # g.trace(full,typ,tb)

    fileName,n = g.getLastTracebackFileAndLineNumber()

    if full or g.app.debugSwitch > 0:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        if 0: # We might as well print the entire SyntaxError message.
            lines = lines[-1:] # Usually only one line, but more for Syntax errors!

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    if g.app.debugSwitch > 1:
        import pdb # Be careful: g.pdb may or may not have been defined.
        pdb.set_trace()

    return fileName,n
#@+node:ekr.20050220030850:test_g_es_exception
def test_g_es_exception():

    if c.config.redirect_execute_script_output_to_log_pane:
        return # Test doesn't work when redirection is on.

    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) > -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) > -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__
#@-node:ekr.20050220030850:test_g_es_exception
#@-node:ekr.20031218072017.3112:es_exception & test
#@+node:ekr.20061015090538:es_exception_type
def es_exception_type (c=None,color="red"):

    # exctype is a Exception class object; value is the error message.
    exctype, value = sys.exc_info()[:2]

    g.es_print('%s, %s' % (exctype.__name__, value),color=color)
#@-node:ekr.20061015090538:es_exception_type
#@+node:ekr.20040731204831:getLastTracebackFileAndLineNumber
def getLastTracebackFileAndLineNumber():

    typ,val,tb = sys.exc_info()

    if typ in (exceptions.SyntaxError,exceptions.IndentationError):
        # Syntax and indentation errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code is similar to the code in format_exception_only(!!)
        try:
            # g.es_print(repr(val))
            msg,(filename, lineno, offset, line) = val
            return filename,lineno
        except:
            g.trace("bad line number")
            return None,0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        if data:
            # g.es_print(repr(data))
            item = data[-1]
            filename = item[0]
            n = item[1]
            return filename,n
        else:
            return None,0
#@-node:ekr.20040731204831:getLastTracebackFileAndLineNumber
#@+node:ekr.20031218072017.3113:printBindings
def print_bindings (name,window):

    bindings = window.bind()
    print
    print "Bindings for", name
    for b in bindings:
        print b
#@-node:ekr.20031218072017.3113:printBindings
#@+node:ekr.20031218072017.3114:printGlobals
def printGlobals(message=None):

    # Get the list of globals.
    globs = list(globals())
    globs.sort()

    # Print the list.
    if message:
        leader = "-" * 10
        print leader, ' ', message, ' ', leader
    for glob in globs:
        print glob
#@-node:ekr.20031218072017.3114:printGlobals
#@+node:ekr.20070510074941:g.printEntireTree
def printEntireTree(c,tag=''):

    print 'printEntireTree','=' * 50
    print 'printEntireTree',tag,'root',c.rootPosition()
    for p in c.allNodes_iter():
        print '..'*p.level(),p.v
#@nonl
#@-node:ekr.20070510074941:g.printEntireTree
#@+node:ekr.20031218072017.3115:printLeoModules
def printLeoModules(message=None):

    # Create the list.
    mods = []
    for name in sys.modules.keys():
        if name and name[0:3] == "leo":
            mods.append(name)

    # Print the list.
    if message:
        leader = "-" * 10
        print leader, ' ', message, ' ', leader
    mods.sort()
    for m in mods:
        print m,
    print
#@-node:ekr.20031218072017.3115:printLeoModules
#@-node:ekr.20031218072017.3108:Dumps
#@+node:ekr.20031218072017.1317:file/module/plugin_date
def module_date (mod,format=None):
    theFile = g.os_path_join(app.loadDir,mod.__file__)
    root,ext = g.os_path_splitext(theFile) 
    return g.file_date(root + ".py",format=format)

def plugin_date (plugin_mod,format=None):
    theFile = g.os_path_join(app.loadDir,"..","plugins",plugin_mod.__file__)
    root,ext = g.os_path_splitext(theFile) 
    return g.file_date(root + ".py",format=format)

def file_date (theFile,format=None):
    if theFile and len(theFile)and g.os_path_exists(theFile):
        try:
            n = g.os_path_getmtime(theFile)
            if format == None:
                format = "%m/%d/%y %H:%M:%S"
            return time.strftime(format,time.gmtime(n))
        except (ImportError,NameError):
            pass # Time module is platform dependent.
    return ""
#@-node:ekr.20031218072017.1317:file/module/plugin_date
#@+node:ekr.20031218072017.3121:redirecting stderr and stdout to Leo's log pane
class redirectClass:

    """A class to redirect stdout and stderr to Leo's log pane."""

    << redirectClass methods >>

# Create two redirection objects, one for each stream.
redirectStdErrObj = redirectClass()
redirectStdOutObj = redirectClass()

<< define convenience methods for redirecting streams >>

if 0: # Test code: may be executed in the child node.
    << test code >>
#@+node:ekr.20031218072017.1656:<< redirectClass methods >>
@others
#@+node:ekr.20041012082437:redirectClass.__init__
def __init__ (self):

    self.old = None
#@-node:ekr.20041012082437:redirectClass.__init__
#@+node:ekr.20041012082437.1:isRedirected
def isRedirected (self):

    return self.old != None
#@-node:ekr.20041012082437.1:isRedirected
#@+node:ekr.20041012082437.2:flush
# For LeoN: just for compatibility.

def flush(self, *args):
    return
#@-node:ekr.20041012082437.2:flush
#@+node:ekr.20041012091252:rawPrint
def rawPrint (self,s):

    if self.old:
        self.old.write(s+'\n')
    else:
        print s
#@-node:ekr.20041012091252:rawPrint
#@+node:ekr.20041012082437.3:redirect
def redirect (self,stdout=1):

    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return

    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self
#@-node:ekr.20041012082437.3:redirect
#@+node:ekr.20041012082437.4:undirect
def undirect (self,stdout=1):

    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None
#@-node:ekr.20041012082437.4:undirect
#@+node:ekr.20041012082437.5:write
def write(self,s):

    if self.old:
        if app.log:
            app.log.put(s)
        else:
            self.old.write(s+'\n')
    else:
        # Can happen when g.batchMode is True.
        print s
#@-node:ekr.20041012082437.5:write
#@-node:ekr.20031218072017.1656:<< redirectClass methods >>
#@+node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
@others
#@+node:ekr.20041012090942:redirectStderr & redirectStdout
# Redirect streams to the current log window.
def redirectStderr():
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout():
    global redirectStdOutObj
    redirectStdOutObj.redirect()
#@-node:ekr.20041012090942:redirectStderr & redirectStdout
#@+node:ekr.20041012090942.1:restoreStderr & restoreStdout
# Restore standard streams.
def restoreStderr():
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)

def restoreStdout():
    global redirectStdOutObj
    redirectStdOutObj.undirect()
#@-node:ekr.20041012090942.1:restoreStderr & restoreStdout
#@+node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
def stdErrIsRedirected():
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()

def stdOutIsRedirected():
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()
#@-node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
#@+node:ekr.20041012090942.3:rawPrint
# Send output to original stdout.

def rawPrint(s):

    global redirectStdOutObj

    redirectStdOutObj.rawPrint(s)
#@-node:ekr.20041012090942.3:rawPrint
#@-node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
#@+node:ekr.20031218072017.3123:<< test code >>
import leoGlobals as g ; import sys
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stderr
import leoGlobals as g ; import sys
g.redirectStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.restoreStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stdout
import leoGlobals as g ; import sys
g.restoreStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.redirectStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()
#@-node:ekr.20031218072017.3123:<< test code >>
#@-node:ekr.20031218072017.3121:redirecting stderr and stdout to Leo's log pane
#@+node:ekr.20031218072017.3127:g.get_line & get_line__after
# Very useful for tracing.

def get_line (s,i):

    nl = ""
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
        nl = "[nl]"
    j = g.find_line_start(s,i)
    k = g.skip_to_end_of_line(s,i)
    return nl + s[j:k]

getLine = get_line

def get_line_after (s,i):

    nl = ""
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
        nl = "[nl]"
    k = g.skip_to_end_of_line(s,i)
    return nl + s[i:k]

getLineAfter = get_line_after
#@nonl
#@-node:ekr.20031218072017.3127:g.get_line & get_line__after
#@+node:ekr.20031218072017.3128:pause
def pause (s):

    print s

    i = 0
    while i < 1000000L:
        i += 1
#@-node:ekr.20031218072017.3128:pause
#@+node:ekr.20050819064157:print_obj & toString
def print_obj (obj,tag=None,sort=False,verbose=True,indent=''):

    if type(obj) in (type(()),type([])):
        g.print_list(obj,tag,sort,indent)
    elif type(obj) == type({}):
        g.print_dict(obj,tag,verbose,indent)
    else:
        print '%s%s' % (indent,repr(obj).strip())

def toString (obj,tag=None,sort=False,verbose=True,indent=''):

    if type(obj) in (type(()),type([])):
        return g.listToString(obj,tag,sort,indent)
    elif type(obj) == type({}):
        return g.dictToString(obj,tag,verbose,indent)
    else:
        return '%s%s' % (indent,repr(obj).strip())
#@-node:ekr.20050819064157:print_obj & toString
#@+node:ekr.20041224080039:print_dict & dictToString
def print_dict(d,tag='',verbose=True,indent=''):

    __pychecker__ = '--no-argsused'
        # verbose unused, but present for compatibility with similar methods.

    if not d:
        if tag: print '%s...{}' % tag
        else:   print '{}'
        return

    keys = d.keys() ; keys.sort()
    n = 6
    for key in keys:
        if type(key) == type(''):
            n = max(n,len(key))
    if tag: print '%s...{\n' % tag
    else:   print '{\n'
    for key in keys:
        print "%s%*s: %s" % (indent,n,key,repr(d.get(key)).strip())
    print '}'

printDict = print_dict

def dictToString(d,tag=None,verbose=True,indent=''):

    __pychecker__ = '--no-argsused'
        # verbose unused, but present for compatibility with similar methods.

    if not d:
        if tag: return '%s...{}' % tag
        else:   return '{}'
    keys = d.keys() ; keys.sort()
    n = 6
    for key in keys:
        if type(key) in (type(''),type(u'')):
            n = max(n,len(key))
    lines = ["%s%*s: %s" % (indent,n,key,repr(d.get(key)).strip()) for key in keys]
    s = '\n'.join(lines)
    if tag:
        return '%s...{\n%s}\n' % (tag,s)
    else:
        return '{\n%s}\n' % s
#@-node:ekr.20041224080039:print_dict & dictToString
#@+node:ekr.20041126060136:print_list & listToString
def print_list(aList,tag=None,sort=False,indent=''):

    if not aList:
        if tag: print '%s...[]' % tag
        else:   print '[]'
        return
    if sort:
        bList = aList[:] # Sort a copy!
        bList.sort()
    else:
        bList = aList
    if tag: print '%s...[' % tag
    else:   print '['
    for e in bList:
        print '%s%s' % (indent,repr(e).strip())
    print ']'

printList = print_list

def listToString(aList,tag=None,sort=False,indent=''):

    if not aList:
        if tag: return '%s...{}' % tag
        else:   return '[]'
    if sort:
        bList = aList[:] # Sort a copy!
        bList.sort()
    else:
        bList = aList
    lines = ["%s%s" % (indent,repr(e).strip()) for e in bList]
    s = '\n'.join(lines)
    if tag:
        return '[%s...\n%s\n]' % (tag,s)
    else:
        return '[%s]' % s
#@-node:ekr.20041126060136:print_list & listToString
#@+node:ekr.20041122153823:print_stack (printStack)
def print_stack():

    traceback.print_stack()

printStack = print_stack
#@-node:ekr.20041122153823:print_stack (printStack)
#@+node:ekr.20031218072017.3129:Sherlock... (trace)
@ Starting with this release, you will see trace statements throughout the code.  The trace function is defined in leoGlobals.py; trace implements much of the functionality of my Sherlock tracing package.  Traces are more convenient than print statements for two reasons: 1) you don't need explicit trace names and 2) you can disable them without recompiling.

In the following examples, suppose that the call to trace appears in function f.

g.trace(string) prints string if tracing for f has been enabled.  For example, the following statment prints from s[i] to the end of the line if tracing for f has been enabled.

  j = g.skip_line(s,i) ; g.trace(s[i:j])

g.trace(function) exectutes the function if tracing for f has been enabled.  For example,

  g.trace(self.f2)

You enable and disable tracing by calling g.init_trace(args).  Examples:

  g.init_trace("+*")         # enable all traces
  g.init_trace("+a","+b")    # enable traces for a and b
  g.init_trace(("+a","+b"))  # enable traces for a and b
  g.init_trace("-a")         # disable tracing for a
  traces = g.init_trace("?") # return the list of enabled traces

If two arguments are supplied to trace, the first argument is the "tracepoint name" and the second argument is the "tracepoint action" as shown in the examples above.  If tracing for the tracepoint name is enabled, the tracepoint action is printed (if it is a string) or exectuted (if it is a function name).

"*" will not match an explicit tracepoint name that starts with a minus sign.  For example,

  g.trace_tag("-nocolor", self.disable_color)
#@+node:ekr.20031218072017.3130:init_sherlock
# Called by startup code.
# Args are all the arguments on the command line.

def init_sherlock (args):

    g.init_trace(args,echo=0)
    # g.trace("sys.argv:",sys.argv)
#@-node:ekr.20031218072017.3130:init_sherlock
#@+node:ekr.20031218072017.3131:get_Sherlock_args
@ It no args are given we attempt to get them from the "SherlockArgs" file.  If there are still no arguments we trace everything.  This default makes tracing much more useful in Python.
@c

def get_Sherlock_args (args):

    if not args or len(args)==0:
        try:
            fn = g.os_path_join(app.loadDir,"SherlockArgs")
            f = open(fn)
            args = f.readlines()
            f.close()
        except: pass
    elif type(args[0]) == type(("1","2")):
        args = args[0] # strip away the outer tuple.

    # No args means trace everything.
    if not args or len(args)==0: args = ["+*"] 
    # print "get_Sherlock_args:", args
    return args
#@-node:ekr.20031218072017.3131:get_Sherlock_args
#@+node:ekr.20031218072017.3132:init_trace
def init_trace(args,echo=1):

    t = app.trace_list
    args = g.get_Sherlock_args(args)

    for arg in args:
        if arg[0] in string.ascii_letters: prefix = '+'
        else: prefix = arg[0] ; arg = arg[1:]

        if prefix == '?':
            print "trace list:", t
        elif prefix == '+' and not arg in t:
            t.append(string.lower(arg))
            if echo:
                print "enabling:", arg
        elif prefix == '-' and arg in t:
            t.remove(string.lower(arg))
            if echo:
                print "disabling:", arg
        else:
            print "ignoring:", prefix + arg
#@-node:ekr.20031218072017.3132:init_trace
#@+node:ekr.20031218072017.2317:trace
# Convert all args to strings.

def trace (*args,**keys):

    callers = keys.get("callers",False)
    newline = keys.get("newline",True)
    align =   keys.get("align",0)

    s = ""
    for arg in args:
        if type(arg) == type(u""):
            pass
            # try:    arg = str(arg) 
            # except: arg = repr(arg)
        elif type(arg) != type(""):
            arg = repr(arg)
        if len(s) > 0:
            s = s + " " + arg
        else:
            s = arg
    message = s
    try: # get the function name from the call stack.
        f1 = sys._getframe(1) # The stack frame, one level up.
        code1 = f1.f_code # The code object
        name = code1.co_name # The code name
    except: name = ""
    if name == "?":
        name = "<unknown>"

    if callers:
        traceback.print_stack()

    if align != 0 and len(name) < abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align > 0: name = name + pad
        else:         name = pad + name

    if newline:
        print name + ": " + message
    else:
        print name + ": " + message,
#@nonl
#@-node:ekr.20031218072017.2317:trace
#@+node:ekr.20031218072017.2318:trace_tag
# Convert all args to strings.
# Print if tracing for name has been enabled.

def trace_tag (name, *args):

    s = ""
    for arg in args:
        if type(arg) != type(""):
            arg = repr(arg)
        if len(s) > 0:
            s = s + ", " + arg
        else:
            s = arg
    message = s

    t = app.trace_list
    # tracepoint names starting with '-' must match exactly.
    minus = len(name) > 0 and name[0] == '-'
    if minus: name = name[1:]
    if (not minus and '*' in t) or name.lower() in t:
        s = name + ": " + message
        print s # Traces _always_ get printed.
#@-node:ekr.20031218072017.2318:trace_tag
#@-node:ekr.20031218072017.3129:Sherlock... (trace)
#@+node:ekr.20031218072017.3133:Statistics
#@+node:ekr.20031218072017.3134:clear_stats
def clear_stats():

    g.trace()

    g.app.statsDict = {}

clearStats = clear_stats
#@-node:ekr.20031218072017.3134:clear_stats
#@+node:ekr.20031218072017.3135:print_stats
def print_stats (name=None):

    if name:
        if type(name) != type(""):
            name = repr(name)
    else:
        name = g._callerName(n=2) # Get caller name 2 levels back.

    g.printDict(g.app.statsDict,tag='statistics at %s' % name)

printStats = print_stats
#@-node:ekr.20031218072017.3135:print_stats
#@+node:ekr.20031218072017.3136:stat
def stat (name=None):

    """Increments the statistic for name in g.app.statsDict
    The caller's name is used by default.
    """

    d = g.app.statsDict

    if name:
        if type(name) != type(""):
            name = repr(name)
    else:
        name = g._callerName(n=2) # Get caller name 2 levels back.

    # g.trace(name)

    d [name] = 1 + d.get(name,0)
#@-node:ekr.20031218072017.3136:stat
#@-node:ekr.20031218072017.3133:Statistics
#@+node:ekr.20031218072017.3137:Timing
# pychecker bug: pychecker complains that there is no attribute time.clock

def getTime():
    return time.clock()

def esDiffTime(message, start):
    g.es("%s %6.3f" % (message,(time.clock()-start)))
    return time.clock()

def printDiffTime(message, start):
    print "%s %6.3f" % (message,(time.clock()-start))
    return time.clock()
#@-node:ekr.20031218072017.3137:Timing
#@-node:ekr.20031218072017.3104:Debugging, Dumping, Timing, Tracing & Sherlock
#@+node:ekr.20031218072017.3116:Files & Directories...
#@+node:ekr.20031218072017.3117:g.create_temp_file & test
def create_temp_file (textMode=False):
    '''Return a tuple (theFile,theFileName)

    theFile: a file object open for writing.
    theFileName: the name of the temporary file.'''

    # mktemp is deprecated, but we can't get rid of it
    # because mkstemp does not exist in Python 2.2.1.
    __pychecker__ = '--no-deprecate'
    try:
        # fd is an handle to an open file as would be returned by os.open()
        fd,theFileName = tempfile.mkstemp(text=textMode)
        mode = g.choose(textMode,'w','wb')
        theFile = os.fdopen(fd,mode)
        # g.trace(fd,theFile)
    except AttributeError:
        # g.trace("mkstemp doesn't exist")
        theFileName = tempfile.mktemp()
        try:
            mode = g.choose(textMode,'w','wb')
            theFile = file(theFileName,mode)
        except IOError:
            theFile,theFileName = None,''
    except Exception:
        g.es('Unexpected exception in g.create_temp_file',color='red')
        g.es_exception()
        theFile,theFileName = None,''

    return theFile,theFileName
#@+node:ekr.20050216052031:test_g_create_temp_file
def test_g_create_temp_file():

    __pychecker__ = '--no-reimport'
    import types

    theFile,theFileName = g.create_temp_file()

    assert type(theFile) == types.FileType, 'not file type'
    assert type(theFileName) in (types.StringType, types.UnicodeType), 'not string type'
#@-node:ekr.20050216052031:test_g_create_temp_file
#@-node:ekr.20031218072017.3117:g.create_temp_file & test
#@+node:ekr.20031218072017.3118:g.ensure_extension
def ensure_extension (name, ext):

    theFile, old_ext = g.os_path_splitext(name)
    if not name:
        return name # don't add to an empty name.
    elif old_ext and old_ext == ext:
        return name
    else:
        return name + ext
#@-node:ekr.20031218072017.3118:g.ensure_extension
#@+node:ekr.20031218072017.1264:g.getBaseDirectory
# Handles the conventions applying to the "relative_path_base_directory" configuration option.

def getBaseDirectory(c):

    base = app.config.relative_path_base_directory

    if base and base == "!":
        base = app.loadDir
    elif base and base == ".":
        base = c.openDirectory

    # g.trace(base)
    if base and len(base) > 0 and g.os_path_isabs(base):
        # Set c.chdir_to_relative_path as needed.
        if not hasattr(c,'chdir_to_relative_path'):
            c.chdir_to_relative_path = c.config.getBool('chdir_to_relative_path')
        # Call os.chdir if requested.
        if c.chdir_to_relative_path:
            os.chdir(base)
        return base # base need not exist yet.
    else:
        return "" # No relative base given.
#@-node:ekr.20031218072017.1264:g.getBaseDirectory
#@+node:EKR.20040504154039:g.is_sentinel
def is_sentinel (line,delims):

    << is_sentinel doc tests >>

    delim1,delim2,delim3 = delims

    line = line.lstrip()

    if delim1:
        return line.startswith(delim1+'@')
    elif delim2 and delim3:
        i = line.find(delim2+'@')
        j = line.find(delim3)
        return 0 == i < j
    else:
        print repr(delims)
        g.es("Can't happen: is_sentinel",color="red")
        return False
#@+node:ekr.20040719161756:<< is_sentinel doc tests >>
"""

Return True if line starts with a sentinel comment.

>>> py_delims = comment_delims_from_extension('.py')
>>> is_sentinel("#@+node",py_delims)
True
>>> is_sentinel("#comment",py_delims)
False

>>> c_delims = comment_delims_from_extension('.c')
>>> is_sentinel("//@+node",c_delims)
True
>>> is_sentinel("//comment",c_delims)
False

>>> html_delims = comment_delims_from_extension('.html')
>>> is_sentinel("<!--@+node-->",html_delims)
True
>>> is_sentinel("<!--comment-->",html_delims)
False

"""
#@-node:ekr.20040719161756:<< is_sentinel doc tests >>
#@-node:EKR.20040504154039:g.is_sentinel
#@+node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
# This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories)

    if c:
        if not c.config.create_nonexistent_directories:
            return None
    elif not app.config.create_nonexistent_directories:
        return None

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) > 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                g.es("created directory: "+path)
            except:
                g.es("exception creating directory: "+path)
                g.es_exception()
                return None
    return dir1 # All have been created.
#@-node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(fileName)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        k and k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20070412082527:g.openLeoOrZipFile
def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            theFile = file(fileName,'rb')
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        g.es("can not open: %s" % (fileName),color="blue")
        return None,False
#@nonl
#@-node:ekr.20070412082527:g.openLeoOrZipFile
#@+node:ekr.20031218072017.3120:g.readlineForceUnixNewline (Steven P. Schaefer)
@ Stephen P. Schaefer 9/7/2002

The Unix readline() routine delivers "\r\n" line end strings verbatim, while the windows versions force the string to use the Unix convention of using only "\n".  This routine causes the Unix readline to do the same.
@c

def readlineForceUnixNewline(f):

    s = f.readline()
    if len(s) >= 2 and s[-2] == "\r" and s[-1] == "\n":
        s = s[0:-2] + "\n"
    return s
#@-node:ekr.20031218072017.3120:g.readlineForceUnixNewline (Steven P. Schaefer)
#@+node:ekr.20031218072017.3124:g.sanitize_filename
def sanitize_filename(s):

    """Prepares string s to be a valid file name:

    - substitute '_' whitespace and characters used special path characters.
    - eliminate all other non-alphabetic characters.
    - strip leading and trailing whitespace.
    - return at most 128 characters."""

    result = ""
    for ch in s.strip():
        if ch in string.ascii_letters:
            result += ch
        elif ch in string.whitespace: # Translate whitespace.
            result += '_'
        elif ch in ('.','\\','/',':'): # Translate special path characters.
            result += '_'
    while 1:
        n = len(result)
        result = result.replace('__','_')
        if len(result) == n:
            break
    result = result.strip()
    return result [:128]
#@-node:ekr.20031218072017.3124:g.sanitize_filename
#@+node:ekr.20060328150113:g.setGlobalOpenDir
def setGlobalOpenDir (fileName):

    if fileName:
        g.app.globalOpenDir = g.os_path_dirname(fileName)
        # g.es('current directory: %s' %  g.app.globalOpenDir)
#@-node:ekr.20060328150113:g.setGlobalOpenDir
#@+node:ekr.20031218072017.3125:g.shortFileName & shortFilename
def shortFileName (fileName):

    return g.os_path_basename(fileName)

shortFilename = shortFileName
#@-node:ekr.20031218072017.3125:g.shortFileName & shortFilename
#@+node:ekr.20050104135720:Used by tangle code & leoFileCommands
#@+node:ekr.20031218072017.1241:g.update_file_if_changed
# This is part of the tangle code.

def update_file_if_changed(c,file_name,temp_name):

    """Compares two files.

    If they are different, we replace file_name with temp_name.
    Otherwise, we just delete temp_name. Both files should be closed."""

    if g.os_path_exists(file_name):
        if filecmp.cmp(temp_name, file_name):
            kind = 'unchanged'
            ok = g.utils_remove(temp_name)
        else:
            kind = '***updating'
            mode = g.utils_stat(file_name)
            ok = g.utils_rename(c,temp_name,file_name,mode)
    else:
        kind = 'creating'
        ok = g.utils_rename(c,temp_name,file_name)

    if ok:
        g.es('%12s: %s' % (kind,file_name))
    else:
        g.es("rename failed: no file created!",color="red")
        g.es(file_name," may be read-only or in use")
#@-node:ekr.20031218072017.1241:g.update_file_if_changed
#@+node:ekr.20050104123726.3:g.utils_remove & test
def utils_remove (fileName,verbose=True):

    try:
        os.remove(fileName)
        return True
    except:
        if verbose:
            g.es("exception removing:" + fileName)
            g.es_exception()
        return False
#@+node:ekr.20050107084901:test_g_utils_remove
def test_g_utils_remove():

    __pychecker__ = '--no-reimport'

    import os
    exists = g.os_path_exists

    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)

    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)

    f = file(path,'w')
    f.write('test')
    f.close()

    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)
#@-node:ekr.20050107084901:test_g_utils_remove
#@-node:ekr.20050104123726.3:g.utils_remove & test
#@+node:ekr.20031218072017.1263:g.utils_rename & test
<< about os.rename >>

def utils_rename (c,src,dst,mode=None,verbose=True):

    '''Platform independent rename.'''

    head, tail = g.os_path_split(dst)
    if head and len(head) > 0:
        g.makeAllNonExistentDirectories(head,c=c)

    if g.os_path_exists(dst):
        if not g.utils_remove(dst):
            return False
    try:
        # New in Leo 4.4b1: try using shutil first.
        try:
            import shutil # shutil is new in Python 2.3
            shutil.move(src,dst)
        except ImportError:
            if sys.platform == "win32":
                os.rename(src,dst)
            else:
                try:
                    # Alas, distutils.file_util may not exist.
                    from distutils.file_util import move_file
                    move_file(src,dst)
                except ImportError:
                    # Desperation: may give: 'Invalid cross-device link'
                    os.rename(src,dst)
        if mode:
            g.utils_chmod(dst,mode,verbose)
        return True
    except Exception:
        if verbose:
            g.es('Exception renaming %s to %s' % (src,dst),color='red')
            g.es_exception(full=False)
        return False
#@+node:ekr.20050104123726.1:<< about os.rename >>
@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
#@-node:ekr.20050104123726.1:<< about os.rename >>
#@+node:ekr.20050107085710.1:test_g_utils_rename
def test_g_utils_rename():

    __pychecker__ = '--no-reimport'

    import os
    exists = g.os_path_exists

    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)

    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)

    f = file(path,'w')
    f.write('test')
    f.close()

    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)
#@-node:ekr.20050107085710.1:test_g_utils_rename
#@-node:ekr.20031218072017.1263:g.utils_rename & test
#@+node:ekr.20050104124903:g.utils_chmod
def utils_chmod (fileName,mode,verbose=True):

    if mode is None:
        return

    try:
        os.chmod(fileName,mode)
    except:
        if verbose:
            g.es("exception in os.chmod(%s)" % (fileName))
            g.es_exception()
#@-node:ekr.20050104124903:g.utils_chmod
#@+node:ekr.20050104123726.4:g.utils_stat
def utils_stat (fileName):

    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''

    try:
        mode = (os.stat(fileName))[0] & 0777
    except:
        mode = None

    return mode
#@-node:ekr.20050104123726.4:g.utils_stat
#@-node:ekr.20050104135720:Used by tangle code & leoFileCommands
#@-node:ekr.20031218072017.3116:Files & Directories...
#@+node:ekr.20031218072017.1588:Garbage Collection
# debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

@others
#@+node:ekr.20031218072017.1589:clearAllIvars
def clearAllIvars (o):

    """Clear all ivars of o, a member of some class."""

    if o:
        o.__dict__.clear()
#@-node:ekr.20031218072017.1589:clearAllIvars
#@+node:ekr.20031218072017.1590:collectGarbage
def collectGarbage():

    try:
        if not g.app.trace_gc_inited:
            g.enable_gc_debug()

        if g.app.trace_gc_verbose or g.app.trace_gc_calls:
            # print('Collecting garbage',g.callers())
            print 'collectGarbage:'

        gc.collect()
    except Exception:
        pass

    # Only init once, regardless of what happens.
    g.app.trace_gc_inited = True
#@-node:ekr.20031218072017.1590:collectGarbage
#@+node:ekr.20060127162818:enable_gc_debug
no_gc_message = False

def enable_gc_debug(event=None):

    if gc:
        if g.app.trace_gc_verbose:
            gc.set_debug(
                gc.DEBUG_STATS | # prints statistics.
                gc.DEBUG_LEAK | # Same as all below.
                gc.DEBUG_COLLECTABLE |
                gc.DEBUG_UNCOLLECTABLE |
                gc.DEBUG_INSTANCES |
                gc.DEBUG_OBJECTS |
                gc.DEBUG_SAVEALL
            )
        # else:
            # gc.set_debug(gc.DEBUG_STATS)
    elif not g.no_gc_message:
        g.no_gc_message = True
        g.es('Can not import gc module',color='blue')
#@-node:ekr.20060127162818:enable_gc_debug
#@+node:ekr.20031218072017.1592:printGc
# Formerly called from unit tests.

def printGc(tag=None):

    if not g.app.trace_gc: return None

    tag = tag or g._callerName(n=2)

    printGcObjects(tag=tag)
    printGcRefs(tag=tag)

    if g.app.trace_gc_verbose:
        printGcVerbose(tag=tag)
#@+node:ekr.20031218072017.1593:printGcRefs
def printGcRefs (tag=''):

    refs = gc.get_referrers(app.windowList[0])
    print('-' * 30,tag)

    if g.app.trace_gc_verbose:
        print("refs of", app.windowList[0])
        for ref in refs:
            print(type(ref))
    else:
        print("%d referers" % len(refs))
#@-node:ekr.20031218072017.1593:printGcRefs
#@-node:ekr.20031218072017.1592:printGc
#@+node:ekr.20060202161935:printGcAll
def printGcAll (tag=''):

    # Suppress warning about keywords arg not supported in sort.

    tag = tag or g._callerName(n=2)
    d = {} ; objects = gc.get_objects()
    print('-' * 30)
    print('%s: %d objects' % (tag,len(objects)))

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except: pass
        # if type(obj) == type(()):
            # print id(obj),repr(obj)
        d[t] = d.get(t,0) + 1

    if 1: # Sort by n
        items = d.items()
        try:
            # Support for keword args to sort function exists in Python 2.4.
            # Support for None as an alternative to omitting cmp exists in Python 2.3.
            items.sort(key=lambda x: x[1],reverse=True)
        except: pass
        for z in items:
            print '%40s %7d' % (z[0],z[1])
    else: # Sort by type
        keys = d.keys() ; keys.sort()
        for t in keys:
            print '%40s %7d' % (t,d.get(t))
#@-node:ekr.20060202161935:printGcAll
#@+node:ekr.20060127164729.1:printGcObjects   (printNewObjects=pno)
def printGcObjects(tag=''):

    '''Print newly allocated objects.'''

    tag = tag or g._callerName(n=2)
    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount
        if delta == 0: return
        lastObjectCount = n2

        << print number of each type of object >>
        if 0:
            << print added functions >>

    except Exception:
        traceback.print_exc()

printNewObjects = pno = printGcObjects

#@+node:ekr.20040703054646:<< print number of each type of object >>
global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    t = type(obj)
    if t == 'instance' and t not in types.StringTypes:
        try: t = obj.__class__
        except: pass
    if t != types.FrameType:
        r = repr(t) # was type(obj) instead of repr(t)
        n = typesDict.get(r,0) 
        typesDict[r] = n + 1

# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

empty = True
for key in keys:
    n3 = lastTypesDict.get(key,0)
    n4 = typesDict.get(key,0)
    delta2 = n4-n3
    if delta2 != 0:
        empty = False
        break

if not empty:
    # keys = [repr(key) for key in keys]
    keys.sort()
    print '-' * 30
    print "%s: garbage: %d, objects: %d, delta: %d" % (tag,n,n2,delta)

    if 0:
        for key in keys:
            n1 = lastTypesDict.get(key,0)
            n2 = typesDict.get(key,0)
            delta2 = n2-n1
            if delta2 != 0:
                print("%+6d =%7d %s" % (delta2,n2,key))

lastTypesDict = typesDict
typesDict = {}
#@-node:ekr.20040703054646:<< print number of each type of object >>
#@+node:ekr.20040703065638:<< print added functions >>
# import types
import inspect

global lastFunctionsDict

funcDict = {}

# Don't print more than 50 objects.
n = 0
for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        n += 1

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if n < 50 and not lastFunctionsDict.has_key(key):
            print(obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            print("args", args)
            if varargs: print("varargs",varargs)
            if varkw: print("varkw",varkw)
            if defaults:
                print("defaults...")
                for s in defaults: print(s)

lastFunctionsDict = funcDict
funcDict = {}
#@-node:ekr.20040703065638:<< print added functions >>
#@-node:ekr.20060127164729.1:printGcObjects   (printNewObjects=pno)
#@+node:ekr.20060205043324.1:printGcSummary
def printGcSummary (tag=''):

    tag = tag or g._callerName(n=2)

    g.enable_gc_debug()

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = '%s: printGCSummary: garbage: %d, objects: %d' % (tag,n,n2)
        print s
    except:
        traceback.print_exc()
#@-node:ekr.20060205043324.1:printGcSummary
#@+node:ekr.20060127165509:printGcVerbose
# WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(tag=''):

    tag = tag or g._callerName(n=2)
    global lastObjectsDict
    objects = gc.get_objects()
    newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]

    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o

    dicts = 0 ; seqs = 0

    i = 0 ; n = len(newObjects)
    while i < 100 and i < n:
        o = newObjects[i]
        if type(o) == type({}): dicts += 1
        elif type(o) in (type(()),type([])):
            #print id(o),repr(o)
            seqs += 1
        #else:
        #    print(o)
        i += 1
    print('=' * 40)
    print('dicts: %d, sequences: %d' % (dicts,seqs))
    print("%s: %d new, %d total objects" % (tag,len(newObjects),len(objects)))
    print('-' * 40)
#@-node:ekr.20060127165509:printGcVerbose
#@-node:ekr.20031218072017.1588:Garbage Collection
#@+node:ekr.20031218072017.3139:Hooks & plugins (leoGlobals)
#@+node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:EKR.20040602125018:enableIdleTimeHook
@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler

    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
#@-node:EKR.20040602125018:enableIdleTimeHook
#@+node:EKR.20040602125018.1:disableIdleTimeHook
# Disables the "idle" hook.
def disableIdleTimeHook():

    g.app.idleTimeHook = False
#@-node:EKR.20040602125018.1:disableIdleTimeHook
#@+node:EKR.20040602125018.2:idleTimeHookHandler
# An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):

    __pychecker__ = '--no-argsused' # args & keys not used.

    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for z in g.app.windowList:
                c = z.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return

    for z in g.app.windowList:
        c = z.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
#@-node:EKR.20040602125018.2:idleTimeHookHandler
#@-node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:ekr.20031218072017.1596:g.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. c.hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):

    if g.app.killed or g.app.hookError: # or (g.app.gui and g.app.gui.isNullGui):
        return None

    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag in ('open0','start1'):
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            g.es_print(s,color="blue")
        return None

    # Get the hook handler function.  Usually this is doPlugins.
    c = keywords.get("c")
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins

    try:
        # Pass the hook to the hook handler.
        # print 'doHook',f.__name__,keywords.get('c')
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
#@-node:ekr.20031218072017.1596:g.doHook
#@+node:ekr.20031218072017.1318:g.plugin_signon
def plugin_signon(module_name,verbose=False):

    # The things we do to keep pychecker happy... 
    m = g.Bunch(__name__='',__version__='')

    exec("import %s ; m = %s" % (module_name,module_name))

    # print 'plugin_signon',module_name # ,'gui',g.app.gui

    if verbose:
        g.es("...%s.py v%s: %s" % (
            m.__name__, m.__version__, g.plugin_date(m)))

        print m.__name__, m.__version__

    app.loadedPlugins.append(module_name)
#@-node:ekr.20031218072017.1318:g.plugin_signon
#@-node:ekr.20031218072017.3139:Hooks & plugins (leoGlobals)
#@+node:ekr.20031218072017.3145:Most common functions...
# These are guaranteed always to exist for scripts.
#@+node:ekr.20031218072017.3146:app & leoProxy (no longer used)
if 0: # No longer needed with the new import scheme.

    class leoProxy:

        """A proxy for the gApp object that can be created before gApp itself.

        After gApp is created, both app.x and app().x refer to gApp.x."""

        def __getattr__(self,attr):
            return getattr(gApp,attr)

        def __setattr__(self,attr,val):
            setattr(gApp,attr,val)

        def __call__(self):
            return gApp

    # The code can use app.x and app().x to refer to ivars of the leoApp class.
    app = leoProxy()
#@-node:ekr.20031218072017.3146:app & leoProxy (no longer used)
#@+node:ekr.20031218072017.3147:choose
def choose(cond, a, b): # warning: evaluates all arguments

    if cond: return a
    else: return b
#@-node:ekr.20031218072017.3147:choose
#@+node:ekr.20031218072017.1474:es, enl, ecnl
def ecnl(tabName='Log'):
    g.ecnls(1,tabName)

def ecnls(n,tabName='Log'):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl(tabName)

def enl(tabName='Log'):
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl(tabName)

def es(s,*args,**keys):
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get('color')
    tabName = keys.get('tabName','Log')
        # Default goes to log pane *Not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and log.isNull:
            pass
        elif log:
            # print 'g.es',s
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@-node:ekr.20031218072017.1474:es, enl, ecnl
#@+node:ekr.20050707064040:es_print & test
def es_print(s,*args,**keys):

    print g.toEncodedString(s,'ascii')

    if g.app.gui and not g.app.gui.isNullGui:
        g.es(s,*args,**keys)

def test_g_es_print():

    g.es_print('\ntest of es_print: Ă',color='red')
#@-node:ekr.20050707064040:es_print & test
#@+node:ekr.20050707065530:es_trace & test
def es_trace(s,*args,**keys):

    g.trace(g.toEncodedString(s,'ascii'))
    g.es(s,*args,**keys)

def test_g_es_trace():

    g.es_trace('\ntest of es_trace: Ă',color='red')
#@-node:ekr.20050707065530:es_trace & test
#@+node:ekr.20060810095921:et, et_* and _ (underscore)
__pychecker__ = 'no-reuseattr'

if 1: # Do nothing
    et = es
    et_print = es_print
    es_trace = es_trace
    def _(s): return s
else: # Use the gettext module to translate arguments.
    def et (s):
        es(_(s))

    def et_trace(s):
        es_trace(_(s))

    def et_trace(s):
        es_trace(_(s))

    def _ (s):
        '''Return the translated text of s.'''
        return gettext.gettext(s)

__pychecker__ = 'reuseattr'
#@nonl
#@-node:ekr.20060810095921:et, et_* and _ (underscore)
#@+node:ekr.20031218072017.3148:top
if 0: # An extremely dangerous function.

    def top():

        """Return the commander of the topmost window"""

        # Warning: may be called during startup or shutdown when nothing exists.
        try:
            return app.log.c
        except:
            return None
#@-node:ekr.20031218072017.3148:top
#@+node:ekr.20031218072017.3149:trace is defined below
#@-node:ekr.20031218072017.3149:trace is defined below
#@+node:ekr.20031218072017.3150:windows
def windows():
    return app.windowList
#@-node:ekr.20031218072017.3150:windows
#@-node:ekr.20031218072017.3145:Most common functions...
#@+node:ekr.20031218072017.2145:os.path wrappers (leoGlobals.py)
@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
#@+node:ekr.20031218072017.2146:os_path_abspath
def os_path_abspath(path,encoding=None):

    """Convert a path to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.abspath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2146:os_path_abspath
#@+node:ekr.20031218072017.2147:os_path_basename
def os_path_basename(path,encoding=None):

    """Return the second half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.basename(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2147:os_path_basename
#@+node:ekr.20031218072017.2148:os_path_dirname
def os_path_dirname(path,encoding=None):

    """Return the first half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.dirname(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2148:os_path_dirname
#@+node:ekr.20031218072017.2149:os_path_exists
def os_path_exists(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.exists(path)
#@-node:ekr.20031218072017.2149:os_path_exists
#@+node:ekr.20031218072017.2150:os_path_getmtime
def os_path_getmtime(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.getmtime(path)
#@-node:ekr.20031218072017.2150:os_path_getmtime
#@+node:ekr.20031218072017.2151:os_path_isabs
def os_path_isabs(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isabs(path)
#@-node:ekr.20031218072017.2151:os_path_isabs
#@+node:ekr.20031218072017.2152:os_path_isdir
def os_path_isdir(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isdir(path)
#@-node:ekr.20031218072017.2152:os_path_isdir
#@+node:ekr.20031218072017.2153:os_path_isfile
def os_path_isfile(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isfile(path)
#@-node:ekr.20031218072017.2153:os_path_isfile
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):

    encoding = keys.get("encoding")

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    path = os.path.join(*uargs)
    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path,encoding)
    return path
#@-node:ekr.20031218072017.2154:os_path_join
#@+node:ekr.20031218072017.2155:os_path_norm NOT USED
if 0:  # A bad idea.

    def os_path_norm(path,encoding=None):

        """Normalize both the path and the case."""

        path = g.toUnicodeFileEncoding(path,encoding)

        path = os.path.normcase(path)
        path = os.path.normpath(path)

        path = g.toUnicodeFileEncoding(path,encoding)

        return path
#@-node:ekr.20031218072017.2155:os_path_norm NOT USED
#@+node:ekr.20041115103456:os_path_normabs NOT USED
if 0: # A bad idea.

    def os_path_normabs (path,encoding=None):

        """Convert the file name to a fully normalized absolute path.

        There is no exact analog to this in os.path"""

        path = g.os_path_abspath(path,encoding = encoding)
        path = g.os_path_norm(path,encoding = encoding)

        return path
#@-node:ekr.20041115103456:os_path_normabs NOT USED
#@+node:ekr.20031218072017.2156:os_path_normcase
def os_path_normcase(path,encoding=None):

    """Normalize the path's case."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normcase(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2156:os_path_normcase
#@+node:ekr.20031218072017.2157:os_path_normpath
def os_path_normpath(path,encoding=None):

    """Normalize the path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normpath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2157:os_path_normpath
#@+node:ekr.20031218072017.2158:os_path_split
def os_path_split(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.split(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
#@-node:ekr.20031218072017.2158:os_path_split
#@+node:ekr.20031218072017.2159:os_path_splitext
def os_path_splitext(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.splitext(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
#@-node:ekr.20031218072017.2159:os_path_splitext
#@+node:ekr.20031218072017.2160:toUnicodeFileEncoding
def toUnicodeFileEncoding(path,encoding):

    if not encoding:
        if sys.platform == "win32":
            # encoding = "mbcs" # Leo 4.2 and previous.
            encoding = 'utf-8' # New in Leo 4.3
        else:
            encoding = app.tkEncoding

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path,encoding)
#@-node:ekr.20031218072017.2160:toUnicodeFileEncoding
#@-node:ekr.20031218072017.2145:os.path wrappers (leoGlobals.py)
#@+node:ekr.20031218072017.3151:Scanning... (leoGlobals.py)
#@+node:ekr.20031218072017.3152:g.scanAtFileOptions (used in 3.x read code)
def scanAtFileOptions (h,err_flag=False):

    assert(g.match(h,0,"@file"))
    i = len("@file")
    atFileType = "@file"
    optionsList = []

    while g.match(h,i,'-'):
        << scan another @file option >>

    # Convert atFileType to a list of options.
    for fileType,option in (
        ("@silentfile","asis"),
        ("@nosentinelsfile","nosent"),
        ("@rawfile","noref"),
        ("@thinfile","thin")
    ):
        if atFileType == fileType and option not in optionsList:
            optionsList.append(option)

    # g.trace(atFileType,optionsList)

    return i,atFileType,optionsList
#@+node:ekr.20031218072017.3153:<< scan another @file option >>
i += 1 ; err = -1

if g.match_word(h,i,"asis"):
    if atFileType == "@file":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("using -asis option in:" + h)
elif g.match(h,i,"noref"): # Just match the prefix.
    if atFileType == "@file":
        atFileType = "@rawfile"
    elif atFileType == "@nosentinelsfile":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("ignoring redundant -noref in:" + h)
elif g.match(h,i,"nosent"): # Just match the prefix.
    if atFileType == "@file":
        atFileType = "@nosentinelsfile"
    elif atFileType == "@rawfile":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("ignoring redundant -nosent in:" + h)
elif g.match_word(h,i,"thin"):
    if atFileType == "@file":
        atFileType = "@thinfile"
    elif err_flag:
        g.es("using -thin option in:" + h)
else:
    if 0: # doesn't work
        for option in ("fat","new","now","old","thin","wait"):
            if g.match_word(h,i,option):
                optionsList.append(option)
        if len(option) == 0:
            err = i-1
# Scan to the next minus sign.
while i < len(h) and h[i] not in (' ','\t','-'):
    i += 1
if err > -1:
    g.es("unknown option:" + h[err:i] + " in " + h)
#@-node:ekr.20031218072017.3153:<< scan another @file option >>
#@-node:ekr.20031218072017.3152:g.scanAtFileOptions (used in 3.x read code)
#@+node:ekr.20031218072017.3154:scanAtRootOptions
def scanAtRootOptions (s,i,err_flag=False):

    assert(g.match(s,i,"@root"))
    i += len("@root")
    mode = None 
    while g.match(s,i,'-'):
        << scan another @root option >>

    if mode == None:
        doc = app.config.at_root_bodies_start_in_doc_mode
        mode = g.choose(doc,"doc","code")
    return i,mode
#@+node:ekr.20031218072017.3155:<< scan another @root option >>
i += 1 ; err = -1

if g.match_word(s,i,"code"): # Just match the prefix.
    if not mode: mode = "code"
    elif err_flag: g.es("modes conflict in:" + g.get_line(s,i))
elif g.match(s,i,"doc"): # Just match the prefix.
    if not mode: mode = "doc"
    elif err_flag: g.es("modes conflict in:" + g.get_line(s,i))
else:
    err = i-1

# Scan to the next minus sign.
while i < len(s) and s[i] not in (' ','\t','-'):
    i += 1

if err > -1 and err_flag:
    g.es("unknown option:" + s[err:i] + " in " + g.get_line(s,i))
#@-node:ekr.20031218072017.3155:<< scan another @root option >>
#@-node:ekr.20031218072017.3154:scanAtRootOptions
#@+node:ekr.20031218072017.3156:scanError
# It is dubious to bump the Tangle error count here, but it really doesn't hurt.

def scanError(s):

    """Bump the error count in the tangle command."""

    # New in Leo 4.4b1: just set this global.
    g.app.scanErrors +=1
    g.es(s)
#@-node:ekr.20031218072017.3156:scanError
#@+node:ekr.20031218072017.3157:scanf
# A quick and dirty sscanf.  Understands only %s and %d.

def scanf (s,pat):
    count = pat.count("%s") + pat.count("%d")
    pat = pat.replace("%s","(\S+)")
    pat = pat.replace("%d","(\d+)")
    parts = re.split(pat,s)
    result = []
    for part in parts:
        if len(part) > 0 and len(result) < count:
            result.append(part)
    # g.trace("scanf returns:",result)
    return result

if 0: # testing
    g.scanf("1.0","%d.%d",)
#@-node:ekr.20031218072017.3157:scanf
#@+node:ekr.20031218072017.3158:Scanners: calling scanError
@ These scanners all call g.scanError() directly or indirectly, so they will call g.es() if they find an error.  g.scanError() also bumps c.tangleCommands.errors, which is harmless if we aren't tangling, and useful if we are.

These routines are called by the Import routines and the Tangle routines.
#@+node:ekr.20031218072017.3159:skip_block_comment
# Scans past a block comment (an old_style C comment).

def skip_block_comment (s,i):

    assert(g.match(s,i,"/*"))
    j = i ; i += 2 ; n = len(s)

    k = string.find(s,"*/",i)
    if k == -1:
        g.scanError("Run on block comment: " + s[j:i])
        return n
    else: return k + 2
#@-node:ekr.20031218072017.3159:skip_block_comment
#@+node:ekr.20031218072017.3160:skip_braces
@ This code is called only from the import logic, so we are allowed to try some tricks.  In particular, we assume all braces are matched in #if blocks.
@c

def skip_braces(s,i):

    """Skips from the opening to the matching brace.

    If no matching is found i is set to len(s)"""

    # start = g.get_line(s,i)
    assert(g.match(s,i,'{'))
    level = 0 ; n = len(s)
    while i < n:
        c = s[i]
        if c == '{':
            level += 1 ; i += 1
        elif c == '}':
            level -= 1
            if level <= 0: return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,'//'): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,'/*'): i = g.skip_block_comment(s,i)
        # 7/29/02: be more careful handling conditional code.
        elif g.match_word(s,i,"#if") or g.match_word(s,i,"#ifdef") or g.match_word(s,i,"#ifndef"):
            i,delta = g.skip_pp_if(s,i)
            level += delta
        else: i += 1
    return i
#@-node:ekr.20031218072017.3160:skip_braces
#@+node:ekr.20031218072017.3161:skip_php_braces (Dave Hein)
@ 08-SEP-2002 DTHEIN: Added for PHP import support
Skips from the opening to the matching . If no matching is found i is set to len(s).

This code is called only from the import logic, and only for PHP imports.
@c

def skip_php_braces(s,i):

    # start = g.get_line(s,i)
    assert(g.match(s,i,'{'))
    level = 0 ; n = len(s)
    while i < n:
        c = s[i]
        if c == '{':
            level += 1 ; i += 1
        elif c == '}':
            level -= 1
            if level <= 0: return i + 1
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,"<<<"): i = g.skip_heredoc_string(s,i)
        elif g.match(s,i,'//') or g.match(s,i,'#'): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,'/*'): i = g.skip_block_comment(s,i)
        else: i += 1
    return i
#@-node:ekr.20031218072017.3161:skip_php_braces (Dave Hein)
#@+node:ekr.20031218072017.3162:skip_parens
def skip_parens(s,i):

    """Skips from the opening ( to the matching ).

    If no matching is found i is set to len(s)"""

    level = 0 ; n = len(s)
    assert(g.match(s,i,'('))
    while i < n:
        c = s[i]
        if c == '(':
            level += 1 ; i += 1
        elif c == ')':
            level -= 1
            if level <= 0:  return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i
#@-node:ekr.20031218072017.3162:skip_parens
#@+node:ekr.20031218072017.3163:skip_pascal_begin_end
def skip_pascal_begin_end(s,i):

    """Skips from begin to matching end.
    If found, i points to the end. Otherwise, i >= len(s)
    The end keyword matches begin, case, class, record, and try."""

    assert(g.match_c_word(s,i,"begin"))
    level = 1 ; i = g.skip_c_id(s,i) # Skip the opening begin.
    while i < len(s):
        ch = s[i]
        if ch =='{' : i = g.skip_pascal_braces(s,i)
        elif ch =='"' or ch == '\'': i = g.skip_pascal_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.match_c_word(s,i,"end"):
            level -= 1 ;
            if level == 0:
                # lines = s[i1:i+3] ; g.trace('\n' + lines + '\n')
                return i
            else: i = g.skip_c_id(s,i)
        elif g.is_c_id(ch):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
            if name in ["begin", "case", "class", "record", "try"]:
                level += 1
        else: i += 1
    return i
#@-node:ekr.20031218072017.3163:skip_pascal_begin_end
#@+node:ekr.20031218072017.3164:skip_pascal_block_comment
# Scans past a pascal comment delimited by (* and *).

def skip_pascal_block_comment(s,i):

    j = i
    assert(g.match(s,i,"(*"))
    i = string.find(s,"*)",i)
    if i > -1: return i + 2
    else:
        g.scanError("Run on comment" + s[j:i])
        return len(s)

#   n = len(s)
#   while i < n:
#       if g.match(s,i,"*)"): return i + 2
#       i += 1
#   g.scanError("Run on comment" + s[j:i])
#   return i
#@-node:ekr.20031218072017.3164:skip_pascal_block_comment
#@+node:ekr.20031218072017.3165:skip_pascal_string : called by tangle
def skip_pascal_string(s,i):

    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')

    while i < len(s):
        if s[i] == delim:
            return i + 1
        else: i += 1

    g.scanError("Run on string: " + s[j:i])
    return i
#@-node:ekr.20031218072017.3165:skip_pascal_string : called by tangle
#@+node:ekr.20031218072017.3166:skip_heredoc_string : called by php import (Dave Hein)
@ 08-SEP-2002 DTHEIN:  added function skip_heredoc_string
A heredoc string in PHP looks like:

  <<<EOS
  This is my string.
  It is mine. I own it.
  No one else has it.
  EOS

It begins with <<< plus a token (naming same as PHP variable names).
It ends with the token on a line by itself (must start in first position.

@c
def skip_heredoc_string(s,i):

    j = i
    assert(g.match(s,i,"<<<"))
    m = re.match("\<\<\<([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)", s[i:])
    if (None == m):
        i += 3
        return i

    # 14-SEP-2002 DTHEIN: needed to add \n to find word, not just string
    delim = m.group(1) + '\n' 

    i = g.skip_line(s,i) # 14-SEP-2002 DTHEIN: look after \n, not before
    n = len(s)
    while i < n and not g.match(s,i,delim):
        i = g.skip_line(s,i) # 14-SEP-2002 DTHEIN: move past \n

    if i >= n:
        g.scanError("Run on string: " + s[j:i])
    elif g.match(s,i,delim):
        i += len(delim)
    return i
#@-node:ekr.20031218072017.3166:skip_heredoc_string : called by php import (Dave Hein)
#@+node:ekr.20031218072017.3167:skip_pp_directive
# Now handles continuation lines and block comments.

def skip_pp_directive(s,i):

    while i < len(s):
        if g.is_nl(s,i):
            if g.escaped(s,i): i = g.skip_nl(s,i)
            else: break
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i
#@-node:ekr.20031218072017.3167:skip_pp_directive
#@+node:ekr.20031218072017.3168:skip_pp_if
# Skips an entire if or if def statement, including any nested statements.

def skip_pp_if(s,i):

    start_line = g.get_line(s,i) # used for error messages.
    # g.trace(start_line)

    assert(
        g.match_word(s,i,"#if") or
        g.match_word(s,i,"#ifdef") or
        g.match_word(s,i,"#ifndef"))

    i = g.skip_line(s,i)
    i,delta1 = g.skip_pp_part(s,i)
    i = g.skip_ws(s,i)
    if g.match_word(s,i,"#else"):
        i = g.skip_line(s,i)
        i = g.skip_ws(s,i)
        i,delta2 = g.skip_pp_part(s,i)
        if delta1 != delta2:
            g.es("#if and #else parts have different braces: " + start_line)
    i = g.skip_ws(s,i)
    if g.match_word(s,i,"#endif"):
        i = g.skip_line(s,i)
    else:
        g.es("no matching #endif: " + start_line)

    # g.trace(delta1,start_line)
    return i,delta1
#@-node:ekr.20031218072017.3168:skip_pp_if
#@+node:ekr.20031218072017.3169:skip_pp_part
# Skip to an #else or #endif.  The caller has eaten the #if, #ifdef, #ifndef or #else

def skip_pp_part(s,i):

    # g.trace(g.get_line(s,i))

    delta = 0
    while i < len(s):
        c = s[i]
        if 0:
            if c == '\n':
                g.trace(delta,g.get_line(s,i))
        if g.match_word(s,i,"#if") or g.match_word(s,i,"#ifdef") or g.match_word(s,i,"#ifndef"):
            i,delta1 = g.skip_pp_if(s,i)
            delta += delta1
        elif g.match_word(s,i,"#else") or g.match_word(s,i,"#endif"):
            return i,delta
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif c == '{':
            delta += 1 ; i += 1
        elif c == '}':
            delta -= 1 ; i += 1
        elif g.match(s,i,"//"): i = g.skip_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i,delta
#@-node:ekr.20031218072017.3169:skip_pp_part
#@+node:ekr.20031218072017.3170:skip_python_string
def skip_python_string(s,i):

    if g.match(s,i,"'''") or g.match(s,i,'"""'):
        j = i ; delim = s[i]*3 ; i += 3
        k = string.find(s,delim,i)
        if k > -1: return k+3
        g.scanError("Run on triple quoted string: " + s[j:i])
        return len(s)
    else:
        return g.skip_string(s,i)
#@-node:ekr.20031218072017.3170:skip_python_string
#@+node:ekr.20031218072017.2369:skip_string
def skip_string(s,i,verbose=True):

    '''Scan forward to the end of a string.
    New in Leo 4.4.2 final: give error only if verbose is True'''

    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')

    n = len(s)
    while i < n and s[i] != delim:
        if s[i] == '\\' : i += 2
        else: i += 1

    if i >= n:
        if verbose:
            g.scanError("Run on string: " + s[j:i])
    elif s[i] == delim:
        i += 1

    # g.trace(s[j:i])
    return i
#@-node:ekr.20031218072017.2369:skip_string
#@+node:ekr.20031218072017.3171:skip_to_semicolon
# Skips to the next semicolon that is not in a comment or a string.

def skip_to_semicolon(s,i):

    n = len(s)
    while i < n:
        c = s[i]
        if c == ';': return i
        elif c == '\'' or c == '"' : i = g.skip_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i
#@-node:ekr.20031218072017.3171:skip_to_semicolon
#@+node:ekr.20031218072017.3172:skip_typedef
def skip_typedef(s,i):

    n = len(s)
    while i < n and g.is_c_id(s[i]):
        i = g.skip_c_id(s,i)
        i = g.skip_ws_and_nl(s,i)
    if g.match(s,i,'{'):
        i = g.skip_braces(s,i)
        i = g.skip_to_semicolon(s,i)
    return i
#@-node:ekr.20031218072017.3172:skip_typedef
#@-node:ekr.20031218072017.3158:Scanners: calling scanError
#@+node:ekr.20031218072017.3173:Scanners: no error messages
#@+node:ekr.20031218072017.3174:escaped
# Returns True if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

    count = 0
    while i-1 >= 0 and s[i-1] == '\\':
        count += 1
        i -= 1
    return (count%2) == 1
#@-node:ekr.20031218072017.3174:escaped
#@+node:ekr.20031218072017.3175:find_line_start
def find_line_start(s,i):

    # bug fix: 11/2/02: change i to i+1 in rfind
    i = string.rfind(s,'\n',0,i+1) # Finds the highest index in the range.
    if i == -1: return 0
    else: return i + 1
#@-node:ekr.20031218072017.3175:find_line_start
#@+node:ekr.20031218072017.3176:find_on_line
def find_on_line(s,i,pattern):

    # j = g.skip_line(s,i) ; g.trace(s[i:j])
    j = string.find(s,'\n',i)
    if j == -1: j = len(s)
    k = string.find(s,pattern,i,j)
    if k > -1: return k
    else: return None
#@-node:ekr.20031218072017.3176:find_on_line
#@+node:ekr.20031218072017.3177:is_c_id
def is_c_id(ch):

    return g.isWordChar(ch)

#@-node:ekr.20031218072017.3177:is_c_id
#@+node:ekr.20031218072017.3178:is_nl
def is_nl(s,i):

    return i < len(s) and (s[i] == '\n' or s[i] == '\r')
#@-node:ekr.20031218072017.3178:is_nl
#@+node:ekr.20031218072017.3179:is_special
# We no longer require that the directive appear befor any @c directive or section definition.

def is_special(s,i,directive):

    """Return True if the body text contains the @ directive."""

    # j = g.skip_line(s,i) ; g.trace(s[i:j],':',directive)
    assert (directive and directive [0] == '@' )

    # 10/23/02: all directives except @others must start the line.
    skip_flag = directive in ("@others","@all")
    while i < len(s):
        if g.match_word(s,i,directive):
            return True, i
        else:
            i = g.skip_line(s,i)
            if skip_flag:
                i = g.skip_ws(s,i)
    return False, -1
#@-node:ekr.20031218072017.3179:is_special
#@+node:ekr.20031218072017.3180:is_ws & is_ws_or_nl
def is_ws(c):

    return c == '\t' or c == ' '

def is_ws_or_nl(s,i):

    return g.is_nl(s,i) or (i < len(s) and g.is_ws(s[i]))
#@-node:ekr.20031218072017.3180:is_ws & is_ws_or_nl
#@+node:ekr.20031218072017.3181:match
# Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

    return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i
#@-node:ekr.20031218072017.3181:match
#@+node:ekr.20031218072017.3182:match_c_word
def match_c_word (s,i,name):

    if name == None: return False
    n = len(name)
    if n == 0: return False
    return name == s[i:i+n] and (i+n == len(s) or not g.is_c_id(s[i+n]))
#@-node:ekr.20031218072017.3182:match_c_word
#@+node:ekr.20031218072017.3183:match_ignoring_case
def match_ignoring_case(s1,s2):

    if s1 == None or s2 == None: return False
    return string.lower(s1) == string.lower(s2)
#@-node:ekr.20031218072017.3183:match_ignoring_case
#@+node:ekr.20031218072017.3184:match_word
def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if s.find(pattern,i,i+j) != i:
        return False
    if i+j >= len(s):
        return True
    ch = s[i+j]
    return not g.isWordChar(ch)
#@-node:ekr.20031218072017.3184:match_word
#@+node:ekr.20031218072017.3185:skip_blank_lines
def skip_blank_lines(s,i):

    while i < len(s):
        if g.is_nl(s,i) :
            i = g.skip_nl(s,i)
        elif g.is_ws(s[i]):
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                i = j
            else: break
        else: break
    return i
#@-node:ekr.20031218072017.3185:skip_blank_lines
#@+node:ekr.20031218072017.3186:skip_c_id
def skip_c_id(s,i):

    n = len(s)
    while i < n and g.isWordChar(s[i]):
        i += 1
    return i
#@-node:ekr.20031218072017.3186:skip_c_id
#@+node:ekr.20040705195048:skip_id
def skip_id(s,i,chars=None):

    chars = chars and g.toUnicode(chars,encoding='ascii') or ''
    n = len(s)
    while i < n and (g.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i
#@nonl
#@-node:ekr.20040705195048:skip_id
#@+node:ekr.20031218072017.3187:skip_line, skip_to_start/end_of_line
@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    if i >= len(s): return len(s) # Bug fix: 2007/5/22
    if i < 0: i = 0
    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1

def skip_to_end_of_line (s,i):

    if i >= len(s): return len(s) # Bug fix: 2007/5/22
    if i < 0: i = 0
    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i

def skip_to_start_of_line (s,i):

    if i >= len(s): return len(s)
    if i <= 0:      return 0
    i = s.rfind('\n',0,i) # Don't find s[i], so it doesn't matter if s[i] is a newline.
    if i == -1: return 0
    else:       return i + 1
#@-node:ekr.20031218072017.3187:skip_line, skip_to_start/end_of_line
#@+node:ekr.20031218072017.3188:skip_long
def skip_long(s,i):

    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i >= n or (not s[i].isdigit() and s[i] not in u'+-'):
        return i, None
    j = i
    if s[i] in u'+-': # Allow sign before the first digit
        i +=1
    while i < n and s[i].isdigit():
        i += 1
    try: # There may be no digits.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
#@-node:ekr.20031218072017.3188:skip_long
#@+node:ekr.20031218072017.3189:skip_matching_python_delims
def skip_matching_python_delims(s,i,delim1,delim2,reverse=False):

    '''Skip from the opening delim to the matching delim2.

    Return the index of the matching ')', or -1'''

    level = 0 ; n = len(s)
    # g.trace('delim1/2',repr(delim1),repr(delim2),'i',i,'s[i]',repr(s[i]),'s',repr(s[i-5:i+5]))
    assert(g.match(s,i,delim1))
    if reverse:
         while i >= 0:
            ch = s[i]
            if ch == delim1:
                level += 1 ; i -= 1
            elif ch == delim2:
                level -= 1
                if level <= 0:  return i
                i -= 1
            # Doesn't handle strings and comments properly...
            else: i -= 1
    else:
        while i < n:
            progress = i
            ch = s[i]
            if ch == delim1:
                level += 1 ; i += 1
            elif ch == delim2:
                level -= 1
                if level <= 0:  return i
                i += 1
            elif ch == '\'' or ch == '"': i = g.skip_string(s,i,verbose=False)
            elif g.match(s,i,'#'):  i = g.skip_to_end_of_line(s,i)
            else: i += 1
            if i == progress: return -1
    return -1
#@-node:ekr.20031218072017.3189:skip_matching_python_delims
#@+node:ekr.20060627080947:skip_matching_python_parens
def skip_matching_python_parens(s,i):

    '''Skip from the opening ( to the matching ).

    Return the index of the matching ')', or -1'''

    return skip_matching_python_delims(s,i,'(',')')
#@-node:ekr.20060627080947:skip_matching_python_parens
#@+node:ekr.20031218072017.3190:skip_nl
# We need this function because different systems have different end-of-line conventions.

def skip_nl (s,i):

    """Skips a single "logical" end-of-line character."""

    if g.match(s,i,"\r\n"): return i + 2
    elif g.match(s,i,'\n') or g.match(s,i,'\r'): return i + 1
    else: return i
#@-node:ekr.20031218072017.3190:skip_nl
#@+node:ekr.20031218072017.3191:skip_non_ws
def skip_non_ws (s,i):

    n = len(s)
    while i < n and not g.is_ws(s[i]):
        i += 1
    return i
#@-node:ekr.20031218072017.3191:skip_non_ws
#@+node:ekr.20031218072017.3192:skip_pascal_braces
# Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

    # No constructs are recognized inside Pascal block comments!
    k = string.find(s,'}',i)
    if i == -1: return len(s)
    else: return k
#@-node:ekr.20031218072017.3192:skip_pascal_braces
#@+node:ekr.20031218072017.3193:skip_to_char
def skip_to_char(s,i,ch):

    j = string.find(s,ch,i)
    if j == -1:
        return len(s),s[i:]
    else:
        return j,s[i:j]
#@-node:ekr.20031218072017.3193:skip_to_char
#@+node:ekr.20031218072017.3194:skip_ws, skip_ws_and_nl
def skip_ws(s,i):

    n = len(s)
    while i < n and g.is_ws(s[i]):
        i += 1
    return i

def skip_ws_and_nl(s,i):

    n = len(s)
    while i < n and (g.is_ws(s[i]) or g.is_nl(s,i)):
        i += 1
    return i
#@-node:ekr.20031218072017.3194:skip_ws, skip_ws_and_nl
#@-node:ekr.20031218072017.3173:Scanners: no error messages
#@+node:ekr.20031218072017.3195:splitLines & joinLines
def splitLines (s):

    """Split s into lines, preserving the number of lines and the ending of the last line."""

    # g.stat()

    if s:
        return s.splitlines(True) # This is a Python string function!
    else:
        return []

splitlines = splitLines

def joinLines (aList):

    return ''.join(aList)

joinlines = joinLines
#@-node:ekr.20031218072017.3195:splitLines & joinLines
#@-node:ekr.20031218072017.3151:Scanning... (leoGlobals.py)
#@+node:ekr.20040327103735.2:Script Tools (leoGlobals.py)
#@+node:ekr.20031218072017.2418:g.initScriptFind (set up dialog)
def initScriptFind(c,findHeadline,changeHeadline=None,firstNode=None,
    script_search=True,script_change=True):

    __pychecker__ = '--no-argsused' # firstNode is not used.

    import leoTest
    import leoGlobals as g

    # Find the scripts.
    p = c.currentPosition()
    u = leoTest.testUtils(c)
    find_p = u.findNodeInTree(p,findHeadline)
    if find_p:
        find_text = find_p.bodyString()
    else:
        g.es("no Find script node",color="red")
        return
    if changeHeadline:
        change_p = u.findNodeInTree(p,changeHeadline)
    else:
        change_p = None
    if change_p:
        change_text = change_p.bodyString()
    else:
        change_text = ""
    # print find_p,change_p

    # Initialize the find panel.
    c.script_search_flag = script_search
    c.script_change_flag = script_change and change_text
    if script_search:
        c.find_text = find_text.strip() + "\n"
    else:
        c.find_text = find_text
    if script_change:
        c.change_text = change_text.strip() + "\n"
    else:
        c.change_text = change_text
    c.frame.findPanel.init(c)
    c.showFindPanel()
#@-node:ekr.20031218072017.2418:g.initScriptFind (set up dialog)
#@+node:ekr.20040321065415:g.findNodeInTree, findNodeAnywhere, findTopLevelNode
def findNodeInTree(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(c,headline):

    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findTopLevelNode(c,headline):

    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
#@-node:ekr.20040321065415:g.findNodeInTree, findNodeAnywhere, findTopLevelNode
#@+node:ekr.20060624085200:g.handleScriptException
def handleScriptException (c,p,script,script1):

    g.es("exception executing script",color='blue')

    full = c.config.getBool('show_full_tracebacks_in_scripts')

    fileName, n = g.es_exception(full=full)

    if p and not script1 and fileName == "<string>":
        c.goToScriptLineNumber(p,script,n)

    << dump the lines near the error >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print(s)

# Print surrounding lines.
i = max(0,n-2)
j = min(n+2,len(lines))
while i < j:
    ch = g.choose(i==n-1,'*',' ')
    s = "%s line %d: %s" % (ch,i+1,lines[i])
    g.es(s,newline=False)
    i += 1
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20060624085200:g.handleScriptException
#@+node:ekr.20050503112513.7:g.executeFile
def executeFile(filename, options= ''):

    if not os.access(filename, os.R_OK): return

    subprocess = g.importExtension('subprocess',None,verbose=False)

    cwd = os.getcwdu()
    fdir, fname = g.os_path_split(filename)

    if subprocess: # Only exists in Python 2.4.
        << define subprocess_wrapper >>
        rc, so, se = subprocess_wrapper('%s %s %s'%(sys.executable, fname, options))
        if rc:
             print 'return code', rc
        print so, se
    else:
        if fdir: os.chdir(fdir)
        d = {'__name__': '__main__'}
        execfile(fname, d)  #, globals()
        os.system('%s %s' % (sys.executable, fname))
        if fdir: os.chdir(cwd)
#@+node:ekr.20050503112513.8:<< define subprocess_wrapper >>
def subprocess_wrapper(cmdlst):

    # g.trace(cmdlst, fdir)
    # g.trace(subprocess.list2cmdline([cmdlst]))

    p = subprocess.Popen(cmdlst, cwd=fdir,
        universal_newlines=True,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    stdo, stde = p.communicate()
    return p.wait(), stdo, stde
#@-node:ekr.20050503112513.8:<< define subprocess_wrapper >>
#@-node:ekr.20050503112513.7:g.executeFile
#@-node:ekr.20040327103735.2:Script Tools (leoGlobals.py)
#@+node:ekr.20031218072017.1498:Unicode utils...
#@+node:ekr.20061006152327:g.isWordChar & g.isWordChar1
def isWordChar (ch):

    '''Return True if ch should be considered a letter.'''

    return ch and (ch.isalnum() or ch == u'_')

def isWordChar1 (ch):

    return ch and (ch.isalpha() or ch == u'_')
#@nonl
#@-node:ekr.20061006152327:g.isWordChar & g.isWordChar1
#@+node:ekr.20060216115304.2:g.safeStringCompare & test (Do not use)
@ Important: Leo is supposed to convert all characters to unicode,
so there should never be a need for safeStringCompare.

The proper way to avoid UnicodeError's is to call g.toUnicode(s,g.app.tkEncoding)

@c

if 0:
    def safeStringCompare (s1,s2):

        s1 = g.toUnicode(s1,'utf-8')
        s2 = g.toUnicode(s2,'utf-8')
        return s1 == s2

    def xxx_test_g_safeStringCompare ():

        assert g.safeStringCompare('a','á') is False
        assert g.safeStringCompare('','á') is False
        assert g.safeStringCompare('',u'á') is False
        assert g.safeStringCompare('a','a') is True
        assert g.safeStringCompare('á','á') is True
        assert g.safeStringCompare(u'á',u'á') is True
#@-node:ekr.20060216115304.2:g.safeStringCompare & test (Do not use)
#@+node:ekr.20031218072017.1503:getpreferredencoding from 2.3a2
# Suppress warning about redefining getpreferredencoding
__pychecker__ = '--no-reuseattr'

try:
    # Use Python's version of getpreferredencoding if it exists.
    # It is new in Python 2.3.
    import locale
    getpreferredencoding = locale.getpreferredencoding
except Exception:
    # Use code copied from locale.py in Python 2.3alpha2.
    if sys.platform in ('win32', 'darwin', 'mac'):
        << define getpreferredencoding using _locale >>
    else:
        << define getpreferredencoding for *nix >>

__pychecker__ = '--reuseattr'
#@+node:ekr.20031218072017.1504:<< define getpreferredencoding using _locale >>
# On Win32, this will return the ANSI code page
# On the Mac, it should return the system encoding;
# it might return "ascii" instead.

def getpreferredencoding(do_setlocale = True):
    """Return the charset that the user is likely using."""
    try:
        import _locale
        return _locale._getdefaultlocale()[1]
    except:
        return None
#@-node:ekr.20031218072017.1504:<< define getpreferredencoding using _locale >>
#@+node:ekr.20031218072017.1505:<< define getpreferredencoding for *nix >>
# Pychecker complains about CODESET

try:
    locale.CODESET # Bug fix, 2/12/05
except NameError:
    # Fall back to parsing environment variables :-(
    def getpreferredencoding(do_setlocale = True):
        """Return the charset that the user is likely using,
        by looking at environment variables."""
        try:
            return locale.getdefaultlocale()[1]
        except:
            return None
else:
    def getpreferredencoding(do_setlocale = True):
        """Return the charset that the user is likely using,
        according to the system configuration."""
        try:
            if do_setlocale:
                oldloc = locale.setlocale(LC_CTYPE)
                locale.setlocale(LC_CTYPE, "")
                result = locale.nl_langinfo(CODESET)
                locale.setlocale(LC_CTYPE, oldloc)
                return result
            else:
                return locale.nl_langinfo(CODESET)
        except:
            return None
#@-node:ekr.20031218072017.1505:<< define getpreferredencoding for *nix >>
#@-node:ekr.20031218072017.1503:getpreferredencoding from 2.3a2
#@+node:ekr.20031218072017.1499:isUnicode
def isUnicode(s):

    return s is None or type(s) == type(u' ')
#@-node:ekr.20031218072017.1499:isUnicode
#@+node:ekr.20031218072017.1500:isValidEncoding
def isValidEncoding (encoding):

    if not encoding:
        return False

    if sys.platform == 'cli':
        return True

    import codecs

    try:
        codecs.lookup(encoding)
        return True
    except LookupError: # Windows.
        return False
    except AttributeError: # Linux.
        return False
#@nonl
#@-node:ekr.20031218072017.1500:isValidEncoding
#@+node:ekr.20031218072017.1501:reportBadChars
def reportBadChars (s,encoding):

    errors = 0
    if type(s) == type(u""):
        for ch in s:
            try: ch.encode(encoding,"strict")
            except UnicodeEncodeError:
                errors += 1
        if errors:
            g.es("%d errors converting %s to %s" % (
                errors, s.encode(encoding,'replace'),
                encoding.encode('ascii','replace')),
            color='red')
    elif type(s) == type(""):
        for ch in s:
            try: unicode(ch,encoding,"strict")
            except: errors += 1
        if errors:
            g.es("%d errors converting %s (%s encoding) to unicode" % (
                errors,
                unicode(s,encoding,'replace'),
                encoding.encode('ascii','replace')),
            color='red')
#@+node:ekr.20050825092149:test_g_reportBadChars
def test_g_reportBadChars ():

    for s,encoding in (
        ('aĂbĂ',  'ascii'),
        (u'aĂbĂ', 'ascii'),
        ('炰',    'ascii'),
        (u'炰',   'ascii'),

        ('aĂbĂ',  'utf-8'),
        (u'aĂbĂ', 'utf-8'),
        ('炰',    'utf-8'),
        (u'炰',   'utf-8'),
    ):

        g.reportBadChars(s,encoding)
#@-node:ekr.20050825092149:test_g_reportBadChars
#@-node:ekr.20031218072017.1501:reportBadChars
#@+node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@+node:ekr.20050208093800:toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@-node:ekr.20050208093800:toEncodedString
#@+node:ekr.20050208093903:toEncodedStringWithErrorCode
def toEncodedStringWithErrorCode (s,encoding):

    ok = True

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            s = s.encode(encoding,"replace")
            ok = False

    return s,ok
#@-node:ekr.20050208093903:toEncodedStringWithErrorCode
#@+node:ekr.20050208093800.1:toUnicode
def toUnicode (s,encoding,reportErrors=False):

    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = unicode(s,encoding,"replace")
    return s
#@-node:ekr.20050208093800.1:toUnicode
#@+node:ekr.20050208095723:toUnicodeWithErrorCode
def toUnicodeWithErrorCode (s,encoding):

    ok = True

    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            s = unicode(s,encoding,"replace")
            ok = False

    return s,ok
#@-node:ekr.20050208095723:toUnicodeWithErrorCode
#@+node:ekr.20050208104358:test_round_trip_toUnicode_toEncodedString
def test_round_trip_toUnicode_toEncodedString ():

    table = [
        ('a',    'utf-8'),
        ('a',    'ascii'),
        ('äöü',  'utf-8'),
        ('äöü',  'mbcs'),
        ('炰',   'utf-8'),
    ]

    import sys

    if sys.platform.startswith('win'):
        data = ('炰','mbcs'),
        table.append

    for s,encoding in table:
        if g.isValidEncoding(encoding):
            s2,ok = g.toUnicodeWithErrorCode(s,encoding)
            assert ok, 'toUnicodeWithErrorCode fails for %s' %s
            s3,ok = g.toEncodedStringWithErrorCode(s2,encoding)
            assert ok, 'toEncodedStringWithErrorCode fails for %s' % s2
            assert s3 == s, 'Round-trip one failed for %s' %s

            s2 = g.toUnicode(s,encoding)
            s3 = g.toEncodedString(s2,encoding)
            assert s3 == s, 'Round-trip two failed for %s' %s

#@-node:ekr.20050208104358:test_round_trip_toUnicode_toEncodedString
#@+node:ekr.20050208112123:test_failure_with_ascii_encodings
def test_failure_with_ascii_encodings():

    encoding = 'ascii'

    s = '炰'
    s2,ok = g.toUnicodeWithErrorCode(s,encoding)
    assert not ok, 'toUnicodeWithErrorCode returns True for %s with ascii encoding' % s

    s = u'炰'
    s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
    assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s
#@-node:ekr.20050208112123:test_failure_with_ascii_encodings
#@-node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@-node:ekr.20031218072017.1498:Unicode utils...
#@+node:ekr.20070524083513:Unit testing (leoGlobals.py)
#@+node:ekr.20070524075713:@test test-proto
if g.app and g.app.unitTesting:

    def sendEmail(self):
        pass # g.trace('self',self,'p',p.headString())

    class test:
        pass

    sendEmail(test())
#@-node:ekr.20070524075713:@test test-proto
#@+node:ekr.20070524083726:test_unit_testing_with_embedded_class
def test_unit_testing_with_embedded_class():

    def sendEmail(self):
        pass # g.trace('self2',self)

    class test:
        pass

    X = test()
    sendEmail(X)
#@-node:ekr.20070524083726:test_unit_testing_with_embedded_class
#@-node:ekr.20070524083513:Unit testing (leoGlobals.py)
#@+node:EKR.20040612114220:Utility classes, functions & objects...
#@+node:ekr.20050315073003: Index utilities... (leoGlobals) (passed)
#@+node:ekr.20050314140957:g.convertPythonIndexToRowCol
def convertPythonIndexToRowCol (s,i):

    '''Convert index i into string s into zero-based row/col indices.'''

    if not s or i <= 0:
        return 0,0

    i = min(i,len(s))

    # works regardless of what s[i] is
    row = s.count('\n',0,i) # Don't include i
    if row == 0:
        return row,i
    else:
        prevNL = s.rfind('\n',0,i) # Don't include i
        # g.trace('prevNL',prevNL,'i',i,g.callers())
        return row,i-prevNL-1
#@-node:ekr.20050314140957:g.convertPythonIndexToRowCol
#@+node:ekr.20050315071727:g.convertRowColToPythonIndex
def convertRowColToPythonIndex (s,row,col):

    '''Convert zero-based row/col indices into a python index into string s.'''

    if row < 0: return 0

    lines = g.splitLines(s)

    if row >= len(lines):
        return len(s)

    col = min(col, len(lines[row]))

    prev = 0
    for line in lines[:row]:
        prev += len(line)

    return prev + col
#@-node:ekr.20050315071727:g.convertRowColToPythonIndex
#@-node:ekr.20050315073003: Index utilities... (leoGlobals) (passed)
#@+node:ekr.20031218072017.3140: List utilities...
#@+node:ekr.20031218072017.3141:appendToList
def appendToList(out, s):

    for i in s:
        out.append(i)
#@-node:ekr.20031218072017.3141:appendToList
#@+node:ekr.20031218072017.3142:flattenList
def flattenList (theList):

    result = []
    for item in theList:
        if type(item) == types.ListType:
            result.extend(g.flattenList(item))
        else:
            result.append(item)
    return result
#@-node:ekr.20031218072017.3142:flattenList
#@+node:ekr.20060221081328:maxStringListLength
def maxStringListLength(aList):

    '''Return the maximum string length in a list of strings.'''

    n = 0
    for z in aList:
        if type(z) in (type(''),type(u'')):
            n = max(n,len(z))

    return n
#@-node:ekr.20060221081328:maxStringListLength
#@-node:ekr.20031218072017.3140: List utilities...
#@+node:ekr.20031218072017.3106:angleBrackets & virtual_event_name
# Returns < < s > >

def angleBrackets(s):

    return ( "<<" + s +
        ">>") # must be on a separate line.

virtual_event_name = angleBrackets
#@-node:ekr.20031218072017.3106:angleBrackets & virtual_event_name
#@+node:ekr.20031218072017.3097:CheckVersion
#@+node:ekr.20060921100435:CheckVersion (EKR) & helper
# Simplified version by EKR: stringCompare not used.

def CheckVersion (s1,s2,condition=">=",stringCompare=None,delimiter='.',trace=False):

    vals1 = [g.CheckVersionToInt(s) for s in s1.split(delimiter)] ; n1 = len(vals1)
    vals2 = [g.CheckVersionToInt(s) for s in s2.split(delimiter)] ; n2 = len(vals2)
    n = max(n1,n2)
    if n1 < n: vals1.extend([0 for i in xrange(n - n1)])
    if n2 < n: vals2.extend([0 for i in xrange(n - n2)])
    for cond,val in (
        ('==', vals1 == vals2), ('!=', vals1 != vals2),
        ('<',  vals1 <  vals2), ('<=', vals1 <= vals2),
        ('>',  vals1 >  vals2), ('>=', vals1 >= vals2),
    ):
        if condition == cond:
            result = val ; break
    else:
        raise EnvironmentError,"condition must be one of '>=', '>', '==', '!=', '<', or '<='."

    if trace:
        # print '%10s' % (repr(vals1)),'%2s' % (condition),'%10s' % (repr(vals2)),result
        print '%7s' % (s1),'%2s' % (condition),'%7s' % (s2),result
    return result
#@nonl
#@+node:ekr.20070120123930:CheckVersionToInt
def CheckVersionToInt (s):

    try:
        return int(s)
    except ValueError:
        aList = []
        for ch in s:
            if ch.isdigit(): aList.append(ch)
            else: break
        if aList:
            s = string.join(aList)
            return int(s)
        else:
            return 0
#@nonl
#@-node:ekr.20070120123930:CheckVersionToInt
#@+node:ekr.20070120125007:test_CheckVersionToInt
def test_CheckVersionToInt (*args):

    assert g.CheckVersionToInt('12') == 12,'fail 1'
    assert g.CheckVersionToInt('2a5') == 2, 'fail 2'
    assert g.CheckVersionToInt('b2') == 0, 'fail 3'
#@nonl
#@-node:ekr.20070120125007:test_CheckVersionToInt
#@-node:ekr.20060921100435:CheckVersion (EKR) & helper
#@+node:ekr.20060921100435.1:oldCheckVersion (Dave Hein)
@
g.CheckVersion() is a generic version checker.  Assumes a
version string of up to four parts, or tokens, with
leftmost token being most significant and each token
becoming less signficant in sequence to the right.

RETURN VALUE

1 if comparison is True
0 if comparison is False

PARAMETERS

version: the version string to be tested
againstVersion: the reference version string to be
              compared against
condition: can be any of "==", "!=", ">=", "<=", ">", or "<"
stringCompare: whether to test a token using only the
             leading integer of the token, or using the
             entire token string.  For example, a value
             of "0.0.1.0" means that we use the integer
             value of the first, second, and fourth
             tokens, but we use a string compare for the
             third version token.
delimiter: the character that separates the tokens in the
         version strings.

The comparison uses the precision of the version string
with the least number of tokens.  For example a test of
"8.4" against "8.3.3" would just compare the first two
tokens.

The version strings are limited to a maximum of 4 tokens.
@c

def oldCheckVersion( version, againstVersion, condition=">=", stringCompare="0.0.0.0", delimiter='.' ):

    __pychecker__ = 'maxreturns=20'


    # tokenize the stringCompare flags
    compareFlag = string.split( stringCompare, '.' )

    # tokenize the version strings
    testVersion = string.split( version, delimiter )
    testAgainst = string.split( againstVersion, delimiter )

    # find the 'precision' of the comparison
    tokenCount = 4
    if tokenCount > len(testAgainst):
        tokenCount = len(testAgainst)
    if tokenCount > len(testVersion):
        tokenCount = len(testVersion)

    # Apply the stringCompare flags
    justInteger = re.compile("^[0-9]+")
    for i in range(tokenCount):
        if "0" == compareFlag[i]:
            m = justInteger.match( testVersion[i] )
            testVersion[i] = m.group()
            m = justInteger.match( testAgainst[i] )
            testAgainst[i] = m.group()
        elif "1" != compareFlag[i]:
            errMsg = "stringCompare argument must be of " +\
                 "the form \"x.x.x.x\" where each " +\
                 "'x' is either '0' or '1'."
            raise EnvironmentError,errMsg

    # Compare the versions
    if condition == ">=":
        for i in range(tokenCount):
            if testVersion[i] < testAgainst[i]:
                return 0
            if testVersion[i] > testAgainst[i]:
                return 1 # it was greater than
        return 1 # it was equal
    if condition == ">":
        for i in range(tokenCount):
            if testVersion[i] < testAgainst[i]:
                return 0
            if testVersion[i] > testAgainst[i]:
                return 1 # it was greater than
        return 0 # it was equal
    if condition == "==":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 0 # any token was not equal
        return 1 # every token was equal
    if condition == "!=":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 1 # any token was not equal
        return 0 # every token was equal
    if condition == "<":
        for i in range(tokenCount):
            if testVersion[i] >= testAgainst[i]:
                return 0
            if testVersion[i] < testAgainst[i]:
                return 1 # it was less than
        return 0 # it was equal
    if condition == "<=":
        for i in range(tokenCount):
            if testVersion[i] > testAgainst[i]:
                return 0
            if testVersion[i] < testAgainst[i]:
                return 1 # it was less than
        return 1 # it was equal

    # didn't find a condition that we expected.
    raise EnvironmentError,"condition must be one of '>=', '>', '==', '!=', '<', or '<='."
#@nonl
#@-node:ekr.20060921100435.1:oldCheckVersion (Dave Hein)
#@-node:ekr.20031218072017.3097:CheckVersion
#@+node:ekr.20031218072017.3098:class Bunch (object)
@ From The Python Cookbook:  Often we want to just collect a bunch of stuff together, naming each item of the bunch; a dictionary's OK for that, but a small do-nothing class is even handier, and prettier to use.

Create a Bunch whenever you want to group a few variables:

    point = Bunch(datum=y, squared=y*y, coord=x)

You can read/write the named attributes you just created, add others, del some of them, etc:
    if point.squared > threshold:
        point.isok = True
@c

class Bunch (object):

    """A class that represents a colection of things.

    Especially useful for representing a collection of related variables."""

    def __init__(self,**keywords):
        self.__dict__.update (keywords)

    def __repr__(self):
        return self.toString()

    def ivars(self):
        return self.__dict__.keys()

    def keys(self):
        return self.__dict__.keys()

    def toString(self):
        tag = self.__dict__.get('tag')
        entries = ["%s: %s" % (key,str(self.__dict__.get(key)))
            for key in self.ivars() if key != 'tag']
        if tag:
            return "Bunch(tag=%s)...\n%s\n" % (tag,'\n'.join(entries))
        else:
            return "Bunch...\n%s\n" % '\n'.join(entries)

    # Used by new undo code.
    def __setitem__ (self,key,value):
        '''Support aBunch[key] = val'''
        return operator.setitem(self.__dict__,key,value)

    def __getitem__ (self,key):
        '''Support aBunch[key]'''
        return operator.getitem(self.__dict__,key)

    def get (self,key,theDefault=None):
        return self.__dict__.get(key,theDefault)

bunch = Bunch
#@-node:ekr.20031218072017.3098:class Bunch (object)
#@+node:EKR.20040504150046:class mulderUpdateAlgorithm (leoGlobals)
class mulderUpdateAlgorithm:

    """A class to update derived files using
    diffs in files without sentinels.
    """

    @others

#def doMulderUpdateAlgorithm(sourcefilename,targetfilename):
#
#    mu = mulderUpdateAlgorithm()
#
#    mu.pull_source(sourcefilename,targetfilename)
#    mu.copy_time(targetfilename,sourcefilename)
#@+node:EKR.20040504150046.3:__init__
def __init__ (self,testing=False,verbose=False):

    self.testing = testing
    self.verbose = verbose
    self.do_backups = False
#@-node:EKR.20040504150046.3:__init__
#@+node:EKR.20040504150046.9:copy_sentinels
@ This script retains _all_ sentinels.  If lines are replaced, or deleted,
we restore deleted sentinel lines by checking for gaps in the mapping.
@c

def copy_sentinels (self,write_lines,fat_lines,fat_pos,mapping,startline,endline):
    """

    Copy sentinel lines from fat_lines to write_lines.

    Copy all sentinels _after_ the current reader postion up to,
    but not including, mapping[endline].

    """

    j_last = mapping[startline]
    i = startline + 1
    while i <= endline:
        j = mapping[i]
        if j_last + 1 != j:
            fat_pos = j_last + 1
            # Copy the deleted sentinels that comprise the gap.
            while fat_pos < j:
                line = fat_lines[fat_pos]
                write_lines.append(line)
                if self.testing and self.verbose: print "Copy sentinel:",fat_pos,line,
                fat_pos += 1
        j_last = j ; i += 1

    fat_pos = mapping[endline]
    return fat_pos
#@-node:EKR.20040504150046.9:copy_sentinels
#@+node:EKR.20040504155109:copy_time
def copy_time(self,sourcefilename,targetfilename):

    """
    Set the target file's modification time to
    that of the source file.
    """

    # pychecker complains about mtime.

    st = os.stat(sourcefilename)

    if hasattr(os, 'utime'):
        os.utime(targetfilename, (st.st_atime, st.st_mtime))
    elif hasattr(os, 'mtime'):
        os.mtime(targetfilename, st.st_mtime)
    else:
        g.trace("Can not set modification time")
#@-node:EKR.20040504155109:copy_time
#@+node:EKR.20040504150046.6:create_mapping
def create_mapping (self,lines,delims):
    """

    'lines' is a list of lines of a file with sentinels.

    Returns:

    result: lines with all sentinels removed.

    mapping: a list such that result[mapping[i]] == lines[i]
    for all i in range(len(result))

    """

    if not lines:
        return [],[]

    # Create mapping and set i to the index of the last non-sentinel line.
    mapping = []
    for i in xrange(len(lines)):
        if not g.is_sentinel(lines[i],delims):
            mapping.append(i)

    # Create a last mapping entry for copy_sentinels.
    mapping.append(i)

    # Use removeSentinelsFromLines to handle @nonl properly.
    stripped_lines = self.removeSentinelsFromLines(lines,delims)

    return stripped_lines, mapping
#@-node:EKR.20040504150046.6:create_mapping
#@+node:EKR.20040505080156:Get or remove sentinel lines
# These routines originally were part of push_filter & push_filter_lines.
#@+node:EKR.20040505081121:separateSentinelsFromFile/Lines
def separateSentinelsFromFile (self,filename):

    """Separate the lines of the file into a tuple of two lists,
    containing the sentinel and non-sentinel lines of the file."""

    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)

    return self.separateSentinelsFromLines(lines,delims)

def separateSentinelsFromLines (self,lines,delims):

    """Separate lines (a list of lines) into a tuple of two lists,
    containing the sentinel and non-sentinel lines of the original list."""

    strippedLines = self.removeSentinelsFromLines(lines,delims)
    sentinelLines = self.getSentinelsFromLines(lines,delims)

    return strippedLines,sentinelLines
#@-node:EKR.20040505081121:separateSentinelsFromFile/Lines
#@+node:EKR.20040505080156.2:removeSentinelsFromFile/Lines
def removeSentinelsFromFile (self,filename):

    """Return a copy of file with all sentinels removed."""

    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)

    return self.removeSentinelsFromLines(lines,delims)

def removeSentinelsFromLines (self,lines,delims):

    """Return a copy of lines with all sentinels removed."""

    delim1,delim2,delim3 = delims
    result = [] ; last_nosent_i = -1
    for i in xrange(len(lines)):
        if not g.is_sentinel(lines[i],delims):
            result.append(lines[i])
            last_nosent_i = i
    << remove the newline from result[-1] if line[i] is followed by @nonl >>
    return result
#@+node:ekr.20040716105102:<< remove the newline from result[-1] if line[i] is followed by @nonl >>
i = last_nosent_i

if i + 1 < len(lines):

    line = lines[i+1]
    j = g.skip_ws(line,0)

    if match(line,j,delim1):
        j += len(delim1)

        if g.match(line,j,"@nonl"):
            line = lines[i]
            if line[-1] == '\n':
                assert(result[-1] == line)
                result[-1] = line[:-1]
#@-node:ekr.20040716105102:<< remove the newline from result[-1] if line[i] is followed by @nonl >>
#@-node:EKR.20040505080156.2:removeSentinelsFromFile/Lines
#@+node:EKR.20040505080156.3:getSentinelsFromFile/Lines
def getSentinelsFromFile (self,filename,delims):

    """Returns all sentinels lines in a file."""

    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)

    return self.getSentinelsFromLines(lines,delims)

def getSentinelsFromLines (self,lines,delims):

    """Returns all sentinels lines in lines."""

    return [line for line in lines if g.is_sentinel(line,delims)]
#@-node:EKR.20040505080156.3:getSentinelsFromFile/Lines
#@-node:EKR.20040505080156:Get or remove sentinel lines
#@+node:EKR.20040504150046.10:propagateDiffsToSentinelsFile
def propagateDiffsToSentinelsFile(self,sourcefilename,targetfilename):

    << init propagateDiffsToSentinelsFile vars >>

    write_lines = self.propagateDiffsToSentinelsLines(
        i_lines,j_lines,fat_lines,mapping)

    # Update _source_ file if it is not the same as write_lines.
    written = self.write_if_changed(write_lines,targetfilename,sourcefilename)
    if written:
        << paranoia check>>
#@+node:EKR.20040504150046.11:<< init propagateDiffsToSentinelsFile vars >>
# Get the sentinel comment delims.
delims = g.comment_delims_from_extension(sourcefilename)
if not delims:
    return

try:
    # Create the readers.
    sfile = file(sourcefilename)
    tfile = file(targetfilename)

    fat_lines = sfile.readlines() # Contains sentinels.
    j_lines   = tfile.readlines() # No sentinels.

    i_lines,mapping = self.create_mapping(fat_lines,delims)

    sfile.close()
    tfile.close()
except:
    g.es_exception("can not open files")
    return
#@-node:EKR.20040504150046.11:<< init propagateDiffsToSentinelsFile vars >>
#@+node:EKR.20040504150046.12:<<paranoia check>>
# Check that 'push' will re-create the changed file.
strippedLines,sentinel_lines = self.separateSentinelsFromFile(sourcefilename)

if strippedLines != j_lines:
    self.report_mismatch(strippedLines, j_lines,
        "Propagating diffs did not work as expected",
        "Content of sourcefile:",
        "Content of modified file:")

# Check that no sentinels got lost.
fat_sentinel_lines = self.getSentinelsFromLines(fat_lines,delims)

if sentinel_lines != fat_sentinel_lines:
    self.report_mismatch(sentinel_lines,fat_sentinel_lines,
        "Propagating diffs modified sentinel lines:",
        "Current sentinel lines:",
        "Old sentinel lines:")
#@-node:EKR.20040504150046.12:<<paranoia check>>
#@-node:EKR.20040504150046.10:propagateDiffsToSentinelsFile
#@+node:EKR.20040504145804.1:propagateDiffsToSentinelsLines (called from perfect import)
def propagateDiffsToSentinelsLines (self,
    i_lines,j_lines,fat_lines,mapping):

    """Compare the 'i_lines' with 'j_lines' and propagate the diffs back into
    'write_lines' making sure that all sentinels of 'fat_lines' are copied.

    i/j_lines have no sentinels.  fat_lines does."""

    << init propagateDiffsToSentinelsLines vars >>
    << copy the sentinels at the beginning of the file >>
    for tag, i1, i2, j1, j2 in matcher.get_opcodes():
        if testing:
            if verbose: print
            print "Opcode %7s %3d %3d %3d %3d" % (tag,i1,i2,j1,j2)
            if verbose: print
        << update and check the loop invariant >>
        if tag == 'equal':
            << handle 'equal' tag >>
        elif tag == 'replace':
            << handle 'replace' tag >>
        elif tag == 'delete':
            << handle 'delete' tag >>
        elif tag == 'insert':
            << handle 'insert' tag >>
        else: assert 0,"bad tag"
    << copy the sentinels at the end of the file >>
    return write_lines
#@+node:EKR.20040504145804.2:<< init propagateDiffsToSentinelsLines vars >>
# Indices into i_lines, j_lines & fat_lines.
i_pos = j_pos = fat_pos = 0

# These vars check that all ranges returned by get_opcodes() are contiguous.
i2_old = j2_old = -1

# Create the output lines.
write_lines = []

matcher = difflib.SequenceMatcher(None,i_lines,j_lines)

testing = self.testing
verbose = self.verbose
#@-node:EKR.20040504145804.2:<< init propagateDiffsToSentinelsLines vars >>
#@+node:EKR.20040504145804.3:<< copy the sentinels at the beginning of the file >>
while fat_pos < mapping[0]:

    line = fat_lines[fat_pos]
    write_lines.append(line)
    if testing:
        print "copy initial line",fat_pos,line,
    fat_pos += 1
#@-node:EKR.20040504145804.3:<< copy the sentinels at the beginning of the file >>
#@+node:EKR.20040504145804.4:<< update and check the loop invariant>>
# We need the ranges returned by get_opcodes to completely cover the source lines being compared.
# We also need the ranges not to overlap.

assert(i2_old in (-1,i1))
assert(j2_old in (-1,j1))

i2_old = i2 ; j2_old = j2

# Check the loop invariants.
assert i_pos == i1
assert j_pos == j1
assert fat_pos == mapping[i1]

if 0: # not yet.
    if testing: # A bit costly.
        t_sourcelines,t_sentinel_lines = push_filter_lines(write_lines, delims)
        # Check that we have all the modifications so far.
        assert t_sourcelines == j_lines[:j1],"t_sourcelines == j_lines[:j1]"
        # Check that we kept all sentinels so far.
        assert t_sentinel_lines == push_filter_lines(fat_lines[:fat_pos], delims)[1]
#@-node:EKR.20040504145804.4:<< update and check the loop invariant>>
#@+node:EKR.20040504145804.5:<< handle 'equal' tag >>
# Copy the lines, including sentinels.
while fat_pos <= mapping[i2-1]:
    line = fat_lines[fat_pos]
    if 0: # too verbose.
        if testing: print "Equal: copying ", line,
    write_lines.append(line)
    fat_pos += 1

if testing and verbose:
    print "Equal: synch i", i_pos,i2
    print "Equal: synch j", j_pos,j2

i_pos = i2
j_pos = j2

# Copy the sentinels which might follow the lines.       
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i2-1,i2)
#@-node:EKR.20040504145804.5:<< handle 'equal' tag >>
#@+node:EKR.20040504145804.6:<< handle 'replace' tag >>
@ Replace lines that may span sentinels.

For now, we put all the new contents after the first sentinel.

A more complex approach: run the difflib across the different lines and try to
construct a mapping changed line => orignal line.
@c

while j_pos < j2:
    line = j_lines[j_pos]
    if testing:
        print "Replace i:",i_pos,repr(i_lines[i_pos])
        print "Replace j:",j_pos,repr(line)
        i_pos += 1

    write_lines.append(line)
    j_pos += 1

i_pos = i2

# Copy the sentinels which might be between the changed code.         
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)
#@-node:EKR.20040504145804.6:<< handle 'replace' tag >>
#@+node:EKR.20040504145804.7:<< handle 'delete' tag >>
if testing and verbose:
    print "delete: i",i_pos,i1
    print "delete: j",j_pos,j1

j_pos = j2
i_pos = i2

# Restore any deleted sentinels.
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)
#@-node:EKR.20040504145804.7:<< handle 'delete' tag >>
#@+node:EKR.20040504145804.8:<< handle 'insert' tag >>
while j_pos < j2:
    line = j_lines[j_pos]
    if testing: print "Insert:", line,
    write_lines.append(line)
    j_pos += 1

# The input streams are already in synch.
#@-node:EKR.20040504145804.8:<< handle 'insert' tag >>
#@+node:EKR.20040504145804.9:<< copy the sentinels at the end of the file >>
while fat_pos < len(fat_lines):

    line = fat_lines[fat_pos]
    write_lines.append(line)
    if testing:
        print "Append last line",line
    fat_pos += 1
#@-node:EKR.20040504145804.9:<< copy the sentinels at the end of the file >>
#@-node:EKR.20040504145804.1:propagateDiffsToSentinelsLines (called from perfect import)
#@+node:EKR.20040504150046.5:report_mismatch
def report_mismatch (self,lines1,lines2,message,lines1_message,lines2_message):

    """
    Generate a report when something goes wrong.
    """

    __pychecker__ = '--no-argsused' # Most args are presently unused.

    print '='*20
    print message

    if 0:
        print lines1_message
        print '-'*20
        for line in lines1:
          print line,

        print '='*20

        print lines2_message
        print '-'*20
        for line in lines2:
            print line,
#@-node:EKR.20040504150046.5:report_mismatch
#@+node:ekr.20040718101315:stripWhitespaceFromBlankLines(before_lines)
def stripWhitespaceFromBlankLines (self,lines):

    # All backslashes must be doubled.

    """Strip blanks and tabs from lines containing only blanks and tabs.

    >>> import leoGlobals as g
    >>> s = "a\\n \\t\\n\\t\\t \\t\\nb"
    >>> theLines = g.splitLines(s)
    >>> theLines
    ['a\\n', ' \\t\\n', '\\t\\t \\t\\n', 'b']
    >>> g.mulderUpdateAlgorithm().stripWhitespaceFromBlankLines(theLines)
    ['a\\n', '\\n', '\\n', 'b']
    """

    for i in xrange(len(lines)):
        # lstrip does not exist in python 2.2.1.
        stripped_line = lines[i]
        while stripped_line and stripped_line[0] in (' ','\t'):
            stripped_line = stripped_line [1:]
        if stripped_line in ('\n',''):
            lines[i] = stripped_line

    return lines
#@-node:ekr.20040718101315:stripWhitespaceFromBlankLines(before_lines)
#@+node:EKR.20040504160820:write_if_changed
def write_if_changed(self,lines,sourcefilename,targetfilename):
    """

    Replaces target file if it is not the same as 'lines',
    and makes the modification date of target file the same as the source file.

    Optionally backs up the overwritten file.

    """

    copy = not os.path.exists(targetfilename) or lines != file(targetfilename).readlines()

    if self.testing:
        if copy:
            print "Writing",targetfilename,"without sentinals"
        else:
            print "Files are identical"

    if copy:
        if self.do_backups:
            << make backup file >>
        outfile = open(targetfilename, "w")
        for line in lines:
            outfile.write(line)
        outfile.close()
        self.copy_time(sourcefilename,targetfilename)
    return copy
#@+node:EKR.20040504160820.1:<< make backup file >>
if os.path.exists(targetfilename):
    count = 0
    backupname = "%s.~%s~" % (targetfilename,count)
    while os.path.exists(backupname):
        count += 1
        backupname = "%s.~%s~" % (targetfilename,count)
    os.rename(targetfilename, backupname)
    if self.testing:
        print "backup file in ", backupname
#@-node:EKR.20040504160820.1:<< make backup file >>
#@-node:EKR.20040504160820:write_if_changed
#@-node:EKR.20040504150046:class mulderUpdateAlgorithm (leoGlobals)
#@+node:ekr.20031219074948.1:class nullObject
# From the Python cookbook, recipe 5.23

class nullObject:

    """An object that does nothing, and does it very well."""

    __pychecker__ = '--no-argsused'

    def __init__   (self,*args,**keys): pass
    def __call__   (self,*args,**keys): return self

    def __repr__   (self): return "nullObject"

    def __nonzero__ (self): return 0

    def __delattr__(self,attr):     return self
    def __getattr__(self,attr):     return self
    def __setattr__(self,attr,val): return self
#@-node:ekr.20031219074948.1:class nullObject
#@+node:ekr.20031218072017.3103:g.computeWindowTitle
def computeWindowTitle (fileName):

    if fileName == None:
        return "untitled"
    else:
        path,fn = g.os_path_split(fileName)
        if path:
            title = fn + " in " + path
        else:
            title = fn
        return title
#@-node:ekr.20031218072017.3103:g.computeWindowTitle
#@+node:ekr.20031218072017.3138:g.executeScript
def executeScript (name):

    """Execute a script whose short python file name is given"""

    mod_name,ext = g.os_path_splitext(name)
    theFile = None
    try:
        # This code is in effect an import or a reload.
        # This allows the user to modify scripts without leaving Leo.
        import imp
        theFile,filename,description = imp.find_module(mod_name)
        imp.load_module(mod_name,theFile,filename,description)
    except:
        g.es("Exception executing " + name,color="red")
        g.es_exception()

    if theFile:
        theFile.close()
#@-node:ekr.20031218072017.3138:g.executeScript
#@+node:ekr.20040331083824.1:g.fileLikeObject
# Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.

    The caller is responsible for handling newlines correctly."""

    @others
#@+node:ekr.20050404151753: ctor
def __init__(self,fromString=None):

    # New in 4.2.1: allow the file to be inited from string s.
    if fromString:
        self.list = g.splitLines(fromString) # Must preserve newlines!
    else:
        self.list = []

    self.ptr = 0

# In CStringIO the buffer is read-only if the initial value (fromString) is non-empty.
#@-node:ekr.20050404151753: ctor
#@+node:ekr.20050404151753.1:clear
def clear (self):

    self.list = []
#@-node:ekr.20050404151753.1:clear
#@+node:ekr.20050404151753.2:close
def close (self):

    pass

    # The StringIo version free's the memory buffer.
#@-node:ekr.20050404151753.2:close
#@+node:ekr.20050404151753.3:flush
def flush (self):

    pass
#@-node:ekr.20050404151753.3:flush
#@+node:ekr.20050404151753.4:get & getvalue
def get (self):

    return ''.join(self.list)

getvalue = get # for compatibility with StringIo
#@-node:ekr.20050404151753.4:get & getvalue
#@+node:ekr.20050404151753.5:readline
def readline(self): # New for read-from-string (readOpenFile).

    if self.ptr < len(self.list):
        line = self.list[self.ptr]
        # g.trace(repr(line))
        self.ptr += 1
        return line
    else:
        return ''
#@-node:ekr.20050404151753.5:readline
#@+node:ekr.20050404151753.6:write
def write (self,s):

    if s:
        self.list.append(s)
#@-node:ekr.20050404151753.6:write
#@-node:ekr.20040331083824.1:g.fileLikeObject
#@+node:ekr.20031218072017.3126:g.funcToMethod
@ The following is taken from page 188 of the Python Cookbook.

The following method allows you to add a function as a method of any class.  That is, it converts the function to a method of the class.  The method just added is available instantly to all existing instances of the class, and to all instances created in the future.

The function's first argument should be self.

The newly created method has the same name as the function unless the optional name argument is supplied, in which case that name is used as the method name.
@c

def funcToMethod(f,theClass,name=None):

    setattr(theClass,name or f.__name__,f)
    # g.trace(name)
#@-node:ekr.20031218072017.3126:g.funcToMethod
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True,useSentinels=True):

    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands ; w = c.frame.body.bodyCtrl
    if not p:
        p = c.currentPosition()
    try:
        if g.app.batchMode:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and w.hasSelection():
                s = w.getSelectedText()
            else:
                s = w.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels,
                useSentinels=useSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    # g.trace(type(script),repr(script))
    return script
#@+node:ekr.20050211100535:test_g_getScript_strips_crlf
def test_g_getScript_strips_crlf():

    # __pychecker__ = '--limit=0' # Suppress warnings about c & p.

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@-node:ekr.20050211100535:test_g_getScript_strips_crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:ekr.20050920084036.4:g.longestCommonPrefix & g.itemsMatchingPrefixInList
def longestCommonPrefix (s1,s2):

    '''Find the longest prefix common to strings s1 and s2.'''

    prefix = ''
    for ch in s1:
        if s2.startswith(prefix + ch):
            prefix = prefix + ch
        else:
            return prefix
    return prefix

def itemsMatchingPrefixInList (s,aList,matchEmptyPrefix=False):

    '''This method returns a sorted list items of aList whose prefix is s.

    It also returns the longest common prefix of all the matches.'''

    if s:
        pmatches = [a for a in aList if a.startswith(s)]
    elif matchEmptyPrefix:
        pmatches = aList[:]
    else: pmatches = []

    if pmatches:
        pmatches.sort()
        common_prefix = reduce(g.longestCommonPrefix,pmatches)
    else:
        common_prefix = ''

    # g.trace(repr(s),len(pmatches))
    return pmatches,common_prefix
#@-node:ekr.20050920084036.4:g.longestCommonPrefix & g.itemsMatchingPrefixInList
#@+node:ekr.20031218072017.3144:g.makeDict
# From the Python cookbook.

def makeDict(**keys):

    """Returns a Python dictionary from using the optional keyword arguments."""

    return keys
#@-node:ekr.20031218072017.3144:g.makeDict
#@+node:ekr.20060221083356:g.prettyPrintType
def prettyPrintType (obj):

    if type(obj) in (
        types.MethodType,types.UnboundMethodType,types.BuiltinMethodType):
        return 'method'
    elif type(obj) in (types.BuiltinFunctionType,types.FunctionType):
        return 'function'
    elif type(obj) == types.ModuleType:
        return 'module'
    elif type(obj) == types.InstanceType:
        return 'object'
    elif type(obj) in (types.UnicodeType,types.StringType):
        return 'string'
    else:
        theType = str(type(obj))
        if theType.startswith("<type '"): theType = theType[7:]
        if theType.endswith("'>"): theType = theType[:-2]
        return theType
#@-node:ekr.20060221083356:g.prettyPrintType
#@+node:ekr.20060410112600:g.stripBrackets
def stripBrackets (s):

    '''Same as s.lstrip('<').rstrip('>') except it works for Python 2.2.1.'''

    if s.startswith('<'):
        s = s[1:]
    if s.endswith('>'):
        s = s[:-1]
    return s
#@-node:ekr.20060410112600:g.stripBrackets
#@+node:ekr.20061031102333.2:g.getWord & getLine (both passed)
def getWord (s,i):

    '''Return i,j such that s[i:j] is the word surrounding s[i].'''

    if i >= len(s): i = len(s) - 1
    if i < 0: i = 0
    # Scan backwards.
    while 0 <= i < len(s) and g.isWordChar(s[i]):
        i-= 1
    i += 1
    # Scan forwards.
    j = i
    while 0 <= j < len(s) and g.isWordChar(s[j]):
        j += 1
    return i,j

def getLine (s,i):

    '''Return i,j such that s[i:j] is the line surrounding s[i].
    s[i] is a newline only if the line is empty.
    s[j] is a newline unless there is no trailing newline.
    '''

    if i >= len(s): i = len(s) - 1
    if i < 0: i = 0
    j = s.rfind('\n',0,i) # A newline *ends* the line, so look to the left of a newline.
    if j == -1: j = 0
    else:       j += 1
    k = s.find('\n',i)
    if k == -1: k = len(s)
    else:       k = k + 1
    # g.trace('i,j,k',i,j,k,repr(s[j:k]))
    return j,k
#@nonl
#@-node:ekr.20061031102333.2:g.getWord & getLine (both passed)
#@+node:ekr.20041219095213:import wrappers
@ 1/6/05: The problem with Tkinter is that imp.load_module is equivalent to reload.

The solutions is easy: simply return sys.modules.get(moduleName) if moduleName is in sys.modules!
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):

    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()

    if verbose and not (app and g.app.unitTesting):
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        g.es_print(s,color="blue")

    return None
#@-node:ekr.20040917061619:g.cantImport
#@+node:ekr.20041219095213.1:g.importModule
def importModule (moduleName,pluginName=None,verbose=False):

    '''Try to import a module as Python's import command does.

    moduleName is the module's name, without file extension.'''

    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except Exception: # Importing a module can throw exceptions other than ImportError.
                g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)
        finally:
            if theFile: theFile.close()
    return module
#@-node:ekr.20041219095213.1:g.importModule
#@+node:ekr.20041219071407:g.importExtension & helpers
def importExtension (moduleName,pluginName=None,verbose=False,required=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''

    # g.trace(verbose,moduleName,pluginName)

    import os

    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    extensionsDir = g.app and g.app.extensionsDir or os.path.join(os.path.dirname(__file__),'..','extensions')

    if not module:
        module = g.importFromPath(moduleName,extensionsDir,pluginName=pluginName,verbose=verbose)

        if not module and required:
            g.cantImportDialog(pluginName,moduleName)
            try: # Avoid raising SystemExit if possible.
                import os ; os._exit(1) # May not be available on all platforms.
            except Exception:
                import sys ; sys.exit(1)

    return module
#@+node:ekr.20060329083657:cantImportDialog & helpers
def cantImportDialog (pluginName,moduleName):

    '''Attempt to show a Tk dialog if an import fails.
    Yes, this is a small Tk dependency, but it can't be helped.'''

    message = '''
%s requires the %s module.
Official distributions contain this module in Leo's extensions folder,
but this module may be missing if you get Leo from cvs.
''' % (pluginName,moduleName)

    if 1: # Requires minimal further imports.
        try:
            import Tkinter as Tk
            root = g.app.root or Tk.Tk()
            title = 'Can not import %s' % moduleName
            top = createDialogFrame(Tk,root,title,message)
            root.wait_window(top)
        except ImportError:
            print 'Can not import %s' % moduleName
            print 'Can not import Tkinter'
            print 'Leo must now exit'

    else: # Can cause import problems during startup.
        import leoTkinterDialog

        d = leoTkinterDialog.tkinterAskOk(
            c=None,title='Can not import %s' %(moduleName),
            message=message)
        d.run(modal=True)
#@+node:ekr.20060329083310.1:createDialogFrame
def createDialogFrame(Tk,root,title,message):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    top = Tk.Toplevel(root)
    top.title(title)

    def onKey(event,top=top):
        if event.char.lower() in ('\n','\r'):
            top.destroy()
    top.bind("<Key>",onKey)

    f = Tk.Frame(top)
    f.pack(side="top",expand=1,fill="both")

    label = Tk.Label(f,text=message)
    label.pack(pady=10)

    def okButton(top=top):
        top.destroy()

    buttons = {"text":'OK',"command":okButton,"default":True}, # Singleton tuple.
    createDialogButtons(Tk,top,buttons)

    center(top)
    top.lift()
    top.focus_force()

    # Attach the icon at idle time.
    def attachIconCallback(top=top):
        g.app.gui.attachLeoIcon(top)
    top.after_idle(attachIconCallback)

    return top
#@-node:ekr.20060329083310.1:createDialogFrame
#@+node:ekr.20060329083310.2:createDialogButtons
def createDialogButtons (Tk,top,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    f = Tk.Frame(top)
    f.pack(side="top",padx=30)

    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
#@-node:ekr.20060329083310.2:createDialogButtons
#@+node:ekr.20060329085417.1:center
def center(top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = g.get_window_info(top)

    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))

    return w,h,x,y
#@-node:ekr.20060329085417.1:center
#@+node:ekr.20060329085612:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (top):

    # This is an emergency measure: this call is NOT a major Tk-dependency.
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)

    return w,h,x,y
#@-node:ekr.20060329085612:get_window_info
#@-node:ekr.20060329083657:cantImportDialog & helpers
#@-node:ekr.20041219071407:g.importExtension & helpers
#@+node:ekr.20031218072017.2278:g.importFromPath
def importFromPath (name,path,pluginName=None,verbose=False):

    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path,app and app.tkEncoding or 'ascii')

    # g.trace(verbose,name,pluginName)
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName,[path]) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                if 0: # verbose:
                    g.es_print("Exception in g.importFromPath",color='blue')
                    g.es_exception()
            except Exception:
                g.es_print("unexpected exception in g.importFromPath(%s)" %
                    (name),color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally: 
            if theFile: theFile.close()

    if not module:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module
#@-node:ekr.20031218072017.2278:g.importFromPath
#@-node:ekr.20041219095213:import wrappers
#@+node:ekr.20040629162023:readLines class and generator
#@+node:EKR.20040612114220.3:g.readLinesGenerator
def readLinesGenerator(s):

    for line in g.splitLines(s):
        # g.trace(repr(line))
        yield line
    yield ''
#@-node:EKR.20040612114220.3:g.readLinesGenerator
#@+node:EKR.20040612114220.4:class readLinesClass
class readLinesClass:

    """A class whose next method provides a readline method for Python's tokenize module."""

    def __init__ (self,s):
        self.lines = g.splitLines(s)
        self.i = 0

    def next(self):
        if self.i < len(self.lines):
            line = self.lines[self.i]
            self.i += 1
        else:
            line = ''
        # g.trace(repr(line))
        return line
#@-node:EKR.20040612114220.4:class readLinesClass
#@-node:ekr.20040629162023:readLines class and generator
#@-node:EKR.20040612114220:Utility classes, functions & objects...
#@+node:ekr.20031218072017.3197:Whitespace...
#@+node:ekr.20051014175117:g.adjustTripleString (same as removeExtraLws)
def adjustTripleString (s,tab_width):

    '''Remove leading indentation from a triple-quoted string.

    This works around the fact that Leo nodes can't represent underindented strings.
    '''

    # Compute the minimum leading whitespace of all non-blank lines.
    lines = g.splitLines(s)
    w = -1
    for s in lines:
       if s.strip():
            lws = g.get_leading_ws(s)
            w2 = g.computeWidth(lws,tab_width)
            if w < 0: w = w2
            else:     w = min(w,w2)
            # g.trace('w',w)
    if w <= 0: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)

    return result
#@-node:ekr.20051014175117:g.adjustTripleString (same as removeExtraLws)
#@+node:ekr.20031218072017.3198:computeLeadingWhitespace
# Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespace (width, tab_width):

    if width <= 0:
        return ""
    if tab_width > 1:
        tabs   = width / tab_width
        blanks = width % tab_width
        return ('\t' * tabs) + (' ' * blanks)
    else: # 7/3/02: negative tab width always gets converted to blanks.
        return (' ' * width)
#@-node:ekr.20031218072017.3198:computeLeadingWhitespace
#@+node:ekr.20031218072017.3199:computeWidth
# Returns the width of s, assuming s starts a line, with indicated tab_width.

def computeWidth (s, tab_width):

    w = 0
    for ch in s:
        if ch == '\t':
            w += (abs(tab_width) - (w % abs(tab_width)))
        else:
            w += 1
    return w
#@-node:ekr.20031218072017.3199:computeWidth
#@+node:ekr.20031218072017.3200:get_leading_ws
def get_leading_ws(s):

    """Returns the leading whitespace of 's'."""

    i = 0 ; n = len(s)
    while i < n and s[i] in (' ','\t'):
        i += 1
    return s[0:i]
#@-node:ekr.20031218072017.3200:get_leading_ws
#@+node:ekr.20031218072017.3201:optimizeLeadingWhitespace
# Optimize leading whitespace in s with the given tab_width.

def optimizeLeadingWhitespace (line,tab_width):

    i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
    s = g.computeLeadingWhitespace(width,tab_width) + line[i:]
    return s
#@-node:ekr.20031218072017.3201:optimizeLeadingWhitespace
#@+node:ekr.20040723093558:regularizeTrailingNewlines
@

The caller should call g.stripBlankLines before calling this routine if desired.

This routine does _not_ simply call rstrip(): that would delete all trailing whitespace-only lines, and in some cases that would change the meaning of program or data.

@c

def regularizeTrailingNewlines(s,kind):

    """Kind is 'asis', 'zero' or 'one'."""

    pass
#@-node:ekr.20040723093558:regularizeTrailingNewlines
#@+node:ekr.20031218072017.3202:removeLeadingWhitespace
# Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

    j = 0 ; ws = 0
    for ch in s:
        if ws >= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j > 0:
        s = s[j:]
    return s
#@-node:ekr.20031218072017.3202:removeLeadingWhitespace
#@+node:ekr.20050211120242.2:g.removeExtraLws & tests
def removeExtraLws (s,tab_width):

    '''Remove extra indentation from one or more lines.

    Warning: used by getScript.  This is *not* the same as g.adjustTripleString.'''

    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for s in lines:
       if s.strip():
            lws = g.get_leading_ws(s)
            w = g.computeWidth(lws,tab_width)
            # g.trace('w',w)
            break
    else: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)

    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            print repr(line)

    return result
#@+node:ekr.20050211120837:test_g_removeExtraLws
def test_g_removeExtraLws():

    # pychecker complains about c and p.

    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
#@-node:ekr.20050211120837:test_g_removeExtraLws
#@-node:ekr.20050211120242.2:g.removeExtraLws & tests
#@+node:ekr.20031218072017.3203:removeTrailingWs
# Warning: string.rstrip also removes newlines!

def removeTrailingWs(s):

    j = len(s)-1
    while j >= 0 and (s[j] == ' ' or s[j] == '\t'):
        j -= 1
    return s[:j+1]
#@-node:ekr.20031218072017.3203:removeTrailingWs
#@+node:ekr.20031218072017.3204:skip_leading_ws
# Skips leading up to width leading whitespace.

def skip_leading_ws(s,i,ws,tab_width):

    count = 0
    while count < ws and i < len(s):
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break

    return i
#@-node:ekr.20031218072017.3204:skip_leading_ws
#@+node:ekr.20031218072017.3205:skip_leading_ws_with_indent
def skip_leading_ws_with_indent(s,i,tab_width):

    """Skips leading whitespace and returns (i, indent), 

    - i points after the whitespace
    - indent is the width of the whitespace, assuming tab_width wide tabs."""

    count = 0 ; n = len(s)
    while i < n:
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break

    return i, count
#@-node:ekr.20031218072017.3205:skip_leading_ws_with_indent
#@+node:ekr.20040723093558.1:stripBlankLines
def stripBlankLines(s):

    lines = g.splitLines(s)

    for i in xrange(len(lines)):

        line = lines[i]
        j = g.skip_ws(line,0)
        if j >= len(line):
            lines[i] = ''
            # g.trace("%4d %s" % (i,repr(lines[i])))
        elif line[j] == '\n':
            lines[i] = '\n'
            # g.trace("%4d %s" % (i,repr(lines[i])))

    return ''.join(lines)
#@-node:ekr.20040723093558.1:stripBlankLines
#@-node:ekr.20031218072017.3197:Whitespace...
#@+node:ekr.20060913091602:ZODB support
#@+node:ekr.20060913090832.1:g.init_zodb
init_zodb_import_failed = False
init_zodb_failed = {} # Keys are paths, values are True.
init_zodb_db = {} # Keys are paths, values are ZODB.DB instances.

def init_zodb (pathToZodbStorage,verbose=True):

    '''Return an ZODB.DB instance from ZODB.FileStorage.FileStorage(pathToZodbStorage)
    return None on any error.'''

    global init_zodb_db, init_zodb_failed, init_zodb_import_failed

    db = init_zodb_db.get(pathToZodbStorage)
    if db: return db

    if init_zodb_import_failed: return None

    failed = init_zodb_failed.get(pathToZodbStorage)
    if failed: return None

    try:
        import ZODB
    except ImportError:
        if verbose:
            g.es('g.init_zodb: can not import ZODB')
            g.es_exception()
        init_zodb_import_failed = True
        return None

    try:
        storage = ZODB.FileStorage.FileStorage(pathToZodbStorage)
        init_zodb_db [pathToZodbStorage] = db = ZODB.DB(storage)
        return db
    except Exception:
        if verbose:
            g.es('g.init_zodb: exception creating ZODB.DB instance')
            g.es_exception()
        init_zodb_failed [pathToZodbStorage] = True
        return None
#@nonl
#@-node:ekr.20060913090832.1:g.init_zodb
#@-node:ekr.20060913091602:ZODB support
#@-node:ekr.20031218072017.3093:@thin leoGlobals.py
#@+node:ekr.20031218072017.3206:@thin leoImport.py
@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import leoTest # Support for unit tests.

import re
import string

class baseLeoImportCommands:
    """The base class for Leo's import commands."""
    @others

class leoImportCommands (baseLeoImportCommands):
    """A class that implements Leo's import commands."""
    pass
#@+node:ekr.20031218072017.3207:import.__init__
def __init__ (self,c):

    self.c = c

    # New in 4.3: honor any tabwidth directive in effect when importing files.
    self.tabwidth = c.tab_width

    # Set by ImportFilesFommand.
    self.treeType = "@file" # "@root" or "@file"
    # Set by ImportWebCommand.
    self.webType = "@noweb" # "cweb" or "noweb"

    # Set by create_outline.
    self.fileName = None # The original file name, say x.cpp
    self.methodName = None # x, as in < < x methods > > =
    self.fileType = None # ".py", ".c", etc.
    self.rootLine = "" # Empty or @root + self.fileName

    # Support of output_newline option
    self.output_newline = g.getOutputNewline(c=c)

    # Used by Importers.
    self.web_st = []
    self.encoding = g.app.tkEncoding # 2/25/03: was "utf-8"
    self._forcedGnxPositionList = []
#@-node:ekr.20031218072017.3207:import.__init__
#@+node:ekr.20031218072017.3209:Import
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent):

    c = self.c ; u = c.undoer
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".lua", ".pas", ".py", ".pyw", ".php")
    << Read file into s >>
    # Create the top-level headline.
    undoData = u.beforeInsertNode(parent)
    p = parent.insertAsLastChild()
    if self.treeType == "@file":
        p.initHeadString("@file " + fileName)
    else:
        p.initHeadString(fileName)
    u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        c.setBodyString(p,body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p)
    elif ext == ".el":
        self.scanElispText(s,p)
    elif ext in (".fs", ".fi"):
        self.scanForthText(s,p)
    elif ext == ".java":
        self.scanJavaText(s,p,True) #outer level
    elif ext == ".lua":
        self.scanLuaText(s,p)
    elif ext == ".pas":
        self.scanPascalText(s,p)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p)
    elif ext == ".php":
        self.scanPHPText(s,p) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20041126042730:getTabWidth
def getTabWidth (self):

    d = g.scanDirectives(self.c)
    w = d.get("tabwidth")
    if w not in (0,None):
        return w
    else:
        return self.c.tab_width
#@-node:ekr.20041126042730:getTabWidth
#@+node:ekr.20031218072017.1810:importDerivedFiles
def importDerivedFiles (self,parent=None,paths=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            g.setGlobalOpenDir(fileName)
            << set isThin if fileName is a thin derived file >>
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()
#@+node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
#@-node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
#@+node:ekr.20051208100903.1:forceGnxOnPosition
def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)
#@-node:ekr.20051208100903.1:forceGnxOnPosition
#@-node:ekr.20031218072017.1810:importDerivedFiles
#@+node:ekr.20031218072017.3212:importFilesCommand
def importFilesCommand (self,files=None,treeType=None,
    perfectImport=True,testing=False,verbose=False):
        # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) < 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    c.beginUpdate()
    try: # range of update...
        if len(files) == 2:
            << Create a parent for two files having a common prefix >>
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                perfectImport = False ###
                testing = True; verbose = True
                if perfectImport and treeType == "@file": # Can't correct @root trees.
                    self.perfectImport(fileName,v,testing=testing,verbose=verbose,verify=False)
                else:
                    g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    finally:
        c.endUpdate()
    c.selectVnode(current)
#@+node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) > 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)
#@-node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
#@-node:ekr.20031218072017.3212:importFilesCommand
#@+node:ekr.20031218072017.3214:importFlattenedOutline & allies
#@+node:ekr.20031218072017.3215:convertMoreString/StringsToOutlineAfter
# Used by paste logic.

def convertMoreStringToOutlineAfter (self,s,firstVnode):
    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.convertMoreStringsToOutlineAfter(strings,firstVnode)

# Almost all the time spent in this command is spent here.

def convertMoreStringsToOutlineAfter (self,strings,firstVnode):

    __pychecker__ = '--no-objattrs' # suppress bad warnings re lastVnode.

    c = self.c
    if len(strings) == 0: return None
    if not self.stringsAreValidMoreFile(strings): return None
    c.beginUpdate()
    try: # range of update...
        firstLevel, junk = self.moreHeadlineLevel(strings[0])
        lastLevel = -1 ; theRoot = lastVnode = None
        index = 0
        while index < len(strings):
            progress = index
            s = strings[index]
            level, newFlag = self.moreHeadlineLevel(s)
            level -= firstLevel
            if level >= 0:
                << Link a new vnode v into the outline >>
                << Set the headline string, skipping over the leader >>
                << Count the number of following body lines >>
                << Add the lines to the body text of v >>
                v.setDirty()
            else: index += 1
            assert progress < index
        if theRoot:
            theRoot.setDirty()
            c.setChanged(True)
    finally:
        c.endUpdate()
    return theRoot
#@+node:ekr.20031218072017.3216:<< Link a new vnode v into the outline >>
assert(level >= 0)
if lastVnode is None:
    # g.trace(firstVnode)
    theRoot = v = firstVnode.insertAfter()
elif level == lastLevel:
    v = lastVnode.insertAfter()
elif level == lastLevel + 1:
    v = lastVnode.insertAsNthChild(0)
else:
    assert(level < lastLevel)
    while level < lastLevel:
        lastLevel -= 1
        lastVnode = lastVnode.parent()
        assert(lastVnode)
        assert(lastLevel >= 0)
    v = lastVnode.insertAfter()
lastVnode = v
lastLevel = level
#@-node:ekr.20031218072017.3216:<< Link a new vnode v into the outline >>
#@+node:ekr.20031218072017.3217:<< Set the headline string, skipping over the leader >>
j = 0
while g.match(s,j,'\t'):
    j += 1
if g.match(s,j,"+ ") or g.match(s,j,"- "):
    j += 2

v.initHeadString(s[j:])
#@-node:ekr.20031218072017.3217:<< Set the headline string, skipping over the leader >>
#@+node:ekr.20031218072017.3218:<< Count the number of following body lines >>
bodyLines = 0
index += 1 # Skip the headline.
while index < len(strings):
    s = strings[index]
    level, junk = self.moreHeadlineLevel(s)
    level -= firstLevel
    if level >= 0:
        break
    # Remove first backslash of the body line.
    if g.match(s,0,'\\'):
        strings[index] = s[1:]
    bodyLines += 1
    index += 1
#@-node:ekr.20031218072017.3218:<< Count the number of following body lines >>
#@+node:ekr.20031218072017.3219:<< Add the lines to the body text of v >>
if bodyLines > 0:
    body = ""
    n = index - bodyLines
    while n < index:
        body += strings[n]
        if n != index - 1:
            body += "\n"
        n += 1
    v.setTnodeText(body)
#@-node:ekr.20031218072017.3219:<< Add the lines to the body text of v >>
#@-node:ekr.20031218072017.3215:convertMoreString/StringsToOutlineAfter
#@+node:ekr.20031218072017.3220:importFlattenedOutline
def importFlattenedOutline (self,files): # Not a command, so no event arg.

    c = self.c ; u = c.undoer ; current = c.currentPosition()
    if current == None: return
    if len(files) < 1: return

    self.setEncoding()
    fileName = files[0] # files contains at most one file.
    g.setGlobalOpenDir(fileName)
    << Read the file into array >>

    # Convert the string to an outline and insert it after the current node.
    undoData = u.beforeInsertNode(current)
    p = self.convertMoreStringsToOutlineAfter(array,current)
    if p:
        c.endEditing()
        c.validateOutline()
        c.editPosition(p)
        p.setDirty()
        c.setChanged(True)
        u.afterInsertNode(p,'Import',undoData)
    else:
        g.es(fileName + " is not a valid MORE file.")
#@+node:ekr.20031218072017.3221:<< Read the file into array >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = string.replace(s,"\r","")
    s = g.toUnicode(s,self.encoding)
    array = string.split(s,"\n")
    theFile.close()
except IOError:
    g.es("Can not open " + fileName, color="blue")
    leoTest.fail()
    return
#@-node:ekr.20031218072017.3221:<< Read the file into array >>
#@-node:ekr.20031218072017.3220:importFlattenedOutline
#@+node:ekr.20031218072017.3222:moreHeadlineLevel
# return the headline level of s,or -1 if the string is not a MORE headline.
def moreHeadlineLevel (self,s):

    level = 0 ; i = 0
    while g.match(s,i,'\t'):
        level += 1
        i += 1
    plusFlag = g.choose(g.match(s,i,"+"),True,False)
    if g.match(s,i,"+ ") or g.match(s,i,"- "):
        return level, plusFlag
    else:
        return -1, plusFlag
#@-node:ekr.20031218072017.3222:moreHeadlineLevel
#@+node:ekr.20031218072017.3223:stringIs/stringsAreValidMoreFile
# Used by paste logic.

def stringIsValidMoreFile (self,s):

    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.stringsAreValidMoreFile(strings)

def stringsAreValidMoreFile (self,strings):

    if len(strings) < 1: return False
    level1, plusFlag = self.moreHeadlineLevel(strings[0])
    if level1 == -1: return False
    # Check the level of all headlines.
    i = 0 ; lastLevel = level1
    while i < len(strings):
        s = strings[i] ; i += 1
        level, newFlag = self.moreHeadlineLevel(s)
        if level > 0:
            if level < level1 or level > lastLevel + 1:
                return False # improper level.
            elif level > lastLevel and not plusFlag:
                return False # parent of this node has no children.
            elif level == lastLevel and plusFlag:
                return False # last node has missing child.
            else:
                lastLevel = level
                plusFlag = newFlag
    return True
#@-node:ekr.20031218072017.3223:stringIs/stringsAreValidMoreFile
#@-node:ekr.20031218072017.3214:importFlattenedOutline & allies
#@+node:ekr.20031218072017.3224:importWebCommand & allies
#@+node:ekr.20031218072017.3225:createOutlineFromWeb
def createOutlineFromWeb (self,path,parent):

    c = self.c ; u = c.undoer
    junk,fileName = g.os_path_split(path)

    undoData = u.beforeInsertNode(parent)

    # Create the top-level headline.
    p = parent.insertAsLastChild()
    p.initHeadString(fileName)
    if self.webType=="cweb":
        c.setBodyString(p,"@ignore\n" + self.rootLine + "@language cweb")

    # Scan the file, creating one section for each function definition.
    self.scanWebFile(path,p)

    u.afterInsertNode(p,'Import',undoData)

    return p
#@-node:ekr.20031218072017.3225:createOutlineFromWeb
#@+node:ekr.20031218072017.3226:importWebCommand
def importWebCommand (self,files,webType):

    c = self.c ; current = c.currentVnode()
    if current == None: return
    if not files: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.webType = webType

    c.beginUpdate()
    try:
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutlineFromWeb(fileName,current)
            v.contract()
            v.setDirty()
            c.setChanged(True)
        c.selectVnode(current)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.3226:importWebCommand
#@+node:ekr.20031218072017.3227:findFunctionDef
def findFunctionDef (self,s,i):

    # Look at the next non-blank line for a function name.
    i = g.skip_ws_and_nl(s,i)
    k = g.skip_line(s,i)
    name = None
    while i < k:
        if g.is_c_id(s[i]):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
        elif s[i] == '(':
            if name: return name
            else: break
        else: i += 1
    return None
#@-node:ekr.20031218072017.3227:findFunctionDef
#@+node:ekr.20031218072017.3228:scanBodyForHeadline
@ This method returns the proper headline text.

1. If s contains a section def, return the section ref.
2. cweb only: if s contains @c, return the function name following the @c.
3. cweb only: if s contains @d name, returns @d name.
4. Otherwise, returns "@"
@c

def scanBodyForHeadline (self,s):

    if self.webType == "cweb":
        << scan cweb body for headline >>
    else:
        << scan noweb body for headline >>
    return "@" # default.
#@+node:ekr.20031218072017.3229:<< scan cweb body for headline >>
i = 0
while i < len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    # Allow constructs such as @ @c, or @ @<.
    if self.isDocStart(s,i):
        i += 2 ; i = g.skip_ws(s,i)
    if g.match(s,i,"@d") or g.match(s,i,"@f"):
        # Look for a macro name.
        directive = s[i:i+2]
        i = g.skip_ws(s,i+2) # skip the @d or @f
        if i < len(s) and g.is_c_id(s[i]):
            j = i ; g.skip_c_id(s,i) ; return s[j:i]
        else: return directive
    elif g.match(s,i,"@c") or g.match(s,i,"@p"):
        # Look for a function def.
        name = self.findFunctionDef(s,i+2)
        return g.choose(name,name,"outer function")
    elif g.match(s,i,"@<"):
        # Look for a section def.
        # A small bug: the section def must end on this line.
        j = i ; k = g.find_on_line(s,i,"@>")
        if k > -1 and (g.match(s,k+2,"+=") or g.match(s,k+2,"=")):
            return s[j:k+2] # return the section ref.
    i = g.skip_line(s,i)
#@-node:ekr.20031218072017.3229:<< scan cweb body for headline >>
#@+node:ekr.20031218072017.3230:<< scan noweb body for headline >>
i = 0
while i < len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if g.match(s,i,"<<"):
        k = g.find_on_line(s,i,">>=")
        if k > -1:
            ref = s[i:k+2]
            name = string.strip(s[i+2:k])
            if name != "@others":
                return ref
    else:
        name = self.findFunctionDef(s,i)
        if name:
            return name
    i = g.skip_line(s,i)
#@-node:ekr.20031218072017.3230:<< scan noweb body for headline >>
#@-node:ekr.20031218072017.3228:scanBodyForHeadline
#@+node:ekr.20031218072017.3231:scanWebFile (handles limbo)
def scanWebFile (self,fileName,parent):

    theType = self.webType
    lb = g.choose(theType=="cweb","@<","<<")
    rb = g.choose(theType=="cweb","@>",">>")

    try: # Read the file into s.
        f = open(fileName)
        s = f.read()
    except:
        g.es("Can not import " + fileName, color="blue")
        return

    << Create a symbol table of all section names >>
    << Create nodes for limbo text and the root section >>
    while i < len(s):
        outer_progress = i
        << Create a node for the next module >>
        assert(i > outer_progress)
#@nonl
#@+node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
i = 0 ; self.web_st = []

while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if self.isDocStart(s,i):
        if theType == "cweb": i += 2
        else: i = g.skip_line(s,i)
    elif theType == "cweb" and g.match(s,i,"@@"):
        i += 2
    elif g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k > -1: self.cstEnter(s[j:k])
    else: i += 1
    assert (i > progress)

# g.trace(self.cstDump())
#@-node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
#@+node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
i = 0
while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isModuleStart(s,i) or g.match(s,i,lb):
        break
    else: i = g.skip_line(s,i)
    assert(i > progress)

j = g.skip_ws(s,0)
if j < i:
    self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if g.match(s,i,lb):
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        else: i = g.skip_line(s,i)
        assert(i > progress)
    self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))

# g.trace(g.get_line(s,i))
#@-node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
#@+node:ekr.20031218072017.3234:<< Create a node for the next module >>
if theType=="cweb":
    assert(self.isModuleStart(s,i))
    start = i
    if self.isDocStart(s,i):
        i += 2
        while i < len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i): break
            else: i = g.skip_line(s,i)
            assert (i > progress)
    << Handle cweb @d, @f, @c and @p directives >>
else:
    assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
    start = i ; i = g.skip_line(s,i)
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i): break
        else: i = g.skip_line(s,i)
        assert (i > progress)

body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)
#@+node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
if g.match(s,i,"@d") or g.match(s,i,"@f"):
    i += 2 ; i = g.skip_line(s,i)
    # Place all @d and @f directives in the same node.
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
        else: break
        assert (i > progress)
    i = g.skip_ws_and_nl(s,i)

while i < len(s) and not self.isModuleStart(s,i):
    progress = i
    i = g.skip_line(s,i)
    i = g.skip_ws_and_nl(s,i)
    assert (i > progress)

if g.match(s,i,"@c") or g.match(s,i,"@p"):
    i += 2
    while i < len(s):
        progress = i
        i = g.skip_line(s,i)
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        assert (i > progress)
#@-node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
#@-node:ekr.20031218072017.3234:<< Create a node for the next module >>
#@-node:ekr.20031218072017.3231:scanWebFile (handles limbo)
#@+node:ekr.20031218072017.3236:Symbol table
#@+node:ekr.20031218072017.3237:cstCanonicalize
# We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.

def cstCanonicalize (self,s,lower=True):

    if lower:
        s = string.lower(s)
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"\r","")
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
#@-node:ekr.20031218072017.3237:cstCanonicalize
#@+node:ekr.20031218072017.3238:cstDump
def cstDump (self):

    self.web_st.sort()
    s = "Web Symbol Table...\n\n"
    for name in self.web_st:
        s += name + "\n"
    return s
#@-node:ekr.20031218072017.3238:cstDump
#@+node:ekr.20031218072017.3239:cstEnter
# We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter (self,s):

    # Don't enter names that end in "..."
    s = string.rstrip(s)
    if s.endswith("..."): return

    # Put the section name in the symbol table, retaining capitalization.
    lower = self.cstCanonicalize(s,True)  # do lower
    upper = self.cstCanonicalize(s,False) # don't lower.
    for name in self.web_st:
        if string.lower(name) == lower:
            return
    self.web_st.append(upper)
#@-node:ekr.20031218072017.3239:cstEnter
#@+node:ekr.20031218072017.3240:cstLookup
# This method returns a string if the indicated string is a prefix of an entry in the web_st.

def cstLookup (self,target):

    # Do nothing if the ... convention is not used.
    target = string.strip(target)
    if not target.endswith("..."): return target
    # Canonicalize the target name, and remove the trailing "..."
    ctarget = target[:-3]
    ctarget = self.cstCanonicalize(ctarget)
    ctarget = string.strip(ctarget)
    found = False ; result = target
    for s in self.web_st:
        cs = self.cstCanonicalize(s)
        if cs[:len(ctarget)] == ctarget:
            if found:
                g.es("****** " + target + ": is also a prefix of: " + s)
            else:
                found = True ; result = s
                # g.es("replacing: " + target + " with: " + s)
    return result
#@-node:ekr.20031218072017.3240:cstLookup
#@-node:ekr.20031218072017.3236:Symbol table
#@-node:ekr.20031218072017.3224:importWebCommand & allies
#@+node:EKR.20040506075328.2:perfectImport
def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):

    __pychecker__ = 'maxlines=500'

    << about this algorithm >>
    c = self.c
    root = p.copy()
    at = c.atFileCommands
    if testing:
        << clear all dirty bits >>
    << Assign file indices >>
    << Write root's tree to to string s >>

    # Set up the data for the algorithm.
    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension(fileName)
    fat_lines = g.splitLines(s) # Keep the line endings.
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    j_lines = file(fileName).readlines()

    # Correct write_lines using the algorihm.
    if i_lines != j_lines:
        if verbose:
            g.es("Running Perfect Import",color="blue")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        if 1: # For testing.
            << put the corrected fat lines in a new node >>
        << correct root's tree using write_lines >>
    if verify:
        << verify that writing the tree would produce the original file >>
#@+node:ekr.20040717112739:<< about this algorithm >>
@nocolor
@

This algorithm corrects the result of an Import To @file command so that it is guaranteed that the result of writing the imported file will be identical to the original file except for any sentinels that have been inserted.

On entry, p points to the newly imported outline.

We correct the outline by applying Bernhard Mulder's algorithm.

1.  We use the atFile.write code to write the newly imported outline to a string s.  This string contains represents a thin derived file, so it can be used to recreate then entire outline structure without any other information.

Splitting s into lines creates the fat_lines argument to mu methods.

2. We make corrections to fat_lines using Mulder's algorithm.  The corrected fat_lines represents the corrected outline.  To do this, we set the arguments as follows:

- i_lines: fat_lines stripped of sentinels
- j_lines to the lines of the original imported file.

The algorithm updates fat_lines using diffs between i_lines and j_lines.

3. Mulder's algorithm doesn't specify which nodes have been changed.  In fact, it Mulder's algorithm doesn't really understand nodes at all.  Therefore, if we want to mark changed nodes we do so by comparing the original version of the imported outline with the corrected version of the outline.
#@-node:ekr.20040717112739:<< about this algorithm >>
#@+node:ekr.20040716065356:<< clear all dirty bits >>
for p2 in p.self_and_subtree_iter():
    p2.clearDirty()
#@-node:ekr.20040716065356:<< clear all dirty bits >>
#@+node:ekr.20040716064333:<< Assign file indices  >>
nodeIndices = g.app.nodeIndices

nodeIndices.setTimestamp()

for p2 in root.self_and_subtree_iter():
    try: # Will fail for None or any pre 4.1 file index.
        theId,time,n = p2.v.t.fileIndex
    except TypeError:
        p2.v.t.fileIndex = nodeIndices.getNewIndex()
#@-node:ekr.20040716064333:<< Assign file indices  >>
#@+node:ekr.20040716064333.1:<< Write root's tree to to string s >>
at.write(root,thinFile=True,toString=True)
s = at.stringOutput
if not s: return
#@-node:ekr.20040716064333.1:<< Write root's tree to to string s >>
#@+node:ekr.20040717132539:<< put the corrected fat lines in a new node >>
write_lines_node = root.insertAfter()
write_lines_node.initHeadString("write_lines")
s = ''.join(write_lines)
write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)
#@-node:ekr.20040717132539:<< put the corrected fat lines in a new node >>
#@+node:ekr.20040717113036:<< correct root's tree using write_lines >>
@ Notes:
1. This code must overwrite the newly-imported tree because the gnx's in
write_lines refer to those nodes.

2. The code in readEndNode now reports when nodes change during importing. This
code also marks changed nodes.
@c

try:
    at.correctedLines = 0
    at.targetFileName = "<perfectImport string-file>"
    at.inputFile = fo = g.fileLikeObject()
    at.file = fo # Strange, that this is needed.  Should be cleaned up.
    for line in write_lines:
        fo.write(line)
    firstLines,junk,junk = c.atFileCommands.scanHeader(fo,at.targetFileName)
    # To do: pass params to readEndNode.
    at.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
    n = at.correctedLines
    if verbose:
        g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
except:
    g.es("Exception in Perfect Import",color="red")
    g.es_exception()
    s = None
#@-node:ekr.20040717113036:<< correct root's tree using write_lines >>
#@+node:ekr.20040718035658:<< verify that writing the tree would produce the original file >>
try:
    # Read the original file into before_lines.
    before = file(fileName)
    before_lines = before.readlines()
    before.close()

    # Write the tree into after_lines.
    at.write(root,thinFile=True,toString=True)
    after_lines1 = g.splitLines(at.stringOutput)

    # Strip sentinels from after_lines and compare.
    after_lines = mu.removeSentinelsFromLines(after_lines1,delims)

    # A major kludge: Leo can not represent unindented blank lines in indented nodes!
    # We ignore the problem here by stripping whitespace from blank lines.
    # We shall need output options to handle such lines.
    if convertBlankLines:
        mu.stripWhitespaceFromBlankLines(before_lines)
        mu.stripWhitespaceFromBlankLines(after_lines)
    if before_lines == after_lines:
        if verbose:
            g.es("Perfect Import verified",color="blue")
    else:
        leoTest.fail()
        if verbose:
            g.es("Perfect Import failed verification test!",color="red")
            << dump the files >>
except IOError:
    g.es("Can not reopen %s!" % fileName,color="red")
    leoTest.fail()
#@+node:ekr.20040718045423:<< dump the files >>
print len(before_lines),len(after_lines)

if len(before_lines)==len(after_lines):
    for i in xrange(len(before_lines)):
        extra = 3
        if before_lines[i] != after_lines[i]:
            j = max(0,i-extra)
            print '-' * 20
            while j < i + extra + 1:
                leader = g.choose(i == j,"* ","  ")
                print "%s%3d" % (leader,j), repr(before_lines[j])
                print "%s%3d" % (leader,j), repr(after_lines[j])
                j += 1
else:
    for i in xrange(min(len(before_lines),len(after_lines))):
        if before_lines[i] != after_lines[i]:
            extra = 5
            print "first mismatch at line %d" % i
            print "printing %d lines after mismatch" % extra
            print "before..."
            for j in xrange(i+1+extra):
                print "%3d" % j, repr(before_lines[j])
            print
            print "after..."
            for k in xrange(1+extra):
                print "%3d" % (i+k), repr(after_lines[i+k])
            print
            print "with sentinels"
            j = 0 ; k = 0
            while k < i + 1 + extra:
                print "%3d" % k,repr(after_lines1[j])
                if not g.is_sentinel(after_lines1[j],delims):
                    k += 1
                j += 1
            break
#@-node:ekr.20040718045423:<< dump the files >>
#@-node:ekr.20040718035658:<< verify that writing the tree would produce the original file >>
#@-node:EKR.20040506075328.2:perfectImport
#@+node:ekr.20031218072017.3241:Scanners for createOutline
#@+node:ekr.20031218072017.2256:Python scanners & tests
#@+node:ekr.20031218072017.2257:scanPythonClass & helpers
def scanPythonClass (self,s,i,start,parent):

    """Creates a child node c of parent for the class, and children of c for each def in the class."""

    # g.trace(g.get_line(s,i))
    c = self.c
    class_indent = self.getLeadingIndent(s,i)
    << set class_name and headline >>
    if not class_name: return i
    i = g.skip_line(s,i) # Skip the class line.
    i,prefix,body = self.createClassNodeText(s,i,start)
    class_vnode = self.createHeadline(parent,prefix + body,headline)
    savedMethodName = self.methodName
    self.methodName = headline
    # Create a node for leading declarations of the class.
    i = self.scanPythonDecls(s,i,class_vnode,class_indent,indent_parent_ref_flag=True)
    start,i = self.scanPythonClassHelper(s,i,class_indent,class_name,class_vnode)
    s2 = s[start:i]
    if s2: c.appendStringToBody(class_vnode,s2)
    self.methodName = savedMethodName
    return i
#@+node:ekr.20031218072017.2258:<< set class_name and headline >>
# Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    class_name = s[j:i]
    headline = "class " + class_name
else:
    headline = ''
    class_name = ''
#@-node:ekr.20031218072017.2258:<< set class_name and headline >>
#@+node:ekr.20060626100102:scanPythonClassHelper
def scanPythonClassHelper(self,s,i,class_indent,class_name,class_vnode):

    indent =  self.getLeadingIndent(s,i)
    start = i = g.skip_blank_lines(s,i)
    parent_vnode = None
    while i < len(s):
        progress = i
        # New in Leo 4.4.1: ignore comment lines, whatever their indentation.
        if indent <= class_indent:
            j = g.skip_ws(s,i)
            if g.match(s,j,'#'):
                i = g.skip_to_end_of_line(s,j)
            else: break
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            j = g.skip_nl(s,i)
            if not backslashNewline:
                indent = self.getLeadingIndent(s,j)
                if indent > class_indent: i = j
                else: break
            else: i = j
        elif g.match_c_word(s,i,"def"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonDef(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif g.match_c_word(s,i,"class"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonClass(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
        elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
        else: i += 1
        assert(progress < i)
    return start,i
#@-node:ekr.20060626100102:scanPythonClassHelper
#@+node:ekr.20060626101103.1:createParentText
def createParentText (self,class_vnode,class_name):

    '''Insert the proper body text in the class_vnode.'''

    c = self.c

    # This must be done after the declaration reference is generated.
    if self.treeType == "@file":
        c.appendStringToBody(class_vnode,"\t@others\n")
    else:
        ref = g.angleBrackets(' class %s methods ' % (class_name))
        c.appendStringToBody(class_vnode,"\t" + ref + "\n\n")
#@-node:ekr.20060626101103.1:createParentText
#@+node:ekr.20060626103415:createClassNodeText
def createClassNodeText (self,s,i,start):

    # Create the section name using the old value of self.methodName.
    if  self.treeType == "@file":
        prefix = ""
    else:
        prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
        self.methodsSeen = True

    # i points just after the class line.

    # Add a docstring to the class node.
    docStringSeen = False
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j != len(s): # No scanning error.
            i = j ; docStringSeen = True

    body = s[start:i]
    body = self.undentBody(body)
    if docStringSeen: body = body + '\n'

    return i,prefix,body
#@-node:ekr.20060626103415:createClassNodeText
#@-node:ekr.20031218072017.2257:scanPythonClass & helpers
#@+node:ekr.20031218072017.2263:scanPythonDef
def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    << set headline or return i >>
    i = self.skipPythonDef(s,i,start)
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    << Create def node >>
    self.methodName = savedMethodName
    return i
#@+node:ekr.20031218072017.2264:<< set headline or return i >>
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i
#@-node:ekr.20031218072017.2264:<< set headline or return i >>
#@+node:ekr.20031218072017.2266:<< Create def node >>
# Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)
#@-node:ekr.20031218072017.2266:<< Create def node >>
#@-node:ekr.20031218072017.2263:scanPythonDef
#@+node:ekr.20031218072017.2267:scanPythonDecls
def scanPythonDecls (self,s,i,parent,indent,indent_parent_ref_flag=True):

    c = self.c
    done = False ; start = i
    while not done and i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n':
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            # 2/14/03: break on lesser indention.
            j = g.skip_ws(s,i)
            if not g.is_nl(s,j) and not g.match(s,j,"#") and not backslashNewline:
                lineIndent = self.getLeadingIndent(s,i)
                if lineIndent <= indent:
                    break
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << break on def or class >>
        else: i += 1
        assert(progress < i)
    j = g.skip_blank_lines(s,start)
    if g.is_nl(s,j): j = g.skip_nl(s,j)
    if j < i:
        << Create a child node for declarations >>
    return i
#@+node:ekr.20031218072017.2268:<< break on def or class >>
if g.match_c_word(s,i,"def") or g.match_c_word(s,i,"class"):
    i = g.find_line_start(s,i)
    done = True
    break
else:
    i = g.skip_c_id(s,i)
#@-node:ekr.20031218072017.2268:<< break on def or class >>
#@+node:ekr.20031218072017.2269:<< Create a child node for declarations >>
headline = ref = g.angleBrackets(" " + self.methodName + " declarations ")
leading_tab = g.choose(indent_parent_ref_flag,"\t","")

# Append the reference to the parent's body.
c.appendStringToBody(parent,leading_tab + ref + "\n") # 7/6/02

# Create the node for the decls.
body = self.undentBody(s[j:i])
if self.treeType == "@root":
    body = "@code\n\n" + body
self.createHeadline(parent,body,headline)
#@-node:ekr.20031218072017.2269:<< Create a child node for declarations >>
#@-node:ekr.20031218072017.2267:scanPythonDecls
#@+node:ekr.20031218072017.2270:scanPythonText
# See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    c = self.c
    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << handle possible Python function or class >>
        else: i += 1
        assert(progress < i)
    if not decls_seen: # 2/17/03
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
    << Append a reference to the methods of this file >>
    << Append any unused python text to the parent's body text >>
#@+node:ekr.20031218072017.2271:<< handle possible Python function or class >>
if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file":
            c.appendStringToBody(parent,"@others\n")
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)
#@-node:ekr.20031218072017.2271:<< handle possible Python function or class >>
#@+node:ekr.20031218072017.2272:<< Append a reference to the methods of this file >>
if self.treeType == "@root" and self.methodsSeen:
    c.appendStringToBody(parent,
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
#@-node:ekr.20031218072017.2272:<< Append a reference to the methods of this file >>
#@+node:ekr.20031218072017.2273:<< Append any unused python text to the parent's body text >>
# Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i < len(s):
    c.appendStringToBody(parent,s[start:])
#@-node:ekr.20031218072017.2273:<< Append any unused python text to the parent's body text >>
#@-node:ekr.20031218072017.2270:scanPythonText
#@+node:ekr.20060626083237.1:skipPythonDef
def skipPythonDef (self,s,i,start):

    # g.trace(g.get_line(s,i))

    # Set defIndent to the indentation of the def line.
    defIndent = self.getLeadingIndent(s,start)
    parenCount = 0
    << skip the entire signature >>
    indent = self.getLeadingIndent(s,i)
    while i < len(s): # and indent > defIndent
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            if not backslashNewline:
                # New in Leo 4.4.1: don't set indent for comment lines.
                j = g.skip_ws(s,i)
                if not g.match(s,j,'#'):
                    indent = self.getLeadingIndent(s,i)
                    if indent <= defIndent and parenCount == 0:
                        break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)

    return i
#@+node:ekr.20060627062652:<< skip the entire signature >>
# Now that we count parens, we must be careful to skip the entire signature.

j = s.find('(',i)
if j != -1:
    j = g.skip_matching_python_parens(s,j)

if j == -1 or not g.match(s,j+1,':'):
    g.es_print('Warning: improper signature: %s' % g.get_line(s,i))
    return i
else:
    i = g.skip_line(s,j) # Still not quite 100% correct.
#@-node:ekr.20060627062652:<< skip the entire signature >>
#@-node:ekr.20060626083237.1:skipPythonDef
#@+node:ekr.20060626083237.2:test_skipPythonDef
def test_skipPythonDef (self):

    global c # Get syntax warning if this is not first.
    if self: c = self.c             # Run from @test node: c not global
    else: self = c.importCommands   # Run from @suite: c *is* global

    d = g.scanDirectives(c)
    self.tab_width = d.get("tabwidth")
    verbose = False
    << define s >>
    start = 0
    i = self.skipPythonDef(s,i=0,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test1') and result.endswith('return 1'),'result:\n%s' % result
    start = i
    i = self.skipPythonDef(s,i=i,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test2') and result.endswith('pass'),'result:\n%s' % result
#@+node:ekr.20060626083725:<< define s >>
s = '''\
def test1():
    aList = (a,
b,c)
# underindented comment.
    return 1

def test2():
# underindented comment.
    pass
'''

s = g.adjustTripleString(s,self.tab_width)
#@-node:ekr.20060626083725:<< define s >>
#@-node:ekr.20060626083237.2:test_skipPythonDef
#@+node:ekr.20060627063313:test_skipPythonDef2
def test_skipPythonDef2 (self):

    '''Tests of long signature lines.'''

    global c # Get syntax warning if this is not first.
    if self: c = self.c             # Run from @test node: c not global
    else: self = c.importCommands   # Run from @suite: c *is* global

    d = g.scanDirectives(c)
    self.tab_width = d.get("tabwidth")
    verbose = False
    << define s >>
    start = 0
    i = self.skipPythonDef(s,i=0,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test1') and result.endswith('return 1'),'result:\n%s' % result
    start = i
    i = self.skipPythonDef(s,i=i,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test2') and result.endswith('return 2'),'result:\n%s' % result
#@+node:ekr.20060627063313.1:<< define s >>
s = '''\
def test1(
        a=2):
    return 1

def test2(
a=3):
    return 2
'''

s = g.adjustTripleString(s,self.tab_width)
#@-node:ekr.20060627063313.1:<< define s >>
#@-node:ekr.20060627063313:test_skipPythonDef2
#@+node:ekr.20060626100102.1:test_scanPythonClass
def test_scanPythonClass (self):

    # pychecker complains about c.

    global c # Get syntax warning if this is not first.
    if self: c = self.c             # Run from @test node: c not global
    else: self = c.importCommands   # Run from @suite: c *is* global

    d = g.scanDirectives(c)
    self.tab_width = d.get("tabwidth")
    verbose = False
    << define s >>
    start = 0
    i = self.skipPythonDef(s,i=0,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('class aClass') and result.endswith("'eggs'"),'result:\n%s' % result
    start = i
    i = self.skipPythonDef(s,i=i,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('class aClass2') and result.endswith("'twit'"),'result:\n%s' % result
#@+node:ekr.20060626100102.2:<< define s >>
s = '''\
class aClass:
    def spam():
        return 'spam'
# underindented comment line
    def eggs():
        return 'eggs'

class aClass2:
    def twit():
        return 'twit'
'''

s = g.adjustTripleString(s,self.tab_width)
#@-node:ekr.20060626100102.2:<< define s >>
#@-node:ekr.20060626100102.1:test_scanPythonClass
#@-node:ekr.20031218072017.2256:Python scanners & tests
#@+node:ekr.20031218072017.3250:scanCText
# Creates a child of parent for each C function definition seen.

def scanCText (self,s,parent):

    scanner = self.cScanner(self)
    scanner.scan(s,parent)
#@-node:ekr.20031218072017.3250:scanCText
#@+node:ekr.20031218072017.3265:scanElispText & allies
def scanElispText(self,s,p):

    c = self.c
    c.appendStringToBody(p,"@ignore\n@language elisp\n")
    i = 0 ; start = 0
    while i < len(s):
        progress = i
        ch = s[i] ; # g.trace(g.get_line(s,i))
        if ch == ';':
            i = g.skip_line(s,i)
        elif ch == '(':
            j = self.skipElispParens(s,i)
            k = g.skip_ws(s,i+1)
            if g.match_word(s,k,"defun") or g.match_word(s,k,"defconst") or g.match_word(s,k,"defvar"):
                data = s[start:i]
                if data.strip():
                    self.createElispDataNode(p,data)
                self.createElispFunction(p,s[i:j+1])
                start = j+1
            i = j
        else:
            i += 1
        assert(progress < i)
    data = s[start:len(s)]
    if data.strip():
        self.createElispDataNode(p,data)
#@+node:ekr.20031218072017.3266:skipElispParens
def skipElispParens (self,s,i):

    level = 0 ; n = len(s)
    assert(g.match(s,i,'('))

    while i < n:
        c = s[i]
        if c == '(':
            level += 1 ; i += 1
        elif c == ')':
            level -= 1
            if level <= 0:
                return i
            i += 1
        elif c == '"': i = g.skip_string(s,i) # Single-quotes are not strings.
        elif g.match(s,i,";"):  i = g.skip_line(s,i)
        else: i += 1
    return i
#@-node:ekr.20031218072017.3266:skipElispParens
#@+node:ekr.20031218072017.3267:skipElispId
def skipElispId (self,s,i):

    n = len(s)
    while i < n and g.isWordChar(s[i]):
        i += 1
    return i
#@-node:ekr.20031218072017.3267:skipElispId
#@+node:ekr.20031218072017.3268:createElispFunction
def createElispFunction (self,p,s):

    body = s
    i = 1 # Skip the '('
    i = g.skip_ws(s,i)

    # Set the prefix in the headline.
    assert(g.match(s,i,"defun") or g.match_word(s,i,"defconst") or g.match_word(s,i,"defvar"))
    if g.match_word(s,i,"defconst"):
        prefix = "const "
    elif g.match_word(s,i,"defvar"):
        prefix = "var "
    else:
        prefix = ""

    # Skip the "defun" or "defconst" or "defvar"
    i = self.skipElispId(s,i)

    # Get the following id.
    i = g.skip_ws(s,i)
    j = self.skipElispId(s,i)
    theId = prefix + s[i:j]

    self.createHeadline(p,body,theId)
#@-node:ekr.20031218072017.3268:createElispFunction
#@+node:ekr.20031218072017.3269:createElispDataNode
def createElispDataNode (self,p,s):

    data = s
    # g.trace(len(data))

    # Skip blank lines and comment lines.
    i = 0
    while i < len(s):
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,';'):
            i = g.skip_line(s,i)
        else: break

    # Find the next id, probably prefixed by an open paren.
    if g.match(s,i,"("):
        i = g.skip_ws(s,i+1)
    j = self.skipElispId(s,i)
    theId = s[i:j]
    if not theId:
        theId = "unnamed data"

    self.createHeadline(p,data,theId)
#@-node:ekr.20031218072017.3269:createElispDataNode
#@-node:ekr.20031218072017.3265:scanElispText & allies
#@+node:ekr.20041107094641:scanForthText
def scanForthText (self,s,parent):

    """Minimal forth scanner - leave it to user to create nodes as they see fit."""

    self.c.setBodyString(parent,"@ignore\n" + "@language forth\n" + self.rootLine + s)
#@-node:ekr.20041107094641:scanForthText
#@+node:ekr.20031218072017.3270:scanJavaText
# Creates a child of parent for each Java function definition seen.

def scanJavaText (self,s,parent,outerFlag): # True if at outer level.

    __pychecker__ = 'maxlines=500'

    << define scanJavaText vars >>
    # if not outerFlag: g.trace("inner:",s)
    while i < len(s):
        # g.trace(g.get_line(s,i))
        ch = s[i]
        # These cases skip tokens.
        if ch == '/':
            << handle possible Java comments >>
        elif ch == '"' or ch == '\'': i = g.skip_string(s,i)
        # These cases help determine where functions start.
        elif ch == '=':
            << handle equal sign in Java >>
        elif ch == '(':
            << handle open paren in Java >>
        elif ch == ';':
            << handle semicolon in Java >>
            class_seen = False
        # These cases can create child nodes.
        elif ch == '{':
            << handle open curly bracket in Java >>
        elif g.is_c_id(s[i]):
            << skip and remember the Java id >>
        else: i += 1
    << Append any unused text to the parent's body text >>
#@+node:ekr.20031218072017.3271:<< define scanJavaText vars >>
c = self.c
method_seen = False
class_seen = False # True: class keyword seen at outer level.
interface_seen = False # True: interface keyword seen at outer level.
lparen = None  # not None if '(' seen at outer level.
scan_start = 0
name = None
function_start = 0 # g.choose(outerFlag, None, 0)
i = 0
#@-node:ekr.20031218072017.3271:<< define scanJavaText vars >>
#@+node:ekr.20031218072017.3277:<< handle possible Java comments >>
if g.match(s,i,"//"):
    i = g.skip_line(s,i)
elif g.match(s,i,"/*"):
    i = g.skip_block_comment(s,i)
else:
    i += 1
#@-node:ekr.20031218072017.3277:<< handle possible Java comments >>
#@+node:ekr.20031218072017.3278:<< handle equal sign in Java >>
@ We can not be seeing a function definition when we find an equal sign at the top level. Equal signs inside parentheses are handled by the open paren logic.
@c

i += 1 # skip the '='
function_start = 0 # 3/23/03: (bug fix: was None) We can't be in a function.
lparen = None   # We have not seen an argument list yet.
if g.match(s,i,'='):
    i = g.skip_braces(s,i)
#@-node:ekr.20031218072017.3278:<< handle equal sign in Java >>
#@+node:ekr.20031218072017.3279:<< handle open paren in Java >>
lparen = i
# This will skip any equal signs inside the paren.
i = g.skip_parens(s,i)
if g.match(s,i,')'):
    i += 1
    i = g.skip_ws_and_nl(s,i)
    if g.match(s,i,';'):
        lparen = None # not a function definition.
else: lparen = None
#@-node:ekr.20031218072017.3279:<< handle open paren in Java >>
#@+node:ekr.20031218072017.3280:<< handle semicolon in Java >>
@ A semicolon signals the end of a declaration, thereby potentially starting the _next_ function defintion.   Declarations end a function definition unless we have already seen a parenthesis, in which case we are seeing an old-style function definition.
@c

i += 1 # skip the semicolon.
if lparen == None:
    function_start = i + 1 # The semicolon ends the declaration.
#@-node:ekr.20031218072017.3280:<< handle semicolon in Java >>
#@+node:ekr.20031218072017.3272:<< handle open curly bracket in Java >>
brace_ip1 = i
i = g.skip_braces(s,i) # Skip all inner blocks.
brace_ip2 = i

if not g.match (s,i,'}'):
    g.es("unmatched '{'")
elif not name:
    i += 1
elif (outerFlag and (class_seen or interface_seen)) or (not outerFlag and lparen):
    # g.trace("starting:",name)
    # g.trace("outerFlag:",outerFlag)
    # g.trace("lparen:",lparen)
    # g.trace("class_seen:",class_seen)
    # g.trace("scan_start:",g.get_line_after(s,scan_start))
    # g.trace("func_start:",g.get_line_after(s,function_start))
    # g.trace("s:",g.get_line(s,i))

    # Point i _after_ the last character of the method.
    i += 1
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
    function_end = i
    headline = name
    if outerFlag:
        leader = "" ; decl_leader = ""
        if class_seen:
            headline = "class " + headline
            methodKind = "classes"
        else:
            headline = "interface " + headline
            methodKind = "interfaces"
    else:
        leader = "\t" # Indent only inner references.
        decl_leader = "\n"  # Declaration leader for inner references.
        methodKind = "methods"
    if method_seen:
        # Include everything after the last fucntion.
        function_start = scan_start
    else:
        << create a Java declaration node >>
        << append Java method reference to parent node >>
    if outerFlag: # Create a class.
        # Backtrack so we remove leading whitespace.
        function_start = g.find_line_start(s,function_start)
        body = s[function_start:brace_ip1+1]
        body = self.massageBody(body,methodKind)
        v = self.createHeadline(parent,body,headline)
        << recursively scan the text >>
        # Append the brace to the parent.
        c.appendStringToBody(v,"}")
        i = brace_ip2 + 1 # Start after the closing brace.
    else: # Create a method.
        # Backtrack so we remove leading whitespace.
        function_start = g.find_line_start(s,function_start)
        body = s[function_start:function_end]
        body = self.massageBody(body,methodKind)
        self.createHeadline(parent,body,headline)
        i = function_end
    method_seen = True
    scan_start = function_start = i # Set the start of the _next_ function.
    lparen = None ; class_seen = False
else: i += 1
#@+node:ekr.20031218072017.3273:<< create a Java declaration node >>
save_ip = i
i = scan_start
while i < function_start and g.is_ws_or_nl(s,i):
    i += 1

if outerFlag:
    c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language java\n")

if i < function_start:
    decl_headline = g.angleBrackets(" " + self.methodName + " declarations ")

    # Append the headline to the parent's body.
    c.appendStringToBody(parent,decl_leader + leader + decl_headline + "\n")
    scan_start = g.find_line_start(s,scan_start) # Backtrack so we remove leading whitespace.
    decls = s[scan_start:function_start]
    decls = self.undentBody(decls)
    body = g.choose(self.treeType == "@file",decls,"@code\n\n" + decls)
    self.createHeadline(parent,body,decl_headline)

i = save_ip
scan_start = i
#@-node:ekr.20031218072017.3273:<< create a Java declaration node >>
#@+node:ekr.20031218072017.3274:<< append Java method reference to parent node >>
if self.treeType == "@file":
    if outerFlag:
        c.appendStringToBody(parent,"\n@others\n")
    else:
        c.appendStringToBody(parent,"\n\t@others\n")
else:
    kind = g.choose(outerFlag,"classes","methods")
    ref_name = g.angleBrackets(" " + self.methodName + " " + kind + " ")
    c.appendStringToBody(parent,leader + ref_name + "\n")
#@-node:ekr.20031218072017.3274:<< append Java method reference to parent node >>
#@+node:ekr.20031218072017.3275:<< recursively scan the text >>
# These mark the points in the present function.
# g.trace("recursive scan:",g.get_line(s,brace_ip1+ 1))
oldMethodName = self.methodName
self.methodName = headline
self.scanJavaText(s[brace_ip1+1:brace_ip2], # Don't include either brace.
    v,False) # inner level
self.methodName = oldMethodName
#@-node:ekr.20031218072017.3275:<< recursively scan the text >>
#@-node:ekr.20031218072017.3272:<< handle open curly bracket in Java >>
#@+node:ekr.20031218072017.3276:<< skip and remember the Java id >>
if g.match_c_word(s,i,"class") or g.match_c_word(s,i,"interface"):
    if g.match_c_word(s,i,"class"):
        class_seen = True
    else:
        interface_seen = True
    i = g.skip_c_id(s,i) # Skip the class or interface keyword.
    i = g.skip_ws_and_nl(s,i)
    if i < len(s) and g.is_c_id(s[i]):
        # Remember the class or interface name.
        j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
else:
    j = i ; i = g.skip_c_id(s,i)
    if not lparen and not class_seen:
        name = s[j:i] # Remember the name.
#@-node:ekr.20031218072017.3276:<< skip and remember the Java id >>
#@+node:ekr.20031218072017.3264:<< append any unused text to the parent's body text >>
# Used by the Java and Pascal scanners.

i = g.skip_ws_and_nl(s,scan_start)
if i < len(s):
    c.appendStringToBody(parent,s[scan_start:])
#@-node:ekr.20031218072017.3264:<< append any unused text to the parent's body text >>
#@-node:ekr.20031218072017.3270:scanJavaText
#@+node:ekr.20060328112327:scanLuaText
def scanLuaText (self,s,parent):

    """Minimal Lua scanner - leave it to user to create nodes as they see fit."""

    self.c.setBodyString(parent,"@ignore\n" + "@language lua\n" + self.rootLine + s)
#@-node:ekr.20060328112327:scanLuaText
#@+node:ekr.20031218072017.3281:scanPascalText
# Creates a child of parent for each Pascal function definition seen.

def scanPascalText (self,s,parent):

    c = self.c
    method_seen = False ; methodKind = "methods"
    scan_start = function_start = i = 0
    name = None
    while i < len(s):
        # line = g.get_line(s,i) ; g.trace(line)
        ch = s[i]
        if ch == '{': i = g.skip_pascal_braces(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_pascal_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.is_c_id(s[i]):
            << handle possible Pascal function >>
        else: i += 1
    << Append any unused text to the parent's body text >>
#@+node:ekr.20031218072017.3282:<< handle possible Pascal function >>
if g.match_c_word(s,i,"begin"):
    i = g.skip_pascal_begin_end(s,i)
    if g.match_c_word(s,i,"end"):
        i = g.skip_c_id(s,i)
elif (g.match_c_word(s,i,"function")  or g.match_c_word(s,i,"procedure") or
    g.match_c_word(s,i,"constructor") or g.match_c_word(s,i,"destructor")):

    # line = g.get_line(s,i) ; g.trace(line)

    start = i
    i = g.skip_c_id(s,i)
    i = g.skip_ws_and_nl(s,i)
    << remember the function name, or continue >>
    << skip the function definition, or continue >>
    if not method_seen:
        method_seen = True
        << create a child node for leading declarations >>
        << append noweb method reference to the parent node >>
        function_start = start
    else: function_start = scan_start
    << create a child node for the function >>
else: i = g.skip_c_id(s,i)
#@+node:ekr.20031218072017.3285:<< remember the function name, or continue >>
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    while i + 1 < len(s) and s[i] == '.' and g.is_c_id(s[i+1]):
        i += 1 ; j = i
        i = g.skip_c_id(s,i)
    name = s[j:i]
else: continue
#@-node:ekr.20031218072017.3285:<< remember the function name, or continue >>
#@+node:ekr.20031218072017.3286:<< skip the function definition, or continue >>
<< skip past the semicolon >>

if not g.match_c_word(s,i,"begin"):
    continue
# Skip to the matching end.
i = g.skip_pascal_begin_end(s,i)
if g.match_c_word(s,i,"end"):
    i = g.skip_c_id(s,i)
    i = g.skip_ws_and_nl(s,i)
    if g.match(s,i,';'):
        i += 1
    i = g.skip_ws(s,i)
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
else: continue
#@+node:ekr.20031218072017.3287:<< skip past the semicolon >>
while i < len(s) and s[i] != ';':
    # The paremeter list may contain "inner" semicolons.
    if s[i] == '(':
        i = g.skip_parens(s,i)
        if g.match(s,i,')'):
            i += 1
        else: break
    else: i += 1
if g.match(s,i,';'):
    i += 1
i = g.skip_ws_and_nl(s,i)

if g.match_c_word(s,i,"var"):
    # Skip to the next begin.
    i = g.skip_c_id(s,i)
    done = False
    while i < len(s) and not done:
        ch = s[i]
        if ch == '{': i = g.skip_pascal_braces(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.is_c_id(ch):
            if g.match_c_word(s,i,"begin"): done = True
            else: i = g.skip_c_id(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_pascal_string(s,i)
        else: i += 1
#@-node:ekr.20031218072017.3287:<< skip past the semicolon >>
#@-node:ekr.20031218072017.3286:<< skip the function definition, or continue >>
#@+node:ekr.20031218072017.3283:<< create a child node for leading declarations >>
save_ip = i
i = scan_start
while i < start and g.is_ws_or_nl(s,i):
    i += 1
if i < start:
    c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language pascal\n")
    headline = g.angleBrackets(self.methodName + " declarations ")
    # Append the headline to the parent's body.
    c.appendStringToBody(parent,headline + "\n")
    if self.treeType == "@file":
        body = s[scan_start:start]
    else:
        body = "@code\n\n" + s[scan_start:start]
    body = self.undentBody(body)
    self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i
#@-node:ekr.20031218072017.3283:<< create a child node for leading declarations >>
#@+node:ekr.20031218072017.3288:<< append noweb method reference to the parent node >>
# Append the headline to the parent's body.
if self.treeType == "@file":
    c.appendStringToBody(parent,"@others\n")
else:
    c.appendStringToBody(parent,
        g.angleBrackets(" " + self.methodName + " methods ") + "\n")
#@-node:ekr.20031218072017.3288:<< append noweb method reference to the parent node >>
#@+node:ekr.20031218072017.3284:<< create a child node for the function >>
# Point i _after_ the last character of the function.
i = g.skip_ws(s,i)
if g.is_nl(s,i):
    i = g.skip_nl(s,i)
function_end = i
headline = name
body = s[function_start:function_end]
body = self.massageBody(body,methodKind)
self.createHeadline(parent,body,headline)
scan_start = i
#@-node:ekr.20031218072017.3284:<< create a child node for the function >>
#@-node:ekr.20031218072017.3282:<< handle possible Pascal function >>
#@+node:ekr.20031218072017.3264:<< append any unused text to the parent's body text >>
# Used by the Java and Pascal scanners.

i = g.skip_ws_and_nl(s,scan_start)
if i < len(s):
    c.appendStringToBody(parent,s[scan_start:])
#@-node:ekr.20031218072017.3264:<< append any unused text to the parent's body text >>
#@-node:ekr.20031218072017.3281:scanPascalText
#@+node:ekr.20031218072017.3242:scanPHPText (Dave Hein)
# 08-SEP-2002 DTHEIN: Added for PHP import support.
#
# PHP uses both # and // as line comments, and /* */ as block comments

def scanPHPText (self,s,parent):

    __pychecker__ = 'maxlines=500'

    """Creates a child of parent for each class and function definition seen."""

    << define scanPHPText vars >>
    << Append file if not pure PHP >>

    # 14-SEP-2002 DTHEIN: Make leading <?php use the @first directive
    c.appendStringToBody(parent,"@first ")
    c.appendStringToBody(parent,s[:startOfCode])
    scan_start = i = startOfCode
    while i < endOfCode:
        # line = g.get_line(s,i) ; g.trace(line)
        ch = s[i]
        # These cases skip tokens.
        if ch == '/' or ch == '#':
            << handle possible PHP comments >>
        elif ch == '<':
            << handle possible heredoc string >>
        elif ch == '"' or ch == '\'':
            i = g.skip_string(s,i)
        # These cases help determine where functions start.
        # FIXME: probably want to capture 'var's as class member data
        elif ch == 'f' or ch =='c':
            << handle possible class or function >>
        elif class_start and (ch == '}'):
            << handle end of class >>
        else: i += 1
    << Append any unused text to the parent's body text >>
    # 14-SEP-2002 DTHEIN: Make leading <?php use the @first directive
    c.appendStringToBody(parent,"@last ")
    c.appendStringToBody(parent,s[endOfCode:])
#@+node:ekr.20031218072017.3244:<< define scanPHPText vars >>
c = self.c
scan_start = 0
class_start = 0
function_start = 0
i = 0
class_body = ""
class_node = ""
phpClassName = re.compile("class\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")
phpFunctionName = re.compile("function\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")

# 14-SEP-2002 DTHEIN: added these 2 variables to allow use of @first/last
startOfCode = s.find("\n") + 1 # this should be the line containing the initial <?php
endOfCode = s.rfind("?>") # this should be the line containing the last ?>
#@-node:ekr.20031218072017.3244:<< define scanPHPText vars >>
#@+node:ekr.20031218072017.3243:<< Append file if not pure PHP >>
# If the file does not begin with <?php or end with ?> then
# it is simply appended like a generic import would do.

s.strip() # Remove inadvertent whitespace.

if (
    not (
        s.startswith("<?P") or
        s.startswith("<?p") or
        s.startswith("<?=") or
        s.startswith("<?\n") or
        s.startswith("<?\r") or
        s.startswith("<? ") or
        s.startswith("<?\t")
    ) or not (
        s.endswith("?>\n") or
        s.endswith("?>\r") or
        s.endswith("?>\r\n")
    )
):
    g.es("File seems to be mixed HTML and PHP; importing as plain text file.")
    c.setBodyString(parent,"@ignore\n" + self.rootLine + s)
    return
#@-node:ekr.20031218072017.3243:<< Append file if not pure PHP >>
#@+node:ekr.20031218072017.3246:<< handle possible PHP comments >>
if g.match(s,i,"//"):
    i = g.skip_line(s,i)
elif g.match(s,i,"#"):
    i = g.skip_line(s,i)
elif g.match(s,i,"/*"):
    i = g.skip_block_comment(s,i)
else:
    i += 1
#@-node:ekr.20031218072017.3246:<< handle possible PHP comments >>
#@+node:ekr.20031218072017.3245:<< handle possible heredoc string >>
if g.match(s,i,"<<<"):
    i = g.skip_heredoc_string(s,i)
else:
    i += 1
#@-node:ekr.20031218072017.3245:<< handle possible heredoc string >>
#@+node:ekr.20031218072017.3247:<< handle possible class or function >>
@ In PHP, all functions are typeless and start with the keyword "function;  all classes start with the keyword class.

Functions can be nested, but we don't handle that right now (I don't think it is a common practice anyway).
@c
if g.match(s,i,"function "):
    #we want to make the function a subnode of either the @file node or a class node
    # 1. get the function name
    # 2. make a reference in the parent
    # 3. create the child node, and dump the function in it.
    function_start = i
    m = phpFunctionName.match(s[i:])
    if (None == m): # function keyword without function name
        i += len("function ")
    else:
        headline = g.angleBrackets(" function " + m.group(1) + " ")
        # find the end of the function
        openingBrace = s.find('{',i)
        function_end = g.skip_php_braces(s,openingBrace)
        function_end = g.skip_to_end_of_line(s,function_end - 1) + 1 # include the line end
        # Insert skipped text into parent's body.
        if class_start:
            class_body += s[scan_start:function_start]
        else:
            c.appendStringToBody(parent,s[scan_start:function_start])
        # Append the headline to the parent's body.
        if class_start:
            class_body += (headline + "\n")
        else:
            c.appendStringToBody(parent,headline + "\n")
        # Backup to capture leading whitespace (for undent purposes)
        while (function_start > 0) and (s[function_start - 1] in [" ", "\t"]):
            function_start -= 1
        # Get the body and undent it
        function_body = s[function_start:function_end]
        function_body = self.undentBody(function_body)
        if self.treeType != "@file":
            function_body = "@code\n\n" + function_body
        # Create the new node
        if class_start:
            self.createHeadline(class_node,function_body,headline)
        else:
            self.createHeadline(parent,function_body,headline)
        i = function_end
        scan_start = i
        function_end = 0
        function_start = 0 #done with this function
        function_body = ""

elif g.match(s,i,"class "):
    # we want to make the class a subnode of the @file node
    # 1. get the class name
    # 2. make a reference in the parent
    # 3. create the child node and dump the function in it
    class_start = i
    class_body = ""
    m = phpClassName.match(s[i:])
    if (None == m): # class keyword without class name
        i += len("class ")
    else:
        # Insert skipped text into parent's body.
        c.appendStringToBody(parent,s[scan_start:class_start])
        # create the headline name
        headline = g.angleBrackets(" class " + m.group(1) + " ")
        # find the place to start looking for methods (functions)
        openingBrace = s.find('{',i)
        # find the end of the class
        class_end = g.skip_php_braces(s,openingBrace)
        class_end = g.skip_to_end_of_line(s,class_end - 1) + 1 # include the line end
        # Append the headline to the parent's body.
        c.appendStringToBody(parent,headline + "\n")
        # Backup to capture leading whitespace (for undent purposes)
        while (class_start > 0) and (s[class_start - 1] in [" ", "\t"]):
            class_start -= 1
        scan_start = class_start
        # Create the new node
        class_node = self.createHeadline(parent,"",headline)
        i = openingBrace

else:
    i += 1
#@-node:ekr.20031218072017.3247:<< handle possible class or function >>
#@+node:ekr.20031218072017.3248:<< handle end of class >>
# Capture the rest of the body
class_body += s[scan_start:class_end]
# insert the class node's body
if self.treeType != "@file":
    class_body = "@code\n\n" + class_body
class_body = self.undentBody(class_body)
c.appendStringToBody(class_node,class_body)
# reset the indices
i = class_end
scan_start = i
class_end = 0
class_start = 0 #done with this class
class_body=""
#@-node:ekr.20031218072017.3248:<< handle end of class >>
#@+node:ekr.20031218072017.3249:<< Append any unused text to the parent's body text >>
c.appendStringToBody(parent,s[scan_start:endOfCode])
#@-node:ekr.20031218072017.3249:<< Append any unused text to the parent's body text >>
#@-node:ekr.20031218072017.3242:scanPHPText (Dave Hein)
#@+node:ekr.20070202105339.1:class cScanner
@
The C scanner uses an internal class as an organizational aid. This is far
superior, imo, to using a single huge scanCText function organized with noweb
section references. Indeed, the helper class creates a separate namespace for
use by the various helper functions.

At present only the C scanner uses this organization, and the utilities of the
cScanner class are identical to the utilites of the leoImportCommands class.
This duplication would go away if all the scanners derived from a baseScanner
class, but that is not likely any time soon, if ever.
@c

class cScanner:
    @others
#@nonl
#@+node:ekr.20070202105914:cScanner.ctor
def __init__ (self,importer):

    # Copy ivars.
    self.c = importer.c
    self.encoding = importer.encoding
    self.methodKind = g.choose(importer.fileType==".c","functions","methods")
    self.methodName = importer.methodName
    self.rootLine = importer.rootLine
    self.treeType = importer.treeType

    # Other ivars.
    self.function_start = 0
    self.name = None
    self.scan_start = 0
#@-node:ekr.20070202105914:cScanner.ctor
#@+node:ekr.20070202105914.1:scan & helpers
def scan (self,s,parent,init=True):

    c = self.c
    if init:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language c\n")
    else:
        saveData = self.name,self.function_start,self.scan_start

    self.name,self.function_start,self.scan_start = '',0,0
    i = 0
    while i < len(s):
        progress = i
        ch = s[i]
        # if i == 0 or ch == '\n': g.trace('line',repr(g.get_line(s,i)))
        # g.trace('ch',repr(ch))
        if ch == '/':         i = self.skipComments(s,i)
        elif ch in ('"',"'"): i = g.skip_string(s,i)
        elif ch == '(':     i = self.doOuterParen(s,i,parent) # Possible function/method definition.
        elif ch == ';':     i = self.doSemicolon(s,i) # Signals a possible start of a function.
        elif g.is_c_id(ch): i = self.doId(s,i,parent) # Possible class/namespace definition.
        else: i += 1
        assert i > progress
    self.appendUnusedText(s,i,parent)
    if init:
        if parent.hasChildren(): c.appendStringToBody(parent,'@others')
    else:
        self.name,self.function_start,self.scan_start = saveData
#@nonl
#@+node:ekr.20070202111549:appendUnusedText
def appendUnusedText (self,s,i,parent):

    c = self.c

    i = g.skip_ws_and_nl(s,self.scan_start)
    if i < len(s):
        s2 = s[self.scan_start:]
        # g.trace(repr(s2))
        c.appendStringToBody(parent,s2)
#@-node:ekr.20070202111549:appendUnusedText
#@+node:ekr.20031218072017.3257:doId
def doId (self,s,i,parent):

    j = i ; i = g.skip_c_id(s,i)
    name = s[j:i]
    if name in ('class','namespace'):
        i = self.doInner(s,j,parent,name)
    else:
        self.name = name
        while g.match(s,i,'::'):
            self.name = self.name + '::'
            i = g.skip_ws_and_nl(s,i+2)
            if g.match(s,i,'~'):
                i += 1
                self.name = self.name + '~'
            i = g.skip_ws_and_nl(s,i)
            j = i ; i = g.skip_c_id(s,i)
            name2 = s[j:i]
            self.name = self.name + name2
    return i
#@-node:ekr.20031218072017.3257:doId
#@+node:ekr.20070203153208:doInner
def doInner (self,s,i,parent,kind):

    '''Handle a namespace or class definition.'''

    c = self.c
    start = i
    i += len(kind)
    j = g.skip_ws_and_nl(s,i)
    i = g.skip_c_id(s,j)
    name = s[j:i].strip()
    if not name: return i
    i = g.skip_ws_and_nl(s,i)
    bracket = i
    if not g.match(s,i,'{'): return i
    i = g.skip_braces(s,i)
    if g.match(s,i,'}'):
        end = i
        i = g.skip_ws_and_nl(s,i+1)
        if g.match(s,i,';'): i += 1
        # Append previous text.
        prev = s[self.scan_start:start]
        c.appendStringToBody(parent,prev)
        self.scan_start = self.function_start = i
        preamble = s[start:bracket+1]
        # Create children.
        p = self.createHeadline(parent,headline='%s %s' % (kind,name),body=preamble)
        body = s[bracket+1:end]
        self.scan(body,p.copy(),init=False)
        # Finish the text.
        if p.hasChildren(): c.appendStringToBody(p,'\n\t@others')
        c.appendStringToBody(p,s[end:i])    
    else:
        g.trace('missing "}" following %s' % kind)
    return i
#@-node:ekr.20070203153208:doInner
#@+node:ekr.20031218072017.3262:doOuterParen
def doOuterParen (self,s,i,parent):

    '''Handle '(' at the top level.
    This begins a function/method if and only if the character after the matching ')' is '{'.'''

    # Skip the param list.  It may not be properly matched if there are #if's involved.
    c = self.c
    i = g.skip_parens(s,i)
    if not g.match(s,i,')'): return i
    i = g.skip_ws_and_nl(s,i+1)
    if g.match(s,i,';'):
        return self.doSemicolon(s,i)
    elif g.match(s,i,'='):
        # An initializer ends a declaration.
        i = g.skip_ws_and_nl(s,i+1)
        if g.match(s,i,'{'):
            i = g.skip_braces(s,i)
        self.function_start = i
        return i
    elif g.match(s,i,'{'):
        i = g.skip_braces(s,i)
        if g.match(s,i,'}'):
            i += 1
            # g.trace('function %s' % self.name)
            c.appendStringToBody(parent,s[self.scan_start:self.function_start])
            body = s[self.function_start:i]
            p = self.createHeadline(parent,headline=self.name,body=body)
        else:
            g.trace('no matching "}" in function/method definition')
        self.scan_start = self.function_start = i
        return i
    else:
        return i
#@-node:ekr.20031218072017.3262:doOuterParen
#@+node:ekr.20031218072017.3263:doSemicolon
def doSemicolon (self,s,i):

    self.function_start = i+1 # The semicolon ends the declaration.
    return i+1
#@-node:ekr.20031218072017.3263:doSemicolon
#@+node:ekr.20031218072017.3260:skipComments
def skipComments (self,s,i):

    if g.match(s,i,"//"):
        i = g.skip_line(s,i)
    elif g.match(s,i,"/*"):
        i = g.skip_block_comment(s,i)
    else:
        i += 1

    return i
#@-node:ekr.20031218072017.3260:skipComments
#@-node:ekr.20070202105914.1:scan & helpers
#@+node:ekr.20070203074709:Utilities (should be in base class)
#@+node:ekr.20070203074709.1:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace("parent,headline:",parent,headline)
    # Create the vnode.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)
    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070203074709.1:createHeadline
#@+node:ekr.20070203074709.2:error
def error (self,s): g.es(s)
#@-node:ekr.20070203074709.2:error
#@+node:ekr.20070203074709.3:getLeadingIndent
def getLeadingIndent (self,s,i):

    """Return the leading whitespace of a line, ignoring blank and comment lines."""

    i = g.find_line_start(s,i)
    while i < len(s):
        # g.trace(g.get_line(s,i))
        j = g.skip_ws(s,i) # Bug fix: 2/14/03
        if g.is_nl(s,j) or g.match(s,j,"#"): # Bug fix: 2/14/03
            i = g.skip_line(s,i) # ignore blank lines and comment lines.
        else:
            i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
            # g.trace("returns:",width)
            return width
    # g.trace("returns:0")
    return 0
#@-node:ekr.20070203074709.3:getLeadingIndent
#@+node:ekr.20070203074709.4:isDocStart and isModuleStart
# The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):

    if not g.match(s,i,"@"):
        return False

    j = g.skip_ws(s,i+1)
    if g.match(s,j,"%defs"):
        return False
    elif self.webType == "cweb" and g.match(s,i,"@*"):
        return True
    else:
        return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

def isModuleStart (self,s,i):

    if self.isDocStart(s,i):
        return True
    else:
        return self.webType == "cweb" and (
            g.match(s,i,"@c") or g.match(s,i,"@p") or
            g.match(s,i,"@d") or g.match(s,i,"@f"))
#@-node:ekr.20070203074709.4:isDocStart and isModuleStart
#@+node:ekr.20070203074709.6:massageComment
def massageComment (self,s):

    """Returns s with all runs of whitespace and newlines converted to a single blank.

    Also removes leading and trailing whitespace."""

    s = s.strip()
    s = s.replace("\n"," ")
    s = s.replace("\r"," ")
    s = s.replace("\t"," ")
    s = s.replace("  "," ")
    s = s.strip()
    return s
#@-node:ekr.20070203074709.6:massageComment
#@+node:ekr.20070203074709.10:setEncoding
def setEncoding (self):

    # scanDirectives checks the encoding: may return None.
    theDict = g.scanDirectives(self.c)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
#@-node:ekr.20070203074709.10:setEncoding
#@+node:ekr.20070203074709.11:skipLeadingComments
def skipLeadingComments (self,s):

    """Skips all leading comments in s, returning the remaining body text and the massaged comment text.

    Returns (body, comment)"""

    # g.trace(g.get_line(s,0))
    s_original = s
    s = s.lstrip()
    i = 0 ; comment = ""
    if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
        << scan for C-style comments >>
    elif self.fileType == ".lua":
        << scan for Lua comments >>
    elif self.fileType == ".pas":
        << scan for Pascal comments >>
    elif self.fileType == ".py":
        << scan for Python comments >>
    comment = string.strip(comment)
    if len(comment) == 0:
        return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
    elif self.treeType == "@file":
        return s[i:], "@ " + comment
    else:
        return s[i:], "@ " + comment + "\n"
#@+node:ekr.20070203074709.12:<< scan for C-style comments >>
while i < len(s):
    if g.match(s,i,"//"): # Handle a C++ comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,"/*"): # Handle a block C comment.
        j = i + 2 ; i = g.skip_block_comment (s,i)
        k = g.choose(g.match(s,i-2,"*/"),i-2,i)
        if self.fileType == ".java":
            # 8/2/02: a hack: add leading whitespace then remove it.
            comment = self.undentBody(comment)
            comment2 = ' ' * 2 + s[j:k]
            comment2 = self.undentBody(comment2)
            comment = comment + comment2 + "\n"
        else:
            comment = comment + self.massageComment(s[j:k]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20070203074709.12:<< scan for C-style comments >>
#@+node:ekr.20070203074709.13:<< scan for Lua comments >>
while i < len(s):
    if g.match(s,i,"--"): # Handle a Lua line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20070203074709.13:<< scan for Lua comments >>
#@+node:ekr.20070203074709.14:<< scan for Pascal comments >>
while i < len(s):
    if g.match(s,i,"//"): # Handle a Pascal line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,'(*'):
        j = i + 1 ; i = g.skip_pascal_block_comment(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20070203074709.14:<< scan for Pascal comments >>
#@+node:ekr.20070203074709.15:<< scan for Python comments >>
while i < len(s) and g.match(s,i,'#'):
    j = i + 1 ; i = g.skip_line(s,i)
    comment = self.undentBody(comment)
    comment = comment + self.massageComment(s[j:i]) + "\n"
    # 8/2/02: Preserve leading whitespace for undentBody
    i = g.skip_ws(s,i)
    i = g.skip_blank_lines(s,i)
#@-node:ekr.20070203074709.15:<< scan for Python comments >>
#@-node:ekr.20070203074709.11:skipLeadingComments
#@+node:ekr.20070203074709.16:undentBody
# We look at the first line to determine how much leading whitespace to delete.

def undentBody (self,s):

    """Removes extra leading indentation from all lines."""

    # g.trace(s)
    i = 0 ; result = ""
    # Copy an @code line as is.
    if g.match(s,i,"@code"):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]
    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i)
    if undent == 0: return s
    while i < len(s):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        line = s[j:i]
        # g.trace(line)
        line = g.removeLeadingWhitespace(line,undent,self.tab_width)
        result += line
    return result
#@-node:ekr.20070203074709.16:undentBody
#@-node:ekr.20070203074709:Utilities (should be in base class)
#@-node:ekr.20070202105339.1:class cScanner
#@-node:ekr.20031218072017.3241:Scanners for createOutline
#@-node:ekr.20031218072017.3209:Import
#@+node:ekr.20031218072017.3289:Export
#@+node:ekr.20031218072017.3290:convertCodePartToWeb
# Headlines not containing a section reference are ignored in noweb and generate index index in cweb.

def convertCodePartToWeb (self,s,i,v,result):

    # g.trace(g.get_line(s,i))
    c = self.c ; nl = self.output_newline
    lb = g.choose(self.webType=="cweb","@<","<<")
    rb = g.choose(self.webType=="cweb","@>",">>")
    h = string.strip(v.headString())
    << put v's headline ref in head_ref >>
    << put name following @root or @file in file_name >>
    if g.match_word(s,i,"@root"):
        i = g.skip_line(s,i)
        << append ref to file_name >>
    elif g.match_word(s,i,"@c") or g.match_word(s,i,"@code"):
        i = g.skip_line(s,i)
        << append head_ref >>
    elif g.match_word(h,0,"@file"):
        # Only do this if nothing else matches.
        << append ref to file_name >>
        i = g.skip_line(s,i) # 4/28/02
    else:
        << append head_ref >>
    i,result = self.copyPart(s,i,result)
    return i, string.strip(result) + nl

@ %defs a b c
#@+node:ekr.20031218072017.3291:<< put v's headline ref in head_ref>>
@ We look for either noweb or cweb brackets. head_ref does not include these brackets.
@c

head_ref = None
j = 0
if g.match(h,j,"<<"):
    k = string.find(h,">>",j)
elif g.match(h,j,"<@"):
    k = string.find(h,"@>",j)
else:
    k = -1

if k > -1:
    head_ref = string.strip(h[j+2:k])
    if len(head_ref) == 0:
        head_ref = None
#@-node:ekr.20031218072017.3291:<< put v's headline ref in head_ref>>
#@+node:ekr.20031218072017.3292:<< put name following @root or @file in file_name >>
if g.match(h,0,"@file") or g.match(h,0,"@root"):
    line = h[5:]
    line = string.strip(line)
    << set file_name >>
else:
    file_name = line = None
#@+node:ekr.20031218072017.3293:<< Set file_name >>
# set j & k so line[j:k] is the file name.
# g.trace(line)

if g.match(line,0,"<"):
    j = 1 ; k = string.find(line,">",1)
elif g.match(line,0,'"'):
    j = 1 ; k = string.find(line,'"',1)
else:
    j = 0 ; k = string.find(line," ",0)
if k == -1:
    k = len(line)

file_name = string.strip(line[j:k])
if file_name and len(file_name) == 0:
    file_name = None
#@-node:ekr.20031218072017.3293:<< Set file_name >>
#@-node:ekr.20031218072017.3292:<< put name following @root or @file in file_name >>
#@+node:ekr.20031218072017.3294:<< append ref to file_name >>
if self.webType == "cweb":
    if not file_name:
        result += "@<root@>=" + nl
    else:
        result += "@(" + file_name + "@>" + nl # @(...@> denotes a file.
else:
    if not file_name:
        file_name = "*"
    result += lb + file_name + rb + "=" + nl
#@-node:ekr.20031218072017.3294:<< append ref to file_name >>
#@+node:ekr.20031218072017.3295:<< append head_ref >>
if self.webType == "cweb":
    if not head_ref:
        result += "@^" + h + "@>" + nl # Convert the headline to an index entry.
        result += "@c" + nl # @c denotes a new section.
    else: 
        escaped_head_ref = string.replace(head_ref,"@","@@")
        result += "@<" + escaped_head_ref + "@>=" + nl
else:
    if not head_ref:
        if v == c.currentVnode():
            head_ref = g.choose(file_name,file_name,"*")
        else:
            head_ref = "@others"

    result += lb + head_ref + rb + "=" + nl
#@-node:ekr.20031218072017.3295:<< append head_ref >>
#@-node:ekr.20031218072017.3290:convertCodePartToWeb
#@+node:ekr.20031218072017.3296:convertDocPartToWeb (handle @ %def)
def convertDocPartToWeb (self,s,i,result):

    nl = self.output_newline

    # g.trace(g.get_line(s,i))
    if g.match_word(s,i,"@doc"):
        i = g.skip_line(s,i)
    elif g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@*"):
        i += 2
    elif g.match(s,i,"@\n"):
        i += 1
    i = g.skip_ws_and_nl(s,i)
    i, result2 = self.copyPart(s,i,"")
    if len(result2) > 0:
        # Break lines after periods.
        result2 = string.replace(result2,".  ","." + nl)
        result2 = string.replace(result2,". ","." + nl)
        result += nl+"@"+nl+string.strip(result2)+nl+nl
    else:
        # All nodes should start with '@', even if the doc part is empty.
        result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
    return i, result
#@-node:ekr.20031218072017.3296:convertDocPartToWeb (handle @ %def)
#@+node:ekr.20031218072017.3297:convertVnodeToWeb
@ This code converts a vnode to noweb text as follows:

Convert @doc to @
Convert @root or @code to << name >>=, assuming the headline contains << name >>
Ignore other directives
Format doc parts so they fit in pagewidth columns.
Output code parts as is.
@c

def convertVnodeToWeb (self,v):

    c = self.c
    if not v or not c: return ""
    startInCode = not c.config.at_root_bodies_start_in_doc_mode
    nl = self.output_newline
    s = v.bodyString()
    lb = g.choose(self.webType=="cweb","@<","<<")
    i = 0 ; result = "" ; docSeen = False
    while i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i) or g.match_word(s,i,"@doc"):
            i,result = self.convertDocPartToWeb(s,i,result)
            docSeen = True
        elif (g.match_word(s,i,"@code") or g.match_word(s,i,"@root") or
            g.match_word(s,i,"@c") or g.match(s,i,lb)):
            << Supply a missing doc part >>
            i,result = self.convertCodePartToWeb(s,i,v,result)
        elif self.treeType == "@file" or startInCode:
            << Supply a missing doc part >>
            i,result = self.convertCodePartToWeb(s,i,v,result)
        else:
            i,result = self.convertDocPartToWeb(s,i,result)
            docSeen = True
        assert(progress < i)
    result = string.strip(result)
    if len(result) > 0:
        result += nl
    return result
#@+node:ekr.20031218072017.3298:<< Supply a missing doc part >>
if not docSeen:
    docSeen = True
    result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
#@-node:ekr.20031218072017.3298:<< Supply a missing doc part >>
#@-node:ekr.20031218072017.3297:convertVnodeToWeb
#@+node:ekr.20031218072017.3299:copyPart
# Copies characters to result until the end of the present section is seen.

def copyPart (self,s,i,result):

    # g.trace(g.get_line(s,i))
    lb = g.choose(self.webType=="cweb","@<","<<")
    rb = g.choose(self.webType=="cweb","@>",">>")
    theType = self.webType
    while i < len(s):
        progress = j = i # We should be at the start of a line here.
        i = g.skip_nl(s,i) ; i = g.skip_ws(s,i)
        if self.isDocStart(s,i):
            return i, result
        if (g.match_word(s,i,"@doc") or
            g.match_word(s,i,"@c") or
            g.match_word(s,i,"@root") or
            g.match_word(s,i,"@code")): # 2/25/03
            return i, result
        elif (g.match(s,i,"<<") and # must be on separate lines.
            g.find_on_line(s,i,">>=") > -1):
            return i, result
        else:
            # Copy the entire line, escaping '@' and
            # Converting @others to < < @ others > >
            i = g.skip_line(s,j) ; line = s[j:i]
            if theType == "cweb":
                line = string.replace(line,"@","@@")
            else:
                j = g.skip_ws(line,0)
                if g.match(line,j,"@others"):
                    line = string.replace(line,"@others",lb + "@others" + rb)
                elif g.match(line,0,"@"):
                    # Special case: do not escape @ %defs.
                    k = g.skip_ws(line,1)
                    if not g.match(line,k,"%defs"):
                        line = "@" + line
            result += line
        assert(progress < i)
    return i, string.rstrip(result)
#@-node:ekr.20031218072017.3299:copyPart
#@+node:ekr.20031218072017.1462:exportHeadlines
def exportHeadlines (self,fileName):

    c = self.c ; nl = self.output_newline
    p = c.currentPosition()
    if not p: return
    self.setEncoding()
    firstLevel = p.level()
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    try:
        theFile = open(fileName,mode)
    except IOError:
        g.es("Can not open " + fileName,color="blue")
        leoTest.fail()
        return
    for p in p.self_and_subtree_iter():
        head = p.moreHead(firstLevel,useVerticalBar=True)
        head = g.toEncodedString(head,self.encoding,reportErrors=True)
        theFile.write(head + nl)
    theFile.close()
#@-node:ekr.20031218072017.1462:exportHeadlines
#@+node:ekr.20031218072017.1147:flattenOutline
def flattenOutline (self,fileName):

    c = self.c ; nl = self.output_newline
    p = c.currentVnode()
    if not p: return
    self.setEncoding()
    firstLevel = p.level()

    # 10/14/02: support for output_newline setting.
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    try:
        theFile = open(fileName,mode)
    except IOError:
        g.es("Can not open " + fileName,color="blue")
        leoTest.fail()
        return

    for p in p.self_and_subtree_iter():
        head = p.moreHead(firstLevel)
        head = g.toEncodedString(head,self.encoding,reportErrors=True)
        theFile.write(head + nl)
        body = p.moreBody() # Inserts escapes.
        if len(body) > 0:
            body = g.toEncodedString(body,self.encoding,reportErrors=True)
            theFile.write(body + nl)
    theFile.close()
#@-node:ekr.20031218072017.1147:flattenOutline
#@+node:ekr.20031218072017.1148:outlineToWeb
def outlineToWeb (self,fileName,webType):

    c = self.c ; nl = self.output_newline
    current = c.currentPosition()
    if not current: return
    self.setEncoding()
    self.webType = webType
    # 10/14/02: support for output_newline setting.
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    try:
        theFile = open(fileName,mode)
    except IOError:
        g.es("Can not open " + fileName,color="blue")
        leoTest.fail()
        return

    self.treeType = "@file"
    # Set self.treeType to @root if p or an ancestor is an @root node.
    for p in current.parents_iter():
        flag,junk = g.is_special(p.bodyString(),0,"@root")
        if flag:
            self.treeType = "@root"
            break
    for p in current.self_and_subtree_iter():
        s = self.convertVnodeToWeb(p)
        if len(s) > 0:
            s = g.toEncodedString(s,self.encoding,reportErrors=True)
            theFile.write(s)
            if s[-1] != '\n': theFile.write(nl)
    theFile.close()
#@-node:ekr.20031218072017.1148:outlineToWeb
#@+node:ekr.20031218072017.3300:removeSentinelsCommand
def removeSentinelsCommand (self,paths):

    c = self.c

    self.setEncoding()

    for fileName in paths:
        g.setGlobalOpenDir(fileName)
        path, self.fileName = g.os_path_split(fileName)
        << Read file into s >>
        << set delims from the header line >>
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = c.config.remove_sentinels_extension
        if not ext:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = g.os_path_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = g.os_path_join(path,head+ext+ext2)
        << Write s into newFileName >>
#@+node:ekr.20031218072017.3301:<< Read file into s >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName, color="blue")
    leoTest.fail()
    return
#@-node:ekr.20031218072017.3301:<< Read file into s >>
#@+node:ekr.20031218072017.3302:<< set delims from the header line >>
# Skip any non @+leo lines.
i = 0
while i < len(s) and not g.find_on_line(s,i,"@+leo"):
    i = g.skip_line(s,i)

# Get the comment delims from the @+leo sentinel line.
at = self.c.atFileCommands
j = g.skip_line(s,i) ; line = s[i:j]

valid,new_df,start_delim,end_delim,derivedFileIsThin = at.parseLeoSentinel(line)
if not valid:
    g.es("invalid @+leo sentinel in " + fileName)
    return

if end_delim:
    line_delim = None
else:
    line_delim,start_delim = start_delim,None
#@-node:ekr.20031218072017.3302:<< set delims from the header line >>
#@+node:ekr.20031218072017.1149:<< Write s into newFileName >>
try:
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    theFile = open(newFileName,mode)
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    theFile.write(s)
    theFile.close()
    g.es("created: " + newFileName)
except:
    g.es("exception creating: " + newFileName)
    g.es_exception()
#@-node:ekr.20031218072017.1149:<< Write s into newFileName >>
#@-node:ekr.20031218072017.3300:removeSentinelsCommand
#@+node:ekr.20031218072017.3303:removeSentinelLines
# This does not handle @nonl properly, but that's a nit...

def removeSentinelLines(self,s,line_delim,start_delim,end_delim):

    '''Properly remove all sentinle lines in s.'''

    __pychecker__ = '--no-argsused' # end_delim.

    delim = (line_delim or start_delim or '') + '@'
    verbatim = delim + 'verbatim' ; verbatimFlag = False
    result = [] ; lines = g.splitLines(s)
    for line in lines:
        i = g.skip_ws(line,0)
        if not verbatimFlag and g.match(line,i,delim):
            if g.match(line,i,verbatim):
                verbatimFlag = True # Force the next line to be in the result.
            # g.trace(repr(line))
        else:
            result.append(line)
            verbatimFlag = False
    result = ''.join(result)
    return result
#@-node:ekr.20031218072017.3303:removeSentinelLines
#@+node:ekr.20031218072017.1464:weave
def weave (self,filename):

    c = self.c ; nl = self.output_newline
    p = c.currentPosition()
    if not p: return
    self.setEncoding()
    << open filename to f, or return >>
    for p in p.self_and_subtree_iter():
        s = p.bodyString()
        s2 = string.strip(s)
        if s2 and len(s2) > 0:
            f.write("-" * 60) ; f.write(nl)
            << write the context of p to f >>
            f.write("-" * 60) ; f.write(nl)
            s = g.toEncodedString(s,self.encoding,reportErrors=True)
            f.write(string.rstrip(s) + nl)
    f.flush()
    f.close()
#@+node:ekr.20031218072017.1150:<< open filename to f, or return >>
try:
    # 10/14/02: support for output_newline setting.
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    f = open(filename,mode)
    if not f: return
except:
    g.es("exception opening:" + filename)
    g.es_exception()
    return
#@-node:ekr.20031218072017.1150:<< open filename to f, or return >>
#@+node:ekr.20031218072017.1465:<< write the context of p to f >>
# write the headlines of p, p's parent and p's grandparent.
context = [] ; p2 = p.copy() ; i = 0
while i < 3:
    i += 1
    if not p2: break
    context.append(p2.headString())
    p2.moveToParent()

context.reverse()
indent = ""
for line in context:
    f.write(indent)
    indent += '\t'
    line = g.toEncodedString(line,self.encoding,reportErrors=True)
    f.write(line)
    f.write(nl)
#@-node:ekr.20031218072017.1465:<< write the context of p to f >>
#@-node:ekr.20031218072017.1464:weave
#@-node:ekr.20031218072017.3289:Export
#@+node:ekr.20031218072017.3305:Utilities
#@+node:ekr.20031218072017.3306:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace("parent,headline:",parent,headline)
    # Create the vnode.
    v = parent.insertAsLastChild()
    v.initHeadString(headline,self.encoding)
    # Set the body.
    if len(body) > 0:
        self.c.setBodyString(v,body,self.encoding)
    return v
#@-node:ekr.20031218072017.3306:createHeadline
#@+node:ekr.20031218072017.3307:error
def error (self,s): g.es(s)
#@-node:ekr.20031218072017.3307:error
#@+node:ekr.20031218072017.3308:getLeadingIndent
def getLeadingIndent (self,s,i):

    """Return the leading whitespace of a line, ignoring blank and comment lines."""

    i = g.find_line_start(s,i)
    while i < len(s):
        # g.trace(g.get_line(s,i))
        j = g.skip_ws(s,i) # Bug fix: 2/14/03
        if g.is_nl(s,j) or g.match(s,j,"#"): # Bug fix: 2/14/03
            i = g.skip_line(s,i) # ignore blank lines and comment lines.
        else:
            i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
            # g.trace("returns:",width)
            return width
    # g.trace("returns:0")
    return 0
#@-node:ekr.20031218072017.3308:getLeadingIndent
#@+node:ekr.20031218072017.3309:isDocStart and isModuleStart
# The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):

    if not g.match(s,i,"@"):
        return False

    j = g.skip_ws(s,i+1)
    if g.match(s,j,"%defs"):
        return False
    elif self.webType == "cweb" and g.match(s,i,"@*"):
        return True
    else:
        return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

def isModuleStart (self,s,i):

    if self.isDocStart(s,i):
        return True
    else:
        return self.webType == "cweb" and (
            g.match(s,i,"@c") or g.match(s,i,"@p") or
            g.match(s,i,"@d") or g.match(s,i,"@f"))
#@-node:ekr.20031218072017.3309:isDocStart and isModuleStart
#@+node:ekr.20031218072017.3310:massageBody
def massageBody (self,s,methodKind):

    # g.trace(s)
    # g.trace(g.get_line(s,0))
    c = self.c
    if self.treeType == "@file":
        if self.fileType == ".py": # 7/31/02: was "py"
            return self.undentBody(s)
        else:
            newBody, comment = self.skipLeadingComments(s)
            newBody = self.undentBody(newBody)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            if len(comment) > 0:
                return comment + "\n@c" + newLine + newBody
            else:
                return newBody
    else:
        # Inserts < < self.methodName methodKind > > =
        cweb = self.fileType == "c" and not c.use_noweb_flag
        lb = g.choose(cweb,"@<","<<")
        rb = g.choose(cweb,"@>=",">>=")
        intro = lb + " " + self.methodName + " " + methodKind + " " + rb
        if self.fileType == ".py": # 7/31/02: was "py"
            newBody = self.undentBody(s)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            return intro + newLine + newBody
        else:
            newBody, comment = self.skipLeadingComments(s)
            newBody = self.undentBody(newBody)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            if len(comment) > 0:
                return comment + "\n" + intro + newLine + newBody
            else:
                return intro + newLine + newBody
#@-node:ekr.20031218072017.3310:massageBody
#@+node:ekr.20031218072017.3311:massageComment
def massageComment (self,s):

    """Returns s with all runs of whitespace and newlines converted to a single blank.

    Also removes leading and trailing whitespace."""

    # g.trace(g.get_line(s,0))
    s = string.strip(s)
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"\r"," ")
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
#@-node:ekr.20031218072017.3311:massageComment
#@+node:ekr.20031218072017.3312:massageWebBody
def massageWebBody (self,s):

    theType = self.webType
    lb = g.choose(theType=="cweb","@<","<<")
    rb = g.choose(theType=="cweb","@>",">>")
    << Remove most newlines from @space and @* sections >>
    << Replace abbreviated names with full names >>
    s = string.rstrip(s)
    return s
#@+node:ekr.20031218072017.3313:<< Remove most newlines from @space and @* sections >>
i = 0
while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isDocStart(s,i):
        # Scan to end of the doc part.
        if g.match(s,i,"@ %def"):
            # Don't remove the newline following %def
            i = g.skip_line(s,i) ; start = end = i
        else:
            start = end = i ; i += 2
        while i < len(s):
            progress2 = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i) or g.match(s,i,lb):
                end = i ; break
            elif theType == "cweb": i += 1
            else: i = g.skip_to_end_of_line(s,i)
            assert (i > progress2)
        # Remove newlines from start to end.
        doc = s[start:end]
        doc = string.replace(doc,"\n"," ")
        doc = string.replace(doc,"\r","")
        doc = string.strip(doc)
        if doc and len(doc) > 0:
            if doc == "@":
                doc = g.choose(self.webType=="cweb", "@ ","@\n")
            else:
                doc += "\n\n"
            # g.trace("new doc:",doc)
            s = s[:start] + doc + s[end:]
            i = start + len(doc)
    else: i = g.skip_line(s,i)
    assert (i > progress)
#@-node:ekr.20031218072017.3313:<< Remove most newlines from @space and @* sections >>
#@+node:ekr.20031218072017.3314:<< Replace abbreviated names with full names >>
i = 0
while i < len(s):
    progress = i
    # g.trace(g.get_line(s,i))
    if g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k > -1:
            name = s[j:k]
            name2 = self.cstLookup(name)
            if name != name2:
                # Replace name by name2 in s.
                # g.trace("replacing %s by %s" % (name,name2))
                s = s[:j] + name2 + s[k:]
                i = j + len(name2)
    i = g.skip_line(s,i)
    assert (i > progress)
#@-node:ekr.20031218072017.3314:<< Replace abbreviated names with full names >>
#@-node:ekr.20031218072017.3312:massageWebBody
#@+node:ekr.20031218072017.1463:setEncoding
def setEncoding (self):

    # scanDirectives checks the encoding: may return None.
    theDict = g.scanDirectives(self.c)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
#@-node:ekr.20031218072017.1463:setEncoding
#@+node:ekr.20031218072017.3315:skipLeadingComments
def skipLeadingComments (self,s):

    """Skips all leading comments in s, returning the remaining body text and the massaged comment text.

    Returns (body, comment)"""

    # g.trace(g.get_line(s,0))
    s_original = s
    s = s.lstrip()
    i = 0 ; comment = ""
    if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
        << scan for C-style comments >>
    elif self.fileType == ".lua":
        << scan for Lua comments >>
    elif self.fileType == ".pas":
        << scan for Pascal comments >>
    elif self.fileType == ".py":
        << scan for Python comments >>
    comment = string.strip(comment)
    if len(comment) == 0:
        return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
    elif self.treeType == "@file":
        return s[i:], "@ " + comment
    else:
        return s[i:], "@ " + comment + "\n"
#@+node:ekr.20031218072017.3316:<< scan for C-style comments >>
while i < len(s):
    if g.match(s,i,"//"): # Handle a C++ comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,"/*"): # Handle a block C comment.
        j = i + 2 ; i = g.skip_block_comment (s,i)
        k = g.choose(g.match(s,i-2,"*/"),i-2,i)
        if self.fileType == ".java":
            # 8/2/02: a hack: add leading whitespace then remove it.
            comment = self.undentBody(comment)
            comment2 = ' ' * 2 + s[j:k]
            comment2 = self.undentBody(comment2)
            comment = comment + comment2 + "\n"
        else:
            comment = comment + self.massageComment(s[j:k]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20031218072017.3316:<< scan for C-style comments >>
#@+node:ekr.20060328112327.1:<< scan for Lua comments >>
while i < len(s):
    if g.match(s,i,"--"): # Handle a Lua line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20060328112327.1:<< scan for Lua comments >>
#@+node:ekr.20031218072017.3317:<< scan for Pascal comments >>
while i < len(s):
    if g.match(s,i,"//"): # Handle a Pascal line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,'(*'):
        j = i + 1 ; i = g.skip_pascal_block_comment(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20031218072017.3317:<< scan for Pascal comments >>
#@+node:ekr.20031218072017.3318:<< scan for Python comments >>
while i < len(s) and g.match(s,i,'#'):
    j = i + 1 ; i = g.skip_line(s,i)
    comment = self.undentBody(comment)
    comment = comment + self.massageComment(s[j:i]) + "\n"
    # 8/2/02: Preserve leading whitespace for undentBody
    i = g.skip_ws(s,i)
    i = g.skip_blank_lines(s,i)
#@-node:ekr.20031218072017.3318:<< scan for Python comments >>
#@-node:ekr.20031218072017.3315:skipLeadingComments
#@+node:ekr.20031218072017.3319:undentBody
# We look at the first line to determine how much leading whitespace to delete.

def undentBody (self,s):

    """Removes extra leading indentation from all lines."""

    # g.trace(s)
    i = 0 ; result = ""
    # Copy an @code line as is.
    if g.match(s,i,"@code"):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]
    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i)
    if undent == 0: return s
    while i < len(s):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        line = s[j:i]
        # g.trace(line)
        line = g.removeLeadingWhitespace(line,undent,self.tab_width)
        result += line
    return result
#@-node:ekr.20031218072017.3319:undentBody
#@-node:ekr.20031218072017.3305:Utilities
#@-node:ekr.20031218072017.3206:@thin leoImport.py
#@+node:ekr.20031218072017.3320:@thin leoNodes.py
@language python
@tabwidth -4
@pagewidth 80

### from __future__ import generators # To make the code work in Python 2.2.

__pychecker__ = '--no-reuseattr' # Suppress warnings about redefining vnode and tnode classes.

use_zodb = False

<< imports >>

@others
#@nonl
#@+node:ekr.20060904165452.1:<< imports >>
if use_zodb:
    # It may be important to import ZODB first.
    try:
        import ZODB
        import ZODB.FileStorage
    except ImportError:
        ZODB = None
else:
    ZODB = None

import leoGlobals as g

if g.app and g.app.use_psyco:
    # print "enabled psyco classes",__file__
    try: from psyco.classes import *
    except ImportError: pass

import string
import time
#@nonl
#@-node:ekr.20060904165452.1:<< imports >>
#@+node:ekr.20031218072017.3321:class tnode
if use_zodb and ZODB:
    class baseTnode (ZODB.Persistence.Persistent):
        pass
else:
    class baseTnode (object):
        pass

class tnode (baseTnode):
    """A class that implements tnodes."""
    << tnode constants >>
    @others
#@nonl
#@+node:ekr.20031218072017.3322:<< tnode constants >>
dirtyBit    = 0x01
richTextBit = 0x02 # Determines whether we use <bt> or <btr> tags.
visitedBit  = 0x04
writeBit    = 0x08 # Set: write the tnode.
#@-node:ekr.20031218072017.3322:<< tnode constants >>
#@+node:ekr.20031218072017.2006:t.__init__
# All params have defaults, so t = tnode() is valid.

def __init__ (self,bodyString=None,headString=None):

    # To support ZODB the code must set t._p_changed = 1 whenever
    # t.vnodeList, t.unknownAttributes or any mutable tnode object changes.

    self.cloneIndex = 0 # For Pre-3.12 files.  Zero for @file nodes
    self.fileIndex = None # The immutable file index for this tnode.
    self.insertSpot = None # Location of previous insert point.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    self.selectionLength = 0 # The length of the selected body text.
    self.selectionStart = 0 # The start of the selected body text.
    self.statusBits = 0 # status bits

    # Convert everything to unicode...
    self.headString = g.toUnicode(headString,g.app.tkEncoding)
    self.bodyString = g.toUnicode(bodyString,g.app.tkEncoding)

    self.vnodeList = [] # List of all vnodes pointing to this tnode.
    self._firstChild = None
#@nonl
#@-node:ekr.20031218072017.2006:t.__init__
#@+node:ekr.20031218072017.3323:t.__repr__ & t.__str__
def __repr__ (self):

    return "<tnode %d>" % (id(self))

__str__ = __repr__
#@-node:ekr.20031218072017.3323:t.__repr__ & t.__str__
#@+node:ekr.20060908205857:t.__hash__ (only for zodb)
if use_zodb and ZODB:

    # The only required property is that objects
    # which compare equal have the same hash value.

    def __hash__(self):

        return hash(g.app.nodeIndices.toString(self.fileIndex))

        # return sum([ord(ch) for ch in g.app.nodeIndices.toString(self.fileIndex)])
#@nonl
#@-node:ekr.20060908205857:t.__hash__ (only for zodb)
#@+node:ekr.20031218072017.3325:Getters
#@+node:EKR.20040625161602:getBody
def getBody (self):

    return self.bodyString
#@-node:EKR.20040625161602:getBody
#@+node:ekr.20031218072017.3326:t.hasBody
def hasBody (self):

    '''Return True if this tnode contains body text.'''

    s = self.bodyString

    return s and len(s) > 0
#@-node:ekr.20031218072017.3326:t.hasBody
#@+node:ekr.20031218072017.3327:Status bits
#@+node:ekr.20031218072017.3328:isDirty
def isDirty (self):

    return (self.statusBits & self.dirtyBit) != 0
#@-node:ekr.20031218072017.3328:isDirty
#@+node:ekr.20031218072017.3329:isRichTextBit
def isRichTextBit (self):

    return (self.statusBits & self.richTextBit) != 0
#@-node:ekr.20031218072017.3329:isRichTextBit
#@+node:ekr.20031218072017.3330:isVisited
def isVisited (self):

    return (self.statusBits & self.visitedBit) != 0
#@-node:ekr.20031218072017.3330:isVisited
#@+node:EKR.20040503094727:isWriteBit
def isWriteBit (self):

    return (self.statusBits & self.writeBit) != 0
#@-node:EKR.20040503094727:isWriteBit
#@-node:ekr.20031218072017.3327:Status bits
#@-node:ekr.20031218072017.3325:Getters
#@+node:ekr.20031218072017.3331:Setters
#@+node:ekr.20031218072017.1484:Setting body text
#@+node:ekr.20031218072017.1485:setTnodeText
# This sets the text in the tnode from the given string.

def setTnodeText (self,s,encoding="utf-8"):

    """Set the body text of a tnode to the given string."""

    s = g.toUnicode(s,encoding,reportErrors=True)

    if 0: # DANGEROUS:  This automatically converts everything when reading files.

        # New in Leo 4.4.2: self.c does not exist!
        # This must be done in the Commands class.
        option = self.c.config.trailing_body_newlines

        if option == "one":
            s = s.rstrip() + '\n'
        elif option == "zero":
            s = s.rstrip()

    self.bodyString = s

    # g.trace(len(s),g.callers())
#@-node:ekr.20031218072017.1485:setTnodeText
#@+node:ekr.20031218072017.1486:setSelection
def setSelection (self,start,length):

    self.selectionStart = start
    self.selectionLength = length
#@-node:ekr.20031218072017.1486:setSelection
#@-node:ekr.20031218072017.1484:Setting body text
#@+node:ekr.20031218072017.3332:Status bits
#@+node:ekr.20031218072017.3333:clearDirty
def clearDirty (self):

    self.statusBits &= ~ self.dirtyBit
#@-node:ekr.20031218072017.3333:clearDirty
#@+node:ekr.20031218072017.3334:clearRichTextBit
def clearRichTextBit (self):

    self.statusBits &= ~ self.richTextBit
#@-node:ekr.20031218072017.3334:clearRichTextBit
#@+node:ekr.20031218072017.3335:clearVisited
def clearVisited (self):

    self.statusBits &= ~ self.visitedBit
#@-node:ekr.20031218072017.3335:clearVisited
#@+node:EKR.20040503093844:clearWriteBit
def clearWriteBit (self):

    self.statusBits &= ~ self.writeBit
#@-node:EKR.20040503093844:clearWriteBit
#@+node:ekr.20031218072017.3336:setDirty
def setDirty (self):

    self.statusBits |= self.dirtyBit
#@-node:ekr.20031218072017.3336:setDirty
#@+node:ekr.20031218072017.3337:setRichTextBit
def setRichTextBit (self):

    self.statusBits |= self.richTextBit
#@-node:ekr.20031218072017.3337:setRichTextBit
#@+node:ekr.20031218072017.3338:setVisited
def setVisited (self):

    self.statusBits |= self.visitedBit
#@-node:ekr.20031218072017.3338:setVisited
#@+node:EKR.20040503094727.1:setWriteBit
def setWriteBit (self):

    self.statusBits |= self.writeBit
#@-node:EKR.20040503094727.1:setWriteBit
#@-node:ekr.20031218072017.3332:Status bits
#@+node:ekr.20031218072017.3339:setCloneIndex (used in 3.x)
def setCloneIndex (self, index):

    self.cloneIndex = index
#@-node:ekr.20031218072017.3339:setCloneIndex (used in 3.x)
#@+node:ekr.20031218072017.3340:setFileIndex
def setFileIndex (self, index):

    self.fileIndex = index
#@-node:ekr.20031218072017.3340:setFileIndex
#@+node:ekr.20050418101546:t.setHeadString (new in 4.3)
def setHeadString (self,s,encoding="utf-8"):

    t = self

    s = g.toUnicode(s,encoding,reportErrors=True)
    t.headString = s
#@-node:ekr.20050418101546:t.setHeadString (new in 4.3)
#@-node:ekr.20031218072017.3331:Setters
#@-node:ekr.20031218072017.3321:class tnode
#@+node:ekr.20031218072017.3341:class vnode
if use_zodb and ZODB:
    class baseVnode (ZODB.Persistence.Persistent):
        pass
else:
    class baseVnode (object):
       pass

class vnode (baseVnode):
    << vnode constants >>
    @others
#@nonl
#@+node:ekr.20031218072017.951:<< vnode constants >>
# Define the meaning of status bits in new vnodes.

# Archived...
clonedBit   = 0x01 # True: vnode has clone mark.

# not used = 0x02
expandedBit = 0x04 # True: vnode is expanded.
markedBit   = 0x08 # True: vnode is marked
orphanBit   = 0x10 # True: vnode saved in .leo file, not derived file.
selectedBit = 0x20 # True: vnode is current vnode.
topBit      = 0x40 # True: vnode was top vnode when saved.

# Not archived...
dirtyBit    = 0x060
richTextBit = 0x080 # Determines whether we use <bt> or <btr> tags.
visitedBit  = 0x100
#@-node:ekr.20031218072017.951:<< vnode constants >>
#@+node:ekr.20031218072017.3342:Birth & death
#@+node:ekr.20031218072017.3343:v.__cmp__ (not used)
if 0: # not used
    def __cmp__(self,other):

        g.trace(self,other)
        return not (self is other) # Must return 0, 1 or -1
#@-node:ekr.20031218072017.3343:v.__cmp__ (not used)
#@+node:ekr.20031218072017.3344:v.__init__
def __init__ (self,t):

    assert(t)

    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.unknownAttributes or any mutable vnode object changes.

    self.t = t # The tnode.
    self.statusBits = 0 # status bits

    # Structure links.
    self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20031218072017.3344:v.__init__
#@+node:ekr.20031218072017.3345:v.__repr__ & v.__str__
def __repr__ (self):

    if self.t:
        return "<vnode %d:'%s'>" % (id(self),self.cleanHeadString())
    else:
        return "<vnode %d:NULL tnode>" % (id(self))

__str__ = __repr__
#@-node:ekr.20031218072017.3345:v.__repr__ & v.__str__
#@+node:ekr.20040312145256:v.dump
def dumpLink (self,link):
    return g.choose(link,link,"<none>")

def dump (self,label=""):

    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)

    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v
#@-node:ekr.20040312145256:v.dump
#@+node:ekr.20060910100316:v.__hash__ (only for zodb)
if use_zodb and ZODB:
    def __hash__(self):
        return self.t.__hash__()
#@nonl
#@-node:ekr.20060910100316:v.__hash__ (only for zodb)
#@-node:ekr.20031218072017.3342:Birth & death
#@+node:ekr.20031218072017.3346:v.Comparisons
#@+node:ekr.20040705201018:v.findAtFileName (new in 4.2 b3)
def findAtFileName (self,names):

    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()

    if not g.match(h,0,'@'):
        return ""

    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
#@-node:ekr.20040705201018:v.findAtFileName (new in 4.2 b3)
#@+node:ekr.20031218072017.3350:anyAtFileNodeName
def anyAtFileNodeName (self):

    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)
#@-node:ekr.20031218072017.3350:anyAtFileNodeName
#@+node:ekr.20031218072017.3348:at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)

def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)

def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@-node:ekr.20031218072017.3348:at...FileNodeName
#@+node:EKR.20040430152000:isAtAllNode
def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag
#@-node:EKR.20040430152000:isAtAllNode
#@+node:ekr.20040326031436:isAnyAtFileNode good
def isAnyAtFileNode (self):

    """Return True if v is any kind of @file or related node."""

    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
#@-node:ekr.20040326031436:isAnyAtFileNode good
#@+node:ekr.20040325073709:isAt...FileNode (vnode)
def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)

def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@-node:ekr.20040325073709:isAt...FileNode (vnode)
#@+node:ekr.20031218072017.3351:isAtIgnoreNode
def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag
#@-node:ekr.20031218072017.3351:isAtIgnoreNode
#@+node:ekr.20031218072017.3352:isAtOthersNode
def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag
#@-node:ekr.20031218072017.3352:isAtOthersNode
#@+node:ekr.20031218072017.3353:matchHeadline
def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.

    The headline may contain characters following the successfully matched pattern."""

    v = self

    h = g.toUnicode(v.headString(),'utf-8')
    h = h.lower().replace(' ','').replace('\t','')

    pattern = g.toUnicode(pattern,'utf-8')
    pattern = pattern.lower().replace(' ','').replace('\t','')

    return h.startswith(pattern)
#@-node:ekr.20031218072017.3353:matchHeadline
#@-node:ekr.20031218072017.3346:v.Comparisons
#@+node:ekr.20031218072017.3359:Getters (vnode)
#@+node:ekr.20040306214240:Tree Traversal getters
#@+node:ekr.20031218072017.3406:v.back
# Compatibility routine for scripts

def back (self):

    return self._back
#@-node:ekr.20031218072017.3406:v.back
#@+node:ekr.20031218072017.3409:v.next
# Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next
#@-node:ekr.20031218072017.3409:v.next
#@-node:ekr.20040306214240:Tree Traversal getters
#@+node:ekr.20031218072017.3360:Children
#@+node:ekr.20040303212445:v.childIndex
def childIndex(self):

    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n
#@-node:ekr.20040303212445:v.childIndex
#@+node:ekr.20031218072017.3362:v.firstChild (changed for 4.2)
def firstChild (self):

    return self.t._firstChild
#@-node:ekr.20031218072017.3362:v.firstChild (changed for 4.2)
#@+node:ekr.20040307085922:v.hasChildren & hasFirstChild
def hasChildren (self):

    v = self
    return v.firstChild()

hasFirstChild = hasChildren
#@-node:ekr.20040307085922:v.hasChildren & hasFirstChild
#@+node:ekr.20031218072017.3364:v.lastChild
def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child
#@-node:ekr.20031218072017.3364:v.lastChild
#@+node:ekr.20031218072017.3365:v.nthChild
# childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n > 0 and child:
        n -= 1
        child = child.next()
    return child
#@-node:ekr.20031218072017.3365:v.nthChild
#@+node:ekr.20031218072017.3366:v.numberOfChildren (n)
def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n += 1
        child = child.next()
    return n
#@-node:ekr.20031218072017.3366:v.numberOfChildren (n)
#@-node:ekr.20031218072017.3360:Children
#@+node:ekr.20031218072017.3367:Status Bits
#@+node:ekr.20031218072017.3368:v.isCloned (4.2)
def isCloned (self):

    return len(self.t.vnodeList) > 1
#@-node:ekr.20031218072017.3368:v.isCloned (4.2)
#@+node:ekr.20031218072017.3369:isDirty
def isDirty (self):

    return self.t.isDirty()
#@-node:ekr.20031218072017.3369:isDirty
#@+node:ekr.20031218072017.3370:isExpanded
def isExpanded (self):

    return ( self.statusBits & self.expandedBit ) != 0
#@-node:ekr.20031218072017.3370:isExpanded
#@+node:ekr.20031218072017.3371:isMarked
def isMarked (self):

    return ( self.statusBits & vnode.markedBit ) != 0
#@-node:ekr.20031218072017.3371:isMarked
#@+node:ekr.20031218072017.3372:isOrphan
def isOrphan (self):

    return ( self.statusBits & vnode.orphanBit ) != 0
#@-node:ekr.20031218072017.3372:isOrphan
#@+node:ekr.20031218072017.3373:isSelected
def isSelected (self):

    return ( self.statusBits & vnode.selectedBit ) != 0
#@-node:ekr.20031218072017.3373:isSelected
#@+node:ekr.20031218072017.3374:isTopBitSet
def isTopBitSet (self):

    return ( self.statusBits & self.topBit ) != 0
#@-node:ekr.20031218072017.3374:isTopBitSet
#@+node:ekr.20031218072017.3376:isVisited
def isVisited (self):

    return ( self.statusBits & vnode.visitedBit ) != 0
#@-node:ekr.20031218072017.3376:isVisited
#@+node:ekr.20031218072017.3377:status
def status (self):

    return self.statusBits
#@-node:ekr.20031218072017.3377:status
#@-node:ekr.20031218072017.3367:Status Bits
#@+node:ekr.20031218072017.3378:v.bodyString
def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.bodyString):
        s = "v.bodyString: Leo internal error: not unicode:" + repr(self.t.bodyString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
#@-node:ekr.20031218072017.3378:v.bodyString
#@+node:ekr.20031218072017.1581:v.headString & v.cleanHeadString
def headString (self):

    """Return the headline string."""

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.headString):
        s = "Leo internal error: not unicode:" + repr(self.t.headString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):

    s = self.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
#@-node:ekr.20031218072017.1581:v.headString & v.cleanHeadString
#@+node:ekr.20040323100443:v.directParents (new method in 4.2)
def directParents (self):

    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.

    This is NOT the same as the list of ancestors of the vnode."""

    v = self

    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []
#@-node:ekr.20040323100443:v.directParents (new method in 4.2)
#@-node:ekr.20031218072017.3359:Getters (vnode)
#@+node:ekr.20040301071824:v.Link/Unlink/Insert methods (used by file read logic)
# These remain in 4.2: the file read logic calls these before creating positions.
#@+node:ekr.20060913091805.1:v.detach
def detach (self):

    '''Return a standalone copy of a vnode,
    detached from all other nodes and with a new tnode.'''

    v = self

    # Create a completely separate tnode.
    t2 = tnode(
        bodyString=v.bodyString(),
        headString=v.headString())

    return vnode(t2)
#@nonl
#@-node:ekr.20060913091805.1:v.detach
#@+node:ekr.20031218072017.3419:v.insertAfter
def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAfter(self)

    return v
#@-node:ekr.20031218072017.3419:v.insertAfter
#@+node:ekr.20031218072017.3421:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAsNthChild(self,n)

    return v
#@-node:ekr.20031218072017.3421:v.insertAsNthChild
#@+node:ekr.20031218072017.2355:v.linkAfter
def linkAfter (self,v):

    """Link self after v."""

    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
#@-node:ekr.20031218072017.2355:v.linkAfter
#@+node:ekr.20031218072017.3425:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v
#@-node:ekr.20031218072017.3425:v.linkAsNthChild
#@+node:ekr.20031218072017.3426:v.linkAsRoot
def linkAsRoot (self,oldRoot):

    """Link a vnode as the root node and set the root _position_."""

    v = self

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot

    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v
#@nonl
#@-node:ekr.20031218072017.3426:v.linkAsRoot
#@+node:ekr.20031218072017.3422:v.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a vnode to the root position.

    Important: oldRoot must the previous root vnode if it exists.'''

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)

    return v
#@nonl
#@-node:ekr.20031218072017.3422:v.moveToRoot
#@+node:ekr.20031218072017.3438:v.unlink
def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []
#@nonl
#@-node:ekr.20031218072017.3438:v.unlink
#@-node:ekr.20040301071824:v.Link/Unlink/Insert methods (used by file read logic)
#@+node:ekr.20031218072017.3384:Setters
#@+node:ekr.20031218072017.3386: v.Status bits
#@+node:ekr.20031218072017.3389:clearClonedBit
def clearClonedBit (self):

    self.statusBits &= ~ self.clonedBit
#@-node:ekr.20031218072017.3389:clearClonedBit
#@+node:ekr.20031218072017.3390:v.clearDirty (no change needed)
def clearDirty (self):

    v = self
    v.t.clearDirty()
#@nonl
#@-node:ekr.20031218072017.3390:v.clearDirty (no change needed)
#@+node:ekr.20031218072017.3391:v.clearMarked
def clearMarked (self):

    self.statusBits &= ~ self.markedBit
#@-node:ekr.20031218072017.3391:v.clearMarked
#@+node:ekr.20031218072017.3392:clearOrphan
def clearOrphan (self):

    self.statusBits &= ~ self.orphanBit
#@-node:ekr.20031218072017.3392:clearOrphan
#@+node:ekr.20031218072017.3393:clearVisited
def clearVisited (self):

    self.statusBits &= ~ self.visitedBit
#@-node:ekr.20031218072017.3393:clearVisited
#@+node:ekr.20031218072017.3395:contract & expand & initExpandedBit
def contract(self):

    self.statusBits &= ~ self.expandedBit

    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit

    # g.trace(self,g.callers())

    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit
#@-node:ekr.20031218072017.3395:contract & expand & initExpandedBit
#@+node:ekr.20031218072017.3396:initStatus
def initStatus (self, status):

    self.statusBits = status
#@-node:ekr.20031218072017.3396:initStatus
#@+node:ekr.20031218072017.3397:setClonedBit & initClonedBit
def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &= ~ self.clonedBit
#@-node:ekr.20031218072017.3397:setClonedBit & initClonedBit
#@+node:ekr.20031218072017.3398:v.setMarked & initMarkedBit
def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
#@-node:ekr.20031218072017.3398:v.setMarked & initMarkedBit
#@+node:ekr.20031218072017.3399:setOrphan
def setOrphan (self):

    self.statusBits |= self.orphanBit
#@-node:ekr.20031218072017.3399:setOrphan
#@+node:ekr.20031218072017.3400:setSelected (vnode)
# This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit
#@-node:ekr.20031218072017.3400:setSelected (vnode)
#@+node:ekr.20031218072017.3401:t.setVisited
# Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit
#@-node:ekr.20031218072017.3401:t.setVisited
#@-node:ekr.20031218072017.3386: v.Status bits
#@+node:ekr.20031218072017.3385:v.computeIcon & setIcon
def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val

def setIcon (self):

    pass # Compatibility routine for old scripts
#@-node:ekr.20031218072017.3385:v.computeIcon & setIcon
#@+node:ekr.20040315032144:v.initHeadString
def initHeadString (self,s,encoding="utf-8"):

    v = self
    s = g.toUnicode(s,encoding,reportErrors=True)
    v.t.headString = s

    # g.trace(g.callers(5))
#@-node:ekr.20040315032144:v.initHeadString
#@+node:ekr.20031218072017.3402:v.setSelection
def setSelection (self, start, length):

    self.t.setSelection ( start, length )
#@-node:ekr.20031218072017.3402:v.setSelection
#@+node:ekr.20040315042106:v.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):

    return self.t.setTnodeText(s,encoding)
#@-node:ekr.20040315042106:v.setTnodeText
#@-node:ekr.20031218072017.3384:Setters
#@-node:ekr.20031218072017.3341:class vnode
#@+node:ekr.20031218072017.1991:class nodeIndices
# Indices are Python dicts containing 'id','loc','time' and 'n' keys.

class nodeIndices (object):

    """A class to implement global node indices (gnx's)."""

    @others
#@+node:ekr.20031218072017.1992:nodeIndices.__init__
def __init__ (self,id):

    """ctor for nodeIndices class"""

    self.userId = id
    self.defaultId = id
    self.lastIndex = None
    self.timeString = None
#@-node:ekr.20031218072017.1992:nodeIndices.__init__
#@+node:ekr.20031218072017.1993:areEqual
def areEqual (self,gnx1,gnx2):

    """Return True if all fields of gnx1 and gnx2 are equal"""

    # works whatever the format of gnx1 and gnx2.
    # This should never throw an exception.
    return gnx1 == gnx2

    id1,time1,n1 = gnx1
    id2,time2,n2 = gnx2
    # g.trace(id1==id2 and time1==time2 and n1==n2,gnx1,gnx2)
    return id1==id2 and time1==time2 and n1==n2
#@-node:ekr.20031218072017.1993:areEqual
#@+node:ekr.20031218072017.1994:get/setDefaultId
# These are used by the fileCommands read/write code.

def getDefaultId (self):

    """Return the id to be used by default in all gnx's"""
    return self.defaultId

def setDefaultId (self,theId):

    """Set the id to be used by default in all gnx's"""
    self.defaultId = theId
#@-node:ekr.20031218072017.1994:get/setDefaultId
#@+node:ekr.20031218072017.1995:getNewIndex
def getNewIndex (self):

    """Create a new gnx using self.timeString and self.lastIndex"""

    theId = self.userId # Always use the user's id for new ids!
    if not self.timeString:
        self.setTimestamp()
    t = self.timeString
    assert(t)
    n = None

    # Set n if id and time match the previous index.
    last = self.lastIndex
    if last:
        lastId,lastTime,lastN = last
        if theId==lastId and t==lastTime:
            if lastN == None: n = 1
            else: n = lastN + 1

    d = (theId,t,n)
    self.lastIndex = d
    # g.trace(d)
    return d
#@-node:ekr.20031218072017.1995:getNewIndex
#@+node:ekr.20031218072017.1996:isGnx
def isGnx (self,gnx):
    try:
        theId,t,n = gnx
        return t != None
    except:
        return False
#@-node:ekr.20031218072017.1996:isGnx
#@+node:ekr.20031218072017.1997:scanGnx
def scanGnx (self,s,i):

    """Create a gnx from its string representation"""

    if type(s) not in (type(""),type(u"")):
        g.es("scanGnx: unexpected index type:",type(s),s,color="red")
        return None,None,None

    s = s.strip()

    theId,t,n = None,None,None
    i,theId = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if theId == None or len(theId) == 0:
        theId = self.defaultId
    # Convert n to int.
    if n:
        try: n = int(n)
        except: pass

    return theId,t,n
#@-node:ekr.20031218072017.1997:scanGnx
#@+node:ekr.20031218072017.1998:setTimeStamp
def setTimestamp (self):

    """Set the timestamp string to be used by getNewIndex until further notice"""

    self.timeString = time.strftime(
        "%Y%m%d%H%M%S", # Help comparisons; avoid y2k problems.
        time.localtime())
#@-node:ekr.20031218072017.1998:setTimeStamp
#@+node:ekr.20031218072017.1999:toString
def toString (self,index,removeDefaultId=False):

    """Convert a gnx (a tuple) to its string representation"""

    try:
        theId,t,n = index
        if removeDefaultId and theId == self.defaultId:
            theId = ""
        if not n: # None or ""
            return "%s.%s" % (theId,t)
        else:
            return "%s.%s.%d" % (theId,t,n)
    except TypeError:
        g.trace('unusual gnx',repr(index))
        return repr(index)
#@nonl
#@-node:ekr.20031218072017.1999:toString
#@-node:ekr.20031218072017.1991:class nodeIndices
#@+node:ekr.20031218072017.889:class position
<< about the position class >>
<< positions may become invalid when outlines change >>

# Positions should *never* be saved by the ZOBD.

class basePosition (object):
    @others

class position (basePosition):
    pass
#@nonl
#@+node:ekr.20031218072017.890:<< about the position class >>
@killcolor

@ This class provides tree traversal methods that operate on positions, not vnodes.  Positions encapsulate the notion of present position within a traversal.

Positions consist of a vnode and a stack of parent nodes used to determine the next parent when a vnode has mutliple parents.

Calling, e.g., p.moveToThreadNext() results in p being an invalid position.  That is, p represents the position following the last node of the outline.  The test "if p" is the _only_ correct way to test whether a position p is valid.  In particular, tests like "if p is None" or "if p is not None" will not work properly.

The only changes to vnodes and tnodes needed to implement shared tnodes are:

- The firstChild field becomes part of tnodes.
- t.vnodes contains a list of all vnodes sharing the tnode.

The advantages of using shared tnodes:

- Leo no longer needs to create or destroy "dependent" trees when changing descendents of cloned trees.
- There is no need for join links and no such things as joined nodes.

These advantages are extremely important: Leo is now scalable to very large outlines.

An important complication is the need to avoid creating temporary positions while traversing trees:
- Several routines use p.vParentWithStack to avoid having to call tempPosition.moveToParent().
  These include p.level, p.isVisible and p.hasThreadNext.
- p.moveToLastNode and p.moveToThreadBack use new algorithms that don't use temporary data.
- Several lookahead routines compute whether a position exists without computing the actual position.
#@-node:ekr.20031218072017.890:<< about the position class >>
#@+node:ekr.20050524082843:<< positions may become invalid when outlines change >>
@killcolor

@ If a vnode has only one parent, v._parent is that parent. Otherwise,
v.t.vnodeList is the list of vnodes v2 such that v2._firstChild == v. Alas, this
means that positions can become invalid when vnodeList's change!

There is no use trying to solve the problem in p.moveToParent or
p.vParentWithStack: the invalidated positions simply don't have the stack
entries needed to compute parent fields properly. In short, changing t.vnodeList
may invalidate existing positions!
#@-node:ekr.20050524082843:<< positions may become invalid when outlines change >>
#@+node:ekr.20040228094013: ctor & other special methods...
#@+node:ekr.20031218072017.893:p.__cmp__
def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self

    # g.trace(p1.headString(),p2 and p2.headString())

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal

    # Check entire stack quickly.
    # The stack contains vnodes, so this is not a recursive call.
    if p1.v != p2.v or p1.stack != p2.stack:
        return 1 # notEqual

    # This is slow: do this last!
    if p1.childIndex() != p2.childIndex():
        # Disambiguate clones having the same parents.
        return 1 # notEqual

    return 0 # equal
#@-node:ekr.20031218072017.893:p.__cmp__
#@+node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):

        """Convert references to p.t into references to p.v.t.

        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                print "unknown position attribute:",attr
                import traceback ; traceback.print_stack()
            raise AttributeError,attr
#@nonl
#@-node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20031218072017.892:p.__init__
# New in Leo 4.4.2: make stack default to None.

def __init__ (self,v,stack=None,trace=True):

    """Create a new position."""

    __pychecker__ = '--no-argsused' # trace not used.

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    # assert(v is None or v.t)

    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # if g.app.tracePositions and trace: g.trace(g.callers())

    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20031218072017.892:p.__init__
#@+node:ekr.20040117173448:p.__nonzero__
@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

def __nonzero__ ( self):

    """Return True if a position is valid."""

    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None
#@-node:ekr.20040117173448:p.__nonzero__
#@+node:ekr.20040301205720:p.__str__ and p.__repr__
def __str__ (self):

    p = self

    if p.v:
        return "<pos %d lvl: %d [%d] %s>" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d        [%d] None>" % (id(p),len(p.stack))

__repr__ = __str__
#@-node:ekr.20040301205720:p.__str__ and p.__repr__
#@+node:ekr.20061006092649:p.archivedPosition
def archivedPosition (self):

    '''Return a representation of a position suitable for use in .leo files.'''

    p = self
    aList = [p2.v.childIndex() for p2 in p.self_and_parents_iter()]
    aList.reverse()
    return aList
#@nonl
#@-node:ekr.20061006092649:p.archivedPosition
#@+node:ekr.20040117171654:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):

    """"Return an independent copy of a position."""

    # if g.app.tracePositions: g.trace(g.callers())

    return position(self.v,self.stack,trace=False)
#@-node:ekr.20040117171654:p.copy
#@+node:ekr.20040310153624:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):

    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label

def vnodeListIds (self):

    p = self
    return [id(v) for v in p.v.t.vnodeList]
#@-node:ekr.20040310153624:p.dump & p.vnodeListIds
#@+node:ekr.20040325142015:p.equal & isEqual
def equal(self,p2):

    """Return True if two postions are equivalent.

    Use this method when the speed comparisons is crucial

    N.B. Unlike __cmp__, p2 must not be None.
    """

    p1 = self

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1.stack == p2.stack and
        p1.childIndex() == p2.childIndex())

isEqual = equal
#@-node:ekr.20040325142015:p.equal & isEqual
#@+node:ekr.20060202090907:p.key (new in 4.4b2)
def key (self):

    p = self

    return '%s:%d.%s' % (
        id(p.v),
        p.childIndex(),
        ','.join([str(id(v)) for v in p.stack])
    )
#@-node:ekr.20060202090907:p.key (new in 4.4b2)
#@-node:ekr.20040228094013: ctor & other special methods...
#@+node:ekr.20040306212636:Getters
#@+node:ekr.20040306210951: vnode proxies
#@+node:ekr.20040306211032:p.Comparisons
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
#@-node:ekr.20040306211032:p.Comparisons
#@+node:ekr.20040306220230:p.Headline & body strings
def bodyString (self):

    return self.v.bodyString()

def headString (self):

    return self.v.headString()

def cleanHeadString (self):

    return self.v.cleanHeadString()
#@-node:ekr.20040306220230:p.Headline & body strings
#@+node:ekr.20040306214401:p.Status bits
def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
#@-node:ekr.20040306214401:p.Status bits
#@+node:ekr.20040323160302:p.directParents
def directParents (self):

    return self.v.directParents()
#@-node:ekr.20040323160302:p.directParents
#@+node:ekr.20040326064330:p.childIndex
def childIndex(self):

    p = self ; v = p.v

    # This is time-critical code!

    # 3/25/04: Much faster code:
    if not v or not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back

    return n
#@-node:ekr.20040326064330:p.childIndex
#@-node:ekr.20040306210951: vnode proxies
#@+node:ekr.20040306214240.2:children
#@+node:ekr.20040306214240.3:p.hasChildren
def hasChildren(self):

    p = self
    # g.trace(p,p.v)
    return p.v and p.v.t and p.v.t._firstChild
#@-node:ekr.20040306214240.3:p.hasChildren
#@+node:ekr.20040306212636.1:p.numberOfChildren
def numberOfChildren (self):

    return self.v.numberOfChildren()
#@-node:ekr.20040306212636.1:p.numberOfChildren
#@-node:ekr.20040306214240.2:children
#@+node:ekr.20031218072017.915:p.getX & vnode compatibility traversal routines
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@-node:ekr.20031218072017.915:p.getX & vnode compatibility traversal routines
#@+node:ekr.20040227212621:p.hasX
def hasBack(self):
    return self.v and self.v._back

hasFirstChild = hasChildren

def hasNext(self):
    return self.v and self.v._next

def hasParent(self):
    return self.v and self.v._parent is not None

def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.

hasVisBack = hasThreadBack
#@+node:ekr.20040227224946:hasThreadNext (the only complex hasX method)
def hasThreadNext(self):

    p = self ; v = p.v
    if not p.v: return False

    if v.t._firstChild or v._next:
        return True
    else:
        n = len(p.stack)-1
        v,n = p.vParentWithStack(v,p.stack,n)
        while v:
            if v._next:
                return True
            v,n = p.vParentWithStack(v,p.stack,n)
        return False

hasVisNext = hasThreadNext
#@-node:ekr.20040227224946:hasThreadNext (the only complex hasX method)
#@-node:ekr.20040227212621:p.hasX
#@+node:ekr.20060920203352:p.findRootPosition (New in 4.4.2)
def findRootPosition (self):

    p = self.copy()
    while p.hasParent():
        p.moveToParent()
    while p.hasBack():
        p.moveToBack()
    return p
#@nonl
#@-node:ekr.20060920203352:p.findRootPosition (New in 4.4.2)
#@+node:ekr.20040307104131.1:p.isAncestorOf
def isAncestorOf (self, p2):

    p = self

    if 0: # Avoid the copies made in the iterator.
        for p3 in p2.parents_iter():
            if p3 == p:
                return True

    # Avoid calling p.copy() or copying the stack.
    v2 = p2.v ; n = len(p2.stack)-1
        # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
    while v2:
        if v2 == p.v:
            return True
        v2,n = p2.vParentWithStack(v2,p2.stack,n)

    return False
#@-node:ekr.20040307104131.1:p.isAncestorOf
#@+node:ekr.20040306215056:p.isCloned
def isCloned (self):

    return len(self.v.t.vnodeList) > 1
#@-node:ekr.20040306215056:p.isCloned
#@+node:ekr.20040307104131.2:p.isRoot
def isRoot (self):

    p = self

    return not p.hasParent() and not p.hasBack()
#@-node:ekr.20040307104131.2:p.isRoot
#@+node:ekr.20040117162509.16:p.isVisible
def isVisible (self):

    """Return True if all of a position's parents are expanded."""

    # v.isVisible no longer exists.
    p = self

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1

    v,n = p.vParentWithStack(v,p.stack,n)
    while v:
        if not v.isExpanded():
            return False
        v,n = p.vParentWithStack(v,p.stack,n)

    return True
#@-node:ekr.20040117162509.16:p.isVisible
#@+node:ekr.20040227214711:p.level & simpleLevel
def simpleLevel(self):

    return len([p for p in self.parents_iter()])

def level(self,verbose=False):

    p = self ; level = 0
    if not p: return level

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1
    while 1:
        assert(p)
        v,n = p.vParentWithStack(v,p.stack,n)
        if v:
            level += 1
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        else:
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # if g.app.debug: assert(level==self.simpleLevel())
            break
    return level
#@-node:ekr.20040227214711:p.level & simpleLevel
#@-node:ekr.20040306212636:Getters
#@+node:ekr.20040305222924:Setters
#@+node:ekr.20040306220634:vnode proxies
#@+node:ekr.20040306220634.9: Status bits (position)
# Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked  (self): return self.v.clearMarked()
def clearOrphan  (self): return self.v.clearOrphan()
def clearVisited (self): return self.v.clearVisited()

def contract (self): return self.v.contract()
def expand   (self): return self.v.expand()

def initExpandedBit    (self): return self.v.initExpandedBit()
def initMarkedBit      (self): return self.v.initMarkedBit()
def initStatus (self, status): return self.v.initStatus(status)

def setMarked   (self): return self.v.setMarked()
def setOrphan   (self): return self.v.setOrphan()
def setSelected (self): return self.v.setSelected()
def setVisited  (self): return self.v.setVisited()
#@-node:ekr.20040306220634.9: Status bits (position)
#@+node:ekr.20040306220634.8:p.computeIcon & p.setIcon
def computeIcon (self):

    return self.v.computeIcon()

def setIcon (self):

    pass # Compatibility routine for old scripts
#@-node:ekr.20040306220634.8:p.computeIcon & p.setIcon
#@+node:ekr.20040306220634.29:p.setSelection
def setSelection (self,start,length):

    return self.v.setSelection(start,length)
#@-node:ekr.20040306220634.29:p.setSelection
#@+node:ekr.20040315034158:p.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):

    return self.v.setTnodeText(s,encoding)
#@-node:ekr.20040315034158:p.setTnodeText
#@-node:ekr.20040306220634:vnode proxies
#@+node:ekr.20040315031401:Head & body text (position)
#@+node:ekr.20040305222924.1:p.setHeadString & p.initHeadString
def setHeadString (self,s,encoding="utf-8"):

    p = self
    p.v.initHeadString(s,encoding)
    p.setDirty()

def initHeadString (self,s,encoding="utf-8"):

    p = self
    p.v.initHeadString(s,encoding)
#@-node:ekr.20040305222924.1:p.setHeadString & p.initHeadString
#@+node:ekr.20040315031445:p.scriptSetBodyString
def scriptSetBodyString (self,s,encoding="utf-8"):

    """Update the body string for the receiver.

    Should be called only from scripts: does NOT update body text."""

    self.v.t.bodyString = g.toUnicode(s,encoding)
#@-node:ekr.20040315031445:p.scriptSetBodyString
#@-node:ekr.20040315031401:Head & body text (position)
#@+node:ekr.20040312015908:Visited bits
#@+node:ekr.20040306220634.17:p.clearVisitedInTree
# Compatibility routine for scripts.

def clearVisitedInTree (self):

    for p in self.self_and_subtree_iter():
        p.clearVisited()
#@-node:ekr.20040306220634.17:p.clearVisitedInTree
#@+node:ekr.20031218072017.3388:p.clearAllVisitedInTree (4.2)
def clearAllVisitedInTree (self):

    for p in self.self_and_subtree_iter():
        p.v.clearVisited()
        p.v.t.clearVisited()
        p.v.t.clearWriteBit()
#@-node:ekr.20031218072017.3388:p.clearAllVisitedInTree (4.2)
#@-node:ekr.20040312015908:Visited bits
#@+node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20040311113514:p.clearDirty
def clearDirty (self):

    p = self
    p.v.clearDirty()
#@-node:ekr.20040311113514:p.clearDirty
#@+node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):

    p = self 

    # Start with all nodes in the vnodeList.
    nodes = []
    newNodes = p.v.t.vnodeList[:]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.t.vnodeList:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
                for v3 in v2.directParents():
                    if v3 not in nodes and v3 not in addedNodes:
                        addedNodes.append(v3)
        newNodes = addedNodes[:]

    # g.trace(len(nodes))
    return nodes
#@-node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
#@+node:ekr.20040702104823:p.inAtIgnoreRange
def inAtIgnoreRange (self):

    """Returns True if position p or one of p's parents is an @ignore node."""

    p = self

    for p in p.self_and_parents_iter():
        if p.isAtIgnoreNode():
            return True

    return False
#@-node:ekr.20040702104823:p.inAtIgnoreRange
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()

    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)

    dirtyVnodeList = [v for v in nodes
        if not v.t.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.t.setDirty() # Do not call v.setDirty here!

    return dirtyVnodeList
#@nonl
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20040303163330:p.setDirty
def setDirty (self,setDescendentsDirty=True):

    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyVnodeList = []

    # g.trace(p.headString(),g.callers())

    if not p.v.t.isDirty():
        p.v.t.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)

    return dirtyVnodeList
#@-node:ekr.20040303163330:p.setDirty
#@-node:ekr.20040305162628:p.Dirty bits
#@-node:ekr.20040305222924:Setters
#@+node:ekr.20040315023430:File Conversion
@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
#@+node:ekr.20040315023430.1:convertTreeToString
def convertTreeToString (self):

    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()

    array = []
    for p in p.self_and_subtree_iter():
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)
#@-node:ekr.20040315023430.1:convertTreeToString
#@+node:ekr.20040315023430.2:moreHead
def moreHead (self, firstLevel,useVerticalBar=False):

    """Return the headline string in MORE format."""

    # useVerticalBar is unused, but it would be useful in over-ridden methods.
    __pychecker__ = '--no-argsused'

    p = self
    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")

    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())
#@-node:ekr.20040315023430.2:moreHead
#@+node:ekr.20040315023430.3:moreBody
@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  

    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; array = []
    lines = string.split(p.bodyString(),'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i < len(s) and s[i] in ('+','-','\\'):
            s = s[:i] + '\\' + s[i:]
        array.append(s)
    return '\n'.join(array)
#@-node:ekr.20040315023430.3:moreBody
#@-node:ekr.20040315023430:File Conversion
#@+node:ekr.20040305162628.1:p.Iterators
@ A crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others
#@+node:EKR.20040529103843:p.tnodes_iter & unique_tnodes_iter
def tnodes_iter(self):

    """Return all tnode's in a positions subtree."""

    p = self
    for p in p.self_and_subtree_iter():
        yield p.v.t

def unique_tnodes_iter(self):

    """Return all unique tnode's in a positions subtree."""

    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v.t not in marks:
            marks[p.v.t] = p.v.t
            yield p.v.t
#@-node:EKR.20040529103843:p.tnodes_iter & unique_tnodes_iter
#@+node:EKR.20040529103945:p.vnodes_iter & unique_vnodes_iter
def vnodes_iter(self):

    """Return all vnode's in a positions subtree."""

    p = self
    for p in p.self_and_subtree_iter():
        yield p.v

def unique_vnodes_iter(self):

    """Return all unique vnode's in a positions subtree."""

    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v
#@-node:EKR.20040529103945:p.vnodes_iter & unique_vnodes_iter
#@+node:ekr.20040305173559:p.subtree_iter
class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=False)

def self_and_subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=True)
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:p.subtree_iter
#@+node:ekr.20040305172211.1:p.children_iter
class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):

    return self.children_iter_class(self,copy)
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:p.children_iter
#@+node:ekr.20040305172855:p.parents_iter
class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=False)

def self_and_parents_iter(self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=True)
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:p.parents_iter
#@+node:ekr.20040305173343:p.siblings_iter
class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):

    return self.siblings_iter_class(self,copy,following)

self_and_siblings_iter = siblings_iter

def following_siblings_iter (self,copy=False):

    return self.siblings_iter_class(self,copy,following=True)
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):

    # We always include p, even if following is True.

    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:p.siblings_iter
#@-node:ekr.20040305162628.1:p.Iterators
#@+node:ekr.20040303175026:p.Moving, Inserting, Deleting, Cloning, Sorting (position)
#@+node:ekr.20040303175026.8:p.clone (does not need any args)
def clone (self):

    """Create a clone of back.

    Returns the newly created position."""

    p = self

    p2 = p.copy()
    p2.v = vnode(p.v.t)
    p2.linkAfter(p)

    return p2
#@nonl
#@-node:ekr.20040303175026.8:p.clone (does not need any args)
#@+node:ekr.20040303175026.9:p.copyTreeAfter, copyTreeTo
# These used by unit tests and by the group_operations plugin.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2

def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v.t.headString = p.headString()
    p2.v.t.bodyString = p.bodyString()
    for child in p.children_iter(copy=True):
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)
#@-node:ekr.20040303175026.9:p.copyTreeAfter, copyTreeTo
#@+node:ekr.20040303175026.2:p.doDelete
@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self):

    """Deletes position p from the outline."""

    p = self
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
#@-node:ekr.20040303175026.2:p.doDelete
#@+node:ekr.20040303175026.3:p.insertAfter
def insertAfter (self,t=None):

    """Inserts a new position after self.

    Returns the newly created position."""

    p = self
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(t)
    p2.v.iconVal = 0
    p2.linkAfter(p)

    return p2
#@-node:ekr.20040303175026.3:p.insertAfter
#@+node:ekr.20040303175026.4:p.insertAsLastChild
def insertAsLastChild (self,t=None):

    """Inserts a new vnode as the last child of self.

    Returns the newly created position."""

    p = self
    n = p.numberOfChildren()

    if not t:
        t = tnode(headString="NewHeadline")

    return p.insertAsNthChild(n,t)
#@-node:ekr.20040303175026.4:p.insertAsLastChild
#@+node:ekr.20040303175026.5:p.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.

    Returns the newly created position."""

    p = self ; p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(t)
    p2.v.iconVal = 0
    p2.linkAsNthChild(p,n)

    return p2
#@-node:ekr.20040303175026.5:p.insertAsNthChild
#@+node:ekr.20040310062332.1:p.invalidOutline
def invalidOutline (self, message):

    p = self

    if p.hasParent():
        node = p.parent()
    else:
        node = p

    g.alert("invalid outline: %s\n%s" % (message,node))
#@-node:ekr.20040310062332.1:p.invalidOutline
#@+node:ekr.20040303175026.10:p.moveAfter
def moveAfter (self,a):

    """Move a position after position a."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAfter(a)

    return p
#@nonl
#@-node:ekr.20040303175026.10:p.moveAfter
#@+node:ekr.20040306060312:p.moveToFirst/LastChildOf
def moveToFirstChildOf (self,parent):

    """Move a position to the first child of parent."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsNthChild(parent,0)
    return p


def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!
    p.unlink()
    n = parent.numberOfChildren()
    p.linkAsNthChild(parent,n)
    return p
#@-node:ekr.20040306060312:p.moveToFirst/LastChildOf
#@+node:ekr.20040303175026.11:p.moveToNthChildOf
def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsNthChild(parent,n)

    return p
#@nonl
#@-node:ekr.20040303175026.11:p.moveToNthChildOf
#@+node:ekr.20040303175026.6:p.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a position to the root position.

    Important: oldRoot must the previous root position if it exists.'''

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)

    return p
#@-node:ekr.20040303175026.6:p.moveToRoot
#@+node:ekr.20040303175026.13:p.validateOutlineWithParent
# This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):

    p = self
    result = True # optimists get only unpleasant surprises.
    parent = p.getParent()
    childIndex = p.childIndex()

    # g.trace(p,parent,pv)
    << validate parent ivar >>
    << validate childIndex ivar >>
    << validate x ivar >>

    # Recursively validate all the children.
    for child in p.children_iter():
        r = child.validateOutlineWithParent(p)
        if not r: result = False

    return result
#@+node:ekr.20040303175026.14:<< validate parent ivar >>
if parent != pv:
    p.invalidOutline( "Invalid parent link: " + repr(parent))
#@-node:ekr.20040303175026.14:<< validate parent ivar >>
#@+node:ekr.20040303175026.15:<< validate childIndex ivar >>
if pv:
    if childIndex < 0:
        p.invalidOutline ( "missing childIndex" + childIndex )
    elif childIndex >= pv.numberOfChildren():
        p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex < 0:
    p.invalidOutline ( "negative childIndex" + childIndex )
#@-node:ekr.20040303175026.15:<< validate childIndex ivar >>
#@+node:ekr.20040303175026.16:<< validate x ivar >>
if not p.v.t and pv:
    self.invalidOutline ( "Empty t" )
#@-node:ekr.20040303175026.16:<< validate x ivar >>
#@-node:ekr.20040303175026.13:p.validateOutlineWithParent
#@-node:ekr.20040303175026:p.Moving, Inserting, Deleting, Cloning, Sorting (position)
#@+node:ekr.20031218072017.928:p.moveToX
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
#@+node:ekr.20031218072017.930:p.moveToBack
def moveToBack (self):

    """Move self to its previous sibling."""

    p = self

    p.v = p.v and p.v._back

    return p
#@-node:ekr.20031218072017.930:p.moveToBack
#@+node:ekr.20031218072017.931:p.moveToFirstChild (pushes stack for cloned nodes)
def moveToFirstChild (self):

    """Move a position to it's first child's position."""

    p = self

    if p:
        child = p.v.t._firstChild
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None

    return p

#@-node:ekr.20031218072017.931:p.moveToFirstChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.932:p.moveToLastChild (pushes stack for cloned nodes)
def moveToLastChild (self):

    """Move a position to it's last child's position."""

    p = self

    if p:
        if p.v.t._firstChild:
            child = p.v.lastChild()
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None

    return p
#@-node:ekr.20031218072017.932:p.moveToLastChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.933:p.moveToLastNode (Big improvement for 4.2)
def moveToLastNode (self):

    """Move a position to last node of its tree.

    N.B. Returns p if p has no children."""

    p = self

    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()

    return p
#@-node:ekr.20031218072017.933:p.moveToLastNode (Big improvement for 4.2)
#@+node:ekr.20031218072017.934:p.moveToNext
def moveToNext (self):

    """Move a position to its next sibling."""

    p = self

    p.v = p.v and p.v._next

    return p
#@-node:ekr.20031218072017.934:p.moveToNext
#@+node:ekr.20031218072017.935:p.moveToNodeAfterTree
def moveToNodeAfterTree (self):

    """Move a position to the node after the position's tree."""

    p = self

    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
#@-node:ekr.20031218072017.935:p.moveToNodeAfterTree
#@+node:ekr.20031218072017.936:p.moveToNthChild (pushes stack for cloned nodes)
def moveToNthChild (self,n):

    p = self

    if p:
        child = p.v.nthChild(n) # Must call vnode method here!
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None

    return p
#@-node:ekr.20031218072017.936:p.moveToNthChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):

    """Move a position to its parent position."""

    p = self

    if not p: return p

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
    else:
        p.v = None
    return p
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@+node:ekr.20031218072017.938:p.moveToThreadBack
def moveToThreadBack (self):

    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
#@-node:ekr.20031218072017.938:p.moveToThreadBack
#@+node:ekr.20031218072017.939:p.moveToThreadNext
def moveToThreadNext (self):

    """Move a position to the next a position in threading order."""

    p = self

    if p:
        if p.v.t._firstChild:
            p.moveToFirstChild()
        elif p.v._next:
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.v._next:
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.

    return p
#@-node:ekr.20031218072017.939:p.moveToThreadNext
#@+node:ekr.20031218072017.940:p.moveToVisBack
def moveToVisBack (self):

    """Move a position to the position of the previous visible node."""

    p = self

    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p
#@-node:ekr.20031218072017.940:p.moveToVisBack
#@+node:ekr.20031218072017.941:p.moveToVisNext
def moveToVisNext (self):

    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()

    return p
#@-node:ekr.20031218072017.941:p.moveToVisNext
#@-node:ekr.20031218072017.928:p.moveToX
#@+node:ekr.20040228094013.1:p.utils...
#@+node:ekr.20040228060340:p.vParentWithStack
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):

    """A utility that allows the computation of p.v without calling p.copy().

    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n >= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
#@+node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)
#@-node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
#@-node:ekr.20040228060340:p.vParentWithStack
#@+node:ekr.20040409203454:p.restoreLinksInTree
def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""

    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    for p in root.children_iter():
        p.restoreLinksInTree()
#@-node:ekr.20040409203454:p.restoreLinksInTree
#@+node:ekr.20040409203454.1:p.deleteLinksInTree & allies
def deleteLinksInTree (self):

    """Delete and otherwise adjust links when deleting node."""

    root = self

    root.deleteLinksInSubtree()

    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@+node:ekr.20040410170806:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20040410170806:p.deleteLinksInSubtree
#@+node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
def adjustParentLinksInSubtree (self,parent):

    root = p = self

    assert(parent)

    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]

    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
#@-node:ekr.20040409203454.1:p.deleteLinksInTree & allies
#@-node:ekr.20040228094013.1:p.utils...
#@+node:ekr.20040310062332:p.Link/Unlink methods
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@+node:ekr.20040310062332.2:p.linkAfter
def linkAfter (self,after):

    """Link self after v."""

    p = self
    # g.trace(p,after)

    p.stack = after.stack[:]
    p.v._parent = after.v._parent

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    p.v._back = after.v
    p.v._next = after.v._next

    after.v._next = p.v

    if p.v._next:
        p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")
#@-node:ekr.20040310062332.2:p.linkAfter
#@+node:ekr.20040310062332.3:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of parent."""

    # g.trace(self,parent,n,parent.v)

    p = self

    # Recreate the stack using the parent.
    p.stack = parent.stack[:]

    if parent.isCloned():
        p.stack.append(parent.v)

    p.v._parent = parent.v

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    if n == 0:
        child1 = parent.v.t._firstChild
        p.v._back = None
        p.v._next = child1
        if child1:
            child1._back = p.v
        parent.v.t._firstChild = p.v
    else:
        prev = parent.nthChild(n-1) # zero based
        assert(prev)
        p.v._back = prev.v
        p.v._next = prev.v._next
        prev.v._next = p.v
        if p.v._next:
            p.v._next._back = p.v

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")
#@-node:ekr.20040310062332.3:p.linkAsNthChild
#@+node:ekr.20040310062332.4:p.linkAsRoot
def linkAsRoot (self,oldRoot):

    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None

    p.stack = [] # Clear the stack.

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRootVnode

    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        oldRoot.v._back = v

    # p.dump(label="root")
#@-node:ekr.20040310062332.4:p.linkAsRoot
#@+node:ekr.20040310062332.5:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.

    The p.v._fistChild link does NOT change."""

    # Warning: p.parent() is NOT necessarily the same as p.v._parent!

    p = self ; v = p.v

    # g.trace('p.v._parent',p.v._parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)

    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)

    # Reset the firstChild link in its direct father.
    if p.v._parent:
        if 0: # This can fail.  I have no idea why it was present.
            assert(p.v and p.v._parent in p.v.directParents())
        if p.v._parent.t._firstChild == v:
            #g.trace('resetting _parent.v.t._firstChild to',v._next)
            p.v._parent.t._firstChild = v._next
    else:
        parent = p.parent()
        if parent:
            if 0: # This can fail.  I have no idea why it was present.
                assert(parent.v in p.v.directParents())
            if parent.v.t._firstChild == v:
                #g.trace('resetting parent().v.t._firstChild to',v._next)
                parent.v.t._firstChild = v._next

    # Do NOT delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20040310062332.5:p.unlink
#@-node:ekr.20040310062332:p.Link/Unlink methods
#@-node:ekr.20031218072017.889:class position
#@-node:ekr.20031218072017.3320:@thin leoNodes.py
#@+node:ekr.20031218072017.3439:@thin leoPlugins.py
"""Install and run Leo plugins.

On startup:
- doPlugins() calls loadHandlers() to import all
  mod_XXXX.py files in the Leo directory.
- Imported files should register hook handlers using the
  registerHandler and registerExclusiveHandler functions.
  Only one "exclusive" function is allowed per hook.

After startup:
- doPlugins() calls doHandlersForTag() to handle the hook.
- The first non-None return is sent back to Leo.
"""

@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import glob

handlers = {}
loadedModules = {} # Keys are module names, values are modules.
loadingModuleNameStack = [] # The stack of module names.  Top is the module being loaded.

@others
#@+node:ekr.20050102094729:callTagHandler
def callTagHandler (bunch,tag,keywords):

    handler = bunch.fn ; moduleName = bunch.moduleName

    # if tag != 'idle': print 'callTagHandler',tag,keywords.get('c')

    # Make sure the new commander exists.
    if tag == 'idle':
        for key in ('c','new_c'):
            c = keywords.get(key)
            if c:
                # Make sure c exists and has a frame.
                if not c.exists or not hasattr(c,'frame'):
                    print 'skipping tag %s: c does not exists or does not have a frame.' % tag
                    return None

    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result
#@-node:ekr.20050102094729:callTagHandler
#@+node:ekr.20031218072017.3442:doHandlersForTag
def doHandlersForTag (tag,keywords):

    """Execute all handlers for a given tag, in alphabetical order.

    All exceptions are caught by the caller, doHook."""

    global handlers

    if g.app.killed:
        return None

    if handlers.has_key(tag):
        bunches = handlers.get(tag)
        # Execute hooks in some random order.
        # Return if one of them returns a non-None result.
        for bunch in bunches:
            val = callTagHandler(bunch,tag,keywords)
            if val is not None:
                return val

    if handlers.has_key("all"):
        bunches = handlers.get('all')
        for bunch in bunches:
            callTagHandler(bunch,tag,keywords)

    return None
#@-node:ekr.20031218072017.3442:doHandlersForTag
#@+node:ekr.20041001161108:doPlugins
def doPlugins(tag,keywords):

    if g.app.killed:
        return

    # g.trace(tag)
    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
#@-node:ekr.20041001161108:doPlugins
#@+node:ekr.20041111124831:getHandlersForTag
def getHandlersForTag(tags):

    import types

    if type(tags) in (types.TupleType,types.ListType):
        result = []
        for tag in tags:
            fn = getHandlersForOneTag(tag) 
            result.append((tag,fn),)
        return result
    else:
        return getHandlersForOneTag(tags)

def getHandlersForOneTag (tag):

    global handlers

    bunch = handlers.get(tag)
    return bunch.fn
#@-node:ekr.20041111124831:getHandlersForTag
#@+node:ekr.20041114113029:getPluginModule
def getPluginModule (moduleName):

    global loadedModules

    return loadedModules.get(moduleName)
#@-node:ekr.20041114113029:getPluginModule
#@+node:ekr.20041001160216:isLoaded
def isLoaded (name):

    if name.endswith('.py'): name = name[:-3]

    return name in g.app.loadedPlugins
#@-node:ekr.20041001160216:isLoaded
#@+node:ekr.20031218072017.3440:loadHandlers & helper
def loadHandlers(tag):

    """Load all enabled plugins from the plugins directory"""

    def pr (*args,**keys):
        if not g.app.unitTesting:
            g.es_print(*args,**keys)

    fileName = "pluginsManager.txt"
    plugins_path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_abspath(theFile) for theFile in files]
    s = g.app.config.getEnabledPlugins()
    theConfigFile = g.app.config.enabledPluginsFileName
    # g.trace('len(s)',s and len(s) or 0)
    if s:
        pr('@enabled-plugins found in %s' % (theConfigFile),color='blue')
        enabled_files = getEnabledFiles(s,plugins_path)
    else:
        for theDir,place in (
            (g.app.homeDir,'HOME'),
            (plugins_path,'leo/config')
        ):
            manager_path = g.os_path_join(theDir,fileName)
            if g.os_path_exists(manager_path):
                g.es_print('%s: %s' % (fileName,theDir),color='blue')
                break
        else: pr('%s not found. No plugins will be loaded' % fileName)
        if g.os_path_exists(manager_path):
            << set enabled_files from pluginsManager.txt >>
        else:  return

    # Load plugins in the order they appear in the enabled_files list.
    if files and enabled_files:
        for theFile in enabled_files:
            if theFile in files:
                loadOnePlugin(theFile)

    # Note: g.plugin_signon adds module names to g.app.loadedPlugins
    if 0:
        if g.app.loadedPlugins:
            pr("%d plugins loaded" % (len(g.app.loadedPlugins)), color="blue")
#@+node:ekr.20031218072017.3441:<< set enabled_files from pluginsManager.txt >>
try:
    # New in 4.3: The first reference to a plugin in pluginsManager.txt controls.
    theFile = open(manager_path)
    s = theFile.read()
    pr('Using settings in pluginsManager.txt')
    enabled_files = getEnabledFiles(s,plugins_path)
    theFile.close()
except IOError:
    pr("Can not open: %s"  % manager_path)
    # Don't import leoTest initially.  It causes problems.
    import leoTest ; leoTest.fail()
    return
#@-node:ekr.20031218072017.3441:<< set enabled_files from pluginsManager.txt >>
#@+node:ekr.20070224082131:getEnabledFiles
def getEnabledFiles (s,plugins_path):

    enabled_files = []
    disabled_files = []
    for s in g.splitLines(s):
        s = s.strip()
        if s:
            if g.match(s,0,"#"):
                s = s[1:].strip()
                # Kludge: ignore comment lines containing a blank or not ending in '.py'.
                if s and s.find(' ') == -1 and s[-3:] == '.py':
                    path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                    if path not in enabled_files and path not in disabled_files:
                        # print 'disabled',path
                        disabled_files.append(path)
            else:
                path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                if path not in enabled_files and path not in disabled_files:
                    # print 'enabled',path
                    enabled_files.append(path)

    return enabled_files
#@nonl
#@-node:ekr.20070224082131:getEnabledFiles
#@-node:ekr.20031218072017.3440:loadHandlers & helper
#@+node:ekr.20041113113140:loadOnePlugin
def loadOnePlugin (moduleOrFileName, verbose=False):

    global loadedModules,loadingModuleNameStack

    verbose = verbose or g.app.config.getBool(c=None,setting='trace_plugins')

    if moduleOrFileName.endswith('.py'):
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            s = 'plugin %s already loaded' % moduleName
            g.es_print(s,color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        if hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                if init_result:
                    loadedModules[moduleName] = result
                else:
                    if verbose and not g.app.initing: ## or not g.app.unitTesting:
                        g.es_print('loadOnePlugin: loading module %s failed' % (moduleName),color="red")
                    result = None
            except Exception:
                g.es('Exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.
            g.trace('no init()',moduleName)
            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if result is None:
        if verbose and not g.app.initing: # or not g.app.unitTesting:
            s = 'can not load enabled %s plugin' % moduleName
            g.es_print(s,color="red")
    elif verbose:
        s = 'loaded %s plugin' % moduleName
        g.es_print(s,color="blue")

    return result
#@nonl
#@-node:ekr.20041113113140:loadOnePlugin
#@+node:ekr.20050110191444:printHandlers
def printHandlers (moduleName=None):

    if moduleName:
        g.es_print('handlers for %s...' % (moduleName))
    else:
        g.es_print('all plugin handlers...')

    modules = {}
    for tag in handlers.keys():
        bunches = handlers.get(tag)
        for bunch in bunches:
            name = bunch.moduleName
            tags = modules.get(name,[])
            tags.append(tag)
            modules[name] = tags
    keys = modules.keys()
    keys.sort()
    for key in keys:
        tags = modules.get(key)
        if moduleName in (None,key):
            for tag in tags:
                g.es_print('%25s %s' % (tag,key))
#@-node:ekr.20050110191444:printHandlers
#@+node:ekr.20070429090122:printPlugins
def printPlugins ():

    g.es_print('Enabled plugins...')
    keys = loadedModules.keys()
    keys = [s.lower() for s in keys]
    keys.sort()
    for key in keys:
        g.es_print(key)
#@-node:ekr.20070429090122:printPlugins
#@+node:ekr.20031218072017.3444:registerExclusiveHandler
def registerExclusiveHandler(tags, fn):

    """ Register one or more exclusive handlers"""

    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            registerOneExclusiveHandler(tag,fn)
    else:
        registerOneExclusiveHandler(tags,fn)

def registerOneExclusiveHandler(tag, fn):

    """Register one exclusive handler"""

    global handlers, loadingModuleNameStack
    try:
        moduleName = loadingModuleNameStack[-1]
    except IndexError:
        moduleName = '<no module>'

    if 0:
        if g.app.unitTesting: print
        print '%6s %15s %25s %s' % (g.app.unitTesting,moduleName,tag,fn.__name__)

    if g.app.unitTesting: return

    if handlers.has_key(tag):
        g.es("*** Two exclusive handlers for '%s'" % tag)
    else:
        bunch = g.Bunch(fn=fn,moduleName=moduleName,tag='handler')
        handlers = [bunch]
#@-node:ekr.20031218072017.3444:registerExclusiveHandler
#@+node:ekr.20031218072017.3443:registerHandler
def registerHandler(tags,fn):

    """ Register one or more handlers"""

    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            registerOneHandler(tag,fn)
    else:
        registerOneHandler(tags,fn)

def registerOneHandler(tag,fn):

    """Register one handler"""

    global handlers, loadingModuleNameStack
    try:
        moduleName = loadingModuleNameStack[-1]
    except IndexError:
        moduleName = '<no module>'

    if 0:
        if g.app.unitTesting: print
        print '%6s %15s %25s %s' % (g.app.unitTesting,moduleName,tag,fn.__name__)

    items = handlers.get(tag,[])
    if fn not in items:

        bunch = g.Bunch(fn=fn,moduleName=moduleName,tag='handler')
        items.append(bunch)

    # g.trace(tag) ; g.printList(items)
    handlers[tag] = items
#@-node:ekr.20031218072017.3443:registerHandler
#@+node:ekr.20050110182317:unloadOnePlugin
def unloadOnePlugin (moduleOrFileName,verbose=False):

    if moduleOrFileName [-3:] == ".py":
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if moduleName in g.app.loadedPlugins:
        if verbose:
            print 'unloading',moduleName
        g.app.loadedPlugins.remove(moduleName)

    for tag in handlers.keys():
        bunches = handlers.get(tag)
        bunches = [bunch for bunch in bunches if bunch.moduleName != moduleName]
        handlers[tag] = bunches
#@-node:ekr.20050110182317:unloadOnePlugin
#@+node:ekr.20041111123313:unregisterHandler
def unregisterHandler(tags,fn):

    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            unregisterOneHandler(tag,fn)
    else:
        unregisterOneHandler(tags,fn)

def unregisterOneHandler (tag,fn):

    global handlers

    if 1: # New code
        bunches = handlers.get(tag)
        bunches = [bunch for bunch in bunches if bunch.fn != fn]
        handlers[tag] = bunches
    else:
        fn_list = handlers.get(tag)
        if fn_list:
            while fn in fn_list:
                fn_list.remove(fn)
            handlers[tag] = fn_list
            # g.trace(handlers.get(tag))
#@-node:ekr.20041111123313:unregisterHandler
#@+node:ktenney.20060628092017.1:baseLeoPlugin
class baseLeoPlugin(object):
    <<docstring>>
    <<baseLeoPlugin declarations>>
    @others
#@+node:ktenney.20060628092017.2:<<docstring>>
"""A Convenience class to simplify plugin authoring

.. contents::

Usage
=====


Initialization
--------------

- import the base class::

    from leoPlugins import leoBasePlugin

- create a class which inherits from leoBasePlugin::

    class myPlugin(leoBasePlugin):

- in the __init__ method of the class, call the parent constructor::

    def __init__(self, tag, keywords):
        leoBasePlugin.__init__(self, tag, keywords)

- put the actual plugin code into a method; for this example, the work
  is done by myPlugin.handler()

- put the class in a file which lives in the <LeoDir>/plugins directory
    for this example it is named myPlugin.py

- add code to register the plugin::

    leoPlugins.registerHandler("after-create-leo-frame", Hello)

Configuration
-------------

baseLeoPlugins has 3 *methods* for setting commands

- setCommand::

        def setCommand(self, commandName, handler, 
                shortcut = None, pane = 'all', verbose = True):

- setMenuItem::

        def setMenuItem(self, menu, commandName = None, handler = None):

- setButton::

        def setButton(self, buttonText = None, commandName = None, color = None):

*variables*

:commandName:  the string typed into minibuffer to execute the ``handler``

:handler:  the method in the class which actually does the work

:shortcut:  the key combination to activate the command

:menu:  a string designating on of the menus ('File', Edit', 'Outline', ...)

:buttonText:  the text to put on the button if one is being created.

Example
=======

Contents of file ``<LeoDir>/plugins/hello.py``::

    class Hello(baseLeoPlugin):
        def __init__(self, tag, keywords):

            # call parent __init__
            baseLeoPlugin.__init__(self, tag, keywords)

            # if the plugin object defines only one command, 
            # just give it a name. You can then create a button and menu entry
            self.setCommand('Hello', self.hello)
            self.setButton()
            self.setMenuItem('Cmds')

            # create a command with a shortcut
            self.setCommand('Hola', self.hola, 'Alt-Ctrl-H')

            # create a button using different text than commandName
            self.setButton('Hello in Spanish')

            # create a menu item with default text
            self.setMenuItem('Cmds')

            # define a command using setMenuItem 
            self.setMenuItem('Cmds', 'Ciao baby', self.ciao)

        def hello(self, event):
            self.g.es( "hello from node %s" % self.c.currentPosition().headString())

        def hola(self, event):
            self.g.es( "hola from node %s" % self.c.currentPosition().headString())

        def ciao(self, event):
            self.g.es( "ciao baby (%s)" % self.c.currentPosition().headString())


    leoPlugins.registerHandler("after-create-leo-frame", Hello)

"""
#@-node:ktenney.20060628092017.2:<<docstring>>
#@+node:ktenney.20060628092017.3:<<baseLeoPlugin declarations>>
import leoGlobals as g
#@-node:ktenney.20060628092017.3:<<baseLeoPlugin declarations>>
#@+node:ktenney.20060628092017.4:__init__
def __init__(self, tag, keywords):

    """Set self.c to be the ``commander`` of the active node
    """

    self.c = keywords['c']
    self.commandNames = []
#@-node:ktenney.20060628092017.4:__init__
#@+node:ktenney.20060628092017.5:setCommand
def setCommand(self, commandName, handler, 
                shortcut = None, pane = 'all', verbose = True):

    """Associate a command name with handler code, 
    optionally defining a keystroke shortcut
    """

    self.commandNames.append(commandName)

    self.commandName = commandName
    self.shortcut = shortcut
    self.handler = handler
    self.c.k.registerCommand (commandName, shortcut, handler, 
                            pane, verbose)
#@-node:ktenney.20060628092017.5:setCommand
#@+node:ktenney.20060628092017.6:setMenuItem
def setMenuItem(self, menu, commandName = None, handler = None):

    """Create a menu item in 'menu' using text 'commandName' calling handler 'handler'
    if commandName and handler are none, use the most recently defined values
    """

    # setMenuItem can create a command, or use a previously defined one.
    if commandName is None:
        commandName = self.commandName
    # make sure commandName is in the list of commandNames                        
    else:
        if commandName not in self.commandNames:
            self.commandNames.append(commandName) 

    if handler is None:
        handler = self.handler

    table = ((commandName, None, handler),)
    self.c.frame.menu.createMenuItemsFromTable(menu, table)
#@-node:ktenney.20060628092017.6:setMenuItem
#@+node:ktenney.20060628092017.7:setButton
def setButton(self, buttonText = None, commandName = None, color = None):

    """Associate an existing command with a 'button'
    """

    if buttonText is None:
        buttonText = self.commandName

    if commandName is None:
        commandName = self.commandName       
    else:
        if commandName not in self.commandNames:
            raise NameError, "setButton error, %s is not a commandName" % commandName

    if color is None:
        color = 'grey'
    script = "c.k.simulateCommand('%s')" % self.commandName
    g.app.gui.makeScriptButton(
        self.c, script=script, 
        buttonText = buttonText, bg = color)
#@-node:ktenney.20060628092017.7:setButton
#@-node:ktenney.20060628092017.1:baseLeoPlugin
#@-node:ekr.20031218072017.3439:@thin leoPlugins.py
#@+node:ekr.20061024060248.1:@thin leoPymacs.py
@first # -*- coding: utf-8 -*-

<< docstring>>

@language python
@tabwidth -4

# As in leo.py we must be very careful about imports.
g = None # set by init: do *not* import it here!
inited = False

@others
#@nonl
#@+node:ekr.20061024060248.2:<< docstring >>
'''A module to allow the Pymacs bridge to access Leo data.

All code in this module must be called *from* Emacs:
calling Pymacs.lisp in other situations will hang Leo.

Emacs code initiallizes this module with::

    (pymacs-eval "sys.path.append('c:\\prog\\tigris-cvs\\leo\\src')")
    (setq leo (pymacs-load "leoPymacs"))

'''
#@-node:ekr.20061024060248.2:<< docstring >>
#@+node:ekr.20061024131236:dump
def dump (anObject):

    init()

    return str(g.toEncodedString(repr(anObject),encoding='ascii'))
#@-node:ekr.20061024131236:dump
#@+node:ekr.20061024130957:getters
def get_app ():
    '''Scripts can use g.app.scriptDict for communication with pymacs.'''
    init()
    return g.app

def get_g():
    init()
    return g

def script_result():
    init()
    return g.app.scriptResult
#@nonl
#@-node:ekr.20061024130957:getters
#@+node:ekr.20061024060248.3:hello
def hello():

    init()
    return 'Hello from Leo.  g.app: %s' % g.app
#@nonl
#@-node:ekr.20061024060248.3:hello
#@+node:ekr.20061024075542:init
def init ():

    global inited

    if inited:
        return
    else:
        inited = True

    # Create the dummy app
    import leo 
    leo.run(pymacs=True)

    import leoGlobals
    global g ; g = leoGlobals

    # These traces show up in the pymacs buffer.
    g.trace('app',g.app)
    g.trace('gui',g.app.gui)
#@-node:ekr.20061024075542:init
#@+node:ekr.20061024075542.1:open
def open (fileName=None):

    init()

    if g.app.unitTesting:
        return

    if not fileName:
        g.es_print('leoPymacs.open: no file name')
        return None

    # openWithFileName checks to see if the file is already open.
    ok, frame = g.openWithFileName(
        fileName,
        old_c=None,
        enableLog=False,
        readAtFileNodesFlag=True)

    c = ok and frame.c or None
    if c:
        g.es_print('leoPymacs.open: %s' % c)
    else:
        g.es_print('leoPymacs.open: Can not open %s' % fileName)

    return c
#@nonl
#@-node:ekr.20061024075542.1:open
#@+node:ekr.20061024084200:run-script
def run_script(c,script,p=None):

    # It is possible to use script=None, in which case p must be defined.

    init()

    if c is None:
        c,frame = g.app.newLeoCommanderAndFrame(fileName='dummy script file')

    g.app.scriptResult = None

    c.executeScript(
        event=None,
        p=p,
        script=script,
        useSelectedText=False,
        define_g=True,
        define_name='__main__',
        silent=True,  # Don't write to the log.
    )

    # g.trace('script returns: ',repr(g.app.scriptResult))
    return g.app.scriptResult
#@nonl
#@-node:ekr.20061024084200:run-script
#@-node:ekr.20061024060248.1:@thin leoPymacs.py
#@+node:ekr.20031218072017.3446:@thin leoTangle.py
@language python
@tabwidth -4
@pagewidth 80

# Tangle and Untangle.
import leoGlobals as g
import os
import string

<< about Tangle and Untangle >>
<< constants & synonyms >>

@others
#@+node:ekr.20031218072017.2411:<< About Tangle and Untangle >>
@ The Tangle command translates the selected @root tree into one or more well-formatted C source files. The outline should contain directives, sections references and section definitions, as described in Chapter 4. The Untangle command is essentially the reverse of the Tangle command. The Tangle command creates a derived file from an @root tree; the Untangle command incorporates changes made to derived files back into the @root tree.

The Tangle command operates in two passes. The first pass discovers the complete definitions of all sections and places these definitions in a symbol table. The first pass also makes a list of root sections. Definitions can appear in any order, so we must scan the entire input file to know whether any particular definition has been completed.

Tangle's second pass creates one file for each @root node. Tangle rescans each section in the list of roots, copying the root text to the output and replacing each section reference by the section's definition. This is a recursive process because any definition may contain other references. We can not allow a section to be defined in terms of itself, either directly or indirectly. We check for such illegally recursive definitions in pass 2 using the section stack class.  Tangle indicates where sections begin and end using comment lines called sentinel lines.  The this part of the appendix discusses the format of the sentinels output by the Tangle command.

The key design principle of the Tangle command is this: Tangle must output newlines in a context-free manner. That is, Tangle must never output conditional newlines, either directly or indirectly. Without this rule Untangle could not determine whether to skip or copy newlines.

The Tangle command increases the indentation level of a section expansion the minimum necessary to align the section expansion with the surrounding code. In essence, this scheme aligns all section expansions with the line of code in which the reference to the section occurs. In some cases, several nested sections expansions will have the same indentation level. This can occur, for example, when a section reference in an outline occurs at the left margin of the outline.

This scheme is probably better than more obvious schemes that indent more "consistently." Such schemes would produce too much indentation for deeply nested outlines. The present scheme is clear enough and avoids indentation wherever possible, yet indents sections adequately. End sentinel lines make this scheme work by making clear where the expansion of one section ends and the expansion of a containing section resumes.

Tangle increases indentation if the section reference does not start a line. Untangle is aware of this hack and adjusts accordingly. This extra indentation handles several common code idioms, which otherwise would create under-indented code. In short, Tangle produces highly readable, given the necessity of preserving newlines for Untangle.

Untangle is inherently complex.  It must do a perfect job of updating the outline, especially whitespace, from expansions of section definitions created by the Tangle command.  Such expansions need not be identical because they may have been generated at different levels of indentation.  The Untangle command can not assume that all expansions of a section will be identical in the derived file; within the derived file, the programmer may have made incompatible changes to two different expansions of the same section. Untangle must check to see that all expansions of a section are "equivalent".  As an added complication, derived files do not contain all the information found in @root trees.  @root trees may contain headlines that generate no code at all.  Also, an outline may define a section in several ways: with an @c or @code directive or with a section definition line.  To be useful, Untangle must handle all these complications flawlessly. The appendix discusses the various conventions used in the sentinels output by the Tangle command.  These conventions allow the Untangle command to recreate whitespace correctly.

Untangle operates in two passes. The first pass finds definitions in the derived file and enters them into the Untangle Symbol Table, or UST.   Definitions often include references to other sections, so definitions often include nested definitions of referenced sections. The first pass of Untangle uses a definition stack to keep track of nested definitions. The top of the stack represents the definition following the latest reference, except for the very first entry pushed on the stack, which represents the code in the outline that contains the @root directive. The stack never becomes empty because of the entry for the @root section. All definitions of a section should match--otherwise there is an inconsistent definition. This pass uses a forgiving compare routine that ignores differences that do not affect the meaning of a program.

Untangle's second pass enters definitions from the outline into the Tangle Symbol Table, or TST. The second pass simultaneously updates all sections in the outline whose definition in the TST does not match the definition in the UST.  The central coding insight of the Untangle command is that the second pass of Untangle is almost identical to the first pass of Tangle! That is, Tangle and Untangle share key parts of code, namely the skip_body() method and its allies.  Just when skip_body() enters a definition into the symbol table, all the information is present that Untangle needs to update that definition.
#@-node:ekr.20031218072017.2411:<< About Tangle and Untangle >>
#@+node:ekr.20031218072017.3447:<< constants & synonyms >>
# Synonyms for multiple_parts_flag.
allow_multiple_parts = 1
disallow_multiple_parts = 2
unused_parts_flag = 3

# Synonyms for is_root_flag to st_enter.
is_root_name = 1 ; not_root_name = 0

# Synonyms for scanAllDirectives
report_errors = 1 ; dont_report_errors = 0
require_path = 1 ; done_require_path = 0

# Constants...
max_errors = 20

@ All these must be defined together, because they form a single enumeration.  Some of these are used by utility functions.
@c

if 1: # A single enum...

    # Used by token_type().
    plain_line = 1 # all other lines
    at_at      = 2 # double-at sign.
    at_chapter = 3 # @chapter
    # at_c       = 4 # @c in noweb mode
    at_code    = 5 # @code, or @c or @p in CWEB mode.
    at_doc     = 6 # @doc
    at_other   = 7 # all other @directives
    at_root    = 8 # @root or noweb * sections
    at_section = 9 # @section
    # at_space   = 10 # @space
    at_web     = 11 # any CWEB control code, except at_at.

    # Returned by self.skip_section_name() and allies and used by token_type.
    bad_section_name = 12  # < < with no matching > >
    section_ref  = 13  # < < name > >
    section_def  = 14  # < < name > > =

    # Returned by is_sentinal_line.
    non_sentinel_line   = 15
    start_sentinel_line = 16
    end_sentinel_line   = 17

    # Stephen P. Schaefer 9/13/2002
    # add support for @first
    at_last    = 18
#@-node:ekr.20031218072017.3447:<< constants & synonyms >>
#@+node:ekr.20031218072017.3448:node classes
#@+node:ekr.20031218072017.3449:class tst_node
class tst_node:
    @others
#@+node:ekr.20031218072017.3450:tst_node.__init__
def __init__ (self,name,root_flag):

    # g.trace("tst_node.__init__",name)
    self.name = name
    self.is_root = root_flag
    self.referenced = False
    self.parts = []
#@-node:ekr.20031218072017.3450:tst_node.__init__
#@+node:ekr.20031218072017.3451:tst_node.__repr__
def __repr__ (self):

    return "tst_node:" + self.name
#@-node:ekr.20031218072017.3451:tst_node.__repr__
#@-node:ekr.20031218072017.3449:class tst_node
#@+node:ekr.20031218072017.3452:class part_node
class part_node:
    @others
#@+node:ekr.20031218072017.3453:part_node.__init__
def __init__ (self,name,code,doc,is_root,is_dirty):

    # g.trace("part_node.__init__",name)
    self.name = name # Section or file name.
    self.code = code # The code text.
    self.doc = doc # The doc text.
    self.is_dirty = is_dirty # True: vnode for body text is dirty.
    self.is_root = is_root # True: name is a root name.
#@-node:ekr.20031218072017.3453:part_node.__init__
#@+node:ekr.20031218072017.3454:part_node.__repr__
def __repr__ (self):

    return "part_node:" + self.name
#@-node:ekr.20031218072017.3454:part_node.__repr__
#@-node:ekr.20031218072017.3452:class part_node
#@+node:ekr.20031218072017.3455:class ust_node
class ust_node:
    @others
#@+node:ekr.20031218072017.3456:ust_node.__init__
@ The text has been masssaged so that 1) it contains no leading indentation and 2) all code arising from section references have been replaced by the reference line itself.  Text for all copies of the same part can differ only in non-critical white space.
@c

def __init__ (self,name,code,part,of,nl_flag,update_flag):

    # g.trace("ust_node.__init__",name,part)
    self.name = name # section name
    self.parts = {} # parts dict
    self.code = code # code text
    self.part = part # n in "(part n of m)" or zero.
    self.of = of  # m in "(part n of m)" or zero.
    self.nl_flag = nl_flag  # True: section starts with a newline.
    self.update_flag = update_flag # True: section corresponds to a section in the outline.
#@-node:ekr.20031218072017.3456:ust_node.__init__
#@+node:ekr.20031218072017.3457:ust_node.__repr__
def __repr__ (self):

    return "ust_node:" + self.name
#@-node:ekr.20031218072017.3457:ust_node.__repr__
#@-node:ekr.20031218072017.3455:class ust_node
#@+node:ekr.20031218072017.3458:class def_node
class def_node:
    @others
#@+node:ekr.20031218072017.3459:def_node.__init__
@ The text has been masssaged so that 1) it contains no leading indentation and 2) all code arising from section references have been replaced by the reference line itself.  Text for all copies of the same part can differ only in non-critical white space.
@c

def __init__ (self,name,indent,part,of,nl_flag,code):

    if 0:
        g.trace("def_node.__init__:",
            "name:",name," part:",part," of:",of," indent:",indent)
    self.name = name
    self.indent = indent
    self.code = code
    if self.code == None: self.code = ""
    self.part = part
    self.of = of
    self.nl_flag = nl_flag
#@-node:ekr.20031218072017.3459:def_node.__init__
#@+node:ekr.20031218072017.3460:def_node.__repr__
def __repr__ (self):

    return "def_node:" + self.name
#@-node:ekr.20031218072017.3460:def_node.__repr__
#@-node:ekr.20031218072017.3458:class def_node
#@+node:ekr.20031218072017.3461:class root_attributes (Stephen P. Schaefer)
@ Stephen P. Schaefer, 9/2/2002
Collect the root node specific attributes in an
easy-to-use container.
@c

class root_attributes:
    @others
#@+node:ekr.20031218072017.3462:root_attributes.__init__
@ Stephen P. Schaefer, 9/2/2002
Keep track of the attributes of a root node
@c

def __init__ (self, tangle_state):

    if 0:
        << trace the state >>
    self.language = tangle_state.language
    self.single_comment_string = tangle_state.single_comment_string
    self.start_comment_string = tangle_state.start_comment_string
    self.end_comment_string = tangle_state.end_comment_string
    self.use_header_flag = tangle_state.use_header_flag
    self.print_mode = tangle_state.print_mode

    # of all the state variables, this one isn't set in tangleCommands.__init__
    # peculiar
    try:
        self.path = tangle_state.path
    except AttributeError:
        self.path = None

    self.page_width = tangle_state.page_width
    self.tab_width = tangle_state.tab_width
    self.first_lines = tangle_state.first_lines # Stephen P. Schaefer 9/13/2002
#@+node:ekr.20031218072017.3463:<< trace the state >>
try:
    if tangle_state.path: pass
except AttributeError:
    tangle_state.path = None

g.trace("def_root_attribute.__init__",
    "language:" + tangle_state.language +
    ", single_comment_string: " + tangle_state.single_comment_string +
    ", start_comment_string: " + tangle_state.start_comment_string +
    ", end_comment_string: " + tangle_state.end_comment_string +
    ", use_header_flag: " + tangle_state.use_header_flag +
    ", print_mode: " + tangle_state.print_mode +
    ", path: " + g.choose(tangle_state.path, tangle_state.path, "") +
    ", page_width: " + tangle_state.page_width +
    ", tab_width: " + tangle_state.tab_width +
    # Stephen P. Schaefer 9/13/2002
    ", first_lines: " + tangle_state.first_lines)
#@-node:ekr.20031218072017.3463:<< trace the state >>
#@-node:ekr.20031218072017.3462:root_attributes.__init__
#@+node:ekr.20031218072017.3464:root_attributes.__repr__
def __repr__ (self):

    return ("root_attributes: language: " + self.language +
        ", single_comment_string: " + self.single_comment_string +
        ", start_comment_string: " + self.start_comment_string +
        ", end_comment_string: " + self.end_comment_string +
        ", use_header_flag: " + self.use_header_flag +
        ", print_mode: " + self.print_mode +
        ", path: " + self.path +
        ", page_width: " + self.page_width +
        ", tab_width: " + self.tab_width +
        # Stephen P. Schaefer 9/13/2002
        ", first_lines: " + self.first_lines)
#@-node:ekr.20031218072017.3464:root_attributes.__repr__
#@-node:ekr.20031218072017.3461:class root_attributes (Stephen P. Schaefer)
#@-node:ekr.20031218072017.3448:node classes
#@+node:ekr.20031218072017.3465:class tangleCommands methods
class baseTangleCommands:
    """The base class for Leo's tangle and untangle commands."""
    @others

class tangleCommands (baseTangleCommands):
    """A class that implements Leo' tangle and untangle commands."""
    pass
#@+node:ekr.20031218072017.3466:tangle.__init__
def __init__ (self,c):

    self.c = c
    self.init_ivars()
#@-node:ekr.20031218072017.3466:tangle.__init__
#@+node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
# Called by __init__

def init_ivars(self):

    c = self.c
    g.app.scanErrors = 0
    << init tangle ivars >>
    << init untangle ivars >>

# Called by scanAllDirectives

def init_directive_ivars (self):

    c = self.c
    << init directive ivars >>
#@+node:ekr.20031218072017.1357:<< init tangle ivars >>
# Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = True # True if tangling, False if untangling.
self.path_warning_given = False # True: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
    self.file_name = c.mFileName # The file name (was a bridge function)
else:
    self.file_name = "<unknown file name>"
self.p = None # position being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for < < * > > = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
    self.head_root = None
    self.code = None
    self.doc = None
    self.header_name = None
    self.header = None
    self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents < < header name > > = and it is valid to continue a section definition.
@c
self.code_seen = False # True if @code seen in body text.

# Support of output_newline option
self.output_newline = g.getOutputNewline(c=c)
#@-node:ekr.20031218072017.1357:<< init tangle ivars >>
#@+node:ekr.20031218072017.1358:<< init untangle ivars >>
@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.
#@-node:ekr.20031218072017.1358:<< init untangle ivars >>
#@+node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
if 0: # not used in this version of Leo
    self.allow_rich_text = default_allow_rich_text
    self.extended_noweb_flag = default_extended_noweb_flag
    self.target_language = default_target_language # uses c.target_lanuage instead

# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
if c.target_language: c.target_language = c.target_language.lower()
self.language = c.target_language
delim1,delim2,delim3 = g.set_delims_from_language(self.language)
# g.trace(delim1,delim2,delim3)

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
    self.use_cweb_flag = False
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
    self.use_cweb_flag = self.language == "cweb"
    self.raw_cweb_flag = False # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""
self.encoding = c.config.default_derived_file_encoding # 2/21/03
self.output_newline = g.getOutputNewline(c=c) # 4/24/03: initialize from config settings.
#@-node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
#@-node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
#@+node:ekr.20031218072017.3467:top level
@ Only top-level drivers initialize ivars.
#@+node:ekr.20031218072017.3468:cleanup
# This code is called from tangleTree and untangleTree.

def cleanup (self):

    if self.errors + g.app.scanErrors == 0:
        << call tangle_done.run() or untangle_done.run() >>

    # Reinitialize the symbol tables and lists.
    self.tst = {}
    self.ust = {}
    self.root_list = []
    self.def_stack = []
#@+node:ekr.20031218072017.3469:<< call tangle_done.run() or untangle_done.run() >>
# Create a list of root names:
root_names = []
theDir = self.tangle_directory # Bug fix: 12/04/02
if not theDir: theDir = ""
for section in self.root_list:
    for part in section.parts:
        if part.is_root:
            root_names.append(g.os_path_join(theDir,part.name))

if self.tangling and self.tangle_batch_flag:
    try:
        import tangle_done
        tangle_done.run(root_names)
    except:
        g.es("Can not execute tangle_done.run()")
        g.es_exception()
if not self.tangling and self.untangle_batch_flag:
    try:
        import untangle_done
        untangle_done.run(root_names)
    except:
        g.es("Can not execute tangle_done.run()")
        g.es_exception()
#@-node:ekr.20031218072017.3469:<< call tangle_done.run() or untangle_done.run() >>
#@-node:ekr.20031218072017.3468:cleanup
#@+node:ekr.20031218072017.3470:initTangleCommand
def initTangleCommand (self):

    c = self.c
    c.endEditing()

    g.es("Tangling...")
    self.init_ivars()
    self.tangling = True
#@-node:ekr.20031218072017.3470:initTangleCommand
#@+node:ekr.20031218072017.3471:initUntangleCommand
def initUntangleCommand (self):

    c = self.c
    c.endEditing()

    g.es("Untangling...")
    self.init_ivars()
    self.tangling = False
#@-node:ekr.20031218072017.3471:initUntangleCommand
#@+node:ekr.20031218072017.3472:tangle
def tangle(self,event=None):

    c = self.c ; p = c.currentPosition()
    self.initTangleCommand()

    if 1: # Paul Paterson's patch.
        if not self.tangleTree(p,report_errors):
            g.es("looking for a parent to tangle...")
            while p:
                d = g.get_directives_dict(p.bodyString(),[self.head_root])
                if d.has_key("root"):
                    g.es("tangling parent")
                    self.tangleTree(p,report_errors)
                    break
                p.moveToParent()
    else:
        self.tangleTree(p,report_errors)

    g.es("tangle complete")
#@-node:ekr.20031218072017.3472:tangle
#@+node:ekr.20031218072017.3473:tangleAll
def tangleAll(self,event=None):

    c = self.c
    self.initTangleCommand()
    has_roots = False

    for p in c.rootPosition().self_and_siblings_iter():
        ok = self.tangleTree(p,dont_report_errors)
        if ok: has_roots = True
        if self.path_warning_given:
            break # Fatal error.

    self.errors += g.app.scanErrors

    if not has_roots:
        self.warning("----- The outline contains no roots")
    elif self.errors > 0 and not self.path_warning_given:
        self.warning("----- Tangle halted because of errors")
    else:
        g.es("Tangle complete")
#@-node:ekr.20031218072017.3473:tangleAll
#@+node:ekr.20031218072017.3474:tangleMarked
def tangleMarked(self,event=None):

    c = self.c ; p = c.rootPosition()
    c.clearAllVisited() # No roots have been tangled yet.
    self.initTangleCommand()
    any_marked = False
    while p:
        is_ignore, i = g.is_special(p.bodyString(),0,"@ignore")
        # Only tangle marked and unvisited nodes.
        if is_ignore:
            p.moveToNodeAfterTree()
        elif p.isMarked():
            ok = self.tangleTree(p,dont_report_errors)
            if ok: any_marked = True
            if self.path_warning_given:
                break # Fatal error.
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()

    self.errors += g.app.scanErrors

    if not any_marked:
        self.warning("----- The outline contains no marked roots")
    elif self.errors > 0 and not self.path_warning_given:
        self.warning("----- Tangle halted because of errors")
    else:
        g.es("Tangle complete")
#@-node:ekr.20031218072017.3474:tangleMarked
#@+node:ekr.20031218072017.3475:tanglePass1
# Traverses the tree whose root is given, handling each headline and associated body text.

def tanglePass1(self,p):

    """The main routine of tangle pass 1"""

    p = p.copy() # 9/14/04
    next = p.nodeAfterTree()
    while p and p != next:
        self.p = p
        self.setRootFromHeadline(p)
        theDict = g.get_directives_dict(p.bodyString(),[self.head_root])
        is_ignore = theDict.has_key("ignore")
        if is_ignore:
            p.moveToNodeAfterTree()
            continue
        # This must be called after root_name has been set.
        if self.tangling:
            self.scanAllDirectives(p,require_path,report_errors) # calls init_directive_ivars.
        # Scan the headline and body text.
        self.skip_headline(p)
        self.skip_body(p)
        p.moveToThreadNext()
        if self.errors + g.app.scanErrors >= max_errors:
            self.warning("----- Halting Tangle: too many errors")
            break

    if self.tangling:
        self.st_check()
        # g.trace(self.st_dump(verbose_flag=True))
#@-node:ekr.20031218072017.3475:tanglePass1
#@+node:ekr.20031218072017.3476:tanglePass2
# At this point p is the root of the tree that has been tangled.

def tanglePass2(self):

    self.p = None # self.p is not valid in pass 2.

    self.errors += g.app.scanErrors

    if self.errors > 0:
        self.warning("----- No file written because of errors")
    elif self.root_list == None:
        self.warning("----- The outline contains no roots")
    else:
        self.put_all_roots() # pass 2 top level function.
#@-node:ekr.20031218072017.3476:tanglePass2
#@+node:ekr.20031218072017.3477:tangleTree (calls cleanup)
# This function is called only from the top level, so there is no need to initialize globals.

def tangleTree(self,p,report_flag):

    """Tangles all nodes in the tree whose root is p.

    Reports on its results if report_flag is True."""

    p = p.copy() # 9/14/04
    assert(p)
    any_root_flag = False
    next = p.nodeAfterTree()
    self.path_warning_given = False

    while p and p != next:
        self.setRootFromHeadline(p)
        theDict = g.get_directives_dict(p.bodyString(),[self.head_root])
        is_ignore = theDict.has_key("ignore")
        is_root = theDict.has_key("root")
        is_unit = theDict.has_key("unit")
        if is_ignore:
            p.moveToNodeAfterTree()
        elif not is_root and not is_unit:
            p.moveToThreadNext()
        else:
            self.tanglePass1(p) # sets self.p
            if self.root_list and self.tangling:
                any_root_flag = True
                self.tanglePass2() # self.p invalid in pass 2.
            self.cleanup()
            p.moveToNodeAfterTree()
            if self.path_warning_given: break # Fatal error.

    if self.tangling and report_flag and not any_root_flag:
        # This is done by Untangle if we are untangling.
        self.warning("----- The outline contains no roots")
    return any_root_flag
#@-node:ekr.20031218072017.3477:tangleTree (calls cleanup)
#@+node:ekr.20031218072017.3478:untangle
def untangle(self,event=None):

    c = self.c ; p = c.currentPosition()
    self.initUntangleCommand()

    c.beginUpdate()
    try:
        self.untangleTree(p,report_errors)
        g.es("Untangle complete")
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.3478:untangle
#@+node:ekr.20031218072017.3479:untangleAll
def untangleAll(self,event=None):

    c = self.c
    self.initUntangleCommand()
    has_roots = False

    c.beginUpdate()
    try:
        for p in c.rootPosition().self_and_siblings_iter():
            ok = self.untangleTree(p,False)
            if ok: has_roots = True
    finally:
        c.endUpdate()

    self.errors += g.app.scanErrors

    if not has_roots:
        self.warning("----- The outline contains no roots")
    elif self.errors > 0:
        self.warning("----- Untangle command halted because of errors")
    else:
        g.es("Untangle complete")
#@-node:ekr.20031218072017.3479:untangleAll
#@+node:ekr.20031218072017.3480:untangleMarked
def untangleMarked(self,event=None):

    c = self.c ; p = c.rootPosition()
    self.initUntangleCommand()
    marked_flag = False

    c.beginUpdate()
    try:
        while p: # Don't use an iterator.
            if p.isMarked():
                ok = self.untangleTree(p,dont_report_errors)
                if ok: marked_flag = True
                if self.errors + g.app.scanErrors > 0: break
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()

    self.errors += g.app.scanErrors

    if not marked_flag:
        self.warning("----- The outline contains no marked roots")
    elif self.errors > 0:
        self.warning("----- Untangle command halted because of errors")
    else:
        g.es("Untangle complete")
#@-node:ekr.20031218072017.3480:untangleMarked
#@+node:ekr.20031218072017.3481:untangleRoot (calls cleanup)
@ This method untangles the derived files in a vnode known to contain at least one @root directive. The work is done in two passes. The first pass creates the UST by scanning the derived file. The second pass updates the outline using the UST and a TST that is created during the pass.

We assume that all sections from root to end are contained in the derived file, and we attempt to update all such sections. The begin/end params indicate the range of nodes to be scanned when building the TST.
@c

def untangleRoot(self,root,begin,end):

    # g.trace("root,begin,end:",root,begin,end)
    << Set path & root_name to the file specified in the @root directive >>
    << return if @silent or unknown language >>
    << Read the file into file_buf >>
    g.es("@root " + path)
    # Pass 1: Scan the C file, creating the UST
    self.scan_derived_file(file_buf)
    # g.trace(self.ust_dump())
    if self.errors + g.app.scanErrors == 0:
        << Pass 2: Untangle the outline using the UST and a newly-created TST >>
    self.cleanup()
#@+node:ekr.20031218072017.3483:<< Set path & root_name to the file specified in the @root directive >>
s = root.bodyString()
i = 0
while i < len(s):
    code, junk = self.token_type(s,i,report_errors)
    if code == at_root:
        # token_type sets root_name unless there is a syntax error.
        if self.root_name: path = self.root_name
        break
    else: i = g.skip_line(s,i)

if not self.root_name:
    # A bad @root command.  token_type has already given an error.
    self.cleanup()
    return
#@-node:ekr.20031218072017.3483:<< Set path & root_name to the file specified in the @root directive >>
#@+node:ekr.20031218072017.3482:<< return if @silent or unknown language >>
if self.language == "unknown":
    g.es("@comment disables Untangle for " + path, color="blue")
    return

if self.print_mode in ("quiet","silent"):
    g.es("@" + self.print_mode +  " inhibits Untangle for " + path, color="blue")
    return
#@-node:ekr.20031218072017.3482:<< return if @silent or unknown language >>
#@+node:ekr.20031218072017.3484:<< Read the file into file_buf  >> in untangleRoot
f = None
try:
    path = g.os_path_join(self.tangle_directory,path)
    f = open(path)
    if f:
        file_buf = f.read()
        file_buf = string.replace(file_buf,g.body_ignored_newline,'')
except:
    if f: f.close()
    g.es("error reading: " + path)
    g.es_exception()
    self.cleanup()
    return
#@-node:ekr.20031218072017.3484:<< Read the file into file_buf  >> in untangleRoot
#@+node:ekr.20031218072017.3485:<< Pass 2:  Untangle the outline using the UST and a newly-created TST >>
@ This code untangles the root and all its siblings. We don't call tangleTree here because we must handle all siblings.  tanglePass1 handles an entire tree.  It also handles @ignore.
@c

p = begin
while p and p != end: # Don't use iterator.
    self.tanglePass1(p)
    if self.errors + g.app.scanErrors != 0:
        break
    p.moveToNodeAfterTree()

self.ust_warn_about_orphans()
#@-node:ekr.20031218072017.3485:<< Pass 2:  Untangle the outline using the UST and a newly-created TST >>
#@-node:ekr.20031218072017.3481:untangleRoot (calls cleanup)
#@+node:ekr.20031218072017.3486:untangleTree
# This funtion is called when the user selects any "Untangle" command.

def untangleTree(self,p,report_flag):

    p = p.copy() # 9/14/04
    c = self.c
    any_root_flag = False
    afterEntireTree = p.nodeAfterTree()
    # Initialize these globals here: they can't be cleared later.
    self.head_root = None
    self.errors = 0 ; g.app.scanErrors = 0
    c.clearAllVisited() # Used by untangle code.

    while p and p != afterEntireTree and self.errors + g.app.scanErrors == 0:
        self.setRootFromHeadline(p)
        theDict = g.get_directives_dict(p.bodyString(),[self.head_root])
        ignore = theDict.has_key("ignore")
        root = theDict.has_key("root")
        unit = theDict.has_key("unit")
        if ignore:
            p.moveToNodeAfterTree()
        elif unit:
            # Expand the context to the @unit directive.
            unitNode = p   # 9/27/99
            afterUnit = p.nodeAfterTree()
            p.moveToThreadNext()
            while p and p != afterUnit and self.errors + g.app.scanErrors== 0:
                self.setRootFromHeadline(p)
                theDict = g.get_directives_dict(p.bodyString(),[self.head_root])
                root = theDict.has_key("root")
                if root:
                    any_root_flag = True
                    end = None
                    << set end to the next root in the unit >>
                    # g.trace("end:",end)
                    self.scanAllDirectives(p,require_path,report_errors)
                    self.untangleRoot(p,unitNode,afterUnit)
                    p = end.copy()
                else: p.moveToThreadNext()
        elif root:
            # Limit the range of the @root to its own tree.
            afterRoot = p.nodeAfterTree()
            any_root_flag = True
            self.scanAllDirectives(p,require_path,report_errors)
            self.untangleRoot(p,p,afterRoot) # 9/27/99
            p = afterRoot.copy()
        else:
            p.moveToThreadNext()

    self.errors += g.app.scanErrors

    if report_flag:
        if not any_root_flag:
            self.warning("----- The outline contains no roots")
        elif self.errors > 0:
            self.warning("----- Untangle command halted because of errors")
    return any_root_flag
#@+node:ekr.20031218072017.3487:<< set end to the next root in the unit >>
@ The untangle_root function will untangle an entire tree by calling untangleTree, so the following code ensures that the next @root node will not be an offspring of p.
@c

end = p.threadNext()
while end and end != afterUnit:
    flag, i = g.is_special(end.bodyString(),0,"@root")
    if flag and not p.isAncestorOf(end):
        break
    end.moveToThreadNext()
#@-node:ekr.20031218072017.3487:<< set end to the next root in the unit >>
#@-node:ekr.20031218072017.3486:untangleTree
#@-node:ekr.20031218072017.3467:top level
#@+node:ekr.20031218072017.3488:tangle
#@+node:ekr.20031218072017.3489:Pass 1
#@+node:ekr.20031218072017.3490:handle_newline
@ This method handles newline processing while skipping a code section. It sets 'done' if the line contains an @directive or section definition that terminates the present code section. On entry: i should point to the first character of a line.  This routine scans past a line only if it could not contain a section reference.

Returns (i, done)
@c

def handle_newline(self,s,i):

    j = i ; done = False
    kind, end = self.token_type(s,i,dont_report_errors)
    # token_type will not skip whitespace in noweb mode.
    i = g.skip_ws(s,i)
    # g.trace(kind,g.get_line(s,i))

    if kind == plain_line:
        pass
    elif (kind == at_code or kind == at_doc or
        kind == at_root or kind == section_def):
        i = j ; done = True # Terminate this code section and rescan.
    elif kind == section_ref:
        # Enter the reference.
        ref = s[i:end]
        self.st_enter_section_name(ref,None,None,unused_parts_flag)
    # DTHEIN 13-OCT-2002: @first directives are OK in code sections
    elif (kind == at_other) and g.match_word(s,j,"@first"):
        pass
    elif kind == at_other or kind == at_chapter or kind == at_section:
        # We expect to see only @doc,@c or @root directives
        # while scanning a code section.
        i = g.skip_to_end_of_line(s,i)
        if 0: # 12/03/02: no longer needed
            self.error("directive not valid here: " + s[j:i])
    elif kind == bad_section_name:
        if self.use_cweb_flag:
            i = g.skip_to_end_of_line(s,i)
    elif kind == at_web or kind == at_at:
        i += 2 # Skip a CWEB control code.
    else: assert(False)

    return i, done
#@-node:ekr.20031218072017.3490:handle_newline
#@+node:ekr.20031218072017.3491:skip_body
# This method handles all the body text.

def skip_body (self,p):

    # g.trace(p)
    c = self.c
    s = p.bodyString()
    code_seen = False ; code = doc = None ; i = 0
    anyChanged = False

    if self.start_mode == "code":
        j = g.skip_blank_lines(s,i)
        i,code = self.skip_code(s,j)
        if code:
            << Define a section for a leading code part >>

    if not code:
        i,doc = self.skip_doc(s,i) # Start in doc section by default.
        if i >= len(s) and doc:
            << Define a section containing only an @doc part >>

    while i < len(s):
        progress = i # progress indicator
        # line = g.get_line(s,i) ; g.trace(line)
        kind, end = self.token_type(s,i,report_errors)
        # if g.is_nl(s,i): i = g.skip_nl(s,i)
        i = g.skip_ws(s,i)
        if kind == section_def:
            << Scan and define a section definition >>
        elif kind == at_code:
            if self.use_cweb_flag:
                i += 2 # Skip the at-c or at-p
            else:
                i = g.skip_line(s,i)
            << Scan and define an @code defininition >>
        elif kind == at_root:
            i = g.skip_line(s,i)
            << Scan and define a root section >>
        elif kind == at_doc:
            if self.use_cweb_flag:
                i += 2 # Skip the at-space
            else:
                i = g.skip_line(s,i)
            i, doc = self.skip_doc(s,i)
        elif kind == at_chapter or kind == at_section:
            i = g.skip_line(s,i)
            i, doc = self.skip_doc(s,i)
        else:
            i = g.skip_line(s,i)
        assert(progress < i) # we must make progress!
    # Only call trimTrailingLines if we have changed its body.
    if anyChanged:
        c.trimTrailingLines(p)
#@+node:ekr.20031218072017.3494:<< Define a section for a leading code part >>
if self.header_name:
    # Tangle code.
    flag = g.choose(code_seen,allow_multiple_parts,disallow_multiple_parts)
    part = self.st_enter_section_name(self.header_name,code,doc,flag)
    # Untangle code.
    if not self.tangling: 
        head = s[:j] ; tail = s[i:]
        s,i,changed = self.update_def(self.header,part,head,code,tail,not_root_name)
        if changed: anyChanged = True
    code_seen = True
    code = doc = None
#@-node:ekr.20031218072017.3494:<< Define a section for a leading code part >>
#@+node:ekr.20031218072017.3493:<< Define a section containing only an @doc part >>
@ It's valid for an @doc directive to appear under a headline that does not contain a section name.  In that case, no section is defined.
@c

if self.header_name:
    # Tangle code.
    flag = g.choose(code_seen,allow_multiple_parts,disallow_multiple_parts)
    part = self.st_enter_section_name(self.header_name,code,doc,flag)
    # Untangle code.
    if not self.tangling: 
        # Untangle no longer updates doc parts.
        # 12/03/02: Mark the part as having been updated to suppress warning.
        junk,junk = self.ust_lookup(self.header_name,
            part,not_root_name,True) # set update flag

doc = None
#@-node:ekr.20031218072017.3493:<< Define a section containing only an @doc part >>
#@+node:ekr.20031218072017.3495:<< Scan and define a section definition >>
# We enter the code part and any preceding doc part into the symbol table.

# Skip the section definition line.
k = i ; i, kind, junk = self.skip_section_name(s,i)
section_name = s[k:i]
# g.trace(section_name)
assert(kind == section_def)
i = g.skip_to_end_of_line(s,i)

# Tangle code: enter the section name even if the code part is empty.
j = g.skip_blank_lines(s,i)
i, code = self.skip_code(s,j)
flag = g.choose(kind==section_def,allow_multiple_parts,disallow_multiple_parts)
part = self.st_enter_section_name(section_name,code,doc,flag)

if not self.tangling: # Untangle code.
    head = s[:j] ; tail = s[i:]
    s,i,changed = self.update_def(section_name,part,head,code,tail,not_root_name)
    if changed: anyChanged = True

code = doc = None
#@-node:ekr.20031218072017.3495:<< Scan and define a section definition >>
#@+node:ekr.20031218072017.3496:<< Scan and define an @code defininition >>
# All @c or @code directives denote < < headline_name > > =
if self.header_name:

    # Tangle code.
    j = g.skip_blank_lines(s,i)
    i, code = self.skip_code(s,j)
    flag = g.choose(code_seen,allow_multiple_parts,disallow_multiple_parts)
    part = self.st_enter_section_name(self.header_name,code,doc,flag)
    if not self.tangling: # Untangle code.
        head = s[:j] ; tail = s[i:]
        s,i,changed = self.update_def(self.header,part,head,code,tail,not_root_name)
        if changed: anyChanged = True
else:
    self.error("@c expects the headline: " + self.header + " to contain a section name")

code_seen = True
code = doc = None
#@-node:ekr.20031218072017.3496:<< Scan and define an @code defininition >>
#@+node:ekr.20031218072017.3497:<< Scan and define a root section >>
# We save the file name in case another @root ends the code section.
old_root_name = self.root_name

# Tangle code.
j = g.skip_blank_lines(s,i)
k, code = self.skip_code(s,j)

# Stephen Schaefer, 9/2/02, later
# st_enter_root_name relies on scanAllDirectives to have set
# the root attributes, such as language, *_comment_string,
# use_header_flag, etc.
self.st_enter_root_name(old_root_name,code,doc)

if not self.tangling: # Untangle code.
    part = 1 # Use 1 for root part.
    head = s[:j] ; tail = s[k:]
    s,i,changed = self.update_def(old_root_name,part,head,code,tail,is_root_name)
    if changed: anyChanged = True

code = doc = None
#@-node:ekr.20031218072017.3497:<< Scan and define a root section >>
#@+node:ekr.20031218072017.3492:The interface between tangle and untangle
@ The following subsections contain the interface between the Tangle and Untangle commands.  This interface is an important hack, and allows Untangle to avoid duplicating the logic in skip_tree and its allies.

The aha is this: just at the time the Tangle command enters a definition into the symbol table, all the information is present that Untangle needs to update that definition.

To get whitespace exactly right we retain the outline's leading whitespace and remove leading whitespace from the updated definition.
#@-node:ekr.20031218072017.3492:The interface between tangle and untangle
#@-node:ekr.20031218072017.3491:skip_body
#@+node:ekr.20031218072017.3498:skip_code
@ This method skips an entire code section. The caller is responsible for entering the completed section into the symbol table. On entry, i points at the line following the @directive or section definition that starts a code section. We skip code until we see the end of the body text or the next @ directive or section defintion that starts a code or doc part.
@c

def skip_code(self,s,i):

    # g.trace(g.get_line(s,i))
    code1 = i
    nl_i = i # For error messages
    done = False # True when end of code part seen.
    if self.use_noweb_flag:
        << skip a noweb code section >>
    else:
        << skip a CWEB code section >>
    code = s[code1:i]
    # g.trace("returns:",code)
    return i,code
#@+node:ekr.20031218072017.3499:<< skip a noweb code section >>
@ This code handles the following escape conventions: double at-sign at the start of a line and at-<< and at.>.
@c

i, done = self.handle_newline(s,i)
while not done and i < len(s):
    ch = s[i]
    if g.is_nl(s,i):
        nl_i = i = g.skip_nl(s,i)
        i, done = self.handle_newline(s,i)
    elif ch == '@' and (g.match(s,i+1,"<<") or # must be on different lines
        g.match(s,i+1,">>")):
        i += 3 # skip the noweb escape sequence.
    elif ch == '<':
        << handle possible noweb section reference >>
    else: i += 1
#@+node:ekr.20031218072017.3500:<< handle possible noweb section reference >>
j, kind, end = self.is_section_name(s,i)
if kind == section_def:
    k = g.skip_to_end_of_line(s,i)
    # We are in the middle of a line.
    i += 1
    self.error("chunk definition not valid here\n" + s[nl_i:k])
elif kind == bad_section_name:
    i += 1 # This is not an error.  Just skip the '<'.
else:
    assert(kind == section_ref)
    # Enter the reference into the symbol table.
    name = s[i:end]
    self.st_enter_section_name(name,None,None,unused_parts_flag)
    i = end
#@-node:ekr.20031218072017.3500:<< handle possible noweb section reference >>
#@-node:ekr.20031218072017.3499:<< skip a noweb code section >>
#@+node:ekr.20031218072017.3501:<< skip a CWEB code section >>
# This code is simple because CWEB control codes are valid anywhere.

while not done and i < len(s):
    if s[i] == '@':
        << handle CWEB control code >>
    else: i += 1
#@+node:ekr.20031218072017.3502:<< handle CWEB control code >>
j, kind, end = self.is_section_name(s,i)

if kind == section_def:
    done = True
elif kind == bad_section_name:
    i += 2 # Any other control code.
else:
    assert(kind == section_ref)
    # Enter the reference into the symbol table.
    name = s[i:j]
    self.st_enter_section_name(name,None,None,unused_parts_flag)
    i = j
#@-node:ekr.20031218072017.3502:<< handle CWEB control code >>
#@-node:ekr.20031218072017.3501:<< skip a CWEB code section >>
#@-node:ekr.20031218072017.3498:skip_code
#@+node:ekr.20031218072017.3503:skip_doc
def skip_doc(self,s,i):

    # g.trace(g.get_line(s,i))
    # Skip @space, @*, @doc, @chapter and @section directives.
    doc1 = i
    while i < len(s):
        if g.is_nl(s,i):
            doc1 = i = g.skip_nl(s,i)
        elif g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@*"):
            i = g.skip_ws(s,i+2) ; doc1 = i
        elif g.match(s,i,"@\n"):
            i += 1 ; doc1 = i
        elif (g.match_word(s,i,"@doc") or
              g.match_word(s,i,"@chapter") or
              g.match_word(s,i,"@section")):
            doc1 = i = g.skip_line(s,i)
        else: break

    while i < len(s):
        kind, end = self.token_type(s,i,dont_report_errors)
        if kind == at_code or kind == at_root or kind == section_def:
            break
        i = g.skip_line(s,i)

    doc = s[doc1:i]
    # g.trace(doc)
    return i, doc
#@-node:ekr.20031218072017.3503:skip_doc
#@+node:ekr.20031218072017.3504:skip_headline
@ This function sets ivars that keep track of the indentation level. We also remember where the next line starts because it is assumed to be the first line of a documentation section.

A headline can contain a leading section name.  If it does, we substitute the section name if we see an @c directive in the body text.
@c

def skip_headline(self,p):

    self.header = s = p.headString()
    # Set self.header_name.
    j = i = g.skip_ws(s,0)
    i, kind, end = self.is_section_name(s,i)
    if kind == bad_section_name:
        self.header_name = None
    else:
        self.header_name = s[j:end]
#@-node:ekr.20031218072017.3504:skip_headline
#@-node:ekr.20031218072017.3489:Pass 1
#@+node:ekr.20031218072017.3505:Pass 2
#@+node:ekr.20031218072017.1488:oblank, oblanks, os, otab, otabs (Tangle)
def oblank (self):
    self.oblanks(1)

def oblanks (self,n):
    if abs(n) > 0:
        self.output_file.write(' ' * abs(n))

def onl(self):
    # 3/18/03: Don't mess with g.body_ignored_newline.
    # self.os(self.output_newline)
    s = self.output_newline
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    self.output_file.write(s)

def os (self,s):
    s = string.replace(s,g.body_ignored_newline,g.body_newline)
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    self.output_file.write(s)

def otab (self):
    self.otabs(1)

def otabs (self,n):
    if abs(n) > 0:
        self.output_file.write('\t' * abs(n))
#@-node:ekr.20031218072017.1488:oblank, oblanks, os, otab, otabs (Tangle)
#@+node:ekr.20031218072017.1151:tangle.put_all_roots
@ This is the top level method of the second pass. It creates a separate C file for each @root directive in the outline. As will be seen later,the file is actually written only if the new version of the file is different from the old version,or if the file did not exist previously. If changed_only_flag FLAG is True only changed roots are actually written.
@c

def put_all_roots(self):

    c = self.c ; outline_name = c.mFileName

    for section in self.root_list:

        # g.trace(section.name)
        file_name = g.os_path_join(self.tangle_directory,section.name)
        file_name = g.os_path_normpath(file_name)
        mode = c.config.output_newline
        # mode = g.choose(mode=="platform",'w','wb')
        textMode = mode == 'platform'
        self.output_file,temp_name = g.create_temp_file(textMode=textMode)
        if not temp_name:
            g.es("Can not create temp file")
            break
        <<Get root specific attributes>>
        <<Put @first lines>>
        if self.use_header_flag and self.print_mode == "verbose":
            << Write a banner at the start of the output file >>
        for part in section.parts:
            if part.is_root:
                self.tangle_indent = 0 # Initialize global.
                self.put_part_node(part,False) # output first lws
        self.onl() # Make sure the file ends with a cr/lf
        self.output_file.close()
        self.output_file = None
        if self.errors + g.app.scanErrors == 0:
            g.update_file_if_changed(c,file_name,temp_name)
        else:
            g.es("unchanged:  " + file_name)
            << Erase the temporary file >>
#@+node:ekr.20031218072017.1152:<<Get root specific attributes>>
# Stephen Schaefer, 9/2/02
# Retrieve the full complement of state for the root node
self.language = section.root_attributes.language
self.single_comment_string = section.root_attributes.single_comment_string
self.start_comment_string = section.root_attributes.start_comment_string
self.end_comment_string = section.root_attributes.end_comment_string
self.use_header_flag = section.root_attributes.use_header_flag
self.print_mode = section.root_attributes.print_mode
self.path = section.root_attributes.path
self.page_width = section.root_attributes.page_width
self.tab_width = section.root_attributes.tab_width
# Stephen P. Schaefer, 9/13/2002
self.first_lines = section.root_attributes.first_lines
#@-node:ekr.20031218072017.1152:<<Get root specific attributes>>
#@+node:ekr.20031218072017.1153:<<Put @first lines>>
# Stephen P. Schaefer 9/13/2002
if self.first_lines:
    self.os(self.first_lines)
#@-node:ekr.20031218072017.1153:<<Put @first lines>>
#@+node:ekr.20031218072017.1154:<<Write a banner at the start of the output file>>
if self.single_comment_string:
    self.os(self.single_comment_string)
    self.os(" Created by Leo from: ")
    self.os(outline_name)
    self.onl() ; self.onl()
elif self.start_comment_string and self.end_comment_string:
    self.os(self.start_comment_string)
    self.os(" Created by Leo from: ")
    self.os(outline_name)
    self.oblank() ; self.os(self.end_comment_string)
    self.onl() ; self.onl()
#@-node:ekr.20031218072017.1154:<<Write a banner at the start of the output file>>
#@+node:ekr.20031218072017.1155:<< Erase the temporary file >>
try: # Just delete the temp file.
    os.remove(temp_name)
except: pass
#@-node:ekr.20031218072017.1155:<< Erase the temporary file >>
#@-node:ekr.20031218072017.1151:tangle.put_all_roots
#@+node:ekr.20031218072017.3506:put_code
@ This method outputs a code section, expanding section references by their definition. We should see no @directives or section definitions that would end the code section.

Most of the differences bewteen noweb mode and CWEB mode are handled by token_type(called from put_newline). Here, the only difference is that noweb handles double-@ signs only at the start of a line.
@c

def put_code(self,s,no_first_lws_flag):

    # g.trace(g.get_line(s,0))
    i = 0
    if i < len(s):
        i = self.put_newline(s,i,no_first_lws_flag)
        # Double @ is valid in both noweb and CWEB modes here.
        if g.match(s,i,"@@"):
            self.os('@') ; i += 2
    while i < len(s):
        progress = i
        ch = s[i]
        if (g.match(s,i,"<<") and self.use_noweb_flag or
            g.match(s,i,"@<") and self.use_cweb_flag):
            << put possible section reference >>
        elif ch == '@': # We are in the middle of a line.
            if self.use_cweb_flag:
                << handle 2-character CWEB control codes >>
            else:
                << handle noweb @ < < convention >>
        elif ch == g.body_ignored_newline:
            i += 1
        elif ch == g.body_newline:
            i += 1 ; self.onl()
            i = self.put_newline(s,i,False) # Put full lws
            if self.use_cweb_flag and g.match(s,i,"@@"):
                self.os('@') ; i += 2
        else: self.os(s[i]) ; i += 1
        assert(progress < i)
#@+node:ekr.20031218072017.3507:<<put possible section reference >>
j, kind, name_end = self.is_section_name(s,i)
if kind == section_def:
    # We are in the middle of a code section
    self.error(
        "Should never happen:\n" +
        "section definition while putting a section reference: " +
        s[i:j])
    i += 1
elif kind == bad_section_name:
    self.os(s[i]) ; i += 1 # This is not an error.
else:
    assert(kind == section_ref)
    name = s[i:name_end]
    self.put_section(s,i,name,name_end)
    i = j
#@-node:ekr.20031218072017.3507:<<put possible section reference >>
#@+node:ekr.20031218072017.3508:<< handle 2-character CWEB control codes >>
if g.match(s,i,"@@"):
    # Handle double @ sign.
    self.os('@') ; i += 2
else:
    i += 1 # skip the @.
    if i+1 >= len(s) or g.is_ws_or_nl(s,i):
        # A control code: at-backslash is not a valid CWEB control code.
        # We are in CWEB mode, so we can output C block comments.
        self.os("/*@" + s[i] + "*/") ; i += 1
    else:
        self.os("@") # The at sign is not part of a control code.
#@-node:ekr.20031218072017.3508:<< handle 2-character CWEB control codes >>
#@+node:ekr.20031218072017.3509:<< handle noweb @ < < convention >>
@ The user must ensure that neither @ < < nor @ > > occurs in comments or strings. However, it is valid for @ < < or @ > > to appear in the doc chunk or in a single-line comment.
@c

if g.match(s,i,"@<<"):
    self.os("/*@*/<<") ; i += 3

elif g.match(s,i,"@>>"):
    self.os("/*@*/>>") ; i += 3

else: self.os("@") ; i += 1
#@-node:ekr.20031218072017.3509:<< handle noweb @ < < convention >>
#@-node:ekr.20031218072017.3506:put_code
#@+node:ekr.20031218072017.3510:put_doc
# This method outputs a doc section within a block comment.

def put_doc(self,s):

    # g.trace(g.get_line(s,0))
    width = self.page_width
    words = 0 ; word_width = 0 ; line_width = 0
    # 8/1/02: can't use choose here!
    if self.single_comment_string == None: single_w = 0
    else: single_w = len(self.single_comment_string)
    # Make sure we put at least 20 characters on a line.
    if width - max(0,self.tangle_indent) < 20:
        width = max(0,self.tangle_indent) + 20
    # Skip Initial white space in the doc part.
    i = g.skip_ws_and_nl(s,0)
    if i < len(s) and (self.print_mode == "verbose" or self.print_mode == "quiet"):
        use_block_comment = self.start_comment_string and self.end_comment_string
        use_single_comment = not use_block_comment and self.single_comment_string
        # javadoc_comment = use_block_comment and self.start_comment_string == "/**"
        if use_block_comment or use_single_comment:
            if 0: # The section name ends in an self.onl().
                self.onl()
            self.put_leading_ws(self.tangle_indent)
            if use_block_comment:
                self.os(self.start_comment_string)
            << put the doc part >>
            self.onl()
            self.put_leading_ws(self.tangle_indent)
            if use_block_comment:
                self.os(self.end_comment_string)
            self.onl()
        else: self.onl()
#@+node:ekr.20031218072017.3511:<<put the doc part>>
@ This code fills and outputs each line of a doc part. It keeps track of whether the next word will fit on a line,and starts a new line if needed.
@c

if use_single_comment:
    # New code: 5/31/00
    self.os(self.single_comment_string) ; self.otab()
    line_width =(single_w / abs(self.tab_width) + 1) * abs(self.tab_width)
else:
    line_width = abs(self.tab_width)
    self.onl() ; self.otab()
self.put_leading_ws(self.tangle_indent)
line_width += max(0,self.tangle_indent)
words = 0 ; word_width = 0
while i < len(s):
    <<output or skip whitespace or newlines>>
    if i >= len(s):
        break
    <<compute the width of the next word>>
    if words == 0 or line_width + word_width < width:
        words += 1
        <<output next word>>
        line_width += word_width
    else:
        # 11-SEP-2002 DTHEIN: Fixed linewrapping bug in
        # tab-then-comment sequencing
        self.onl()
        if use_single_comment:
            self.os(self.single_comment_string) ; self.otab()
            line_width = (single_w / abs(self.tab_width) + 1) * abs(self.tab_width)
        else:
            self.otab()
            line_width = abs(self.tab_width)
        words = 0
        self.put_leading_ws(self.tangle_indent)
        # tangle_indent is in spaces.
        line_width += max(0,self.tangle_indent)
#@+node:ekr.20031218072017.3512:<<output or skip whitespace or newlines>>
@ This outputs whitespace if it fits, and ignores it otherwise, and starts a new line if a newline is seen. The effect of self code is that we never start a line with whitespace that was originally at the end of a line.
@c

while g.is_ws_or_nl(s,i):
    ch = s[i]
    if ch == '\t':
        pad = abs(self.tab_width) - (line_width % abs(self.tab_width))
        line_width += pad
        if line_width < width: self.otab()
        i += 1
    elif ch == ' ':
        line_width += 1
        if line_width < width: self.os(ch)
        i += 1
    else:
        assert(g.is_nl(s,i))
        self.onl()
        if use_single_comment:
            # New code: 5/31/00
            self.os(self.single_comment_string) ; self.otab()
            line_width = (single_w / abs(self.tab_width) + 1) * abs(self.tab_width)
        else:
            self.otab()
            line_width = abs(self.tab_width)
        i = g.skip_nl(s,i)
        words = 0
        self.put_leading_ws(self.tangle_indent)
        # tangle_indent is in spaces.
        line_width += max(0,self.tangle_indent)
#@-node:ekr.20031218072017.3512:<<output or skip whitespace or newlines>>
#@+node:ekr.20031218072017.3513:<<compute the width of the next word>>
j = i ; word_width = 0
while j < len(s) and not g.is_ws_or_nl(s,j):
    word_width += 1
    j += 1
#@-node:ekr.20031218072017.3513:<<compute the width of the next word>>
#@+node:ekr.20031218072017.3514:<<output next word>>
while i < len(s) and not g.is_ws_or_nl(s,i):
    self.os(s[i])
    i += 1
#@-node:ekr.20031218072017.3514:<<output next word>>
#@-node:ekr.20031218072017.3511:<<put the doc part>>
#@-node:ekr.20031218072017.3510:put_doc
#@+node:ekr.20031218072017.3515:put_leading_ws
# Puts tabs and spaces corresponding to n spaces, assuming that we are at the start of a line.

def put_leading_ws(self,n):

    # g.trace("tab_width,indent:",self.tab_width,indent)
    w = self.tab_width

    if w > 1:
        q,r = divmod(n,w)
        self.otabs(q) 
        self.oblanks(r) 
    else:
        self.oblanks(n)
#@-node:ekr.20031218072017.3515:put_leading_ws
#@+node:ekr.20031218072017.3516:put_newline
@ This method handles scanning when putting the start of a new line. Unlike the corresponding method in pass one, this method doesn't need to set a done flag in the caller because the caller already knows where the code section ends.
@c

def put_newline(self,s,i,no_first_lws_flag):

    kind, end = self.token_type(s,i,dont_report_errors)
    << Output leading white space except for blank lines >>
    if i >= len(s):
        return i
    elif kind == at_web or kind == at_at:
        i += 2 # Allow the line to be scanned.
    elif kind == at_doc or kind == at_code:
        if self.use_cweb_flag:
            i += 2
    else:
        # These should have set limit in pass 1.
        assert(kind != section_def and kind != at_chapter and kind != at_section)
    return i
#@+node:ekr.20031218072017.3517:<< Output leading white space except for blank lines >>
j = i ; i = g.skip_ws(s,i)
if i < len(s) and not g.is_nl(s,i):
    # Conditionally output the leading previous leading whitespace.
    if not no_first_lws_flag:
        self.put_leading_ws(self.tangle_indent)
    # Always output the leading whitespace of _this_ line.
    k, width = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    self.put_leading_ws(width)
#@-node:ekr.20031218072017.3517:<< Output leading white space except for blank lines >>
#@-node:ekr.20031218072017.3516:put_newline
#@+node:ekr.20031218072017.3518:put_part_node
# This method outputs one part of a section definition.

def put_part_node(self,part,no_first_lws_flag):

    if 0:
        if part: name = part.name # can't use choose.
        else: name = "<NULL part>"
        g.trace(name)

    if part.doc and self.output_doc_flag and self.print_mode != "silent" and part.doc:
        self.put_doc(part.doc)

    if part.code:
        self.put_code(part.code,no_first_lws_flag)
#@-node:ekr.20031218072017.3518:put_part_node
#@+node:ekr.20031218072017.3519:put_section
@ This method outputs the definition of a section and all sections referenced from the section. name is the section's name. This code checks for recursive definitions by calling section_check(). We can not allow section x to expand to code containing another call to section x, either directly or indirectly.
@c

def put_section(self,s,i,name,name_end):

    j = g.skip_line(s,i)
    # g.trace("indent:",self.tangle_indent,s[i:j])
    outer_old_indent = self.tangle_indent
    trailing_ws_indent = 0 # Set below.
    inner_old_indent = 0 # Set below.
    newline_flag = False  # True if the line ends with the reference.
    assert(g.match(name,0,"<<") or g.match(name,0,"@<"))
    << Calculate the new value of tangle_indent >>
    << Set 'newline_flag' if the line ends with the reference >>
    section = self.st_lookup(name,not_root_name)
    if section and section.parts:
        # Expand the section only if we are not already expanding it.
        if self.section_check(name):
            self.section_stack.append(name)
            << put all parts of the section definition >>
            self.section_stack.pop()
    else:
        << Put a comment about the undefined section >>
    if not newline_flag:
        self.put_leading_ws(trailing_ws_indent)
    self.tangle_indent = outer_old_indent
    return i, name_end
#@+node:ekr.20031218072017.3520:<< Calculate the new value of tangle_indent >>
# Find the start of the line containing the reference.
j = i
while j > 0 and not g.is_nl(s,j):
    j -= 1
if g.is_nl(s,j):
    j = g.skip_nl(s,j)

# Bump the indentation
j, width = g.skip_leading_ws_with_indent(s,j,self.tab_width)
self.tangle_indent += width
# g.trace("leading ws,new indent:",width,self.tangle_indent)

# 4/27/01: Force no trailing whitespace in @silent mode.
if self.print_mode == "silent":
    trailing_ws_indent = 0
else:
    trailing_ws_indent = self.tangle_indent

# Increase the indentation if the section reference does not immediately follow
# the leading white space.  4/3/01: Make no adjustment in @silent mode.
if (j < len(s) and self.print_mode != "silent" and
        ((self.use_noweb_flag and s[j] != '<') or
        (self.use_cweb_flag and s[j] != '@'))):
    self.tangle_indent += abs(self.tab_width)
#@-node:ekr.20031218072017.3520:<< Calculate the new value of tangle_indent >>
#@+node:ekr.20031218072017.3521:<< Set 'newline_flag' if the line ends with the reference >>
if self.print_mode != "silent":
    i = name_end
    i = g.skip_ws(s,i)
    newline_flag = (i >= len(s) or g.is_nl(s,i))
#@-node:ekr.20031218072017.3521:<< Set 'newline_flag' if the line ends with the reference >>
#@+node:ekr.20031218072017.3522:<<put all parts of the section definition>>
@ This section outputs each part of a section definition. We first count how many parts there are so that the code can output a comment saying 'part x of y'.
@c

# Output each part of the section.
sections = len(section.parts)
count = 0
for part in section.parts:
    count += 1
    # In @silent mode, there is no sentinel line to "use up" the previously output
    # leading whitespace.  We set the flag to tell put_part_node and put_code
    # not to call put_newline at the start of the first code part of the definition.
    no_first_leading_ws_flag = (count == 1 and self.print_mode == "silent")
    inner_old_indent = self.tangle_indent
    # 4/3/01: @silent inhibits newlines after section expansion.
    if self.print_mode != "silent":
        << Put the section name in a comment >>
    self.put_part_node(part,no_first_leading_ws_flag)
    # 4/3/01: @silent inhibits newlines after section expansion.
    if count == sections and (self.print_mode != "silent" and self.print_mode != "quiet"):
        << Put the ending comment >>
    # Restore the old indent.
    self.tangle_indent = inner_old_indent
#@+node:ekr.20031218072017.3523:<< Put the section name in a comment >>
if count > 1:
    self.onl()
    self.put_leading_ws(self.tangle_indent)

# Don't print trailing whitespace
name = string.rstrip(name)
if self.single_comment_string:
    self.os(self.single_comment_string) ; self.oblank() ; self.os(name)
    << put (n of m) >>
else:
    assert(
        self.start_comment_string and len(self.start_comment_string) > 0 and
        self.end_comment_string and len(self.end_comment_string)> 0)
    self.os(self.start_comment_string) ; self.oblank() ; self.os(name)
    << put (n of m) >>
    self.oblank() ; self.os(self.end_comment_string)

self.onl() # Always output a newline.
#@+node:ekr.20031218072017.3524:<< put ( n of m ) >>
if sections > 1:
    self.oblank()
    self.os("(%d of %d)" % (count,sections))
#@-node:ekr.20031218072017.3524:<< put ( n of m ) >>
#@-node:ekr.20031218072017.3523:<< Put the section name in a comment >>
#@+node:ekr.20031218072017.3525:<< Put the ending comment >>
@ We do not produce an ending comment unless we are ending the last part of the section,and the comment is clearer if we don't say(n of m).
@c

self.onl() ; self.put_leading_ws(self.tangle_indent)
#  Don't print trailing whitespace
while name_end > 0 and g.is_ws(s[name_end-1]):
    name_end -= 1

if self.single_comment_string:
    self.os(self.single_comment_string) ; self.oblank()
    self.os("-- end -- ") ; self.os(name)
else:
    self.os(self.start_comment_string) ; self.oblank()
    self.os("-- end -- ") ; self.os(name)
    self.oblank() ; self.os(self.end_comment_string)

@ The following code sets a flag for untangle.

If something follows the section reference we must add a newline, otherwise the "something" would become part of the comment.  Any whitespace following the (!newline) should follow the section defintion when Untangled.
@c

if not newline_flag:
    self.os(" (!newline)") # LeoCB puts the leading blank, so we must do so too.
    # Put the whitespace following the reference.
    while name_end < len(s) and g.is_ws(s[name_end]):
        self.os(s[name_end])
        name_end += 1
    self.onl() # We must supply the newline!
#@-node:ekr.20031218072017.3525:<< Put the ending comment >>
#@-node:ekr.20031218072017.3522:<<put all parts of the section definition>>
#@+node:ekr.20031218072017.3526:<<Put a comment about the undefined section>>
self.onl() ; self.put_leading_ws(self.tangle_indent)

if self.print_mode != "silent":
    if self.single_comment_string:
        self.os(self.single_comment_string)
        self.os(" undefined section: ") ; self.os(name) ; self.onl()
    else:
        self.os(self.start_comment_string)
        self.os(" undefined section: ") ; self.os(name)
        self.oblank() ; self.os(self.end_comment_string) ; self.onl()

self.error("Undefined section: " + name)
#@-node:ekr.20031218072017.3526:<<Put a comment about the undefined section>>
#@-node:ekr.20031218072017.3519:put_section
#@+node:ekr.20031218072017.3527:section_check
@ We can not allow a section to be defined in terms of itself, either directly or indirectly.

We push an entry on the section stack whenever beginning to expand a section and pop the section stack at the end of each section.  This method checks whether the given name appears in the stack. If so, the section is defined in terms of itself.
@c

def section_check (self,name):

    if name in self.section_stack:
        s = "Invalid recursive reference of " + name + "\n"
        for n in self.section_stack:
            s += "called from: " + n + "\n"
        self.error(s)
        return False
    return True
#@-node:ekr.20031218072017.3527:section_check
#@-node:ekr.20031218072017.3505:Pass 2
#@-node:ekr.20031218072017.3488:tangle
#@+node:ekr.20031218072017.3528:tst
#@+node:ekr.20031218072017.3529:st_check
def st_check(self):

    """Checks the given symbol table for defined but never referenced sections."""

    keys = self.tst.keys()
    keys.sort()
    # g.trace(keys)
    for name in keys:
        section = self.tst[name]
        if not section.referenced:
            g.es(' ' * 4 + "Warning: " +
                g.choose(self.use_noweb_flag,"<< ","@< ") +
                section.name +
                g.choose(self.use_noweb_flag," >>"," @>") +
                " has been defined but not used.")
#@-node:ekr.20031218072017.3529:st_check
#@+node:ekr.20031218072017.3530:st_dump
# Dumps the given symbol table in a readable format.

def st_dump(self,verbose_flag=True):

    s = "\ndump of symbol table...\n"
    keys = self.tst.keys()
    keys.sort()
    for name in keys:
        section = self.tst[name]
        if verbose_flag:
            s += self.st_dump_node(section)
        else:
            theType = g.choose(len(section.parts)>0,"  ","un")
            s += ("\n" + theType + "defined:[" + section.name + "]")
    return s
#@-node:ekr.20031218072017.3530:st_dump
#@+node:ekr.20031218072017.3531:st_dump_node
# Dumps each part of a section's definition.

def st_dump_node(self,section):

    s = ("\nsection: " + section.name +
        ", referenced:" + str(section.referenced) +
        ", is root:" + str(section.is_root))

    if len(section.parts) > 0:
        s += "\n----- parts of " + g.angleBrackets(section.name)
        n = 1 # part list is in numeric order
        for part in section.parts:
            s += "\n----- Part " + str(n)
            n += 1
            s += "\ndoc:  [" + repr(part.doc)  + "]"
            s += "\ncode: [" + repr(part.code) + "]"
        s += "\n----- end of partList\n"
    return s
#@-node:ekr.20031218072017.3531:st_dump_node
#@+node:ekr.20031218072017.3532:st_enter
def st_enter(self,name,code,doc,multiple_parts_flag,is_root_flag):

    """Enters names and their associated code and doc parts into the given symbol table."""

    # g.trace(name)
    section = self.st_lookup(name,is_root_flag)
    assert(section)
    if doc:
        doc = string.rstrip(doc) # remove trailing lines.
    if code:
        if self.print_mode != "silent": # @silent supresses newline processing.
            i = g.skip_blank_lines(code,0) # remove leading lines.
            if i > 0: code = code[i:] 
            if code and len(code) > 0: code = string.rstrip(code) # remove trailing lines.
        if len(code) == 0: code = None
    if code:
        << check for duplicate code definitions >>
    if code or doc:
        part = part_node(name,code,doc,is_root_flag,False) # not dirty
        section.parts.append(part)
    else: # A reference
        section.referenced = True
    if is_root_flag:
        self.root_list.append(section)
        section.referenced = True # Mark the root as referenced.
        <<remember root node attributes>>
    # Stephen Schaefer, 9/2/02
    return len(section.parts) # part number
#@+node:ekr.20031218072017.3533:<<check for duplicate code definitions >>
for part in section.parts:

    if part.code and multiple_parts_flag == disallow_multiple_parts:
        # Give the message only for non-empty parts.
        self.error("Multiple parts not allowed for " + name)
        return 0 # part number

    if self.tangling and code and code == part.code:
        g.es("Warning: possible duplicate definition of: <<" +
            section.name + ">>")
#@-node:ekr.20031218072017.3533:<<check for duplicate code definitions >>
#@+node:ekr.20031218072017.3534:<<remember root node attributes>>
# Stephen Schaefer, 9/2/02
# remember the language and comment characteristics
section.root_attributes = root_attributes(self)
#@-node:ekr.20031218072017.3534:<<remember root node attributes>>
#@-node:ekr.20031218072017.3532:st_enter
#@+node:ekr.20031218072017.3535:st_enter_root_name
# Enters a root name into the given symbol table.

def st_enter_root_name(self,name,code,doc):

    # assert(code)
    if name: # User errors can result in an empty @root name.
        self.st_enter(name,code,doc,disallow_multiple_parts,is_root_name)
#@-node:ekr.20031218072017.3535:st_enter_root_name
#@+node:ekr.20031218072017.3536:st_enter_section_name
def st_enter_section_name(self,name,code,doc,multiple_parts_flag):

    """Enters a section name into the given symbol table.

    The code and doc pointers are None for references."""

    return self.st_enter(name,code,doc,multiple_parts_flag,not_root_name)
#@-node:ekr.20031218072017.3536:st_enter_section_name
#@+node:ekr.20031218072017.3537:st_lookup
def st_lookup(self,name,is_root_flag):

    """Looks up name in the symbol table and creates a tst_node for it if it does not exist."""

    if is_root_flag:
        key = name
    else:
        key = self.standardize_name(name)

    if self.tst.has_key(key):
        section = self.tst[key]
        # g.trace("found:" + key)
        return section
    else:
        # g.trace("not found:" + key)
        section = tst_node(key,is_root_flag)
        self.tst [key] = section
        return section
#@-node:ekr.20031218072017.3537:st_lookup
#@-node:ekr.20031218072017.3528:tst
#@+node:ekr.20031218072017.3538:ust
#@+node:ekr.20031218072017.3539:ust_dump
def ust_dump (self):

    s = "\n---------- Untangle Symbol Table ----------"
    keys = self.ust.keys()
    keys.sort()
    for name in keys:
        section = self.ust[name]
        s += "\n\n" + section.name
        for part in section.parts.values():
            assert(part.of == section.of)
            s += "\n----- part %d of %d -----\n" % (part.part,part.of)
            s += repr(g.get_line(part.code,0))
    s += "\n--------------------"
    return s
#@-node:ekr.20031218072017.3539:ust_dump
#@+node:ekr.20031218072017.3540:ust_enter
@ This routine enters names and their code parts into the given table. The 'part' and 'of' parameters are taken from the "(part n of m)" portion of the line that introduces the section definition in the C code.

If no part numbers are given the caller should set the 'part' and 'of' parameters to zero.  The caller is reponsible for checking for duplicate parts.

This function handles names scanned from a source file; the corresponding st_enter routine handles names scanned from outlines.
@c

def ust_enter (self,name,part,of,code,nl_flag,is_root_flag):

    if not is_root_flag:
        name = self.standardize_name(name)
    << remove blank lines from the start and end of the text >>
    u = ust_node(name,code,part,of,nl_flag,False) # update_flag
    if not self.ust.has_key(name):
        self.ust[name] = u
    section = self.ust[name]
    section.parts[part]=u # Parts may be defined in any order.
    # g.trace("section [%s](part %d of %d)...%s" % (name,part,of,g.get_line(code,0)))
#@+node:ekr.20031218072017.3541:<< remove blank lines from the start and end of the text >>
i = g.skip_blank_lines(code,0)
if i > 0:
    code = code[i:]
    code = string.rstrip(code)
#@-node:ekr.20031218072017.3541:<< remove blank lines from the start and end of the text >>
#@-node:ekr.20031218072017.3540:ust_enter
#@+node:ekr.20031218072017.3542:ust_lookup
# Searches the given table for a part matching the name and part number.

def ust_lookup (self,name,part_number,is_root_flag,update_flag):

    # g.trace(name,part_number)

    if not is_root_flag:
        name = self.standardize_name(name)

    if part_number == 0: part_number = 1 # A hack: zero indicates the first part.
    if self.ust.has_key(name):
        section = self.ust[name]
        if section.parts.has_key(part_number):
            part = section.parts[part_number]
            if update_flag: part.update_flag = True
            # g.trace("found: %d (%d)...\n" % (name,part_number,g.get_line(part.code,0)))
            return part, True

    # g.trace("not found: %s(%d)...\n" % (name,part_number))
    return None, False
#@-node:ekr.20031218072017.3542:ust_lookup
#@+node:ekr.20031218072017.3543:ust_warn_about_orphans
def ust_warn_about_orphans (self):

    """Issues a warning about any sections in the derived file for which
    no corresponding section has been seen in the outline."""

    for section in self.ust.values():
        # g.trace(section)
        for part in section.parts.values():
            assert(part.of == section.of)
            if not part.update_flag:
                g.es("Warning: " +
                    g.choose(self.use_noweb_flag,"<< ","@< ") +
                    part.name +
                    g.choose(self.use_noweb_flag," >>"," @>") +
                    " is not in the outline")
                break # One warning per section is enough.
#@-node:ekr.20031218072017.3543:ust_warn_about_orphans
#@-node:ekr.20031218072017.3538:ust
#@+node:ekr.20031218072017.3544:untangle
#@+node:ekr.20031218072017.3545:compare_comments
@ This function compares the interior of comments and returns True if they are identical except for whitespace or newlines. It is up to the caller to eliminate the opening and closing delimiters from the text to be compared.
@c

def compare_comments (self,s1,s2):

    tot_len = 0
    if self.comment: tot_len += len(self.comment)
    if self.comment_end: tot_len += len(self.comment_end)
    CWEB_flag = (self.language == "c" and not self.use_noweb_flag)

    p1, p2 = 0, 0
    while p1 < len(s1) and p2 < len(s2):
        p1 = g.skip_ws_and_nl(s1,p1)
        p2 = g.skip_ws_and_nl(s2,p2)
        if self.comment and self.comment_end:
            << Check both parts for @ comment conventions >>
        if p1 >= len(s1) or p2 >= len(s2):
            break
        if s1[p1] != s2[p2]:
            return False
        p1 += 1 ; p2 += 1
    p1 = g.skip_ws_and_nl(s1,p1)
    p2 = g.skip_ws_and_nl(s2,p2)
    return p1 == len(s1) and p2 == len(s2)
#@+node:ekr.20031218072017.3546:<< Check both parts for @ comment conventions >>
@ This code is used in forgiving_compare()and in compare_comments().

In noweb mode we allow / * @ * /  (without the spaces)to be equal to @.
In CWEB mode we allow / * @ ? * / (without the spaces)to be equal to @?.
at-backslash is not a valid CWEB control code, so we don't have to equate
/ * @ \\ * / with at-backslash.

We must be careful not to run afoul of this very convention here!
@c

if p1 < len(s1) and s1[p1] == '@':
    if g.match(s2,p2,self.comment + '@' + self.comment_end):
        p1 += 1
        p2 += tot_len + 1
        continue
    elif (CWEB_flag and s1[p1] == '@' and p1 + 1 < len(s1) and
        g.match(s2,p2,self.comment + '@' + s1[p1+1])):
        p1 += 2
        p2 += tot_len + 2
        continue
elif p2 < len(s2) and s2[p2] == '@':
    if g.match(s1,p1,self.comment + '@' + self.comment_end):
        p2 += 1
        p1 += tot_len + 1
        continue
    elif (CWEB_flag and s1[p1] == '@' and p1 + 1 < len(s1) and
        g.match(s1,p1,self.comment + '@' + s2[p2+1])):
        p2 += 2
        p1 += tot_len + 2
        continue
#@-node:ekr.20031218072017.3546:<< Check both parts for @ comment conventions >>
#@-node:ekr.20031218072017.3545:compare_comments
#@+node:ekr.20031218072017.3547:massage_block_comment (no longer used)
@ This function is called to massage an @doc part in the ust. We call this routine only after a mismatch in @doc parts is found between the ust and tst. On entry, the parameters point to the inside of a block C comment: the opening and closing delimiters are not part of the text handled by self routine.

This code removes newlines that may have been inserted by the Tangle command in a block comment. Tangle may break lines differently in different expansions, but line breaks are ignored by forgiving_compare() and doc_compare() within block C comments.

We count the leading whitespace from the first non-blank line and remove this much whitespace from all lines. We also remove singleton newlines and replace sequences of two or more newlines by a single newline.
@c

def massage_block_comment (self,s):

    c = self.c
    newlines = 0  # Consecutive newlines seen.
    i = g.skip_blank_lines(s,0)
    # Copy the first line and set n
    i, n = g.skip_leading_ws_with_indent(s,i,c.tab_width)
    j = i ; i = g.skip_to_end_of_line(s,i)
    result = s[j:i]
    while i < len(s):
        assert(g.is_nl(s,i))
        newlines += 1
        # Replace the first newline with a blank.
        result += ' ' ; i += 1
        while i < len(s) and g.is_nl(s,i):
            i += 1 # skip the newline.
        j = i ; i = g.skip_ws(s,i)
        if g.is_nl(s,i)and newlines > 1:
            # Skip blank lines.
            while g.is_nl(s,i):
                i += 1
        else:
            # Skip the leading whitespace.
            i = j # back track
            i = g.skip_leading_ws(s,i,n,c.tab_width)
            newlines = 0
            # Copy the rest of the line.
            j = i ; i = g.skip_to_end_of_line(s,i)
            result += s[j:i]
    return result
#@-node:ekr.20031218072017.3547:massage_block_comment (no longer used)
#@+node:ekr.20031218072017.3548:forgiving_compare
@ This is the "forgiving compare" function.  It compares two texts and returns True if they are identical except for comments or non-critical whitespace.  Whitespace inside strings or preprocessor directives must match exactly.
@c

def forgiving_compare (self,name,part,s1,s2):

    __pychecker__ = 'maxlines=500 maxbranches=100 --no-argsused'
        # name and part are good for debugging.

    if 0:
        g.trace(name,part,
            "\n1:",g.get_line(s1,0),
            "\n2:",g.get_line(s2,0))
    s1 = g.toUnicode(s1,self.encoding) # 4/4/03
    s2 = g.toUnicode(s2,self.encoding) # 4/4/03
    << Define forgiving_compare vars >>
    p1 = g.skip_ws_and_nl(s1,0) 
    p2 = g.skip_ws_and_nl(s2,0)
    result = True
    while result and p1 < len(s1) and p2 < len(s2):
        first1 = p1 ; first2 = p2
        if self.comment and self.comment_end:
            << Check both parts for @ comment conventions >>
        ch1 = s1[p1]
        if ch1 == '\r' or ch1 == '\n':
            << Compare non-critical newlines >>
        elif ch1 ==  ' ' or ch1 == '\t':
            << Compare non-critical whitespace >>
        elif ch1 == '\'' or ch1 == '"':
            << Compare possible strings >>
        elif ch1 == '#':
            << Compare possible preprocessor directives >>
        elif ch1 == '<' or ch1 == '@':
            << Compare possible section references >>
        else:
            << Compare comments or single characters >>
    << Make sure both parts have ended >>
    if not result:
        << trace the mismatch >>
    return result
#@+node:ekr.20031218072017.3549:<< Define forgiving_compare vars >>
# scan_derived_file has set the ivars describing comment delims.
first1 = first2 = 0

tot_len = 0
if self.comment: tot_len += len(self.comment)
if self.comment_end: tot_len += len(self.comment_end)

CWEB_flag = (self.language == "c" and not self.use_noweb_flag)
#@-node:ekr.20031218072017.3549:<< Define forgiving_compare vars >>
#@+node:ekr.20031218072017.3546:<< Check both parts for @ comment conventions >>
@ This code is used in forgiving_compare()and in compare_comments().

In noweb mode we allow / * @ * /  (without the spaces)to be equal to @.
In CWEB mode we allow / * @ ? * / (without the spaces)to be equal to @?.
at-backslash is not a valid CWEB control code, so we don't have to equate
/ * @ \\ * / with at-backslash.

We must be careful not to run afoul of this very convention here!
@c

if p1 < len(s1) and s1[p1] == '@':
    if g.match(s2,p2,self.comment + '@' + self.comment_end):
        p1 += 1
        p2 += tot_len + 1
        continue
    elif (CWEB_flag and s1[p1] == '@' and p1 + 1 < len(s1) and
        g.match(s2,p2,self.comment + '@' + s1[p1+1])):
        p1 += 2
        p2 += tot_len + 2
        continue
elif p2 < len(s2) and s2[p2] == '@':
    if g.match(s1,p1,self.comment + '@' + self.comment_end):
        p2 += 1
        p1 += tot_len + 1
        continue
    elif (CWEB_flag and s1[p1] == '@' and p1 + 1 < len(s1) and
        g.match(s1,p1,self.comment + '@' + s2[p2+1])):
        p2 += 2
        p1 += tot_len + 2
        continue
#@-node:ekr.20031218072017.3546:<< Check both parts for @ comment conventions >>
#@+node:ekr.20031218072017.3550:<< Compare non-critical newlines >>
p1 = g.skip_ws_and_nl(s1,p1)
p2 = g.skip_ws_and_nl(s2,p2)
#@-node:ekr.20031218072017.3550:<< Compare non-critical newlines >>
#@+node:ekr.20031218072017.3551:<< Compare non-critical whitespace >>
p1 = g.skip_ws(s1,p1)
p2 = g.skip_ws(s2,p2)
#@-node:ekr.20031218072017.3551:<< Compare non-critical whitespace >>
#@+node:ekr.20031218072017.3555:<< Compare possible strings >>
# This code implicitly assumes that string1_len == string2_len == 1.
# The match test ensures that the language actually supports strings.

if (g.match(s1,p1,self.string1) or g.match(s1,p1,self.string2)) and s1[p1] == s2[p2]:

    if self.language == "pascal":
        << Compare Pascal strings >>
    else:
        << Compare C strings >>
    if not result:
        self.mismatch("Mismatched strings")
else:
    << Compare single characters >>
#@+node:ekr.20031218072017.3557:<< Compare Pascal strings >>
@ We assume the Pascal string is on a single line so the problems with cr/lf do not concern us.
@c

first1 = p1 ; first2 = p2
p1 = g.skip_pascal_string(s1,p1)
p2 = g.skip_pascal_string(s2,p2)
result = s1[first1,p1] == s2[first2,p2]
#@-node:ekr.20031218072017.3557:<< Compare Pascal strings >>
#@+node:ekr.20031218072017.3556:<< Compare C strings >>
delim = s1[p1]
result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1

while result and p1 < len(s1) and p2 < len(s2):
    if s1[p1] == delim and self.is_end_of_string(s1,p1,delim):
        result =(s2[p2] == delim and self.is_end_of_string(s2,p2,delim))
        p1 += 1 ; p2 += 1
        break
    elif g.is_nl(s1,p1) and g.is_nl(s2,p2):
        p1 = g.skip_nl(s1,p1)
        p2 = g.skip_nl(s2,p2)
    else:
        result = s1[p1] == s2[p2]
        p1 += 1 ; p2 += 1
#@-node:ekr.20031218072017.3556:<< Compare C strings >>
#@+node:ekr.20031218072017.3553:<< Compare single characters >>
assert(p1 < len(s1) and p2 < len(s2))
result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
if not result: self.mismatch("Mismatched single characters")
#@-node:ekr.20031218072017.3553:<< Compare single characters >>
#@-node:ekr.20031218072017.3555:<< Compare possible strings >>
#@+node:ekr.20031218072017.3552:<< Compare possible preprocessor directives >>
if self.language == "c":
    << compare preprocessor directives >>
else:
    << compare single characters >>
#@+node:ekr.20031218072017.3554:<< Compare preprocessor directives >>
# We cannot assume that newlines are single characters.

result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
while result and p1 < len(s1) and p2 < len(s2):
    if g.is_nl(s1,p1):
        result = g.is_nl(s2,p2)
        if not result or self.is_end_of_directive(s1,p1):
            break
        p1 = g.skip_nl(s1,p1)
        p2 = g.skip_nl(s2,p2)
    else:
        result = s1[p1] == s2[p2]
        p1 += 1 ; p2 += 1
if not result:
    self.mismatch("Mismatched preprocessor directives")
#@-node:ekr.20031218072017.3554:<< Compare preprocessor directives >>
#@+node:ekr.20031218072017.3553:<< Compare single characters >>
assert(p1 < len(s1) and p2 < len(s2))
result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
if not result: self.mismatch("Mismatched single characters")
#@-node:ekr.20031218072017.3553:<< Compare single characters >>
#@-node:ekr.20031218072017.3552:<< Compare possible preprocessor directives >>
#@+node:ekr.20031218072017.3558:<< Compare possible section references >>
if s1[p1] == '@' and CWEB_flag:  start_ref = "@<"
elif s1[p1] == '<' and not CWEB_flag:  start_ref = "<<"
else: start_ref = None

# Tangling may insert newlines.
p2 = g.skip_ws_and_nl(s2,p2)

junk, kind1, junk2 = self.is_section_name(s1,p1)
junk, kind2, junk2 = self.is_section_name(s2,p2)

if start_ref and (kind1 != bad_section_name or kind2 != bad_section_name):
    result = self.compare_section_names(s1[p1:],s2[p2:])
    if result:
        p1, junk1, junk2 = self.skip_section_name(s1,p1)
        p2, junk1, junk2 = self.skip_section_name(s2,p2)
    else: self.mismatch("Mismatched section names")
else:
    # Neither p1 nor p2 points at a section name.
    result = s1[p1] == s2[p2]
    p1 += 1 ; p2 += 1
    if not result:
        self.mismatch("Mismatch at '@' or '<'")
#@-node:ekr.20031218072017.3558:<< Compare possible section references >>
#@+node:ekr.20031218072017.3559:<< Compare comments or single characters >>
if g.match(s1,p1,self.sentinel) and g.match(s2,p2,self.sentinel):
    first1 = p1 ; first2 = p2
    p1 = g.skip_to_end_of_line(s1,p1)
    p2 = g.skip_to_end_of_line(s2,p2)
    result = self.compare_comments(s1[first1:p1],s2[first2:p2])
    if not result:
        self.mismatch("Mismatched sentinel comments")
elif g.match(s1,p1,self.line_comment) and g.match(s2,p2,self.line_comment):
    first1 = p1 ; first2 = p2
    p1 = g.skip_to_end_of_line(s1,p1)
    p2 = g.skip_to_end_of_line(s2,p2)
    result = self.compare_comments(s1[first1:p1],s2[first2:p2])
    if not result:
        self.mismatch("Mismatched single-line comments")
elif g.match(s1,p1,self.comment) and g.match(s2,p2,self.comment):
    while (p1 < len(s1) and p2 < len(s2) and
        not g.match(s1,p1,self.comment_end) and not g.match(s2,p2,self.comment_end)):
        # ws doesn't have to match exactly either!
        if g.is_nl(s1,p1)or g.is_ws(s1[p1]):
            p1 = g.skip_ws_and_nl(s1,p1)
        else: p1 += 1
        if g.is_nl(s2,p2)or g.is_ws(s2[p2]):
            p2 = g.skip_ws_and_nl(s2,p2)
        else: p2 += 1
    p1 = g.skip_ws_and_nl(s1,p1)
    p2 = g.skip_ws_and_nl(s2,p2)
    if g.match(s1,p1,self.comment_end) and g.match(s2,p2,self.comment_end):
        first1 = p1 ; first2 = p2
        p1 += len(self.comment_end)
        p2 += len(self.comment_end)
        result = self.compare_comments(s1[first1:p1],s2[first2:p2])
    else: result = False
    if not result:
        self.mismatch("Mismatched block comments")
elif g.match(s1,p1,self.comment2) and g.match(s2,p2,self.comment2):
    while (p1 < len(s1) and p2 < len(s2) and
        not g.match(s1,p1,self.comment2_end) and not g.match(s2,p2,self.comment2_end)):
        # ws doesn't have to match exactly either!
        if  g.is_nl(s1,p1)or g.is_ws(s1[p1]):
            p1 = g.skip_ws_and_nl(s1,p1)
        else: p1 += 1
        if g.is_nl(s2,p2)or g.is_ws(s2[p2]):
            p2 = g.skip_ws_and_nl(s2,p2)
        else: p2 += 1
    p1 = g.skip_ws_and_nl(s1,p1)
    p2 = g.skip_ws_and_nl(s2,p2)
    if g.match(s1,p1,self.comment2_end) and g.match(s2,p2,self.comment2_end):
        first1 = p1 ; first2 = p2
        p1 += len(self.comment2_end)
        p2 += len(self.comment2_end)
        result = self.compare_comments(s1[first1:p1],s2[first2:p2])
    else: result = False
    if not result:
        self.mismatch("Mismatched alternalte block comments")
else:
    << Compare single characters >>
#@+node:ekr.20031218072017.3553:<< Compare single characters >>
assert(p1 < len(s1) and p2 < len(s2))
result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
if not result: self.mismatch("Mismatched single characters")
#@-node:ekr.20031218072017.3553:<< Compare single characters >>
#@-node:ekr.20031218072017.3559:<< Compare comments or single characters >>
#@+node:ekr.20031218072017.3560:<< Make sure both parts have ended >>
if result:
    p1 = g.skip_ws_and_nl(s1,p1)
    p2 = g.skip_ws_and_nl(s2,p2)
    result = p1 >= len(s1) and p2 >= len(s2)
    if not result:
        # Show the ends of both parts.
        p1 = len(s1)
        p2 = len(s2)
        self.mismatch("One part ends before the other.")
#@-node:ekr.20031218072017.3560:<< Make sure both parts have ended >>
#@+node:ekr.20031218072017.3561:<< Trace the mismatch >>
if 0:
    g.trace(self.message +
        "\nPart ",part," section ",name,
        "\n1:",g.get_line(s1,p1),
        "\n2:",g.get_line(s2,p2))
#@-node:ekr.20031218072017.3561:<< Trace the mismatch >>
#@-node:ekr.20031218072017.3548:forgiving_compare
#@+node:ekr.20031218072017.3562:mismatch
def mismatch (self,message):

    self.message = message
#@-node:ekr.20031218072017.3562:mismatch
#@+node:ekr.20031218072017.3563:scan_derived_file (pass 1)
@ This function scans an entire derived file in s, discovering section or part definitions.

This is the easiest place to delete leading whitespace from each line: we simply don't copy it.  We also ignore leading blank lines and trailing blank lines.  The resulting definition must compare equal using the "forgiving" compare to any other definitions of that section or part.

We use a stack to handle nested expansions.  The outermost level of expansion corresponds to the @root directive that created the file.  When the stack is popped, the indent variable is restored.

self.root_name is the name of the file mentioned in the @root directive.

The caller has deleted all body_ignored_newlines from the text.
@c

def scan_derived_file (self,s):

    __pychecker__ = 'maxlines=500'

    c = self.c
    self.def_stack = []
    << set the private global matching vars >>
    line_indent = 0  # The indentation to use if we see a section reference.
    # indent is the leading whitespace to be deleted.
    i, indent = g.skip_leading_ws_with_indent(s,0,self.tab_width)
    << Skip the header line output by tangle >>
    # The top level of the stack represents the root.
    self.push_new_def_node(self.root_name,indent,1,1,True)
    while i < len(s):
        ch = s[i]
        if ch == g.body_ignored_newline:
            i += 1 # ignore
        elif ch == g.body_newline:
            << handle the start of a new line >>
        elif g.match(s,i,self.sentinel) and self.is_sentinel_line(s,i):
            << handle a sentinel line  >>
        elif g.match(s,i,self.line_comment) or g.match(s,i,self.verbatim):
            << copy the entire line >>
        elif g.match(s,i,self.comment):
            << copy a multi-line comment >>
        elif g.match(s,i,self.comment2):
            << copy an alternate multi-line comment >>
        elif g.match(s,i,self.string1) or g.match(s,i,self.string2):
            << copy a string >>
        else:
            self.copy(ch) ; i += 1
    << end all open sections >>
#@+node:ekr.20031218072017.2368:<< set the private global matching vars >>
# Set defaults from the public globals set by the @comment command.
if self.single_comment_string:
    self.sentinel = self.single_comment_string
    self.sentinel_end = None
elif self.end_comment_string:
    self.sentinel = self.start_comment_string
    self.sentinel_end = self.end_comment_string
else:
    self.sentinel = self.sentinel_end = None

if 0:
    g.trace("single,start,end,sentinel:",
        repr(self.single_comment_string),
        repr(self.start_comment_string),
        repr(self.end_comment_string),
        repr(self.sentinel))

# Set defaults.  See set_delims_from_langauge.
self.line_comment = self.single_comment_string
self.comment = self.start_comment_string
self.comment_end = self.end_comment_string
self.comment2 = self.comment2_end = None
self.string1 = "\""
self.string2 = "'"
self.verbatim = None

# Set special cases.
if self.language == "plain":
    self.string1 = self.string2 = None # This is debatable.
    self.line_comment = None
if self.language == "pascal":
    self.comment2 = "(*" ; self.comment2_end = "*)"
if self.language == "latex": # 3/10/03: Joo-won Jung
    self.string1 = self.string2 = None # This is debatable.
if self.language == "html":
    self.string1 = '"' ; self.string2 = None # 12/3/03
#@-node:ekr.20031218072017.2368:<< set the private global matching vars >>
#@+node:ekr.20031218072017.3564:<< Skip the header line output by tangle >>
if self.sentinel or self.comment:
    line = g.choose(self.sentinel,self.sentinel,self.comment) + " Created by Leo from" 
    if g.match(s,i,line):
        # Even a block comment will end on the first line.
        i = g.skip_to_end_of_line(s,i)
#@-node:ekr.20031218072017.3564:<< Skip the header line output by tangle >>
#@+node:ekr.20031218072017.3565:<< handle the start of a new line >>
self.copy(ch) ; i += 1 # This works because we have one-character newlines.

# Set line_indent, used only if we see a section reference.
junk, line_indent = g.skip_leading_ws_with_indent(s,i,c.tab_width)
i = g.skip_leading_ws(s,i,indent,c.tab_width) # skip indent leading white space.
#@-node:ekr.20031218072017.3565:<< handle the start of a new line >>
#@+node:ekr.20031218072017.3566:<< handle a sentinel line >>
@ This is the place to eliminate the proper amount of whitespace from the start of each line. We do this by setting the 'indent' variable to the leading whitespace of the first _non-blank_ line following the opening sentinel.

Tangle increases the indentation by one tab if the section reference is not the first non-whitespace item on the line,so self code must do the same.
@c

# g.trace(g.get_line(s,i))
result,junk,kind,name,part,of,end,nl_flag = self.is_sentinel_line_with_data(s,i)
assert(result)
<< terminate the previous part of this section if it exists >>

if kind == start_sentinel_line:
    indent = line_indent
    # Increase line_indent by one tab width if the
    # the section reference does not start the line.
    j = i - 1
    while j >= 0:
        if g.is_nl(s,j):
            break
        elif not g.is_ws(s[j]):
            indent += abs(self.tab_width) ; break
        j -= 1
    # copy the section reference to the _present_ section,
    # but only if this is the first part of the section.
    if part < 2: self.copy(name)
    # Skip to the first character of the new section definition.
    i = g.skip_to_end_of_line(s,i)
    # Start the new section.
    self.push_new_def_node(name,indent,part,of,nl_flag)
else:
    assert(kind == end_sentinel_line)
    # Skip the sentinel line.
    i = g.skip_to_end_of_line(s,i)
    # Skip a newline only if it was added after(!newline)
    if not nl_flag:
        i = g.skip_ws(s,i)
        i = g.skip_nl(s,i)
        i = g.skip_ws(s,i)
        # Copy any whitespace following the (!newline)
        while end and g.is_ws(s[end]):
            self.copy(s[end])
            end += 1
    # Restore the old indentation level.
    if len(self.def_stack) > 0:
        indent = self.def_stack[-1].indent
#@+node:ekr.20031218072017.3567:<< terminate the previous part of this section if it exists >>
@ We have just seen a sentinel line. Any kind of sentinel line will terminate a previous part of the present definition. For end sentinel lines, the present section name must match the name on the top of the stack.
@c

if len(self.def_stack) > 0:
    dn = self.def_stack[-1]
    if self.compare_section_names(name,dn.name):
        dn = self.def_stack.pop()
        if len(dn.code) > 0:
            thePart, found = self.ust_lookup(name,dn.part,False,False) # not root, not update
            # Check for incompatible previous definition.
            if found and not self.forgiving_compare(name,dn.part,dn.code,thePart.code):
                self.error("Incompatible definitions of " + name)
            elif not found:
                self.ust_enter(name,dn.part,dn.of,dn.code,dn.nl_flag,False) # not root
    elif kind == end_sentinel_line:
        self.error("Missing sentinel line for: " + name)
#@-node:ekr.20031218072017.3567:<< terminate the previous part of this section if it exists >>
#@-node:ekr.20031218072017.3566:<< handle a sentinel line >>
#@+node:ekr.20031218072017.3568:<< copy the entire line >>
j = i ; i = g.skip_to_end_of_line(s,i)
self.copy(s[j:i])
#@-node:ekr.20031218072017.3568:<< copy the entire line >>
#@+node:ekr.20031218072017.3570:<< copy a multi-line comment >>
assert(self.comment_end)

# Scan for the ending delimiter.
j = i ; i += len(self.comment)
while i < len(s) and not g.match(s,i,self.comment_end):
    i += 1
if g.match(s,i,self.comment_end):
    i += len(self.comment_end)
self.copy(s[j:i])
#@-node:ekr.20031218072017.3570:<< copy a multi-line comment >>
#@+node:ekr.20031218072017.3571:<< copy an alternate multi-line comment >>
assert(self.comment2_end)
j = i
# Scan for the ending delimiter.
i += len(self.comment2)
while i < len(s) and not g.match(s,i,self.comment2_end):
    i += 1
if g.match(s,i,self.comment2_end):
    i += len(self.comment2)
self.copy(s[j:i])
#@-node:ekr.20031218072017.3571:<< copy an alternate multi-line comment >>
#@+node:ekr.20031218072017.3569:<< copy a string >>
j = i
if self.language == "pascal":
    i = g.skip_pascal_string(s,i)
else:
    i = g.skip_string(s,i)
self.copy(s[j:i])
#@-node:ekr.20031218072017.3569:<< copy a string >>
#@+node:ekr.20031218072017.3572:<< end all open sections >>
dn= None
while len(self.def_stack) > 0:
    dn = self.def_stack.pop()
    if len(self.def_stack) > 0:
        self.error("Unterminated section: " + dn.name)
if dn:
    # Terminate the root setcion.
    i = len(s)
    if dn.code and len(dn.code) > 0:
        self.ust_enter(dn.name,dn.part,dn.of,dn.code,dn.nl_flag,True) # is_root_flag
    else:
        self.error("Missing root part")
else:
    self.error("Missing root section")
#@-node:ekr.20031218072017.3572:<< end all open sections >>
#@-node:ekr.20031218072017.3563:scan_derived_file (pass 1)
#@+node:ekr.20031218072017.3573:update_def (pass 2)
@ This function handles the actual updating of section definitions in the web.  Only code parts are updated, never doc parts.

During pass 2 of Untangle, skip_body() calls this routine when it discovers the definition of a section in the outline.  We look up the name in the ust. If an entry exists, we compare the code (the code part of an outline node) with the code part in the ust. We update the code part if necessary.

We use the forgiving_compare() to compare code parts. It's not possible to change only trivial whitespace using Untangle because forgiving_compare() ignores trivial whitespace.
@c

# Major change: 2/23/01: Untangle never updates doc parts.

def update_def (self,name,part_number,head,code,tail,is_root_flag): # Doc parts are never updated!

    # g.trace(name,part_number,code)
    p = self.p ; body = p.bodyString()
    if not head: head = ""
    if not tail: tail = ""
    if not code: code = ""
    false_ret = head + code + tail, len(head) + len(code), False
    part, found = self.ust_lookup(name,part_number,is_root_flag,True) # Set update
    if not found:
        return false_ret  # Not an error.
    ucode = g.toUnicode(part.code,self.encoding) # 4/4/03
    << Remove leading blank lines and comments from ucode >>
    # g.trace(ucode)
    if not ucode or len(ucode) == 0:
        return false_ret # Not an error.
    if code and self.forgiving_compare(name,part,code,ucode):
        return false_ret # Not an error.
    # Update the body.
    g.es("***Updating: " + p.headString())
    i = g.skip_blank_lines(ucode,0)
    ucode = ucode[i:]
    ucode = string.rstrip(ucode)
    # Add the trailing whitespace of code to ucode.
    code2 = string.rstrip(code)
    trail_ws = code[len(code2):]
    ucode = ucode + trail_ws
    body = head + ucode + tail
    self.update_current_vnode(body)
    # g.trace("\nhead:",head,"\nucode:"ucode,"\ntail:",tail)
    return body, len(head) + len(ucode),True
#@+node:ekr.20031218072017.3574:<< Remove leading blank lines and comments from ucode >>
@ We assume that any leading comments came from an @doc part.  This isn't always valid and this code will eliminate such leading comments.  This is a defect in Untangle; it can hardly be avoided.
@c

i = g.skip_blank_lines(ucode,0)
j = g.skip_ws(ucode,i)
# g.trace("comment,end,single:",self.comment,self.comment_end,self.line_comment)

if self.comment and self.comment_end:
    if ucode and g.match(ucode,j,self.comment):
        # Skip to the end of the block comment.
        i = j + len(self.comment)
        i = string.find(ucode,self.comment_end,i)
        if i == -1: ucode = None # An unreported problem in the user code.
        else:
            i += len(self.comment_end)
            i = g.skip_blank_lines(ucode,i)
elif self.line_comment:
    while ucode and g.match(ucode,j,self.line_comment):
        i = g.skip_line(ucode,i)
        i = g.skip_blank_lines(ucode,i)
        j = g.skip_ws(ucode,i)
# Only the value of ucode matters here.
if ucode: ucode = ucode[i:]
#@-node:ekr.20031218072017.3574:<< Remove leading blank lines and comments from ucode >>
#@-node:ekr.20031218072017.3573:update_def (pass 2)
#@+node:ekr.20031218072017.3575:update_current_vnode
def update_current_vnode (self,s):

    """Called from within the Untangle logic to update the body text of self.p."""

    c = self.c ; p = self.p
    assert(self.p)
    c.setBodyString(p,s)

    c.beginUpdate()
    try:
        c.setChanged(True)
        p.setDirty()
        p.setMarked()
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.3575:update_current_vnode
#@-node:ekr.20031218072017.3544:untangle
#@+node:ekr.20031218072017.3576:utility methods
@ These utilities deal with tangle ivars, so they should be methods.
#@+node:ekr.20031218072017.3577:compare_section_names
# Compares section names or root names.
# Arbitrary text may follow the section name on the same line.

def compare_section_names (self,s1,s2):

    # g.trace(g.get_line(s1,0),':',g.get_line(s2,0))
    if g.match(s1,0,"<<") or g.match(s1,0,"@<"):
        # Use a forgiving compare of the two section names.
        delim = g.choose(self.use_cweb_flag,"@>",">>")
        i1 = i2 = 0
        while i1 < len(s1) and i2 < len(s2):
            ch1 = s1[i1] ; ch2 = s2[i2]
            if g.is_ws(ch1) and g.is_ws(ch2):
                i1 = g.skip_ws(s1,i1)
                i2 = g.skip_ws(s2,i2)
            elif g.match(s1,i1,delim) and g.match(s2,i2,delim):
                return True
            elif string.lower(ch1) == string.lower(ch2):
                i1 += 1 ; i2 += 1
            else: return False
        return False
    else: # A root name.
        return s1 == s2
#@-node:ekr.20031218072017.3577:compare_section_names
#@+node:ekr.20031218072017.3578:copy
def copy (self, s):

    assert(len(self.def_stack) > 0)
    dn = self.def_stack[-1] # Add the code at the top of the stack.
    dn.code += s
#@-node:ekr.20031218072017.3578:copy
#@+node:ekr.20031218072017.3579:error, pathError, warning
def error (self,s):
    self.errors += 1
    g.es_error(s)

def pathError (self,s):
    if not self.path_warning_given:
        self.path_warning_given = True
        self.error(s)

def warning (self,s):
    g.es_error(s)
#@-node:ekr.20031218072017.3579:error, pathError, warning
#@+node:ekr.20031218072017.3580:is_end_of_directive
# This function returns True if we are at the end of preprocessor directive.

def is_end_of_directive (self,s,i):

    return g.is_nl(s,i) and not self.is_escaped(s,i)
#@-node:ekr.20031218072017.3580:is_end_of_directive
#@+node:ekr.20031218072017.3581:is_end_of_string
def is_end_of_string (self,s,i,delim):

    return i < len(s) and s[i] == delim and not self.is_escaped(s,i)
#@-node:ekr.20031218072017.3581:is_end_of_string
#@+node:ekr.20031218072017.3582:is_escaped
# This function returns True if the s[i] is preceded by an odd number of back slashes.

def is_escaped (self,s,i):

    back_slashes = 0 ; i -= 1
    while i >= 0 and s[i] == '\\':
        back_slashes += 1
        i -= 1
    return (back_slashes & 1) == 1
#@-node:ekr.20031218072017.3582:is_escaped
#@+node:ekr.20031218072017.3583:is_section_name
def is_section_name(self,s,i):

    kind = bad_section_name ; end = -1

    if self.use_cweb_flag :
        if g.match(s,i,"@<"):
            i, kind, end = self.skip_cweb_section_name(s,i)
    elif g.match(s,i,"<<"):
        i, kind, end = self.skip_noweb_section_name(s,i)

    # g.trace(kind,g.get_line(s,end))
    return i, kind, end
#@-node:ekr.20031218072017.3583:is_section_name
#@+node:ekr.20031218072017.3584:is_sentinel_line & is_sentinel_line_with_data
@ This function returns True if i points to a line a sentinel line of one of the following forms:

start_sentinel <<section name>> end_sentinel
start_sentinel <<section name>> (n of m) end_sentinel
start_sentinel -- end -- <<section name>> end_sentinel
start_sentinel -- end -- <<section name>> (n of m) end_sentinel

start_sentinel: the string that signals the start of sentinel lines\
end_sentinel:   the string that signals the endof sentinel lines.

end_sentinel may be None,indicating that sentinel lines end with a newline.

Any of these forms may end with (!newline), indicating that the section reference was not followed by a newline in the orignal text.  We set nl_flag to False if such a string is seen. The name argument contains the section name.

The valid values of kind param are:

non_sentinel_line,   # not a sentinel line.
start_sentinel_line, #   /// <section name> or /// <section name>(n of m)
end_sentinel_line  //  /// -- end -- <section name> or /// -- end -- <section name>(n of m).
@c
def is_sentinel_line (self,s,i):

    result,i,kind,name,part,of,end,nl_flag = self.is_sentinel_line_with_data(s,i)
    return result

def is_sentinel_line_with_data (self,s,i):

    __pychecker__ = 'maxreturns=50'

    start_sentinel = self.sentinel
    end_sentinel = self.sentinel_end
    << Initialize the return values >>
    << Make sure the line starts with start_sentinel >>
    << Set end_flag if we have -- end -- >>
    << Make sure we have a section reference >>
    << Set part and of if they exist >>
    << Set nl_flag to False if !newline exists >>
    << Make sure the line ends with end_sentinel >>
    kind = g.choose(end_flag,end_sentinel_line,start_sentinel_line)
    return True,i,kind,name,part,of,end,nl_flag
#@+node:ekr.20031218072017.3585:<< Initialize the return values  >>
name = end = None
part = of = 1
kind = non_sentinel_line
nl_flag = True
false_data = (False,i,kind,name,part,of,end,nl_flag)
#@-node:ekr.20031218072017.3585:<< Initialize the return values  >>
#@+node:ekr.20031218072017.3586:<< Make sure the line starts with start_sentinel >>
if g.is_nl(s,i): i = g.skip_nl(s,i)
i = g.skip_ws(s,i)

# 4/18/00: We now require an exact match of the sentinel.
if g.match(s,i,start_sentinel):
    i += len(start_sentinel)
else:
    return false_data
#@-node:ekr.20031218072017.3586:<< Make sure the line starts with start_sentinel >>
#@+node:ekr.20031218072017.3587:<< Set end_flag if we have -- end -- >>
# If i points to "-- end --", this code skips it and sets end_flag.

end_flag = False
i = g.skip_ws(s,i)
if g.match(s,i,"--"):
    while i < len(s) and s[i] == '-':
        i += 1
    i = g.skip_ws(s,i)
    if not g.match(s,i,"end"):
        return false_data # Not a valid sentinel line.
    i += 3 ; i = g.skip_ws(s,i)
    if not g.match(s,i,"--"):
        return false_data # Not a valid sentinel line.
    while i < len(s) and s[i] == '-':
        i += 1
    end_flag = True
#@-node:ekr.20031218072017.3587:<< Set end_flag if we have -- end -- >>
#@+node:ekr.20031218072017.3588:<< Make sure we have a section reference >>
i = g.skip_ws(s,i)

if (self.use_noweb_flag and g.match(s,i,"<<") or
    self.use_cweb_flag  and g.match(s,i,"@<") ):

    j = i ; i, kind, end = self.skip_section_name(s,i)
    if kind != section_ref:
        return false_data
    name = s[j:i]
else:
    return false_data
#@-node:ekr.20031218072017.3588:<< Make sure we have a section reference >>
#@+node:ekr.20031218072017.3589:<< Set part and of if they exist >>
# This code handles (m of n), if it exists.
i = g.skip_ws(s,i)
if g.match(s,i,'('):
    j = i
    i += 1 ; i = g.skip_ws(s,i)
    i, part = self.scan_short_val(s,i)
    if part == -1:
        i = j # back out of the scanning for the number.
        part = 1
    else:
        i = g.skip_ws(s,i)
        if not g.match(s,i,"of"):
            return false_data
        i += 2 ; i = g.skip_ws(s,i)
        i, of = self.scan_short_val(s,i)
        if of == -1:
            return false_data
        i = g.skip_ws(s,i)
        if g.match(s,i,')'):
            i += 1 # Skip the paren and do _not_ return.
        else:
            return false_data
#@-node:ekr.20031218072017.3589:<< Set part and of if they exist >>
#@+node:ekr.20031218072017.3590:<< Set nl_flag to false if !newline exists >>
line = "(!newline)"
i = g.skip_ws(s,i)
if g.match(s,i,line):
    i += len(line)
    nl_flag = False
#@-node:ekr.20031218072017.3590:<< Set nl_flag to false if !newline exists >>
#@+node:ekr.20031218072017.3591:<< Make sure the line ends with end_sentinel >>
i = g.skip_ws(s,i)
if end_sentinel:
    # Make sure the line ends with the end sentinel.
    if g.match(s,i,end_sentinel):
        i += len(end_sentinel)
    else:
        return false_data

end = i # Show the start of the whitespace.
i = g.skip_ws(s,i)
if i < len(s) and not g.is_nl(s,i):
    return false_data
#@-node:ekr.20031218072017.3591:<< Make sure the line ends with end_sentinel >>
#@-node:ekr.20031218072017.3584:is_sentinel_line & is_sentinel_line_with_data
#@+node:ekr.20031218072017.3592:push_new_def_node
# This function pushes a new def_node on the top of the section stack.

def push_new_def_node (self,name,indent,part,of,nl_flag):

    # g.trace(name,part)
    node = def_node(name,indent,part,of,nl_flag,None)
    self.def_stack.append(node)
#@-node:ekr.20031218072017.3592:push_new_def_node
#@+node:ekr.20031218072017.3593:scan_short_val
# This function scans a positive integer.
# returns (i,val), where val == -1 if there is an error.

def scan_short_val (self,s,i):


    if i >= len(s) or not s[i].isdigit():
        return i, -1
    j = i
    while i < len(s) and s[i].isdigit():
        i += 1
    val = int(s[j:i])
    # g.trace(s[j:i],val)
    return i, val
#@nonl
#@-node:ekr.20031218072017.3593:scan_short_val
#@+node:ekr.20031218072017.3594:setRootFromHeadline
def setRootFromHeadline (self,p):

    s = p.headString()

    if s[0:5] == "@root":
        i,self.start_mode = g.scanAtRootOptions(s,0)
        i = g.skip_ws(s,i)

        if i < len(s): # Non-empty file name.
            # self.root_name must be set later by token_type().
            self.root = s[i:]
#@-node:ekr.20031218072017.3594:setRootFromHeadline
#@+node:ekr.20031218072017.1259:setRootFromText
@ This code skips the file name used in @root directives.  i points after the @root directive.

File names may be enclosed in < and > characters, or in double quotes.  If a file name is not enclosed be these delimiters it continues until the next newline.
@c
def setRootFromText(self,s,err_flag):

    # g.trace(s)
    self.root_name = None
    i,self.start_mode = g.scanAtRootOptions(s,0)
    i = g.skip_ws(s,i)

    if i >= len(s): return i
    # Allow <> or "" as delimiters, or a bare file name.
    if s[i] == '"':
        i += 1 ; delim = '"'
    elif s[i] == '<':
        i += 1 ; delim = '>'
    else: delim = g.body_newline

    root1 = i # The name does not include the delimiter.
    while i < len(s) and s[i] != delim and not g.is_nl(s,i):
        i += 1
    root2 = i

    if delim != g.body_newline and not g.match(s,i,delim):
        if err_flag:
            g.scanError("bad filename in @root " + s[:i])
    else:
        self.root_name = string.strip(s[root1:root2])
    return i
#@-node:ekr.20031218072017.1259:setRootFromText
#@+node:ekr.20031218072017.3595:skip_CWEB_section_name
@ This function skips past a section name that starts with @< and ends with @>. This code also skips any = following the section name.

Returns (i, kind, end), where kind is:

    bad_section_name:  @ < with no matching @ >
    section_ref: @ < name @ >
    section_def: @ < name @ > =

Unlike noweb, bad section names generate errors.
@c

def skip_cweb_section_name(self,s,i):

    j = i # Used for error message.
    kind = bad_section_name ; end = -1
    runon = False ; empty_name = True
    assert(s[i:i+2]=="@<")
    i += 2
    while i < len(s):
        if g.match(s,i,"@>="):
            i += 3 ; end = i-1 ; kind = section_def ; break
        elif g.match(s,i,"@>"):
            i += 2 ; end = i ; kind = section_ref ; break
        elif g.match(s,i,"@<"):
            runon = True ; break
        elif g.match(s,i,"@@"): i += 2
        elif g.is_ws_or_nl(s,i): i += 1
        else:
            i += 1 ; empty_name = False

    if empty_name:
        g.scanError("empty CWEB section name: " + s[j:i])
        return i, bad_section_name, -1
    elif i >= len(s) or runon:
        g.scanError("Run on CWEB section name: " + s[j:i])
        return i, bad_section_name, -1
    else:
        return i, kind, end
#@-node:ekr.20031218072017.3595:skip_CWEB_section_name
#@+node:ekr.20031218072017.3596:skip_noweb_section_name
@ This function skips past a section name that starts with < < and might end with > > or > > =. The entire section name must appear on the same line.

Note: this code no longer supports extended noweb mode.

Returns (i, kind, end),
    end indicates the end of the section name itself (not counting the =).
    kind is one of:
        bad_section_name: "no matching ">>" or ">>"  This is _not_ a user error!
        section_ref: < < name > >
        section_def: < < name > > =
        at_root:     < < * > > =
@c
def skip_noweb_section_name(self,s,i):

    assert(g.match(s,i,"<<"))
    i += 2
    j = i # Return this value if no section name found.
    kind = bad_section_name ; end = -1 ; empty_name = True

    # Scan for the end of the section name.
    while i < len(s) and not g.is_nl(s,i):
        if g.match(s,i,">>="):
            i += 3 ; end = i - 1 ; kind = section_def ; break
        elif g.match(s,i,">>"):
            i += 2 ; end = i ; kind = section_ref ; break
        elif g.is_ws_or_nl(s,i):
            i += 1
        elif empty_name and s[i] == '*':
            empty_name = False
            i = g.skip_ws(s,i+1) # skip the '*'
            if g.match(s,i,">>="):
                i += 3 ; end = i - 1 ; kind = at_root ; break
        else:
            i += 1 ; empty_name = False

    if empty_name:
        kind = bad_section_name
    if kind == bad_section_name:
        i = j
    return i, kind, end
#@-node:ekr.20031218072017.3596:skip_noweb_section_name
#@+node:ekr.20031218072017.3597:skip_section_name
# Returns a tuple (i, kind, end)

def skip_section_name(self,s,i):

    if self.use_noweb_flag:
        return self.skip_noweb_section_name(s,i)
    else:
        return self.skip_cweb_section_name(s,i)
#@-node:ekr.20031218072017.3597:skip_section_name
#@+node:ekr.20031218072017.3598:standardize_name
def standardize_name (self,name):

    """Removes leading and trailing brackets, converts white space to a single blank and converts to lower case."""

    # Convert to lowercase.
    name = string.lower(name)
    # Convert whitespace to a single space.
    name = string.replace(name,'\t',' ')
    name = string.replace(name,'  ',' ')
    # Remove leading '<'
    i = 0 ; n = len(name)
    while i < n and name[i] == '<':
        i += 1
    j = i
    # Find the first '>'
    while i < n and name [i] != '>':
        i += 1
    name = string.strip(name[j:i])
    # g.trace(name)
    return name
#@-node:ekr.20031218072017.3598:standardize_name
#@+node:ekr.20031218072017.1360:tangle.scanAllDirectives
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):

    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    __pychecker__ = 'maxlines=500 maxbranches=100'

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for print modes directives >>
        << Test for @path >>
        << Test for @pagewidth >>
        << Test for @root >>
        << Test for @tabwidth >>
        << Test for @header and @noheader >>
        old.update(theDict)
    << Set self.tangle_directory >>
#@+node:ekr.20031218072017.1361:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break
#@-node:ekr.20031218072017.1361:<< Collect @first attributes >>
#@+node:ekr.20031218072017.1362:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20031218072017.1362:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1363:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20031218072017.1363:<< Test for @encoding >>
#@+node:ekr.20031218072017.1364:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):

    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.1364:<< Test for @lineending >>
#@+node:ekr.20031218072017.1365:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
#@-node:ekr.20031218072017.1365:<< Test for print modes directives >>
#@+node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute dir and relative_path from s[k:] >>
    if len(theDir) > 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                << handle absolute @path >>
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
#@+node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)
#@-node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
#@+node:ekr.20031218072017.1368:<< handle absolute @path >>
if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir,c=c)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) > 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) > 0:
                g.es("relative path in @path directive: " + relative_path)
#@-node:ekr.20031218072017.1368:<< handle absolute @path >>
#@-node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
#@+node:ekr.20031218072017.1369:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w > 0:
        self.page_width = w
#@-node:ekr.20031218072017.1369:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1370:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
#@-node:ekr.20031218072017.1370:<< Test for @root >>
#@+node:ekr.20031218072017.1371:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20031218072017.1371:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.

elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
#@-node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) > 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) > 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                << handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20031218072017.1374:<< handle absolute path >>
if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir,c=c)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) > 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) > 0:
            g.es(kind + " directory: " + dir2)
#@-node:ekr.20031218072017.1374:<< handle absolute path >>
#@-node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
#@-node:ekr.20031218072017.1360:tangle.scanAllDirectives
#@+node:ekr.20031218072017.3599:token_type
def token_type(self,s,i,err_flag):

    """This method returns a code indicating the apparent kind of token at the position i.

    The caller must determine whether section definiton tokens are valid.

    returns (kind, end) and sets global root_name using setRootFromText()."""

    kind = plain_line ; end = -1
    if self.use_noweb_flag:
        << set token_type in noweb mode >>
    else:
        << set token_type for CWEB mode >>
    if kind == at_other :
        << set kind for directive >>
    # g.trace(kind,g.get_line(s,i))
    return kind, end
#@+node:ekr.20031218072017.3600:<< set token_type in noweb mode >>
if g.match(s,i,"<<"):
    i, kind, end = self.skip_section_name(s,i)
    if kind == bad_section_name:
        kind = plain_line # not an error.
    elif kind == at_root:
        if self.head_root:
            self.setRootFromText(self.head_root,err_flag)
        else:
            kind = bad_section_name # The warning has been given.
elif g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n"):
    # 10/30/02: Only @doc starts a noweb doc part in raw cweb mode.
    kind = g.choose(self.raw_cweb_flag,plain_line,at_doc)
elif g.match(s,i,"@@"): kind = at_at
elif i < len(s) and s[i] == '@': kind = at_other
else: kind = plain_line
#@-node:ekr.20031218072017.3600:<< set token_type in noweb mode >>
#@+node:ekr.20031218072017.3601:<< set token_type for CWEB mode >>
i = g.skip_ws(s,i)
if g.match(s,i,"@*") or g.match(s,i,"@ "): kind = at_doc
elif g.match(s,i,"@<"): i, kind, end = self.skip_section_name(s,i)
elif g.match(s,i,"@@"): kind = at_at
elif g.match_word(s,i,"@c") or g.match_word(s,i,"@p"): kind = at_code
elif i < len(s) and s[i] == '@':
    if   i + 1 >= len(s): kind = at_doc
    elif i + 1 < len(s) and s[i+1] not in string.ascii_letters:
        kind = at_web
    else: kind = at_other # Set kind later
else: kind = plain_line
#@-node:ekr.20031218072017.3601:<< set token_type for CWEB mode >>
#@+node:ekr.20031218072017.3602:<< set kind for directive >>
# This code will return at_other for any directive other than those listed.

if g.match_word(s,i,"@c"):
    # 10/30/02: Only @code starts a code section in raw cweb mode.
    kind = g.choose(self.raw_cweb_flag,plain_line,at_code)
else:
    for name, theType in [
        ("@chapter", at_chapter),
        ("@code", at_code),
        ("@doc", at_doc),
        ("@root", at_root),
        ("@section", at_section) ]:
        if g.match_word(s,i,name):
            kind = theType ; break

if self.raw_cweb_flag and kind == at_other:
    # 10/30/02: Everything else is plain text in raw cweb mode.
    kind = plain_line

if kind == at_root:
    i = self.setRootFromText(s[i:],err_flag)
#@-node:ekr.20031218072017.3602:<< set kind for directive >>
#@-node:ekr.20031218072017.3599:token_type
#@-node:ekr.20031218072017.3576:utility methods
#@-node:ekr.20031218072017.3465:class tangleCommands methods
#@-node:ekr.20031218072017.3446:@thin leoTangle.py
#@+node:ekr.20051104075904:@thin leoTest.py
'''Classes for Leo's unit testing. 

Run the unit tests in test.leo using the Execute Script command.'''

@language python
@tabwidth -4

__pychecker__ = '--no-import --no-reimportself --no-reimport --no-constCond --no-constant1'
    # Disable all import warnings.
    # Disable warnings about if 1 and if 0.

<< leoTest imports >>

# print 'leoTest.py.__file__',__file__

if g.app: # Make sure we can import this module stand-alone.
    import leoPlugins
    newAtFile = leoPlugins.isLoaded("___proto_atFile")
else:
    newAtFile = False

@others
#@+node:ekr.20051104075904.1:<< leoTest imports >>
import leoGlobals as g

import leoColor
import leoCommands
import leoFrame
import leoGui
import leoNodes

import doctest
import glob
import os

import sys
import tabnanny
import tokenize
import unittest

try:
    import compiler
    import gc
    import profile
    import pstats
    import timeit
except ImportError:
    pass
#@-node:ekr.20051104075904.1:<< leoTest imports >>
#@+node:ekr.20051104075904.2:Support @profile, @suite, @test, @timer
#@+node:ekr.20051104075904.3:isSuiteNode and isTestNode
def isSuiteNode (p):
    h = p.headString().lower()
    return g.match_word(h,0,"@suite")

def isTestNode (p):
    h = p.headString().lower()
    return g.match_word(h,0,"@test")
#@-node:ekr.20051104075904.3:isSuiteNode and isTestNode
#@+node:ekr.20051104075904.4:doTests...
def doTests(c,all,verbosity=1):

    p = c.currentPosition() ; p1 = p.copy()
    try:
        g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        if all: theIter = c.all_positions_iter()
        else:   theIter = p.self_and_subtree_iter()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
        for p in theIter:
            if isTestNode(p):
                test = makeTestCase(c,p)
                if test: suite.addTest(test)
            elif isSuiteNode(p):
                test = makeTestSuite(c,p)
                if test: suite.addTest(test)

        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=verbosity).run(suite)
    finally:
        c.setChanged(changed) # Restore changed state.
        c.selectPosition(p1)
        g.app.unitTesting = False
#@+node:ekr.20051104075904.5:class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20051104075904.6:__init__
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@-node:ekr.20051104075904.6:__init__
#@+node:ekr.20051104075904.7: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20051104075904.7: fail
#@+node:ekr.20051104075904.8:setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)
#@-node:ekr.20051104075904.8:setUp
#@+node:ekr.20051104075904.9:tearDown
def tearDown (self):

    pass

    # To do: restore the outline.
#@-node:ekr.20051104075904.9:tearDown
#@+node:ekr.20051104075904.10:runTest
def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)

    if define_g:
        d = {'c':c,'g':g,'p':p}
    else:
        d = {}

    # Execute the script. Let unit test handle any errors!
    if 0: # debug
        import pdb
        pdb.run(script+'\n',d)
    else:
        exec script + '\n' in d
#@nonl
#@-node:ekr.20051104075904.10:runTest
#@+node:ekr.20051104075904.11:shortDescription
def shortDescription (self):

    return self.p.headString() + '\n'
#@-node:ekr.20051104075904.11:shortDescription
#@-node:ekr.20051104075904.5:class generalTestCase
#@+node:ekr.20051104075904.12:makeTestSuite
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()

    h = p.headString()
    script = g.getScript(c,p).strip()
    if not script:
        print "no script in %s" % h
        return None

    try:
        exec script + '\n' in {'c':c,'g':g,'p':p}
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print "%s script did not set g.app.scriptDict" % h
        return suite
    except:
        g.trace('Exception creating test cases for %s' % p.headString())
        g.es_exception()
        return None
#@-node:ekr.20051104075904.12:makeTestSuite
#@+node:ekr.20051104075904.13:makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.bodyString().strip():
        return generalTestCase(c,p)
    else:
        return None
#@-node:ekr.20051104075904.13:makeTestCase
#@-node:ekr.20051104075904.4:doTests...
#@+node:ekr.20051104075904.14:runProfileOnNode
# A utility for use by script buttons.

def runProfileOnNode (p,outputPath):

    s = p.bodyString().rstrip() + '\n'

    profile.run(s,outputPath)

    stats = pstats.Stats(outputPath)
    stats.strip_dirs()
    stats.sort_stats('cum','file','name')
    stats.print_stats()
#@-node:ekr.20051104075904.14:runProfileOnNode
#@+node:ekr.20051104075904.15:runTimerOnNode
# A utility for use by script buttons.

def runTimerOnNode (c,p,count):

    s = p.bodyString().rstrip() + '\n'

    # A kludge so we the statement below can get c and p.
    g.app.unitTestDict = {'c':c,'p':p}

    # This looks like the best we can do.
    setup = 'import leoGlobals as g; c = g.app.unitTestDict.get("c"); p = g.app.unitTestDict.get("p")'

    t = timeit.Timer(s,setup)

    try:
        if count is None:
            count = 1000000
        result = t.timeit(count)
        g.es_print("count: %d time/count: %f %s" % (count,result/count,p.headString()))
    except:
        t.print_exc()
#@-node:ekr.20051104075904.15:runTimerOnNode
#@-node:ekr.20051104075904.2:Support @profile, @suite, @test, @timer
#@+node:ekr.20051104075904.16:run gc
#@+node:ekr.20051104075904.17:runGC
lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

# Adapted from similar code in leoGlobals.g.
def runGc(disable=False):

    message = "runGC"

    if gc is None:
        print "@gc: can not import gc"
        return

    gc.enable()
    set_debugGc()
    gc.collect()
    printGc(message=message)
    if disable:
        gc.disable()
    # makeObjectList(message)

runGC = runGc
#@-node:ekr.20051104075904.17:runGC
#@+node:ekr.20051104075904.18:enableGc
def set_debugGc ():

    gc.set_debug(
        gc.DEBUG_STATS | # prints statistics.
        # gc.DEBUG_LEAK | # Same as all below.
        # gc.DEBUG_COLLECTABLE
        # gc.DEBUG_UNCOLLECTABLE
        gc.DEBUG_INSTANCES |
        gc.DEBUG_OBJECTS
        # gc.DEBUG_SAVEALL
    )
#@-node:ekr.20051104075904.18:enableGc
#@+node:ekr.20051104075904.19:makeObjectList
def makeObjectList(message):

    # WARNING: this id trick is not proper: newly allocated objects can have the same address as old objects.
    global lastObjectsDict
    objects = gc.get_objects()

    newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]

    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o

    print "%25s: %d new, %d total objects" % (message,len(newObjects),len(objects))
#@-node:ekr.20051104075904.19:makeObjectList
#@+node:ekr.20051104075904.20:printGc
def printGc(message=None):

    '''Called from unit tests.'''

    if not message:
        message = g.callers(2)

    global lastObjectCount

    n = len(gc.garbage)
    n2 = len(gc.get_objects())
    delta = n2-lastObjectCount

    print '-' * 30
    print "garbage: %d" % n
    print "%6d =%7d %s" % (delta,n2,"totals")

    << print number of each type of object >>
    if 0:
        << print added functions >>

    lastObjectCount = n2
    return delta
#@+node:ekr.20051104075904.21:<< print number of each type of object >>
global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    n = typesDict.get(type(obj),0)
    typesDict[type(obj)] = n + 1

# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

keys.sort()
for key in keys:
    n1 = lastTypesDict.get(key,0)
    n2 = typesDict.get(key,0)
    delta2 = n2-n1
    if delta2 != 0:
        print "%+6d =%7d %s" % (delta2,n2,key)

lastTypesDict = typesDict
typesDict = {}
#@-node:ekr.20051104075904.21:<< print number of each type of object >>
#@+node:ekr.20051104075904.22:<< print added functions >>
import types
import inspect

global lastFunctionsDict

funcDict = {}

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if not lastFunctionsDict.has_key(key):
            print ; print obj
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            print "args", args
            if varargs: print "varargs",varargs
            if varkw: print "varkw",varkw
            if defaults:
                print "defaults..."
                for s in defaults: print s

lastFunctionsDict = funcDict
funcDict = {}
#@-node:ekr.20051104075904.22:<< print added functions >>
#@-node:ekr.20051104075904.20:printGc
#@+node:ekr.20051104075904.23:printGcRefs
def printGcRefs (verbose=True):

    refs = gc.get_referrers(g.app.windowList[0])
    print '-' * 30

    if verbose:
        print "refs of", g.app.windowList[0]
        for ref in refs:
            print type(ref)
    else:
        print "%d referrers" % len(refs)
#@-node:ekr.20051104075904.23:printGcRefs
#@-node:ekr.20051104075904.16:run gc
#@+node:ekr.20051104075904.24: class testUtils
class testUtils:

    """Common utility routines used by unit tests."""

    @others
#@+node:ekr.20060106114716.1:ctor (testUtils)
def __init__ (self,c):

    self.c = c
#@-node:ekr.20060106114716.1:ctor (testUtils)
#@+node:ekr.20051104075904.25:compareOutlines
def compareOutlines (self,root1,root2,compareHeadlines=True,tag='',report=True):

    """Compares two outlines, making sure that their topologies,
    content and join lists are equivalent"""

    p2 = root2.copy() ; ok = True
    for p1 in root1.self_and_subtree_iter():
        ok = (
            p1 and p2 and
            p1.numberOfChildren() == p2.numberOfChildren() and
            (not compareHeadlines or (p1.headString() == p2.headString())) and
            p1.bodyString() == p2.bodyString() and
            p1.isCloned()   == p2.isCloned()
        )
        if not ok: break
        p2.moveToThreadNext()

    if not report:
        return ok

    if ok:
        if 0:
            print 'compareOutlines ok',
            if tag: print 'tag:',tag
            else: print
            if p1: print 'p1',p1,p1.v
            if p2: print 'p2',p2,p2.v
    else:
        print 'compareOutlines failed',
        if tag: print 'tag:',tag
        else: print
        if p1: print 'p1',p1,p1.v
        if p2: print 'p2',p2,p2.v
        if not p1 or not p2:
            print 'p1 and p2'
        if p1.numberOfChildren() != p2.numberOfChildren():
            print 'p1.numberOfChildren()=%d, p2.numberOfChildren()=%d' % (
                p1.numberOfChildren(),p2.numberOfChildren())
        if compareHeadlines and (p1.headString() != p2.headString()):
            print 'p1.head', p1.headString()
            print 'p2.head', p2.headString()
        if p1.bodyString() != p2.bodyString():
            print 'p1.body'
            print repr(p1.bodyString())
            print 'p2.body'
            print repr(p2.bodyString())
        if p1.isCloned() != p2.isCloned():
            print 'p1.isCloned() == p2.isCloned()'

    return ok
#@-node:ekr.20051104075904.25:compareOutlines
#@+node:ekr.20051104075904.26:Finding nodes...
#@+node:ekr.20051104075904.27:findChildrenOf
def findChildrenOf (self,root):

    return [p.copy() for p in root.children_iter()]
#@-node:ekr.20051104075904.27:findChildrenOf
#@+node:ekr.20051104075904.28:findSubnodesOf
def findSubnodesOf (self,root):

    return [p.copy() for p in root.subtree_iter()]
#@-node:ekr.20051104075904.28:findSubnodesOf
#@+node:ekr.20051104075904.29:findNodeInRootTree
def findRootNode (self,p):

    """Return the root of p's tree."""

    while p and p.hasParent():
        p.moveToParent()
    return p
#@-node:ekr.20051104075904.29:findNodeInRootTree
#@+node:ekr.20051104075904.30:u.findNodeInTree
def findNodeInTree(self,p,headline,startswith=False):

    """Search for a node in p's tree matching the given headline."""

    c = self.c
    h = headline.strip().lower()
    for p in p.subtree_iter():
        h2 = p.headString().strip().lower()
        if h2 == h or startswith and h2.startswith(h):
            return p.copy()
    return c.nullPosition()

#@-node:ekr.20051104075904.30:u.findNodeInTree
#@+node:ekr.20051104075904.31:findNodeAnywhere
def findNodeAnywhere(self,headline):

    c = self.c
    for p in c.allNodes_iter():
        h = headline.strip().lower()
        if p.headString().strip().lower() == h:
            return p.copy()
    return c.nullPosition()
#@-node:ekr.20051104075904.31:findNodeAnywhere
#@-node:ekr.20051104075904.26:Finding nodes...
#@+node:ekr.20051104075904.33:numberOfClonesInOutline
def numberOfClonesInOutline (self):

    """Returns the number of cloned nodes in an outline"""

    c = self.c ; n = 0
    for p in c.allNodes_iter():
        if p.isCloned():
            n += 1
    return n
#@-node:ekr.20051104075904.33:numberOfClonesInOutline
#@+node:ekr.20051104075904.34:numberOfNodesInOutline
def numberOfNodesInOutline (self):

    """Returns the total number of nodes in an outline"""

    return len([p for p in self.c.allNodes_iter()])
#@-node:ekr.20051104075904.34:numberOfNodesInOutline
#@+node:ekr.20051104075904.36:testUtils.writeNode/sToNode
#@+node:ekr.20051104075904.37:writeNodesToNode
def writeNodesToNode (self,c,input,output,sentinels=True):

    result = []
    for p in input.self_and_subtree_iter():
        s = self.writeNodeToString(c,p,sentinels)
        result.append(s)
    result = ''.join(result)
    output.scriptSetBodyString (result)
#@-node:ekr.20051104075904.37:writeNodesToNode
#@+node:ekr.20051104075904.38:writeNodeToNode
def writeNodeToNode (self,c,input,output,sentinels=True):

    """Do an atFile.write the input tree to the body text of the output node."""

    s = self.writeNodeToString(c,input,sentinels)

    output.scriptSetBodyString (s)
#@-node:ekr.20051104075904.38:writeNodeToNode
#@+node:ekr.20051104075904.39:writeNodeToString
def writeNodeToString (self,c,input,sentinels):

    """Return an atFile.write of the input tree to a string."""

    df = c.atFileCommands
    nodeIndices = g.app.nodeIndices

    # Assign input.v.t.fileIndex
    nodeIndices.setTimestamp()
    for p in input.self_and_subtree_iter():
        try:
            theId,time,n = p.v.t.fileIndex
        except TypeError:
            p.v.t.fileIndex = nodeIndices.getNewIndex()

    # Write the file to a string.
    df.write(input,thinFile=True,nosentinels= not sentinels,toString=True)
    s = df.stringOutput

    return s
#@-node:ekr.20051104075904.39:writeNodeToString
#@-node:ekr.20051104075904.36:testUtils.writeNode/sToNode
#@+node:ekr.20051104075904.40:testUtils.compareIgnoringNodeNames
def compareIgnoringNodeNames (self,s1,s2,delims,verbose=False):

    # Compare text containing sentinels, but ignore differences in @+-nodes.
    delim1,delim2,delim3 = delims

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    if len(lines1) != len(lines2):
        if verbose: g.trace("Different number of lines")
        return False

    for i in xrange(len(lines2)):
        line1 = lines1[i]
        line2 = lines2[i]
        if line1 == line2:
            continue
        else:
            n1 = g.skip_ws(line1,0)
            n2 = g.skip_ws(line2,0)
            if (
                not g.match(line1,n1,delim1) or
                not g.match(line2,n2,delim1)
            ):
                if verbose: g.trace("Mismatched non-sentinel lines")
                return False
            n1 += len(delim1)
            n2 += len(delim1)
            if g.match(line1,n1,"@+node") and g.match(line2,n2,"@+node"):
                continue
            if g.match(line1,n1,"@-node") and g.match(line2,n2,"@-node"):
                continue
            else:
                if verbose:
                    g.trace("Mismatched sentinel lines",delim1)
                    g.trace("line1:",repr(line1))
                    g.trace("line2:",repr(line2))
                return False
    return True
#@-node:ekr.20051104075904.40:testUtils.compareIgnoringNodeNames
#@-node:ekr.20051104075904.24: class testUtils
#@+node:ekr.20051104075904.41: fail
def fail ():

    """Mark a unit test as having failed."""

    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20051104075904.41: fail
#@+node:ekr.20051104075904.42:leoTest.runLeoTest
def runLeoTest(c,path,verbose=False,full=False):

    frame = None ; ok = False ; old_gui = g.app.gui

    # Do not set or clear g.app.unitTesting: that is only done in leoTest.runTest.

    try:
        ok, frame = g.openWithFileName(path,c,enableLog=False)
        assert(ok and frame)
        errors = frame.c.checkOutline(verbose=verbose,unittest=True,full=full)
        assert(errors == 0)
        ok = True
    finally:
        g.app.gui = old_gui
        if frame and frame.c != c:
            frame.c.setChanged(False)
            g.app.closeLeoWindow(frame.c.frame)
        c.frame.update()
#@nonl
#@-node:ekr.20051104075904.42:leoTest.runLeoTest
#@+node:ekr.20051104075904.43:Specific to particular unit tests...
#@+node:ekr.20051104075904.44:at-File test code (leoTest.py)
def runAtFileTest(c,p):

    """Common code for testing output of @file, @thin, etc."""

    at = c.atFileCommands
    child1 = p.firstChild()
    child2 = child1.next()
    h1 = child1.headString().lower().strip()
    h2 = child2.headString().lower().strip()
    assert(g.match(h1,0,"#@"))
    assert(g.match(h2,0,"output"))
    expected = child2.bodyString()

    # Compute the type from child1's headline.
    j = g.skip_c_id(h1,2)
    theType = h1[1:j]
    assert theType in ("@file","@thin","@nosent","@noref","@asis"), "bad type: %s" % type

    thinFile = theType == "@thin"
    nosentinels = theType in ("@asis","@nosent")

    if theType == "@asis":
        at.asisWrite(child1,toString=True)
    elif theType == "@noref":
        at.norefWrite(child1,toString=True)
    else:
        at.write(child1,thinFile=thinFile,nosentinels=nosentinels,toString=True)
    try:
        result = g.toUnicode(at.stringOutput,"ascii")
        assert(result == expected)
    except AssertionError:
        << dump result and expected >>
        raise
#@+node:ekr.20051104075904.45:<< dump result and expected >>
print ; print '-' * 20
print "result..."
for line in g.splitLines(result):
    print "%3d" % len(line),repr(line)
print '-' * 20
print "expected..."
for line in g.splitLines(expected):
    print "%3d" % len(line),repr(line)
print '-' * 20
#@-node:ekr.20051104075904.45:<< dump result and expected >>
#@-node:ekr.20051104075904.44:at-File test code (leoTest.py)
#@+node:ekr.20051104075904.46:Reformat Paragraph test code (leoTest.py)
# DTHEIN 2004.01.11: Added unit tests for reformatParagraph
#@+node:ekr.20051104075904.47:class reformatParagraphTest
class reformatParagraphTest:

    '''A class to work around stupidities of the Unittest classes.'''

    @others
#@+node:ekr.20051104075904.48:__init__
def __init__ (self,c,p):

    self.c = c
    self.p = p.copy()

    self.go()
#@-node:ekr.20051104075904.48:__init__
#@+node:ekr.20051104075904.49:go
def go (self):

    try:
        self.setUp()
        self.runTest()
    finally:
        self.tearDown()
#@-node:ekr.20051104075904.49:go
#@+node:ekr.20051104075904.50:checkPosition
def checkPosition(self,expRow,expCol):

    row,col = self.getRowCol()

    assert expCol == col, "Got column %d.  Expected %d" % (col,expCol)

    assert expRow == row, "Got row %d.  Expected %d" % (row,expRow)
#@-node:ekr.20051104075904.50:checkPosition
#@+node:ekr.20051104075904.51:checkText
def checkText(self):

    new_text = self.tempChild.bodyString()
    ref_text = self.after.bodyString()
    newLines = new_text.splitlines(1)
    refLines = ref_text.splitlines(1)
    newLinesCount = len(newLines)
    refLinesCount = len(refLines)
    for i in range(min(newLinesCount,refLinesCount)):
        assert newLines[i] == refLines[i], \
            "Mismatch on line " + str(i) + "." \
            + "\nExpected text: " + `refLines[i]` \
            + "\n  Actual text: " + `newLines[i]`

    assert newLinesCount == refLinesCount, \
        "Expected " + str(refLinesCount) + " lines, but " \
        + "received " + str(newLinesCount) + " lines."
#@-node:ekr.20051104075904.51:checkText
#@+node:ekr.20051104075904.52:copyBeforeToTemp
def copyBeforeToTemp(self):

    c = self.c ; tempNode = self.tempNode

    # Delete all children of temp node.
    while tempNode.firstChild():
        tempNode.firstChild().doDelete()

    # Copy the before node text to the temp node.
    text = self.before.bodyString()
    tempNode.setTnodeText(text,g.app.tkEncoding)

    # create the child node that holds the text.
    t = leoNodes.tnode(headString="tempChildNode")
    self.tempChild = self.tempNode.insertAsNthChild(0,t)

    # copy the before text to the temp text.
    text = self.before.bodyString()
    self.tempChild.setTnodeText(text,g.app.tkEncoding)

    # Make the temp child node current, and put the cursor at the beginning.
    c.selectPosition(self.tempChild)
    w = c.frame.body.bodyCtrl
    w.setSelectionRange(0,0)
#@-node:ekr.20051104075904.52:copyBeforeToTemp
#@+node:ekr.20051104075904.53:getRowCol
def getRowCol(self):

    c = self.c ; w = c.frame.body.bodyCtrl
    tab_width = c.frame.tab_width

    # Get the Tkinter row col position of the insert cursor.
    s = w.getAllText()
    index = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,index)
    row += 1
    # g.trace(index,row,col)

    # Adjust col position for tabs.
    if col > 0:
        s2 = s[index-col:index]
        s2 = g.toUnicode(s2,g.app.tkEncoding)
        col = g.computeWidth(s2,tab_width)

    return row,col
#@-node:ekr.20051104075904.53:getRowCol
#@+node:ekr.20051104075904.54:runTest
def runTest(self):

    g.trace('must be overridden in subclasses')
#@-node:ekr.20051104075904.54:runTest
#@+node:ekr.20051104075904.55:setUp
def setUp(self):

    c = self.c ; p = self.p
    u = self.u = testUtils(c)

    # self.undoMark = c.undoer.getMark()
    c.undoer.clearUndoState()

    assert(c.positionExists(p))
    self.before = u.findNodeInTree(p,"before")
    self.after  = u.findNodeInTree(p,"after")
    self.tempNode = u.findNodeInTree(p,"tempNode")

    assert self.tempNode,'no tempNode: ' + p
    assert c.positionExists(self.tempNode),'tempNode does not exist'
    self.tempChild = None

    self.copyBeforeToTemp()
#@-node:ekr.20051104075904.55:setUp
#@+node:ekr.20051104075904.56:tearDown
def tearDown(self):

    c = self.c ; tempNode = self.tempNode

    # clear the temp node and mark it unchanged
    tempNode.setTnodeText("",g.app.tkEncoding)
    tempNode.clearDirty()

    if 1: # Disabling this is good for debugging.
        # Delete all children of temp node.
        while tempNode.firstChild():
            tempNode.firstChild().doDelete()

    # c.undoer.rollbackToMark(self.undoMark)
    c.undoer.clearUndoState()
#@-node:ekr.20051104075904.56:tearDown
#@-node:ekr.20051104075904.47:class reformatParagraphTest
#@+node:ekr.20051104075904.57:class singleParagraphTest (reformatParagraphTest)
class singleParagraphTest (reformatParagraphTest):

    '''A class to work around stupidities of the Unittest classes.'''

    @others
#@+node:ekr.20051104075904.58:__init__
def __init__ (self,c,p,finalRow,finalCol):

    self.finalCol = finalCol
    self.finalRow = finalRow

    # Call the base class.
    reformatParagraphTest.__init__(self,c,p)
#@-node:ekr.20051104075904.58:__init__
#@+node:ekr.20051104075904.59:runTest
def runTest(self):

    # Reformat the paragraph
    self.c.reformatParagraph()

    # Compare the computed result to the reference result.
    self.checkText()
    self.checkPosition(self.finalRow,self.finalCol)
#@-node:ekr.20051104075904.59:runTest
#@-node:ekr.20051104075904.57:class singleParagraphTest (reformatParagraphTest)
#@+node:ekr.20051104075904.60:class multiParagraphTest (reformatParagraphTest)
class multiParagraphTest (reformatParagraphTest):

    @others
#@+node:ekr.20051104075904.61:runTest
def runTest(self):

    self.c.reformatParagraph()
    self.checkPosition(13,0)

    # Keep going, in the same manner
    self.c.reformatParagraph()
    self.checkPosition(25,0)
    self.c.reformatParagraph()
    self.checkPosition(32,11)

    # Compare the computed result to the reference result.
    self.checkText()
#@-node:ekr.20051104075904.61:runTest
#@-node:ekr.20051104075904.60:class multiParagraphTest (reformatParagraphTest)
#@+node:ekr.20051104075904.62:class multiParagraphWithListTest (reformatParagraphTest)
class multiParagraphWithListTest (reformatParagraphTest):

    @others
#@+node:ekr.20051104075904.63:runTest
def runTest(self):

    # reformat the paragraph and check insertion cursor position
    self.c.reformatParagraph()
    self.checkPosition(4,0)

    # Keep going, in the same manner.
    self.c.reformatParagraph()
    self.checkPosition(7,0)
    self.c.reformatParagraph()
    self.checkPosition(10,0)
    self.c.reformatParagraph()
    self.checkPosition(13,0)
    self.c.reformatParagraph()
    self.checkPosition(14,18)

    # Compare the computed result to the reference result.
    self.checkText()
#@-node:ekr.20051104075904.63:runTest
#@-node:ekr.20051104075904.62:class multiParagraphWithListTest (reformatParagraphTest)
#@+node:ekr.20051104075904.64:class leadingWSOnEmptyLinesTest (reformatParagraphTest)
class leadingWSOnEmptyLinesTest (reformatParagraphTest):

    @others
#@+node:ekr.20051104075904.65:runTest
def runTest(self):

    # reformat the paragraph and check insertion cursor position
    self.c.reformatParagraph()
    self.checkPosition(4,0)

    # Keep going, in the same manner
    self.c.reformatParagraph()
    self.checkPosition(7,0)
    self.c.reformatParagraph()
    self.checkPosition(10,0)
    self.c.reformatParagraph()
    self.checkPosition(13,0)
    self.c.reformatParagraph()
    self.checkPosition(14,18)

    # Compare the computed result to the reference result.
    self.checkText()
#@-node:ekr.20051104075904.65:runTest
#@-node:ekr.20051104075904.64:class leadingWSOnEmptyLinesTest (reformatParagraphTest)
#@+node:ekr.20051104075904.66:class testDirectiveBreaksParagraph (reformatParagraphTest)
class directiveBreaksParagraphTest (reformatParagraphTest):

    @others
#@+node:ekr.20051104075904.67:runTest
def runTest(self):

    # reformat the paragraph and check insertion cursor position
    self.c.reformatParagraph()
    self.checkPosition(13,0) # at next paragraph

    # Keep going, in the same manner
    self.c.reformatParagraph()
    self.checkPosition(25,0) # at next paragraph
    self.c.reformatParagraph()
    self.checkPosition(32,11)

    # Compare the computed result to the reference result.
    self.checkText()
#@-node:ekr.20051104075904.67:runTest
#@-node:ekr.20051104075904.66:class testDirectiveBreaksParagraph (reformatParagraphTest)
#@-node:ekr.20051104075904.46:Reformat Paragraph test code (leoTest.py)
#@+node:ekr.20051104075904.68:Edit Body test code (leoTest.py)
#@+node:ekr.20051104075904.69: makeEditBodySuite
def makeEditBodySuite(c):

    """Create an Edit Body test for every descendant of testParentHeadline.."""

    p = c.currentPosition()
    u = testUtils(c)
    assert c.positionExists(p)
    data_p = u.findNodeInTree(p,"editBodyTests")
    assert(data_p)
    temp_p = u.findNodeInTree(data_p,"tempNode")
    assert(temp_p)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in data_p.children_iter():
        if p.headString()=="tempNode": continue # TempNode now in data tree.
        before = u.findNodeInTree(p,"before")
        after  = u.findNodeInTree(p,"after")
        sel    = u.findNodeInTree(p,"selection")
        ins    = u.findNodeInTree(p,"insert")
        if before and after:
            test = editBodyTestCase(c,p,before,after,sel,ins,temp_p)
            suite.addTest(test)
        else:
            print 'missing "before" or "after" for', p.headString()

    return suite
#@-node:ekr.20051104075904.69: makeEditBodySuite
#@+node:ekr.20051104075904.70:class editBodyTestCase
class editBodyTestCase(unittest.TestCase):

    """Data-driven unit tests for Leo's edit body commands."""

    @others
#@+node:ekr.20051104075904.71: __init__
def __init__ (self,c,parent,before,after,sel,ins,tempNode):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.u = testUtils(c)
    self.c = c
    self.parent = parent.copy()
    self.before = before.copy()
    self.after  = after.copy()
    self.sel    = sel.copy() # Two lines giving the selection range in tk coordinates.
    self.ins    = ins.copy() # One line giving the insert point in tk coordinate.
    self.tempNode = tempNode.copy()

    if 0:
        g.trace('parent',parent)
        g.trace('before',before)
        g.trace('after',after)
#@-node:ekr.20051104075904.71: __init__
#@+node:ekr.20051104075904.72: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20051104075904.72: fail
#@+node:ekr.20051104075904.73:editBody
def editBody (self):

    c = self.c ; u = self.u

    if not g.app.enableUnitTest: return

    # Blank stops the command name.
    commandName = self.parent.headString()
    i = commandName.find(' ')
    if i > -1:
        commandName = commandName[:i] 
    # g.trace(commandName)

    # Compute the result in tempNode.bodyString()
    command = getattr(c,commandName)
    command()

    # Don't call the undoer if we expect no change.
    if not u.compareOutlines(self.before,self.after,compareHeadlines=False,report=False):
        assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
        c.undoer.undo()
        assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
        c.undoer.redo()
        assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: after redo' % commandName
        c.undoer.undo()
        assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo2' % commandName
#@-node:ekr.20051104075904.73:editBody
#@+node:ekr.20051104075904.74:runTest
def runTest(self):

    self.editBody()
#@-node:ekr.20051104075904.74:runTest
#@+node:ekr.20051104075904.75:setUp
def setUp(self):

    c = self.c ; tempNode = self.tempNode

    if not g.app.enableUnitTest: return

    # self.undoMark = c.undoer.getMark()
    c.undoer.clearUndoState()

    # Delete all children of temp node.
    while tempNode.firstChild():
        tempNode.firstChild().doDelete()

    text = self.before.bodyString()

    tempNode.setTnodeText(text,g.app.tkEncoding)
    c.selectPosition(self.tempNode)

    w = c.frame.body.bodyCtrl
    if self.sel:
        s = str(self.sel.bodyString()) # Can't be unicode.
        lines = s.split('\n')
        w.setSelectionRange(lines[0],lines[1])

    if self.ins:
        s = str(self.ins.bodyString()) # Can't be unicode.
        lines = s.split('\n')
        g.trace(lines)
        w.setInsertPoint(lines[0])

    if not self.sel and not self.ins: # self.sel is a **tk** index.
        w.setInsertPoint(0)
        w.setSelectionRange(0,0)
#@-node:ekr.20051104075904.75:setUp
#@+node:ekr.20051104075904.76:tearDown
def tearDown (self):

    c = self.c ; tempNode = self.tempNode

    c.selectVnode(tempNode)
    tempNode.setTnodeText("",g.app.tkEncoding)

    # Delete all children of temp node.
    while tempNode.firstChild():
        tempNode.firstChild().doDelete()

    tempNode.clearDirty()

    # c.undoer.rollbackToMark(self.undoMark)
    c.undoer.clearUndoState()
#@-node:ekr.20051104075904.76:tearDown
#@-node:ekr.20051104075904.70:class editBodyTestCase
#@-node:ekr.20051104075904.68:Edit Body test code (leoTest.py)
#@+node:ekr.20051104075904.77:Import/Export test code (leoTest.py)
#@+node:ekr.20051104075904.78:makeImportExportSuite
def makeImportExportSuite(c,parentHeadline,doImport):

    """Create an Import/Export test for every descendant of testParentHeadline.."""

    u = testUtils(c)
    parent = u.findNodeAnywhere(parentHeadline)
    assert(parent)
    temp = u.findNodeInTree(parent,"tempNode")
    assert(temp)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in parent.children_iter(copy=True):
        if p == temp: continue
        dialog = u.findNodeInTree(p,"dialog")
        assert(dialog)
        test = importExportTestCase(c,p,dialog,temp,doImport)
        suite.addTest(test)

    return suite
#@-node:ekr.20051104075904.78:makeImportExportSuite
#@+node:ekr.20051104075904.79:class importExportTestCase
class importExportTestCase(unittest.TestCase):

    """Data-driven unit tests for Leo's edit body commands."""

    @others
#@+node:ekr.20051104075904.80:__init__
def __init__ (self,c,v,dialog,temp_v,doImport):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.dialog = dialog
    self.v = v
    self.temp_v = temp_v

    self.gui = None
    self.oldGui = None
    self.wasChanged = c.changed
    self.fileName = ""
    self.doImport = doImport

    self.old_v = c.currentVnode()
#@-node:ekr.20051104075904.80:__init__
#@+node:ekr.20051104075904.81: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20051104075904.81: fail
#@+node:ekr.20051104075904.82:importExport
def importExport (self):

    c = self.c ; v = self.v

    g.app.unitTestDict = {}

    commandName = v.headString()
    command = getattr(c,commandName) # Will fail if command does not exist.
    command(event=None)

    failedMethod = g.app.unitTestDict.get("fail")
    self.failIf(failedMethod,failedMethod)
#@-node:ekr.20051104075904.82:importExport
#@+node:ekr.20051104075904.83:runTest
def runTest(self):

    # """Import Export Test Case"""

    self.importExport()
#@-node:ekr.20051104075904.83:runTest
#@+node:ekr.20051104075904.84:setUp
def setUp(self):

    c = self.c ; temp_v = self.temp_v ; d = self.dialog

    temp_v.setTnodeText('',g.app.tkEncoding)

    # Create a node under temp_v.
    child = temp_v.insertAsLastChild()
    assert(child)
    c.setHeadString(child,"import test: " + self.v.headString())
    c.selectVnode(child)

    assert(d)
    s = d.bodyString()
    lines = s.split('\n')
    name = lines[0]
    fileName = lines[1]

    # Replace '\\' by os.path.sep in fileName
    try:
        # os.path.sep does not exist in Python 2.2.x.
        sep = os.path.sep
        fileName = fileName.replace('\\',sep)
    except AttributeError:
        fileName = g.os_path_normpath(fileName)

    self.fileName = fileName = g.os_path_join(g.app.loadDir,"..",fileName)

    if self.doImport:
        theDict = {name: [fileName]}
    else:
        theDict = {name: fileName}

    self.oldGui = g.app.gui
    self.gui = leoGui.unitTestGui(theDict,trace=False)
#@-node:ekr.20051104075904.84:setUp
#@+node:ekr.20051104075904.85:shortDescription
def shortDescription (self):

    try:
        return "ImportExportTestCase: %s %s" % (self.v.headString(),self.fileName)
    except:
        return "ImportExportTestCase"
#@-node:ekr.20051104075904.85:shortDescription
#@+node:ekr.20051104075904.86:tearDown
def tearDown (self):

    c = self.c ; temp_v = self.temp_v

    if self.gui:
        self.gui.destroySelf()
        self.gui = None

    temp_v.setTnodeText("",g.app.tkEncoding)
    temp_v.clearDirty()

    if not self.wasChanged:
        c.setChanged (False)

    if 1: # Delete all children of temp node.
        while temp_v.firstChild():
            temp_v.firstChild().doDelete()

    g.app.gui = self.oldGui
    c.selectVnode(self.old_v)
#@-node:ekr.20051104075904.86:tearDown
#@-node:ekr.20051104075904.79:class importExportTestCase
#@-node:ekr.20051104075904.77:Import/Export test code (leoTest.py)
#@+node:ekr.20051104075904.87:Perfect Import test code (leoTest.py)
#@+node:ekr.20051104075904.88:About the Perfect Import tests
@killcolor
@

This code assumes that the test code contains child nodes with the following headlines:

-input          Contains the "before" tree, without sentinels
-input-after    Contains the "after" tree, without sentinels.

These two nodes define what the test means.

The following nodes must also exist.  The test code sets their contents as follows:

-output-sent        The result of writing the -input tree, with sentinels.
-output-after-sent  The result of writing the -input-after tree, with sentinels.
-i_lines            The i_lines list created by mu.create_mapping
-j_lines            The j_lines list created by stripping sentinels from -input-after's tree.
-result             The result of running mu.propagateDiffsToSentinelsLines, containing sentinels.

A test passes if and only if the body of -result matches the body of output-after-sent, ignoring the details of @+node and @-node sentinels.
#@-node:ekr.20051104075904.88:About the Perfect Import tests
#@+node:ekr.20051104075904.89:runPerfectImportTest
def runPerfectImportTest(c,p,
    testing=False,verbose=False,
    ignoreSentinelsInCompare=False):

    __pychecker__ = '--no-shadowbuiltin' # input is a builtin.

    # The contents of the "-input" and "-input-after" nodes define the changes.

    p = c.currentPosition()
    u = testUtils(c)
    input           = u.findNodeInTree(p,"-input")              # i file: before the change.
    input_ins       = u.findNodeInTree(p,"-input-after")        # j file: after the change.
    output_sent     = u.findNodeInTree(p,"-output-sent")        # fat file -> i file.
    out_after_sent  = u.findNodeInTree(p,"-output-after-sent")  # Should match result.
    result          = u.findNodeInTree(p,"-result")
    ilines          = u.findNodeInTree(p,"-i_lines")
    jlines          = u.findNodeInTree(p,"-j_lines")

    # Create the output nodes containing sentinels from the original input.
    u.writeNodesToNode(c,input,output_sent,sentinels=True)
    u.writeNodesToNode(c,input_ins,out_after_sent,sentinels=True)

    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension("foo.py")

    fat_lines = g.splitLines(output_sent.bodyString())
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    if input_ins.hasChildren():
        # Get the lines by stripping sentinels from -output-after-sent node.
        lines = g.splitLines(out_after_sent.bodyString()) 
        j_lines = mu.removeSentinelsFromLines(lines,delims)
    else:
        j_lines = g.splitLines(input_ins.bodyString()) 

    # For viewing...
    ilines.scriptSetBodyString(''.join(i_lines))
    jlines.scriptSetBodyString(''.join(j_lines))
    if ilines.bodyString() != input.bodyString():
        if not ignoreSentinelsInCompare:
            print "i_lines != input !"

    # Put the resulting lines (with sentinels) into the -result node.
    lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
    result.scriptSetBodyString(''.join(lines))

    if ignoreSentinelsInCompare:
        sList = []
        for s in (result.bodyString(),out_after_sent.bodyString()):
            lines = g.splitLines(s)
            lines = mu.removeSentinelsFromLines(lines,delims)
            sList.append(''.join(lines))
        return sList[0] == sList[1]
    else:
        return u.compareIgnoringNodeNames(
            result.bodyString(),
            out_after_sent.bodyString(),
            delims,verbose=True)
#@-node:ekr.20051104075904.89:runPerfectImportTest
#@-node:ekr.20051104075904.87:Perfect Import test code (leoTest.py)
#@+node:ekr.20051104075904.90:Plugin tests... (leoTest.py)
#@+node:ekr.20051104075904.91:getAllPluginFilenames
def getAllPluginFilenames ():

    path = g.os_path_join(g.app.loadDir,"..","plugins")

    files = glob.glob(g.os_path_join(path,"*.py"))
    files = [g.os_path_abspath(f) for f in files]
    files.sort()
    return files
#@-node:ekr.20051104075904.91:getAllPluginFilenames
#@+node:ekr.20051104075904.92:testPlugin (no longer used)
def oldTestPlugin (fileName,verbose=False):

    path = g.os_path_join(g.app.loadDir,"..","plugins")
    path = g.os_path_abspath(path)

    module = g.importFromPath(fileName,path)
    assert module, "Can not import %s" % path

    # Run any unit tests in the module itself.
    if hasattr(module,"unitTest"):
        if verbose:
            g.trace("Executing unitTest in plugins/%s..." % fileName)

        module.unitTest(verbose=verbose)
#@-node:ekr.20051104075904.92:testPlugin (no longer used)
#@+node:ekr.20051104075904.93:checkFileSyntax
def checkFileSyntax (fileName,s):

    try:
        compiler.parse(s + '\n')
    except SyntaxError:
        g.es("Syntax error in: %s" % fileName,color="blue")
        g.es_exception(full=False,color="black")
        raise
#@-node:ekr.20051104075904.93:checkFileSyntax
#@+node:ekr.20051104075904.94:checkFileTabs
def checkFileTabs (fileName,s):

    try:
        readline = g.readLinesClass(s).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))

    except tokenize.TokenError, msg:
        s = "Token error in %s" % fileName
        print s ; g.es(s,color="blue")
        s = str(msg)
        print s ; g.es(s)
        assert 0, "test failed"

    except tabnanny.NannyNag, nag:
        badline = nag.get_lineno()
        line    = nag.get_line()
        message = nag.get_msg()
        s = "Indentation error in %s, line %d" % (fileName, badline)
        print s ; g.es(s,color="blue")
        print message ; g.es(message)
        s = "offending line:\n%s" % repr(str(line))[1:-1]
        print s ; g.es(s)
        assert 0, "test failed"

    except:
        s = "unexpected exception"
        print s ; g.trace(s)
        g.es_exception()
        assert 0, "test failed"
#@-node:ekr.20051104075904.94:checkFileTabs
#@-node:ekr.20051104075904.90:Plugin tests... (leoTest.py)
#@+node:ekr.20051104075904.95:throwAssertionError
def throwAssertionError():

    assert 0, 'assert(0) as a test of catching assertions'
#@-node:ekr.20051104075904.95:throwAssertionError
#@+node:ekr.20061008140603:runEditCommandTest
def runEditCommandTest (c,p):

    u = testUtils(c) ; atTest = p.copy()
    w = c.frame.body.bodyCtrl

    h = atTest.headString()
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)

    work,before,after = u.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.headString()
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.headString()[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    #g.trace(repr(sels))

    c.beginUpdate()
    try:
        c.selectPosition(work)
        c.setBodyString(work,before.bodyString())
        #g.trace(repr(sel1[0]),repr(sel1[1]))
        w.setSelectionRange(sel1[0],sel1[1],insert=sel1[1])
        c.k.simulateCommand(commandName)
        s1 = work.bodyString() ; s2 = after.bodyString()
        assert s1 == s2, 'mismatch in body\nexpected: %s\n     got: %s' % (repr(s2),repr(s1))
        sel3 = w.getSelectionRange()
        ins = w.toGuiIndex(w.getInsertPoint())
        #g.trace('ins',ins,'s1[j:...]',repr(s1[j:j+10]))
        # Convert both selection ranges to gui indices.
        sel2_orig = sel2
        # g.trace(w)
        i,j = sel2 ; sel2 = w.toGuiIndex(i),w.toGuiIndex(j)
        i,j = sel3 ; sel3 = w.toGuiIndex(i),w.toGuiIndex(j)
        assert sel2 == sel3, 'mismatch in sel\nexpected: %s = %s, got: %s' % (sel2_orig,sel2,sel3)
        c.selectPosition(atTest)
        atTest.contract()
    finally:
        c.endUpdate(False) # Don't redraw.
#@nonl
#@-node:ekr.20061008140603:runEditCommandTest
#@-node:ekr.20051104075904.43:Specific to particular unit tests...
#@+node:ekr.20051104075904.96:Test of doctest
#@+node:ekr.20051104075904.97:factorial
def factorial(n):
    """Return the factorial of n, an exact integer >= 0.

    If the result is small enough to fit in an int, return an int.
    Else return a long.

    >>> [factorial(n) for n in range(6)]
    [1, 1, 2, 6, 24, 120]
    >>> [factorial(long(n)) for n in range(6)]
    [1, 1, 2, 6, 24, 120]
    >>> factorial(30)
    265252859812191058636308480000000L
    >>> factorial(30L)
    265252859812191058636308480000000L
    >>> factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: n must be >= 0

    Factorials of floats are OK, but the float must be an exact integer:
    >>> factorial(30.1)
    Traceback (most recent call last):
        ...
    ValueError: n must be exact integer
    >>> factorial(30.0)
    265252859812191058636308480000000L

    It must also not be ridiculously large:
    >>> factorial(1e100)
    Traceback (most recent call last):
        ...
    OverflowError: n too large
    """

    import math
    if not n >= 0:
        raise ValueError("n must be >= 0")
    if math.floor(n) != n:
        raise ValueError("n must be exact integer")
    if n+1 == n:  # catch a value like 1e300
        raise OverflowError("n too large")
    result = 1
    factor = 2
    while factor <= n:
        try:
            result *= factor
        except OverflowError:
            result *= long(factor)
        factor += 1
    return result
#@-node:ekr.20051104075904.97:factorial
#@-node:ekr.20051104075904.96:Test of doctest
#@+node:ekr.20051104075904.98:Docutils stuff
#@+node:ekr.20051104075904.99:createUnitTestsFromDoctests
def createUnitTestsFromDoctests (modules,verbose=True):

    created = False # True if suite is non-empty.

    suite = unittest.makeSuite(unittest.TestCase)

    for module in list(modules):
        # New in Python 4.2: n may be zero.
        try:
            test = doctest.DocTestSuite(module)
            n = test.countTestCases()
            if n > 0:
                suite.addTest(test)
                created = True
                if verbose:
                    print "found %2d doctests for %s" % (n,module.__name__)
        except ValueError:
            pass # No tests found.

    return g.choose(created,suite,None)
#@-node:ekr.20051104075904.99:createUnitTestsFromDoctests
#@+node:ekr.20051104075904.100:findAllAtFileNodes
def findAllAtFileNodes(c):

    paths = []

    for p in c.all_positions_iter():
        name = p.anyAtFileNodeName()
        if name:
            head,tail = g.os_path_split(name)
            filename,ext = g.os_path_splitext(tail)
            if ext == ".py":
                path = g.os_path_join(g.app.loadDir,name)
                path = g.os_path_abspath(path)
                paths.append(path)

    return paths
#@-node:ekr.20051104075904.100:findAllAtFileNodes
#@+node:ekr.20051104075904.101:importAllModulesInPathList
def importAllModulesInPathList(paths):

    paths = list(paths)
    modules = []

    for path in paths:
        module = safeImportModule(path)
        if module:
            modules.append(module)

    return modules
#@-node:ekr.20051104075904.101:importAllModulesInPathList
#@+node:ekr.20051104075904.102:importAllModulesInPath
def importAllModulesInPath (path):

    path = g.os_path_abspath(path)

    if not g.os_path_exists(path):
        g.es("path does not exist: %s" % path)
        return []

    path2 = g.os_path_join(path,"leo*.py")
    files = glob.glob(path2)

    modules = []

    for theFile in files:
        module = safeImportModule(theFile)
        if module:
            modules.append(module)

    return modules
#@nonl
#@-node:ekr.20051104075904.102:importAllModulesInPath
#@+node:ekr.20051104075904.103:safeImportModule
@ Warning: do NOT use g.importFromPath here!

g.importFromPath uses imp.load_module, and that is equivalent to reload!
reloading Leo files while running will crash Leo.
@c

def safeImportModule (fileName):

    fileName = g.os_path_abspath(fileName)
    head,tail = g.os_path_split(fileName)
    moduleName,ext = g.os_path_splitext(tail)

    if ext == ".py":
        try:
            return __import__(moduleName)
        except Exception: # leoScriptModule.py, for example, can throw other exceptions.
            return None
    else:
        print "Not a .py file:",fileName
        return None
#@-node:ekr.20051104075904.103:safeImportModule
#@-node:ekr.20051104075904.98:Docutils stuff
#@+node:ekr.20051104075904.104:Test of doTestRoutinesInModule
#@+node:ekr.20051104075904.105:test_dummy
def test_dummy():
    import leoGlobals as g
    g.trace()
    # raise SyntaxError

# class dummyTestClass: # NOT a TestCase.
    # def test_one (self):
        # import leoGlobals as g
        # g.trace(self)
#@-node:ekr.20051104075904.105:test_dummy
#@-node:ekr.20051104075904.104:Test of doTestRoutinesInModule
#@-node:ekr.20051104075904:@thin leoTest.py
#@-node:ekr.20031218072017.2604:Core classes...
#@+node:ekr.20031218072017.3625:Gui Base classes
<< about gui classes and gui plugins >>
#@+node:ekr.20050721093241:<< about gui classes and gui plugins >>
@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code-->Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code-->Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
#@-node:ekr.20050721093241:<< about gui classes and gui plugins >>
#@+node:ekr.20031218072017.3630:@thin leoCompare.py
@language python
@tabwidth -4
@pagewidth 80

"""Leo's base compare class."""

import leoGlobals as g
import filecmp
import os
import string

@others
#@+node:ekr.20031218072017.3631:choose
def choose(cond, a, b): # warning: evaluates all arguments

    if cond: return a
    else: return b
#@-node:ekr.20031218072017.3631:choose
#@+node:ekr.20031218072017.3632:go
def go ():

    compare = leoCompare(
        commands = None,

        appendOutput = True,

        ignoreBlankLines = True,
        ignoreFirstLine1 = False,
        ignoreFirstLine2 = False,
        ignoreInteriorWhitespace = False,
        ignoreLeadingWhitespace = True,
        ignoreSentinelLines = False,

        limitCount = 9, # Zero means don't stop.
        limitToExtension = ".py",  # For directory compares.
        makeWhitespaceVisible = True,

        printBothMatches = False,
        printMatches = False,
        printMismatches = True,
        printTrailingMismatches = False,

        outputFileName = None)

    if 1: # Compare all files in Tangle test directories

        path1 = "c:\\prog\\test\\tangleTest\\"
        path2 = "c:\\prog\\test\\tangleTestCB\\"
        compare.compare_directories(path1,path2)

    else: # Compare two files.

        name1 = "c:\\prog\\test\\compare1.txt"
        name2 = "c:\\prog\\test\\compare2.txt"
        compare.compare_files(name1,name2)
#@-node:ekr.20031218072017.3632:go
#@+node:ekr.20031218072017.3633:class leoCompare
class baseLeoCompare:
    """The base class for Leo's compare code."""
    @others

class leoCompare (baseLeoCompare):
    """A class containing Leo's compare code."""
    pass
#@+node:ekr.20031218072017.3634:compare.__init__
# All these ivars are known to the leoComparePanel class.

def __init__ (self,

    # Keyword arguments are much convenient and more clear for scripts.
    commands = None,

    appendOutput = False,

    ignoreBlankLines = True,
    ignoreFirstLine1 = False,
    ignoreFirstLine2 = False,
    ignoreInteriorWhitespace = False,
    ignoreLeadingWhitespace = True,
    ignoreSentinelLines = False,

    limitCount = 0, # Zero means don't stop.
    limitToExtension = ".py",  # For directory compares.
    makeWhitespaceVisible = True,

    printBothMatches = False,
    printMatches = False,
    printMismatches = True,
    printTrailingMismatches = False,

    outputFileName = None ):

    __pychecker__ = 'maxargs=50'

    # It is more convenient for the leoComparePanel to set these directly.
    self.c = commands

    self.appendOutput = appendOutput

    self.ignoreBlankLines = ignoreBlankLines
    self.ignoreFirstLine1 = ignoreFirstLine1
    self.ignoreFirstLine2 = ignoreFirstLine2
    self.ignoreInteriorWhitespace = ignoreInteriorWhitespace
    self.ignoreLeadingWhitespace = ignoreLeadingWhitespace
    self.ignoreSentinelLines = ignoreSentinelLines

    self.limitCount = limitCount
    self.limitToExtension = limitToExtension

    self.makeWhitespaceVisible = makeWhitespaceVisible

    self.printBothMatches = printBothMatches
    self.printMatches = printMatches
    self.printMismatches = printMismatches
    self.printTrailingMismatches = printTrailingMismatches

    # For communication between methods...
    self.outputFileName = outputFileName
    self.fileName1 = None 
    self.fileName2 = None
    # Open files...
    self.outputFile = None
#@-node:ekr.20031218072017.3634:compare.__init__
#@+node:ekr.20031218072017.3635:compare_directories (entry)
# We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):

    # Ignore everything except the directory name.
    dir1 = g.os_path_dirname(path1)
    dir2 = g.os_path_dirname(path2)
    dir1 = g.os_path_normpath(dir1)
    dir2 = g.os_path_normpath(dir2)

    if dir1 == dir2:
        return self.show("Please pick distinct directories.")
    try:
        list1 = os.listdir(dir1)
    except:
        return self.show("invalid directory:" + dir1)
    try:
        list2 = os.listdir(dir2)
    except:
        return self.show("invalid directory:" + dir2)

    if self.outputFileName:
        self.openOutputFile()
    ok = self.outputFileName == None or self.outputFile
    if not ok: return None

    # Create files and files2, the lists of files to be compared.
    files1 = []
    files2 = []
    for f in list1:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files1.append(f)
        else:
            files1.append(f)
    for f in list2:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files2.append(f)
        else:
            files2.append(f)

    # Compare the files and set the yes, no and missing lists.
    yes = [] ; no = [] ; missing1 = [] ; missing2 = []
    for f1 in files1:
        head,f2 = g.os_path_split(f1)
        if f2 in files2:
            try:
                name1 = g.os_path_join(dir1,f1)
                name2 = g.os_path_join(dir2,f2)
                val = filecmp.cmp(name1,name2,0)
                if val: yes.append(f1)
                else:    no.append(f1)
            except:
                self.show("exception in filecmp.cmp")
                g.es_exception()
                missing1.append(f1)
        else:
            missing1.append(f1)
    for f2 in files2:
        head,f1 = g.os_path_split(f2)
        if f1 not in files1:
            missing2.append(f1)

    # Print the results.
    for kind, files in (
        ("----- matches --------",yes),
        ("----- mismatches -----",no),
        ("----- not found 1 ------",missing1),
        ("----- not found 2 ------",missing2),
    ):
        self.show(kind)
        for f in files:
            self.show(f)

    if self.outputFile:
        self.outputFile.close()
        self.outputFile = None

    return None # To keep pychecker happy.
#@nonl
#@-node:ekr.20031218072017.3635:compare_directories (entry)
#@+node:ekr.20031218072017.3636:compare_files (entry)
def compare_files (self, name1, name2):

    if name1 == name2:
        self.show("File names are identical.\nPlease pick distinct files.")
        return

    f1 = f2 = None
    try:
        f1 = self.doOpen(name1)
        f2 = self.doOpen(name2)
        if self.outputFileName:
            self.openOutputFile()
        ok = self.outputFileName == None or self.outputFile
        ok = g.choose(ok and ok != 0,1,0)
        if f1 and f2 and ok: # Don't compare if there is an error opening the output file.
            self.compare_open_files(f1,f2,name1,name2)
    except:
        self.show("exception comparing files")
        g.es_exception()
    try:
        if f1: f1.close()
        if f2: f2.close()
        if self.outputFile:
            self.outputFile.close() ; self.outputFile = None
    except:
        self.show("exception closing files")
        g.es_exception()
#@-node:ekr.20031218072017.3636:compare_files (entry)
#@+node:ekr.20031218072017.3637:compare_lines
def compare_lines (self,s1,s2):

    if self.ignoreLeadingWhitespace:
        s1 = s1.lstrip()
        s2 = s2.lstrip()

    if self.ignoreInteriorWhitespace:
        k1 = g.skip_ws(s1,0)
        k2 = g.skip_ws(s2,0)
        ws1 = s1[:k1]
        ws2 = s2[:k2]
        tail1 = s1[k1:]
        tail2 = s2[k2:]
        tail1 = string.replace(tail1," ","")
        tail1 = string.replace(tail1,"\t","")
        tail2 = string.replace(tail2," ","")
        tail2 = string.replace(tail2,"\t","")
        s1 = ws1 + tail1
        s2 = ws2 + tail2

    return s1 == s2
#@-node:ekr.20031218072017.3637:compare_lines
#@+node:ekr.20031218072017.3638:compare_open_files
def compare_open_files (self, f1, f2, name1, name2):

    # self.show("compare_open_files")
    lines1 = 0 ; lines2 = 0 ; mismatches = 0 ; printTrailing = True
    sentinelComment1 = sentinelComment2 = None
    if self.openOutputFile():
        self.show("1: " + name1)
        self.show("2: " + name2)
        self.show("")
    s1 = s2 = None
    << handle opening lines >>
    while 1:
        if s1 == None:
            s1 = g.readlineForceUnixNewline(f1) ; lines1 += 1
        if s2 == None:
            s2 = g.readlineForceUnixNewline(f2) ; lines2 += 1
        << ignore blank lines and/or sentinels >>
        n1 = len(s1) ; n2 = len(s2)
        if n1==0 and n2 != 0: self.show("1.eof***:")
        if n2==0 and n1 != 0: self.show("2.eof***:")
        if n1==0 or n2==0: break
        match = self.compare_lines(s1,s2)
        if not match: mismatches += 1
        << print matches and/or mismatches >>
        << warn if mismatch limit reached >>
        s1 = s2 = None # force a read of both lines.
    << handle reporting after at least one eof is seen >>
#@+node:ekr.20031218072017.3639:<< handle opening lines >>
if self.ignoreSentinelLines:

    s1 = g.readlineForceUnixNewline(f1) ; lines1 += 1
    s2 = g.readlineForceUnixNewline(f2) ; lines2 += 1
    # Note: isLeoHeader may return None.
    sentinelComment1 = self.isLeoHeader(s1)
    sentinelComment2 = self.isLeoHeader(s2)
    if not sentinelComment1: self.show("no @+leo line for " + name1)
    if not sentinelComment2: self.show("no @+leo line for " + name2)

if self.ignoreFirstLine1:
    if s1 == None:
        g.readlineForceUnixNewline(f1) ; lines1 += 1
    s1 = None

if self.ignoreFirstLine2:
    if s2 == None:
        g.readlineForceUnixNewline(f2) ; lines2 += 1
    s2 = None
#@-node:ekr.20031218072017.3639:<< handle opening lines >>
#@+node:ekr.20031218072017.3640:<< ignore blank lines and/or sentinels >>
# Completely empty strings denotes end-of-file.
if s1 and len(s1) > 0:
    if self.ignoreBlankLines and len(string.strip(s1)) == 0:
        s1 = None ; continue

    if self.ignoreSentinelLines and sentinelComment1 and self.isSentinel(s1,sentinelComment1):
        s1 = None ; continue

if s2 and len(s2) > 0:
    if self.ignoreBlankLines and len(string.strip(s2)) == 0:
        s2 = None ; continue

    if self.ignoreSentinelLines and sentinelComment2 and self.isSentinel(s2,sentinelComment2):
        s2 = None ; continue
#@-node:ekr.20031218072017.3640:<< ignore blank lines and/or sentinels >>
#@+node:ekr.20031218072017.3641:<< print matches and/or mismatches >>
if self.limitCount == 0 or mismatches <= self.limitCount:

    if match and self.printMatches:

        if self.printBothMatches:
            self.dump(string.rjust("1." + str(lines1),6) + ' :',s1)
            self.dump(string.rjust("2." + str(lines2),6) + ' :',s2)
        else:
            self.dump(string.rjust(       str(lines1),6) + ' :',s1)

    if not match and self.printMismatches:

        self.dump(string.rjust("1." + str(lines1),6) + '*:',s1)
        self.dump(string.rjust("2." + str(lines2),6) + '*:',s2)
#@-node:ekr.20031218072017.3641:<< print matches and/or mismatches >>
#@+node:ekr.20031218072017.3642:<< warn if mismatch limit reached >>
if self.limitCount > 0 and mismatches >= self.limitCount:

    if printTrailing:
        self.show("")
        self.show("limit count reached")
        self.show("")
        printTrailing = False
#@-node:ekr.20031218072017.3642:<< warn if mismatch limit reached >>
#@+node:ekr.20031218072017.3643:<< handle reporting after at least one eof is seen >>
if n1 > 0: 
    lines1 += self.dumpToEndOfFile("1.",f1,s1,lines1,printTrailing)

if n2 > 0:
    lines2 += self.dumpToEndOfFile("2.",f2,s2,lines2,printTrailing)

self.show("")
self.show("lines1:" + str(lines1))
self.show("lines2:" + str(lines2))
self.show("mismatches:" + str(mismatches))
#@-node:ekr.20031218072017.3643:<< handle reporting after at least one eof is seen >>
#@-node:ekr.20031218072017.3638:compare_open_files
#@+node:ekr.20031218072017.3644:filecmp
def filecmp (self,f1,f2):

    val = filecmp.cmp(f1,f2)
    if 1:
        if val: self.show("equal")
        else:   self.show("*** not equal")
    else:
        self.show("filecmp.cmp returns:")
        if val: self.show(str(val)+ " (equal)")
        else:   self.show(str(val) + " (not equal)")
    return val
#@-node:ekr.20031218072017.3644:filecmp
#@+node:ekr.20031218072017.3645:utils...
#@+node:ekr.20031218072017.3646:doOpen
def doOpen (self,name):

    try:
        f = open(name,'r')
        return f
    except:
        self.show("can not open:" + '"' + name + '"')
        return None
#@-node:ekr.20031218072017.3646:doOpen
#@+node:ekr.20031218072017.3647:dump
def dump (self,tag,s):

    compare = self ; out = tag

    for ch in s[:-1]: # don't print the newline

        if compare.makeWhitespaceVisible:
            if ch == '\t':
                out += "[" ; out += "t" ; out += "]"
            elif ch == ' ':
                out += "[" ; out += " " ; out += "]"
            else: out += ch
        else:
            if 1:
                out += ch
            else: # I don't know why I thought this was a good idea ;-)
                if ch == '\t' or ch == ' ':
                    out += ' '
                else:
                    out += ch

    self.show(out)
#@-node:ekr.20031218072017.3647:dump
#@+node:ekr.20031218072017.3648:dumpToEndOfFile
def dumpToEndOfFile (self,tag,f,s,line,printTrailing):

    trailingLines = 0
    while 1:
        if not s:
            s = g.readlineForceUnixNewline(f)
        if len(s) == 0: break
        trailingLines += 1
        if self.printTrailingMismatches and printTrailing:
            tag2 = string.rjust(tag + str(line),6) + "+:"
            self.dump(tag2,s)
        s = None

    self.show(tag + str(trailingLines) + " trailing lines")
    return trailingLines
#@-node:ekr.20031218072017.3648:dumpToEndOfFile
#@+node:ekr.20031218072017.3649:isLeoHeader & isSentinel
@ These methods are based on atFile.scanHeader().  They are simpler because we only care about the starting sentinel comment: any line starting with the starting sentinel comment is presumed to be a sentinel line.
@c

def isLeoHeader (self,s):

    tag = "@+leo"
    j = string.find(s,tag)
    if j > 0:
        i = g.skip_ws(s,0)
        if i < j: return s[i:j]
        else: return None
    else: return None

def isSentinel (self,s,sentinelComment):

    i = g.skip_ws(s,0)
    return g.match(s,i,sentinelComment)
#@-node:ekr.20031218072017.3649:isLeoHeader & isSentinel
#@+node:ekr.20031218072017.1144:openOutputFile (compare)
def openOutputFile (self):

    if self.outputFileName == None:
        return
    theDir,name = g.os_path_split(self.outputFileName)
    if len(theDir) == 0:
        self.show("empty output directory")
        return
    if len(name) == 0:
        self.show("empty output file name")
        return
    if not g.os_path_exists(theDir):
        self.show("output directory not found: " + theDir)
    else:
        try:
            if self.appendOutput:
                self.show("appending to " + self.outputFileName)
                self.outputFile = open(self.outputFileName,"ab")
            else:
                self.show("writing to " + self.outputFileName)
                self.outputFile = open(self.outputFileName,"wb")
        except:
            self.outputFile = None
            self.show("exception opening output file")
            g.es_exception()
#@-node:ekr.20031218072017.1144:openOutputFile (compare)
#@+node:ekr.20031218072017.3650:show
def show (self,s):

    # print s
    if self.outputFile:
        self.outputFile.write(s + '\n')
    elif self.c:
        g.es(s)
    else:
        print s
        print
#@-node:ekr.20031218072017.3650:show
#@+node:ekr.20031218072017.3651:showIvars
def showIvars (self):

    self.show("fileName1:"        + str(self.fileName1))
    self.show("fileName2:"        + str(self.fileName2))
    self.show("outputFileName:"   + str(self.outputFileName))
    self.show("limitToExtension:" + str(self.limitToExtension))
    self.show("")

    self.show("ignoreBlankLines:"         + str(self.ignoreBlankLines))
    self.show("ignoreFirstLine1:"         + str(self.ignoreFirstLine1))
    self.show("ignoreFirstLine2:"         + str(self.ignoreFirstLine2))
    self.show("ignoreInteriorWhitespace:" + str(self.ignoreInteriorWhitespace))
    self.show("ignoreLeadingWhitespace:"  + str(self.ignoreLeadingWhitespace))
    self.show("ignoreSentinelLines:"      + str(self.ignoreSentinelLines))
    self.show("")

    self.show("limitCount:"              + str(self.limitCount))
    self.show("printMatches:"            + str(self.printMatches))
    self.show("printMismatches:"         + str(self.printMismatches))
    self.show("printTrailingMismatches:" + str(self.printTrailingMismatches))
#@-node:ekr.20031218072017.3651:showIvars
#@-node:ekr.20031218072017.3645:utils...
#@-node:ekr.20031218072017.3633:class leoCompare
#@-node:ekr.20031218072017.3630:@thin leoCompare.py
#@+node:ekr.20060123151617:@thin leoFind.py
'''Leo's gui-independent find classes.'''

@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import re

<< Theory of operation of find/change >>

@others
#@+node:ekr.20031218072017.2414:<< Theory of operation of find/change >>
@ The find and change commands are tricky; there are many details that must be handled properly. This documentation describes the leo.py code. Previous versions of Leo used an inferior scheme.  The following principles govern the leoFind class:

1. Find and Change commands initialize themselves using only the state of the present Leo window. In particular, the Find class must not save internal state information from one invocation to the next. This means that when the user changes the nodes, or selects new text in headline or body text, those changes will affect the next invocation of any Find or Change command. Failure to follow this principle caused all kinds of problems in the Borland and Macintosh codes. There is one exception to this rule: we must remember where interactive wrapped searches start. This principle simplifies the code because most ivars do not persist. However, each command must ensure that the Leo window is left in a state suitable for restarting the incremental (interactive) Find and Change commands. Details of initialization are discussed below.

2. The Find and Change commands must not change the state of the outline or body pane during execution. That would cause severe flashing and slow down the commands a great deal. In particular, c.selectVnode and c.editPosition methods must not be called while looking for matches.

3. When incremental Find or Change commands succeed they must leave the Leo window in the proper state to execute another incremental command. We restore the Leo window as it was on entry whenever an incremental search fails and after any Find All and Change All command.

Initialization involves setting the c, p, in_headline, wrapping and s_ctrl ivars. Setting in_headline is tricky; we must be sure to retain the state of the outline pane until initialization is complete. Initializing the Find All and Change All commands is much easier because such initialization does not depend on the state of the Leo window.

Using Tk.Text widgets for both headlines and body text results in a huge simplification of the code. Indeed, the searching code does not know whether it is searching headline or body text. The search code knows only that s_ctrl is a Tk.Text widget that contains the text to be searched or changed and the insert and sel Tk attributes of self.search_text indicate the range of text to be searched. Searching headline and body text simultaneously is complicated. The selectNextPosition() method handles the many details involved by setting s_ctrl and its insert and sel attributes.
#@-node:ekr.20031218072017.2414:<< Theory of operation of find/change >>
#@+node:ekr.20070105092022.1:class searchWidget
class searchWidget:

    '''A class to simulating a hidden Tk Text widget.'''

    def __repr__(self):
        return 'searchWidget id: %s' % (id(self))

    @others
#@nonl
#@+node:ekr.20070105092438:ctor
def __init__ (self,*args,**keys):

    # g.trace ('searchWidget',g.callers())

    self.s = ''    # The widget text
    self.i = 0     # The insert point
    self.sel = 0,0 # The selection range
#@-node:ekr.20070105092438:ctor
#@+node:ekr.20070105093138:getters
def getAllText (self):          return self.s
def getInsertPoint (self):      return self.i       # Returns Python index.
def getSelectionRange(self):    return self.sel     # Returns Python indices.

#@-node:ekr.20070105093138:getters
#@+node:ekr.20070105102419:setters
def delete(self,i,j=None):
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    else: j = self.toPythonIndex(j)
    self.s = self.s[:i] + self.s[j:]

def insert(self,i,s):
    if not s: return
    i = self.toPythonIndex(i)
    self.s = self.s[:i] + s + self.s[i:]
    self.i = i
    self.sel = i,i

def setAllText (self,s):
    self.s = s
    self.i = 0
    self.sel = 0,0

def setInsertPoint (self,i):
    self.i = i

def setSelectionRange (self,i,j,insert=None):
    self.sel = self.toPythonIndex(i),self.toPythonIndex(j)
    if insert is not None:
        self.i = self.toPythonIndex(insert)
#@-node:ekr.20070105102419:setters
#@+node:ekr.20070105092022.4:toPythonIndex
def toPythonIndex (self,i):

    '''Make sure i is a Python index.'''

    if i is None:
        return 0

    elif type(i) in (type('a'),type(u'a')):
        row,col = i.split('.')
        row,col = int(row),int(col)
        row -= 1
        i = g.convertRowColToPythonIndex(self.s,row,col)

    return i
#@-node:ekr.20070105092022.4:toPythonIndex
#@-node:ekr.20070105092022.1:class searchWidget
#@+node:ekr.20061212084717:class leoFind
class leoFind:

    """The base class for Leo's Find commands."""

    @others
#@+node:ekr.20031218072017.3053:leoFind.__init__ & helpers
def __init__ (self,c,title=None):

    # g.trace('leoFind',c)

    self.c = c

    # Spell checkers use this class, so we can't always compute a title.
    if title:
        self.title = title
    else:
        << compute self.title >>

    << init the gui-independent ivars >>

def init (self,c):
    self.oops()
#@+node:ekr.20041121145452:<< compute self.title >>
if not c.mFileName:
    s = "untitled"
else:
    path,s = g.os_path_split(c.mFileName)

self.title = "Find/Change for %s" %  s
#@-node:ekr.20041121145452:<< compute self.title >>
#@+node:ekr.20031218072017.3054:<< init the gui-independent ivars >>
self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated by update_ivars just before doing any find.
@c

<< do dummy initialization to keep Pychecker happy >>

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = searchWidget() # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.  The search() method will fail if p==wrapPosition and pos >= wrapPos.  selectNextPosition() will fail if p == wrapPosition.  We set wrapPos on entry, before the first search.  We set wrapPosition in selectNextPosition after the first search fails.  We also set wrapPosition on exit if the first search suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
self.selStart = self.selEnd = None # For selection-only searches.
#@+node:ekr.20050123164539:<< do dummy initialization to keep Pychecker happy >>
if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.selection_only = None
    self.wrap = None
    self.whole_word = None

if 1:
    self.change_ctrl = None
    self.find_ctrl = None
    self.frame = None
    self.svarDict = {}
#@-node:ekr.20050123164539:<< do dummy initialization to keep Pychecker happy >>
#@-node:ekr.20031218072017.3054:<< init the gui-independent ivars >>
#@-node:ekr.20031218072017.3053:leoFind.__init__ & helpers
#@+node:ekr.20060123065756.1:Top Level Buttons
#@+node:ekr.20031218072017.3057:changeAllButton
# The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_change:
        self.doChangeAllScript()
    elif self.selection_only:
        self.change()
    else:
        self.changeAll()
#@-node:ekr.20031218072017.3057:changeAllButton
#@+node:ekr.20031218072017.3056:changeButton
# The user has pushed the "Change" button from the find panel.

def changeButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
    else:
        self.change()
#@-node:ekr.20031218072017.3056:changeButton
#@+node:ekr.20031218072017.3058:changeThenFindButton
# The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
        if self.script_search:
            self.doFindScript()
        else:
            self.findNext()
    else:
        if self.script_search:
            self.change()
            self.doFindScript()
        else:
            self.changeThenFind()
#@-node:ekr.20031218072017.3058:changeThenFindButton
#@+node:ekr.20031218072017.3060:findAllButton
# The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    elif self.selection_only:
        self.findNext()
    else:
        self.findAll()
#@-node:ekr.20031218072017.3060:findAllButton
#@+node:ekr.20031218072017.3059:findButton
# The user has pushed the "Find" button from the find panel.

def findButton(self):

    self.setup_button()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
#@-node:ekr.20031218072017.3059:findButton
#@+node:ekr.20031218072017.3065:setup_button
# Initializes a search when a button is pressed in the Find panel.

def setup_button(self):

    c = self.c
    self.p = c.currentPosition()

    c.bringToFront()
    if 0: # We _must_ retain the editing status for incremental searches!
        c.endEditing()

    self.update_ivars()
#@-node:ekr.20031218072017.3065:setup_button
#@-node:ekr.20060123065756.1:Top Level Buttons
#@+node:ekr.20031218072017.3055:Top Level Commands
#@+node:ekr.20031218072017.3061:changeCommand
# The user has selected the "Replace" menu item.

def changeCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
    else:
        self.change()
#@-node:ekr.20031218072017.3061:changeCommand
#@+node:ekr.20031218072017.3062:changeThenFindCommand
# The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
        self.doFindScript()
    else:
        self.changeThenFind()
#@-node:ekr.20031218072017.3062:changeThenFindCommand
#@+node:ekr.20051013084200.1:dismiss: defined in subclass class
def dismiss (self):
    pass
#@-node:ekr.20051013084200.1:dismiss: defined in subclass class
#@+node:ekr.20031218072017.3063:findNextCommand
# The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
#@-node:ekr.20031218072017.3063:findNextCommand
#@+node:ekr.20031218072017.3064:findPreviousCommand
# The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

    self.setup_command()

    self.reverse = not self.reverse

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()

    self.reverse = not self.reverse
#@-node:ekr.20031218072017.3064:findPreviousCommand
#@+node:EKR.20040503070514:handleUserClick
def handleUserClick (self,p):

    """Reset suboutline-only search when the user clicks a headline."""

    try:
        if self.c and self.suboutline_only:
            # g.trace(p)
            self.onlyPosition = p.copy()
    except: pass
#@-node:EKR.20040503070514:handleUserClick
#@+node:ekr.20031218072017.3066:setup_command
# Initializes a search when a command is invoked from the menu.

def setup_command(self):

    # g.trace('leoFind')

    if 0: # We _must_ retain the editing status for incremental searches!
        self.c.endEditing()

    self.update_ivars()
#@-node:ekr.20031218072017.3066:setup_command
#@-node:ekr.20031218072017.3055:Top Level Commands
#@+node:ekr.20031218072017.3067:Find/change utils
#@+node:ekr.20031218072017.2293:batchChange (sets start of change-all group)
@ This routine performs a single batch change operation, updating the head or body string of p and leaving the result in s_ctrl.  We update the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; w = self.s_ctrl
    # Replace the selection with self.change_text
    if pos1 > pos2: pos1,pos2=pos2,pos1
    s = w.getAllText()
    if pos1 != pos2: w.delete(pos1,pos2)
    w.insert(pos1,self.change_text)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+len(self.change_text))
    w.setSelectionRange(insert,insert)
    w.setInsertPoint(insert)
    # Update the node
    s = w.getAllText() # Used below.
    if self.in_headline:
        << change headline >>
    else:
        << change body >>
#@+node:ekr.20031218072017.2294:<< change headline >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.headString():

    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Headline',undoData)
#@-node:ekr.20031218072017.2294:<< change headline >>
#@+node:ekr.20031218072017.2295:<< change body >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.bodyString():

    undoData = u.beforeChangeNodeContents(p)

    c.setBodyString(p,s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Body',undoData)
#@-node:ekr.20031218072017.2295:<< change body >>
#@-node:ekr.20031218072017.2293:batchChange (sets start of change-all group)
#@+node:ekr.20031218072017.3068:change
def change(self,event=None):

    if self.checkArgs():
        self.initInHeadline()
        self.changeSelection()
#@-node:ekr.20031218072017.3068:change
#@+node:ekr.20031218072017.3069:changeAll (sets end of change-all group)
def changeAll(self):

    # g.trace(g.callers())

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.currentPosition()
    w = self.s_ctrl
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        while 1:
            pos1, pos2 = self.findNextMatch()
            if pos1 is None: break
            count += 1
            self.batchChange(pos1,pos2)
            s = w.getAllText()
            i,j = g.getLine(s,pos1)
            line = s[i:j]
            self.printLine(line,allFlag=True)
        p = c.currentPosition()
        u.afterChangeGroup(p,undoType,reportFlag=True)
        g.es("changed: %d instances" % (count))
    finally:
        c.endUpdate()
        self.restore(saveData)
#@-node:ekr.20031218072017.3069:changeAll (sets end of change-all group)
#@+node:ekr.20031218072017.3070:changeSelection
# Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    oldSel = sel = w.getSelectionRange()
    start,end = sel
    if start > end: start,end = end,start
    if start == end:
        g.es("No text selected") ; return False

    # g.trace(start,end)

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text

    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)

    for w2 in (w,self.s_ctrl):
        if start != end: w2.delete(start,end)
        w2.insert(start,change_text)
        w2.setInsertPoint(g.choose(self.reverse,start,start+len(change_text)))

    # Update the selection for the next match.
    w.setSelectionRange(start,start+len(change_text))
    c.widgetWantsFocus(w)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
        if self.mark_changes:
            p.setMarked()
        if self.in_headline:
            c.frame.tree.onHeadChanged(p,'Change')
        else:
            c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.

    return True
#@+node:ekr.20060526201951:makeRegexSubs
def makeRegexSubs(self,s,groups):

    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''

    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j < n:
        k = s.find('\\',j)
        if k == -1 or k + 1 >= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn < len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
#@-node:ekr.20060526201951:makeRegexSubs
#@-node:ekr.20031218072017.3070:changeSelection
#@+node:ekr.20031218072017.3071:changeThenFind
def changeThenFind(self):

    if not self.checkArgs():
        return

    self.initInHeadline()
    if self.changeSelection():
        self.findNext(False) # don't reinitialize
#@-node:ekr.20031218072017.3071:changeThenFind
#@+node:ekr.20031218072017.2417:doChange...Script
def doChangeScript (self):

    g.app.searchDict["type"] = "change"
    self.runChangeScript()

def doChangeAllScript (self):

    """The user has just pressed the Change All button with script-change box checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "changeAll"
    while 1:
        self.runChangeScript()
        if not g.app.searchDict.get("continue"):
            break

def runChangeScript (self):

    try:
        assert(self.script_change)
        exec self.change_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing change script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
#@-node:ekr.20031218072017.2417:doChange...Script
#@+node:ekr.20031218072017.3072:doFind...Script
def doFindScript (self):

    g.app.searchDict["type"] = "find"
    self.runFindScript()

def doFindAllScript (self):

    """The user has just pressed the Find All button with script-find radio button checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "findAll"
    while 1:
        self.runFindScript()
        if not g.app.searchDict.get("continue"):
            break

def runFindScript (self):

    try:
        exec self.find_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing find script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
#@-node:ekr.20031218072017.3072:doFind...Script
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                << create the found node and begin the undo group >>
            clones.append(self.p.v.t)
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        c.setRootPosition(c.findRootPosition(found)) # New in 4.4.2.
        u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)

    c.redraw_now()
    g.es("found: %d matches" % (count))
    self.restore(data)
#@+node:ekr.20051113110735:<< create the found node and begin the undo group >>
u.beforeChangeGroup(c.currentPosition(),undoType)

undoData = u.beforeInsertNode(c.currentPosition())

oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)

u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110735:<< create the found node and begin the undo group >>
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
undoData = u.beforeCloneNode(self.p)
q = self.p.clone()
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20031218072017.3074:findNext
def findNext(self,initFlag=True):

    c = self.c
    if not self.checkArgs():
        return

    if initFlag:
        self.initInHeadline()
        data = self.save()
        self.initInteractiveCommands()
    else:
        data = self.save()

    pos, newpos = self.findNextMatch()

    if pos is not None:
        self.showSuccess(pos,newpos)
    else:
        if self.wrapping:
            g.es("end of wrapped search")
        else:
            g.es("not found: " + "'" + self.find_text + "'")
        self.restore(data)
#@-node:ekr.20031218072017.3074:findNext
#@+node:ekr.20031218072017.3075:findNextMatch
# Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not self.search_headline and not self.search_body:
        return None, None

    if len(self.find_text) == 0:
        return None, None

    p = self.p ; self.errors = 0
    while p:
        pos, newpos = self.search()
        # g.trace('pos',pos,'p',p.headString(),g.callers())
        if pos is not None:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            return None,None # Abort the search.
        elif self.node_only:
            return None,None # We are only searching one node.
        else:
            p = self.p = self.selectNextPosition()
    return None, None
#@-node:ekr.20031218072017.3075:findNextMatch
#@+node:ekr.20031218072017.3076:resetWrap
def resetWrap (self,event=None):

    self.wrapPosition = None
    self.onlyPosition = None
#@-node:ekr.20031218072017.3076:resetWrap
#@+node:ekr.20031218072017.3077:search & helpers
def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.

    Returns (pos, newpos) or (None,None)."""

    c = self.c ; p = self.p ; w = self.s_ctrl
    index = w.getInsertPoint()

    s = w.getAllText()
    # g.trace(index,repr(s[index:index+20]))
    stopindex = g.choose(self.reverse,0,len(s)) # 'end' doesn't work here.
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)
    # g.trace('pos,newpos',pos,newpos)
    if pos == -1: return None,None
    << fail if we are passed the wrap point >>
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    w.setSelectionRange(pos,newpos,insert=insert)
    return pos,newpos
#@+node:ekr.20060526140328:<< fail if we are passed the wrap point >>
if self.wrapping and self.wrapPos is not None and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and pos < self.wrapPos:
        # g.trace("wrap done")
        return None, None

    if not self.reverse and newpos > self.wrapPos:
        return None, None
#@-node:ekr.20060526140328:<< fail if we are passed the wrap point >>
#@+node:ekr.20060526081931:searchHelper & allies
def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):

    if swapij and backwards: i,j = j,i

    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # g.trace('empty',i,j)
        return -1,-1

    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    return pos,newpos
#@+node:ekr.20060526092203:regexHelper
def regexHelper (self,s,i,j,pattern,backwards,nocase):

    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1

    if backwards: # Scan to the last match.  We must use search here.
        last_mo = None ; i = 0
        while i < len(s):
            mo = re_obj.search(s,i,j)
            if not mo: break
            i += 1 ; last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s,i,j)

    if 0:
        g.trace('i',i,'j',j,'s[i:j]',repr(s[i:j]),
            'mo.start',mo and mo.start(),'mo.end',mo and mo.end())

    while mo and 0 <= i < len(s):
        if mo.start() == mo.end():
            if backwards:
                # Search backward using match instead of search.
                i -= 1
                while 0 <= i < len(s):
                    mo = re_obj.match(s,i,j)
                    if mo: break
                    i -= 1
            else:
                i += 1 ; mo = re_obj.search(s,i,j)
        else:
            self.match_obj = mo
            return mo.start(),mo.end()
    self.match_obj = None
    return -1,-1
#@-node:ekr.20060526092203:regexHelper
#@+node:ekr.20060526140744:backwardsHelper
def backwardsHelper (self,s,i,j,pattern,nocase,word):

    if nocase:
        s = s.lower() ; pattern.lower()
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)

    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            # g.trace(i,j,k)
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        # g.trace(i,j,k)
        if k == -1:
            return -1, -1
        else:
            return k,k+n
#@-node:ekr.20060526140744:backwardsHelper
#@+node:ekr.20060526093531:plainHelper
@tabwidth 4

def plainHelper (self,s,i,j,pattern,nocase,word):

    # g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
	pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n
#@-node:ekr.20060526093531:plainHelper
#@+node:ekr.20060526140744.1:matchWord
def matchWord(self,s,i,pattern):

    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 <= i-1 < len(s) and s[i-1] or '.'
    ch2 = 0 <= i+n < len(s) and s[i+n] or '.'

    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)

    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))

    if isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2:
        return False
    else:
        return True
#@-node:ekr.20060526140744.1:matchWord
#@+node:ekr.20070105165924:replaceBackSlashes
def replaceBackSlashes (self,s):

    '''Carefully replace backslashes in a search pattern.'''

    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.

    i = 0
    while i + 1 < len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                 s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1
    return s
#@-node:ekr.20070105165924:replaceBackSlashes
#@-node:ekr.20060526081931:searchHelper & allies
#@-node:ekr.20031218072017.3077:search & helpers
#@+node:ekr.20031218072017.3081:selectNextPosition
# Selects the next node to be searched.

def selectNextPosition(self):

    c = self.c ; p = self.p

    if self.selection_only:
        return None

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace('switching to body',g.callers(5))
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()

    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        # g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p
#@-node:ekr.20031218072017.3081:selectNextPosition
#@-node:ekr.20031218072017.3067:Find/change utils
#@+node:ekr.20061212095134.1:General utils
#@+node:ekr.20051020120306.26:bringToFront (leoFind)
def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; w = self.find_ctrl

    # g.trace(g.callers())
    c.widgetWantsFocusNow(w)
    g.app.gui.selectAllText(w)
    c.widgetWantsFocus(w)
#@-node:ekr.20051020120306.26:bringToFront (leoFind)
#@+node:ekr.20061111084423.1:oops (leoFind)
def oops(self):
    print ("leoFind oops:",
        g.callers(10),"should be overridden in subclass")
#@-node:ekr.20061111084423.1:oops (leoFind)
#@+node:ekr.20051020120306.27:selectAllFindText (leoFind)
def selectAllFindText (self,event=None):

    __pychecker__ = '--no-argsused' # event

    # This is called only when the user presses ctrl-a in the find panel.

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        w.selectAllText()

    return "break"
#@-node:ekr.20051020120306.27:selectAllFindText (leoFind)
#@-node:ekr.20061212095134.1:General utils
#@+node:ekr.20031218072017.3082:Initing & finalizing
#@+node:ekr.20031218072017.3083:checkArgs
def checkArgs (self):

    val = True
    if not self.search_headline and not self.search_body:
        g.es("not searching headline or body")
        val = False
    if len(self.find_text) == 0:
        g.es("empty find patttern")
        val = False
    return val
#@-node:ekr.20031218072017.3083:checkArgs
#@+node:ekr.20051020120306.28:init_s_ctrl
def init_s_ctrl (self,s):

    w = self.s_ctrl
    w.setAllText(s)
    i = g.choose(self.reverse,len(s),0)
    w.setInsertPoint(i)
    return w
#@-node:ekr.20051020120306.28:init_s_ctrl
#@+node:ekr.20031218072017.3084:initBatchCommands
# Initializes for the Find All and Change All commands.

def initBatchCommands (self):

    c = self.c ; w = c.frame.body.bodyCtrl
    self.in_headline = self.search_headline # Search headlines first.
    self.errors = 0

    # Select the first node.
    if self.suboutline_only or self.node_only or self.selection_only:
        self.p = c.currentPosition()
        if self.selection_only: self.selStart,self.selEnd = w.getSelectionRange()
        else:                   self.selStart,self.selEnd = None,None
    else:
        p = c.rootPosition()
        if self.reverse:
            while p and p.next():
                p = p.next()
            p = p.lastNode()
        self.p = p

    # Set the insert point.
    self.initBatchText()
#@-node:ekr.20031218072017.3084:initBatchCommands
#@+node:ekr.20031218072017.3085:initBatchText & initNextText
# Returns s_ctrl with "insert" point set properly for batch searches.
def initBatchText(self):
    p = self.p
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    return self.init_s_ctrl(s)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self):
    p = self.p
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    return self.init_s_ctrl(s)
#@-node:ekr.20031218072017.3085:initBatchText & initNextText
#@+node:ekr.20031218072017.3086:initInHeadline
# Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

    c = self.c ; p = self.p

    # Do not change this without careful thought and extensive testing!
    if self.search_headline and self.search_body:
        # A temporary expedient.
        if self.reverse:
            self.in_headline = False
        else:
            # Search headline first.
            self.in_headline = (
                p == c.frame.tree.editPosition() and
                c.get_focus() != c.frame.body.bodyCtrl)
    else:
        self.in_headline = self.search_headline
#@-node:ekr.20031218072017.3086:initInHeadline
#@+node:ekr.20031218072017.3087:initInteractiveCommands
# For incremental searches

def initInteractiveCommands(self):

    c = self.c ; p = self.p

    self.errors = 0
    if self.in_headline:
        c.frame.tree.setEditPosition(p)
        w = c.edit_widget(p)
        sel = None
    else:
        w = c.frame.bodyCtrl
        sel = w.getSelectionRange()
    pos = w.getInsertPoint()
    st = self.initNextText()
    c.widgetWantsFocus(w)
    st.setInsertPoint(pos)
    if sel:
        self.selStart,self.selEnd = sel
    else:
        self.selStart,self.selEnd = None,None
    self.wrapping = self.wrap
    if self.wrap and self.wrapPosition == None:
        self.wrapPos = pos
        # Do not set self.wrapPosition here: that must be done after the first search.
#@-node:ekr.20031218072017.3087:initInteractiveCommands
#@+node:ekr.20031218072017.3088:printLine
def printLine (self,line,allFlag=False):

    both = self.search_body and self.search_headline
    context = self.batch # "batch" now indicates context

    if allFlag and both and context:
        g.es('-' * 20,self.p.headString())
        theType = g.choose(self.in_headline,"head: ","body: ")
        g.es(theType + line)
    elif allFlag and context and not self.p.isVisited():
        # We only need to print the context once.
        g.es('-' * 20,self.p.headString())
        g.es(line)
        self.p.setVisited()
    else:
        g.es(line)
#@-node:ekr.20031218072017.3088:printLine
#@+node:ekr.20031218072017.3089:restore
# Restores the screen after a search fails

def restore (self,data):

    c = self.c
    in_headline,p,t,insert,start,end = data

    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)

    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        t.setSelectionRange(insert,insert)
        t.setInsertPoint(insert)
        t.seeInsertPoint()

    #g.trace(c.widget_name(t))

    if 1: # I prefer always putting the focus in the body.
        c.invalidateFocus()
        c.bodyWantsFocusNow()
    else:
        c.widgetWantsFocusNow(t)
#@-node:ekr.20031218072017.3089:restore
#@+node:ekr.20031218072017.3090:save
def save (self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    insert = w.getInsertPoint()
    sel = w.getSelectionRange()
    if len(sel) == 2:
        start,end = sel
    else:
        start,end = None,None
    return (self.in_headline,p,w,insert,start,end)
#@-node:ekr.20031218072017.3090:save
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible()
    c.beginUpdate()
    try:
        if sparseFind:
            # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
            for p in c.allNodes_iter():
                if not p.isAncestorOf(self.p):
                    p.contract()
                    redraw = True
            for p in self.p.parents_iter():
                if not p.isExpanded():
                    p.expand()
                    redraw = True
        p = self.p
        c.selectPosition(p)
    finally:
        c.endUpdate(redraw)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    c.widgetWantsFocusNow(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@+node:ekr.20031218072017.1460:update_ivars (leoFind)
# New in Leo 4.4.3: This is now gui-independent code.

def update_ivars (self):

    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        # g.trace(self.svarDict.get(key))
        val = self.svarDict[key].get()
        setattr(self, key, val) # No more _flag hack.

    # Set ivars from radio buttons. Convert these to 1 or 0.
    search_scope = self.svarDict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0)

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.getAllText()
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.getAllText()
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@-node:ekr.20031218072017.1460:update_ivars (leoFind)
#@-node:ekr.20031218072017.3082:Initing & finalizing
#@-node:ekr.20061212084717:class leoFind
#@+node:ekr.20051020120306.6:class findTab (leoFind)
class findTab (leoFind):

    '''An adapter class that implements Leo's Find tab.'''

    @others
#@+node:ekr.20051020120306.11:findTab.__init__
def __init__(self,c,parentFrame):

    # g.trace('findTab',c)

    # Init the base class...
    leoFind.__init__(self,c,title='Find Tab')

    self.c = c
    self.parentFrame = parentFrame
    self.frame = self.outerFrame = self.top = None

    self.optionsOnly = c.config.getBool('show_only_find_tab_options')

    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.initGui()
    self.createFrame(parentFrame)
    self.createBindings()
    self.init(c) # New in 4.3: init only once.
#@-node:ekr.20051020120306.11:findTab.__init__
#@+node:ekr.20061212092124:Must be defined in subclasses
def createBindings (self):
    self.oops()

def createFrame (self,parent):
    __pychecker__ = '--no-argsused'
    self.oops()

def getOption (self,ivar):
    self.oops()

def init (self,c):
    self.oops()

def initGui (self):
    pass # Optional method.

def setOption (self,ivar,val):
    __pychecker__ = '--no-argsused'
    self.oops()

def toggleOption (self,ivar):
    self.oops()

# self.oops is defined in the leoFind class.
#@-node:ekr.20061212092124:Must be defined in subclasses
#@+node:ekr.20060221074900:Callbacks
#@+node:ekr.20060221074900.1:findButtonCallback
def findButtonCallback(self,event=None):

    self.findButton()
    return 'break'
#@-node:ekr.20060221074900.1:findButtonCallback
#@+node:ekr.20051020120306.25:hideTab
def hideTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@-node:ekr.20051020120306.25:hideTab
#@-node:ekr.20060221074900:Callbacks
#@+node:ekr.20051024192602: Top level
#@+node:ekr.20051024192642.3:change/ThenFindCommand
def changeCommand (self,event=None):

    self.setup_command()
    self.change()

def changeThenFindCommand(self,event=None):

    self.setup_command()
    self.changeThenFind()
#@-node:ekr.20051024192642.3:change/ThenFindCommand
#@+node:ekr.20070105123638:changeAllCommand
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
#@-node:ekr.20070105123638:changeAllCommand
#@+node:ekr.20060128075225:cloneFindAllCommand
def cloneFindAllCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
#@-node:ekr.20060128075225:cloneFindAllCommand
#@+node:ekr.20060204120158.1:findAgainCommand
def findAgainCommand (self):

    s = self.find_ctrl.getAllText()

    if s and s != '<find pattern here>':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
#@-node:ekr.20060204120158.1:findAgainCommand
#@+node:ekr.20060209064832:findAllCommand
def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()
#@-node:ekr.20060209064832:findAllCommand
#@+node:ekr.20051024192642.2:findNext/PrefCommand
def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()

def findPrevCommand (self,event=None):

    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
#@-node:ekr.20051024192642.2:findNext/PrefCommand
#@-node:ekr.20051024192602: Top level
#@-node:ekr.20051020120306.6:class findTab (leoFind)
#@+node:ekr.20070302090616:class nullFindTab class (findTab)
class nullFindTab (findTab):

    @others
#@nonl
#@+node:ekr.20070302090616.1:Birth (nullFindTab)
#@+node:ekr.20070302090616.2: ctor (nullFindTab)
if 0: # Use the base-class ctor.

    def __init__ (self,c,parentFrame):

        findTab.__init__(self,c,parentFrame)
            # Init the base class.
            # Calls initGui, createFrame, createBindings & init(c), in that order.
#@-node:ekr.20070302090616.2: ctor (nullFindTab)
#@+node:ekr.20070302090616.3:initGui
# Called from findTab.ctor.

def initGui (self):

    self.svarDict = {} # Keys are ivar names, values are svar objects.

    for key in self.intKeys:
        self.svarDict[key] = self.svar() # Was Tk.IntVar.

    for key in self.newStringKeys:
        self.svarDict[key] = self.svar() # Was Tk.StringVar.
#@-node:ekr.20070302090616.3:initGui
#@+node:ekr.20070302090616.4:init
# Called from findTab.ctor.

def init (self,c):

    # Separate c.ivars are much more convenient than a svarDict.
    for key in self.intKeys:
        # Get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0)
        svar = self.svarDict.get(key)
        if svar: svar.set(val)
        #g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
    << set checkboxes from ivars >>
#@+node:ekr.20070302090616.5:<< set find/change widgets >>
self.find_ctrl.delete(0,"end")
self.change_ctrl.delete(0,"end")

# Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@-node:ekr.20070302090616.5:<< set find/change widgets >>
#@+node:ekr.20070302090616.6:<< set radio buttons from ivars >>
# In Tk, setting the var also sets the widget.
# Here, we do so explicitly.
d = self.widgetsDict
for ivar,key in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-find-type"].set(key)
        w = d.get(key)
        if w: w.set(True)
        break
else:
    self.svarDict["radio-find-type"].set("plain-search")

for ivar,key in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-search-scope"].set(key)
        break
else:
    key = 'entire-outline'
    self.svarDict["radio-search-scope"].set(key)
    w = self.widgetsDict.get(key)
    if w: w.set(True)
#@-node:ekr.20070302090616.6:<< set radio buttons from ivars >>
#@+node:ekr.20070302090616.7:<< set checkboxes from ivars >>
for ivar in (
    'ignore_case',
    'mark_changes',
    'mark_finds',
    'pattern_match',
    'reverse',
    'search_body',
    'search_headline',
    'whole_word',
    'wrap',
):
    svar = self.svarDict[ivar].get()
    if svar:
        w = self.widgetsDict.get(ivar)
        if w: w.set(True)
#@-node:ekr.20070302090616.7:<< set checkboxes from ivars >>
#@-node:ekr.20070302090616.4:init
#@+node:ekr.20070302090616.15:createBindings
def createBindings (self):
    pass
#@nonl
#@-node:ekr.20070302090616.15:createBindings
#@+node:ekr.20070302090616.9:createFrame
def createFrame (self,parentFrame):

    self.parentFrame = self.top = parentFrame

    self.createFindChangeAreas()
    self.createBoxes()
#@nonl
#@+node:ekr.20070302090616.10:createFindChangeAreas
def createFindChangeAreas (self):

    c = self.c

    # A plainTextWidget must be a stringTextWidget
    plainTextWidget = g.app.gui.plainTextWidget

    import leoFrame
    assert issubclass(plainTextWidget,leoFrame.stringTextWidget)

    self.find_ctrl   = plainTextWidget(c,name='find-text')
    self.change_ctrl = plainTextWidget(c,name='change-text')
#@-node:ekr.20070302090616.10:createFindChangeAreas
#@+node:ekr.20070302090616.12:createBoxes
def createBoxes (self):

    '''Create two columns of radio buttons & check boxes.'''

    c = self.c
    # f = self.parentFrame
    self.boxes = []
    self.widgetsDict = {} # Keys are ivars, values are checkboxes or radio buttons.

    data = ( # Leading star denotes a radio button.
        ('Whole &Word', 'whole_word',),
        ('&Ignore Case','ignore_case'),
        ('Wrap &Around','wrap'),
        ('&Reverse',    'reverse'),
        ('Rege&xp',     'pattern_match'),
        ('Mark &Finds', 'mark_finds'),
        ("*&Entire Outline","entire-outline"),
        ("*&Suboutline Only","suboutline-only"),  
        ("*&Node Only","node-only"),
        ('Search &Headline','search_headline'),
        ('Search &Body','search_body'),
        ('Mark &Changes','mark_changes'),
    )

    # Important: changing these controls merely changes entries in self.svarDict.
    # First, leoFind.update_ivars sets the find ivars from self.svarDict.
    # Second, self.init sets the values of widgets from the ivars.
    # inGroup = False
    for label,ivar in data:
        if label.startswith('*'):
            label = label[1:]
            # style = g.choose(inGroup,0,wx.RB_GROUP)
            # inGroup = True
            # w = wx.RadioButton(f,label=label,style=style)
            w = self.buttonWidget(label)
            self.widgetsDict[ivar] = w
            # def radioButtonCallback(event=None,ivar=ivar):
                # svar = self.svarDict["radio-search-scope"]
                # svar.set(ivar)
            # w.Bind(wx.EVT_RADIOBUTTON,radioButtonCallback)
        else:
            #w = wx.CheckBox(f,label=label)
            w = self.buttonWidget(label)
            self.widgetsDict[ivar] = w
            # def checkBoxCallback(event=None,ivar=ivar):
                # svar = self.svarDict.get(ivar)
                # val = svar.get()
                # svar.set(g.choose(val,False,True))
                # # g.trace(ivar,val)
            # w.Bind(wx.EVT_CHECKBOX,checkBoxCallback)
        self.boxes.append(w)
#@nonl
#@-node:ekr.20070302090616.12:createBoxes
#@+node:ekr.20070302090616.14:createButtons (not used)
def createButtons (self):

    '''Create two columns of buttons.'''

    # # Create the alignment panes.
    # buttons  = Tk.Frame(outer,background=bg)
    # buttons1 = Tk.Frame(buttons,bd=1,background=bg)
    # buttons2 = Tk.Frame(buttons,bd=1,background=bg)
    # buttons.pack(side='top',expand=1)
    # buttons1.pack(side='left')
    # buttons2.pack(side='right')

    # width = 15 ; defaultText = 'Find' ; buttons = []

    # for text,boxKind,frame,callback in (
        # # Column 1...
        # ('Find','button',buttons1,self.findButtonCallback),
        # ('Find All','button',buttons1,self.findAllButton),
        # # Column 2...
        # ('Change','button',buttons2,self.changeButton),
        # ('Change, Then Find','button',buttons2,self.changeThenFindButton),
        # ('Change All','button',buttons2,self.changeAllButton),
    # ):
        # w = underlinedTkButton(boxKind,frame,
            # text=text,command=callback)
        # buttons.append(w)
        # if text == defaultText:
            # w.button.configure(width=width-1,bd=4)
        # elif boxKind != 'check':
            # w.button.configure(width=width)
        # w.button.pack(side='top',anchor='w',pady=2,padx=2)
#@-node:ekr.20070302090616.14:createButtons (not used)
#@-node:ekr.20070302090616.9:createFrame
#@-node:ekr.20070302090616.1:Birth (nullFindTab)
#@+node:ekr.20070302090616.8:class svar (nullFindTab)
class svar:
    '''A class like Tk's IntVar and StringVar classes.'''
    def __init__(self):
        self.val = None
    def get (self):
        return self.val
    def set (self,val):
        self.val = val

    SetValue = set # SetValue is the wxWidgets spelling.
#@nonl
#@-node:ekr.20070302090616.8:class svar (nullFindTab)
#@+node:ekr.20070302092907:class buttonWidget (nullFindTab)
class buttonWidget:

    '''A class to simulate a Tk.Button.'''

    def __init__ (self,label):
        self.label = label
        self.val = False

    def __repr (self):
        return 'nullFindTab.buttonWidget: %s' % self.label

    def get (self):
        return self.val

    def set (self,val):
        self.val = val
#@-node:ekr.20070302092907:class buttonWidget (nullFindTab)
#@+node:ekr.20070302090616.16:Options
# This is the same as the Tk code because we simulate Tk svars.
#@nonl
#@+node:ekr.20070302090616.17:getOption
def getOption (self,ivar):

    var = self.svarDict.get(ivar)

    if var:
        val = var.get()
        # g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
#@-node:ekr.20070302090616.17:getOption
#@+node:ekr.20070302090616.18:setOption
def setOption (self,ivar,val):

    if ivar in self.intKeys:
        if val is not None:
            var = self.svarDict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
#@-node:ekr.20070302090616.18:setOption
#@+node:ekr.20070302090616.19:toggleOption
def toggleOption (self,ivar):

    if ivar in self.intKeys:
        var = self.svarDict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
#@-node:ekr.20070302090616.19:toggleOption
#@-node:ekr.20070302090616.16:Options
#@-node:ekr.20070302090616:class nullFindTab class (findTab)
#@-node:ekr.20060123151617:@thin leoFind.py
#@+node:ekr.20031218072017.3655:@thin leoFrame.py
"""The base classes for all Leo Windows, their body, log and tree panes, key bindings and menus.

These classes should be overridden to create frames for a particular gui."""

@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import leoColor
import leoMenu
import leoNodes
import leoUndo

import re

<< About handling events >>
<< define text classes >>

@others
#@+node:ekr.20031218072017.2410:<< About handling events >>
@
Leo must handle events or commands that change the text in the outline or body
panes. We must ensure that headline and body text corresponds to the vnode and
tnode corresponding to presently selected outline, and vice versa. For example,
when the user selects a new headline in the outline pane, we must ensure that:

1) All vnodes and tnodes have up-to-date information and

2) the body pane is loaded with the correct data.

Early versions of Leo attempted to satisfy these conditions when the user
switched outline nodes. Such attempts never worked well; there were too many
special cases. Later versions of Leo use a much more direct approach: every
keystroke in the body pane updates the presently selected tnode immediately.

The leoTree class contains all the event handlers for the tree pane, and the
leoBody class contains the event handlers for the body pane. The following
convenience methods exists:

- body.updateBody & tree.updateBody:
    Called by k.masterCommand after any keystroke not handled by k.masterCommand.
    These are suprising complex.

- body.bodyChanged & tree.headChanged:
    Called by commands throughout Leo's core that change the body or headline.
    These are thin wrappers for updateBody and updateTree.
#@-node:ekr.20031218072017.2410:<< About handling events >>
#@+node:ekr.20070228074228:<< define text classes >>
@others
#@nonl
#@+node:ekr.20070228074312:class baseTextWidget
# Subclassing from wx.EvtHandler allows methods of this and derived class to be event handlers.

class baseTextWidget:

    '''The base class for all wrapper classes for leo Text widgets.'''

    @others
#@+node:ekr.20070228074312.1:Birth & special methods (baseText)
def __init__ (self,c,baseClassName,name,widget):

    self.baseClassName = baseClassName
    self.c = c
    self.name = name
    self.virtualInsertPoint = None
    self.widget = widget # Not used at present.

def __repr__(self):
    return '%s: %s' % (self.baseClassName,id(self))

#@-node:ekr.20070228074312.1:Birth & special methods (baseText)
#@+node:ekr.20070228074312.2:baseTextWidget.onChar
# Don't even think of using key up/down events.
# They don't work reliably and don't support auto-repeat.

def onChar (self, event):

    c = self.c
    keycode = event.GetKeyCode()
    event.leoWidget = self
    keysym = g.app.gui.eventKeysym(event)
    #g.trace('text: keycode %3s keysym %s' % (keycode,keysym))
    if keysym:
        c.k.masterKeyHandler(event,stroke=keysym)
#@nonl
#@-node:ekr.20070228074312.2:baseTextWidget.onChar
#@+node:ekr.20070228074312.3:Do-nothing
def update (self,*args,**keys):             pass
def update_idletasks (self,*args,**keys):   pass
#@-node:ekr.20070228074312.3:Do-nothing
#@+node:ekr.20070228074312.4:bindings (must be overridden in subclasses)
# def _appendText(self,s):            self.oops()
# def _get(self,i,j):                 self.oops()
# def _getAllText(self):              self.oops()
# def _getFocus(self):                self.oops()
# def _getInsertPoint(self):          self.oops()
# def _getLastPosition(self):         self.oops()
# def _getSelectedText(self):         self.oops()
# def _getSelectionRange(self):       self.oops()
# def _hitTest(self,pos):             self.oops()
# def _insertText(self,i,s):          self.oops()
# def _scrollLines(self,n):           self.oops()
# def _see(self,i):                   self.oops()
# def _setAllText(self,s):            self.oops()
# def _setBackgroundColor(self,color): self.oops()
# def _setFocus(self):                self.oops()
# def _setInsertPoint(self,i):        self.oops()
# def _setSelectionRange(self,i,j):   self.oops()

# _findFocus = _getFocus
#@-node:ekr.20070228074312.4:bindings (must be overridden in subclasses)
#@+node:ekr.20070228074312.5:oops
def oops (self):

    print('wxGui baseTextWidget oops:',self,g.callers(),
        'must be overridden in subclass')
#@-node:ekr.20070228074312.5:oops
#@+node:ekr.20070228074312.6:Index conversion
#@+node:ekr.20070228074312.7:w.toGuiIndex & toPythonIndex
def toPythonIndex (self,index):

    w = self

    if type(index) == type(99):
        return index
    elif index == '1.0':
        return 0
    elif index == 'end':
        return w._getLastPosition()
    else:
        # g.trace(repr(index))
        s = w._getAllText()
        row,col = index.split('.')
        row,col = int(row),int(col)
        i = g.convertRowColToPythonIndex(s,row-1,col)
        # g.trace(index,row,col,i,g.callers(6))
        return i

toGuiIndex = toPythonIndex
#@nonl
#@-node:ekr.20070228074312.7:w.toGuiIndex & toPythonIndex
#@+node:ekr.20070228074312.8:w.rowColToGuiIndex
# This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):

    return g.convertRowColToPythonIndex(s,row,col)    
#@-node:ekr.20070228074312.8:w.rowColToGuiIndex
#@-node:ekr.20070228074312.6:Index conversion
#@+node:ekr.20070228074312.9:Wrapper methods (widget-independent)
# These methods are widget-independent because they call the corresponding _xxx methods.
#@nonl
#@+node:ekr.20070228074312.10:appendText
def appendText (self,s):

    w = self
    w._appendText(s)
#@-node:ekr.20070228074312.10:appendText
#@+node:ekr.20070228074312.11:bind
def bind (self,kind,*args,**keys):

    w = self

    pass # g.trace('wxLeoText',kind,args[0].__name__)
#@nonl
#@-node:ekr.20070228074312.11:bind
#@+node:ekr.20070228074312.12:clipboard_clear & clipboard_append
def clipboard_clear (self):

    g.app.gui.replaceClipboardWith('')

def clipboard_append(self,s):

    s1 = g.app.gui.getTextFromClipboard()

    g.app.gui.replaceClipboardWith(s1 + s)
#@-node:ekr.20070228074312.12:clipboard_clear & clipboard_append
#@+node:ekr.20070228074312.13:delete
def delete(self,i,j=None):

    w = self
    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    # g.trace(i,j,len(s),repr(s[:20]))
    s = w.getAllText()
    w.setAllText(s[:i] + s[j:])
#@-node:ekr.20070228074312.13:delete
#@+node:ekr.20070228074312.14:deleteTextSelection
def deleteTextSelection (self):

    w = self
    i,j = w._getSelectionRange()
    if i == j: return

    s = w._getAllText()
    s = s[i:] + s[j:]

    # g.trace(len(s),repr(s[:20]))
    w._setAllText(s)
#@-node:ekr.20070228074312.14:deleteTextSelection
#@+node:ekr.20070228074312.15:event_generate (baseTextWidget)
def event_generate(self,stroke):

    w = self ; c = self.c ; char = stroke

    # Canonicalize the setting.
    stroke = c.k.shortcutFromSetting(stroke)

    # g.trace('baseTextWidget','char',char,'stroke',stroke)

    class eventGenerateEvent:
        def __init__ (self,c,w,char,keysym):
            self.c = c
            self.char = char
            self.keysym = keysym
            self.leoWidget = w
            self.widget = w

    event = eventGenerateEvent(c,w,char,stroke)
    c.k.masterKeyHandler(event,stroke=stroke)
#@-node:ekr.20070228074312.15:event_generate (baseTextWidget)
#@+node:ekr.20070228074312.16:flashCharacter (to do)
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75): # tkTextWidget.

    w = self

    return ###

    def addFlashCallback(w,count,index):
        # g.trace(count,index)
        i,j = w.toPythonIndex(index),w.toPythonIndex(index+1)
        Tk.Text.tag_add(w,'flash',i,j)
        Tk.Text.after(w,delay,removeFlashCallback,w,count-1,index)

    def removeFlashCallback(w,count,index):
        # g.trace(count,index)
        Tk.Text.tag_remove(w,'flash','1.0','end')
        if count > 0:
            Tk.Text.after(w,delay,addFlashCallback,w,count,index)

    try:
        Tk.Text.tag_configure(w,'flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass ; g.es_exception()
#@nonl
#@-node:ekr.20070228074312.16:flashCharacter (to do)
#@+node:ekr.20070228074312.17:getFocus (baseText)
def getFocus (self):

    w = self
    w2 = w._getFocus()
    # g.trace('w',w,'focus',w2)
    return w2

findFocus = getFocus
#@-node:ekr.20070228074312.17:getFocus (baseText)
#@+node:ekr.20070228074312.18:get
def get(self,i,j=None):

    w = self

    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    s = w._get(i,j)
    return g.toUnicode(s,g.app.tkEncoding)
#@-node:ekr.20070228074312.18:get
#@+node:ekr.20070228074312.19:getAllText
def getAllText (self):

    w = self

    s = w._getAllText()
    return g.toUnicode(s,g.app.tkEncoding)
#@-node:ekr.20070228074312.19:getAllText
#@+node:ekr.20070228074312.20:getInsertPoint (baseText)
def getInsertPoint(self):

    w = self
    i = w._getInsertPoint()

    # g.trace(self,'baseWidget: i:',i,'virtual',w.virtualInsertPoint)

    if i is None:
        if w.virtualInsertPoint is None:
            i = 0
        else:
            i = w.virtualInsertPoint

    w.virtualInsertPoint = i

    return i
#@-node:ekr.20070228074312.20:getInsertPoint (baseText)
#@+node:ekr.20070228102413:getName & GetName
def GetName(self):
    return self.name

getName = GetName
#@nonl
#@-node:ekr.20070228102413:getName & GetName
#@+node:ekr.20070228074312.21:getSelectedText
def getSelectedText (self):

    w = self
    s = w._getSelectedText()
    return g.toUnicode(s,g.app.tkEncoding)
#@-node:ekr.20070228074312.21:getSelectedText
#@+node:ekr.20070228074312.22:getSelectionRange (baseText)
def getSelectionRange (self,sort=True):

    """Return a tuple representing the selected range of the widget.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self

    sel = w._getSelectionRange() # wx.richtext.RichTextCtrl returns (-1,-1) on no selection.
    if len(sel) == 2 and sel[0] >= 0 and sel[1] >= 0:
        #g.trace(self,'baseWidget: sel',repr(sel),g.callers(6))
        i,j = sel
        if sort and i > j: i,j = j,i
        return sel
    else:
        # Return the insertion point if there is no selected text.
        i =  w._getInsertPoint()
        #g.trace(self,'baseWidget: i',i,g.callers(6))
        return i,i
#@-node:ekr.20070228074312.22:getSelectionRange (baseText)
#@+node:ekr.20070228074312.23:getYScrollPosition
def getYScrollPosition (self):

     w = self
     return w._getYScrollPosition()
#@-node:ekr.20070228074312.23:getYScrollPosition
#@+node:ekr.20070228074312.24:getWidth
def getWidth (self):

    '''Return the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    return 0
#@-node:ekr.20070228074312.24:getWidth
#@+node:ekr.20070228074312.25:hasSelection
def hasSelection (self):

    w = self
    i,j = w.getSelectionRange()
    return i != j
#@-node:ekr.20070228074312.25:hasSelection
#@+node:ekr.20070228074312.26:insert
# The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toPythonIndex(i)
    # w._setInsertPoint(i)
    w._insertText(i,s)
#@-node:ekr.20070228074312.26:insert
#@+node:ekr.20070228074312.27:indexIsVisible
def indexIsVisible (self,i):

    return False # Code will loop if this returns True forever.
#@nonl
#@-node:ekr.20070228074312.27:indexIsVisible
#@+node:ekr.20070228074312.28:replace
def replace (self,i,j,s):

    w = self
    w.delete(i,j)
    w.insert(i,s)
#@-node:ekr.20070228074312.28:replace
#@+node:ekr.20070228074312.29:scrollLines
def scrollLines (self,n):

    w = self
    w._scrollLines(n)
#@nonl
#@-node:ekr.20070228074312.29:scrollLines
#@+node:ekr.20070228074312.30:see & seeInsertPoint
def see(self,index):

    w = self
    i = self.toPythonIndex(index)
    w._see(i)

def seeInsertPoint(self):

    w = self
    i = w._getInsertPoint()
    w._see(i)
#@-node:ekr.20070228074312.30:see & seeInsertPoint
#@+node:ekr.20070228074312.31:selectAllText
def selectAllText (self,insert=None):

    '''Select all text of the widget.'''

    w = self
    w.setSelectionRange(0,'end',insert=insert)
#@-node:ekr.20070228074312.31:selectAllText
#@+node:ekr.20070228074312.32:setAllText
def setAllText (self,s):

    w = self
    w._setAllText(s)
#@nonl
#@-node:ekr.20070228074312.32:setAllText
#@+node:ekr.20070228074312.33:setBackgroundColor & SetBackgroundColour
def setBackgroundColor (self,color):

    w = self

    # Translate tk colors to wx colors.
    d = { 'lightgrey': 'light grey', 'lightblue': 'leo blue',}

    color = d.get(color,color)

    return w._setBackgroundColor(color)

SetBackgroundColour = setBackgroundColor
#@nonl
#@-node:ekr.20070228074312.33:setBackgroundColor & SetBackgroundColour
#@+node:ekr.20070228074312.34:setFocus (baseText)
def setFocus (self):

    w = self
    # g.trace('baseText')
    return w._setFocus()

SetFocus = setFocus
#@-node:ekr.20070228074312.34:setFocus (baseText)
#@+node:ekr.20070228074312.35:setInsertPoint (baseText)
def setInsertPoint (self,pos):

    w = self
    w.virtualInsertPoint = i = w.toPythonIndex(pos)
    # g.trace(self,i)
    w._setInsertPoint(i)
#@-node:ekr.20070228074312.35:setInsertPoint (baseText)
#@+node:ekr.20070228074312.36:setSelectionRange (baseText)
def setSelectionRange (self,i,j,insert=None):

    w = self
    i1, j1, insert1 = i,j,insert
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)

    # g.trace(self,'baseWidget',repr(i1),'=',repr(i),repr(j1),'=',repr(j),repr(insert1),'=',repr(insert),g.callers(4))

    if i == j:
        w._setInsertPoint(j)
    else:
        w._setSelectionRange(i,j)

    if insert is not None and insert in (i,j):
        ins = w.toPythonIndex(insert)
        if ins in (i,j):
            self.virtualInsertPoint = ins
#@-node:ekr.20070228074312.36:setSelectionRange (baseText)
#@+node:ekr.20070228074312.37:setWidth
def setWidth (self,width):

    '''Set the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    pass
#@-node:ekr.20070228074312.37:setWidth
#@+node:ekr.20070228074312.38:setYScrollPosition
def setYScrollPosition (self,i):

     w = self
     w._setYScrollPosition(i)
#@nonl
#@-node:ekr.20070228074312.38:setYScrollPosition
#@+node:ekr.20070228074312.39:tags (to-do)
#@+node:ekr.20070228074312.40:mark_set (to be removed)
def mark_set(self,markName,i):

    w = self
    i = self.toPythonIndex(i)

    ### Tk.Text.mark_set(w,markName,i)
#@-node:ekr.20070228074312.40:mark_set (to be removed)
#@+node:ekr.20070228074312.41:tag_add
# The signature is slightly different than the Tk.Text.insert method.

def tag_add(self,tagName,i,j=None,*args):

    w = self
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)

    return ###

    if not hasattr(w,'leo_styles'):
        w.leo_styles = {}

    style = w.leo_styles.get(tagName)

    if style is not None:
        # g.trace(i,j,tagName)
        w.textBaseClass.SetStyle(w,i,j,style)
#@nonl
#@-node:ekr.20070228074312.41:tag_add
#@+node:ekr.20070228074312.42:tag_configure & helper
def tag_configure (self,colorName,**keys):
    pass

tag_config = tag_configure
#@nonl
#@+node:ekr.20070228074312.43:tkColorToWxColor
def tkColorToWxColor (self, color):

    d = {
        'black':        wx.BLACK,
        "red":          wx.RED,
        "blue":         wx.BLUE,
        "#00aa00":      wx.GREEN,
        "firebrick3":   wx.RED,
        'white':        wx.WHITE,
    }

    return d.get(color)
#@nonl
#@-node:ekr.20070228074312.43:tkColorToWxColor
#@-node:ekr.20070228074312.42:tag_configure & helper
#@+node:ekr.20070228074312.44:tag_delete (NEW)
def tag_delete (self,tagName,*args,**keys):

    pass # g.trace(tagName,args,keys)
#@nonl
#@-node:ekr.20070228074312.44:tag_delete (NEW)
#@+node:ekr.20070228074312.45:tag_names
def tag_names (self, *args):

    return []
#@-node:ekr.20070228074312.45:tag_names
#@+node:ekr.20070228074312.46:tag_ranges
def tag_ranges(self,tagName):

    return tuple() ###

    w = self
    aList = Tk.Text.tag_ranges(w,tagName)
    aList = [w.toPythonIndex(z) for z in aList]
    return tuple(aList)
#@-node:ekr.20070228074312.46:tag_ranges
#@+node:ekr.20070228074312.47:tag_remove
def tag_remove(self,tagName,i,j=None,*args):

    w = self
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)

    return ### Not ready yet.

    if not hasattr(w,'leo_styles'):
        w.leo_styles = {}

    style = w.leo_styles.get(tagName)

    if style is not None:
        # g.trace(i,j,tagName)
        w.textBaseClass.SetStyle(w,i,j,style)
#@nonl
#@-node:ekr.20070228074312.47:tag_remove
#@+node:ekr.20070228074312.48:yview
def yview (self,*args):

    '''w.yview('moveto',y) or w.yview()'''

    return 0,0
#@nonl
#@-node:ekr.20070228074312.48:yview
#@-node:ekr.20070228074312.39:tags (to-do)
#@+node:ekr.20070228074312.49:xyToGui/PythonIndex
def xyToPythonIndex (self,x,y):
    return 0
#@-node:ekr.20070228074312.49:xyToGui/PythonIndex
#@-node:ekr.20070228074312.9:Wrapper methods (widget-independent)
#@-node:ekr.20070228074312:class baseTextWidget
#@+node:ekr.20070228074228.1:class stringTextWidget (stringTextWidget)
class stringTextWidget (baseTextWidget):

    '''A class that represents text as a Python string.'''

    @others
#@+node:ekr.20070228074228.2:ctor
def __init__ (self,c,name):

    # Init the base class
    baseTextWidget.__init__ (self,c=c,
        baseClassName='stringTextWidget',name=name,widget=None)

    self.ins = 0
    self.sel = 0,0
    self.s = ''
    self.trace = False
#@-node:ekr.20070228074228.2:ctor
#@+node:ekr.20070228074228.3:Overrides
def _appendText(self,s):
    #if self.trace: g.trace(self,'len(s)',len(s))
    if self.trace: g.trace(self,'ins',self.ins,'s',repr(s[-10:]),g.callers())
    self.s = self.s + s
    self.ins = len(self.s)
    self.sel = self.ins,self.ins
def _get(self,i,j):                 return self.s[i:j]
def _getAllText(self):              return self.s
def _getFocus(self):                return self
def _getInsertPoint(self):
    # if self.trace: g.trace(self,self.ins)
    return self.ins
def _getLastPosition(self):         return len(self.s)
def _getSelectedText(self):         i,j = self.sel ; return self.s[i:j]
def _getSelectionRange(self):       return self.sel
def _getYScrollPosition(self):      return None # A flag.
def _hitTest(self,pos):             pass
def _insertText(self,i,s):
    s1 = s
    self.s = self.s[:i] + s1 + self.s[i:]
    # if self.trace: g.trace(self,'s',repr(s),'self.s',repr(self.s))
    # if self.trace: g.trace(self,'i',i,'len(s)',len(s),g.callers())
    if self.trace: g.trace(self,'i',i,'s',repr(s[-10:]),g.callers())
    i += len(s1)
    self.ins = i
    self.sel = i,i
def _scrollLines(self,n):           pass
def _see(self,i):                   pass
def _setAllText(self,s):
    # if self.trace: g.trace(self,'len(s)',len(s),g.callers())
    if self.trace: g.trace(self,'s',repr(s[-10:]),g.callers())
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i,i
def _setBackgroundColor(self,color): pass
def _setFocus(self):                pass
def _setInsertPoint(self,i):
    if self.trace: g.trace(self,'i',i)
    self.ins = i
    self.sel = i,i
#@nonl
#@-node:ekr.20070228074228.3:Overrides
#@+node:ekr.20070228111853:setSelectionRange (stringText)
def setSelectionRange (self,i,j,insert=None):

    w = self
    i1, j1, insert1 = i,j,insert
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)

    self.sel = i,j

    if insert is not None: 
        self.ins = w.toPythonIndex(insert)
    else:
        self.ins = j

    if self.trace: g.trace('i',i,'j',j,'insert',repr(insert))
#@nonl
#@-node:ekr.20070228111853:setSelectionRange (stringText)
#@-node:ekr.20070228074228.1:class stringTextWidget (stringTextWidget)
#@-node:ekr.20070228074228:<< define text classes >>
#@+node:ekr.20031218072017.3656:class leoBody
class leoBody:

    """The base class for the body pane in Leo windows."""

    __pychecker__ = '--no-argsused' # base classes have many unused args.

    @others
#@+node:ekr.20031218072017.3657:leoBody.__init__
def __init__ (self,frame,parentFrame):

    self.frame = frame
    self.c = c = frame.c
    self.editorWidgets = {} # keys are pane names, values are text widgets
    self.forceFullRecolorFlag = False
    frame.body = self

    # May be overridden in subclasses...
    self.bodyCtrl = self.widget = None ### self
    self.numberOfEditors = 1
    self.pb = None # paned body widget.

    self.use_chapters = c.config.getBool('use_chapters')

    # Must be overridden in subclasses...
    self.colorizer = None
#@+node:ekr.20031218072017.3660:leoBody.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Birth, death & config.
    '__init__',
    'createBindings',
    'createControl',
    'setColorFromConfig',
    'setFontFromConfig'
    # Editors
    'createEditorLabel',
    'setEditorColors',
    # Events...
    'scheduleIdleTimeRoutine',
    # Low-level gui...(May be deleted)
    'getBodyPaneHeight',
    'getBodyPaneWidth',
    'hasFocus',
    'setFocus',
    # 'tag_add',
    # 'tag_bind',
    # 'tag_configure',
    # 'tag_delete',
    # 'tag_remove',
)
#@-node:ekr.20031218072017.3660:leoBody.mustBeDefinedInSubclasses
#@+node:ekr.20061109102912:define leoBody.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    'getAllText',
    'getColorizer',
    'getInsertLines',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionAreas',
    'getSelectionLines',
    'getYScrollPosition',
    'hasTextSelection',
    'oops',
    'onBodyChanged',
    'onClick',
    'recolor',
    'recolor_now',
    'recolor_range',
    'see',
    'seeInsertPoint',
    'selectAllText',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
    'setSelectionAreas',
    'setYScrollPosition',
    'updateSyntaxColorer',
    # Editors... (These may be overridden)
    # 'addEditor',
    # 'cycleEditorFocus',
    # 'deleteEditor',
    # 'selectEditor',
    # 'selectLabel',
    # 'unselectLabel',
    # 'updateEditors',
)
#@-node:ekr.20061109102912:define leoBody.mustBeDefinedOnlyInBaseClass
#@-node:ekr.20031218072017.3657:leoBody.__init__
#@+node:ekr.20061109173122:leoBody: must be defined in subclasses
# Birth, death & config
def createBindings (self,w=None):               self.oops()
def createControl (self,frame,parentFrame,p):   self.oops()
def setColorFromConfig (self,w=None):           self.oops()
def setFontFromConfig (self,w=None):            self.oops()
# Editor
def createEditorLabel (self,pane):              self.oops()
def setEditorColors (self,bg,fg):               self.oops()
# Events...
def scheduleIdleTimeRoutine (self,function,*args,**keys): self.oops()
#@-node:ekr.20061109173122:leoBody: must be defined in subclasses
#@+node:ekr.20061109173021:leoBody: must be defined in the base class
#@+node:ekr.20031218072017.3677:Coloring
def getColorizer(self):

    return self.colorizer

def recolor_now(self,p,incremental=False):

    self.colorizer.colorize(p.copy(),incremental)

def recolor_range(self,p,leading,trailing):

    self.colorizer.recolor_range(p.copy(),leading,trailing)

def recolor(self,p,incremental=False):

    if 0: # Do immediately
        self.colorizer.colorize(p.copy(),incremental)
    else: # Do at idle time
        self.colorizer.schedule(p.copy(),incremental)

def updateSyntaxColorer(self,p):

    return self.colorizer.updateSyntaxColorer(p.copy())
#@-node:ekr.20031218072017.3677:Coloring
#@+node:ekr.20060528100747:Editors (leoBody)
@ Notes:
- body.bodyCtrl and body.frame.bodyCtrl must always be the same.

- This code uses self.pb, a paned body widget, created by tkBody.finishCreate.


#@+node:ekr.20070424053629:entries
#@+node:ekr.20060528100747.1:addEditor
def addEditor (self,event=None):

    '''Add another editor to the body pane.'''

    c = self.c ; p = c.currentPosition()

    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1

    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        w_old = self.editorWidgets.get('1')
        self.updateInjectedIvars(w_old,p)
        self.selectLabel(w_old) # Immediately create the label in the old editor.

    name = '%d' % self.totalNumberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))

    f = self.createEditorFrame(pane)
    << create text widget w >>
    self.editorWidgets[name] = w

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)

    self.pb.updatelayout()
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.updateInjectedIvars(w,p)
    self.selectLabel(w)
    self.selectEditor(w)
    self.updateEditors()
    c.bodyWantsFocusNow()
#@+node:ekr.20060528110922:<< create text widget w >>
w = self.createTextWidget(self.frame,f,name=name,p=p)
w.delete(0,'end')
w.insert('end',p.bodyString())
w.see(0)

self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

self.recolorWidget(w)
#@-node:ekr.20060528110922:<< create text widget w >>
#@-node:ekr.20060528100747.1:addEditor
#@+node:ekr.20060528170438:cycleEditorFocus
def cycleEditorFocus (self,event=None):

    '''Cycle keyboard focus between the body text editors.'''

    c = self.c ; d = self.editorWidgets ; w = self.bodyCtrl
    values = d.values()
    if len(values) > 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.selectEditor(w2)
        self.bodyCtrl = self.frame.bodyCtrl = w2
        # print '***',g.app.gui.widget_name(w2),id(w2)

    return 'break'
#@-node:ekr.20060528170438:cycleEditorFocus
#@+node:ekr.20060528113806:deleteEditor
def deleteEditor (self,event=None):

    '''Delete the presently selected body text editor.'''

    w = self.bodyCtrl ; d = self.editorWidgets

    if len(d.keys()) == 1: return

    name = w.leo_name

    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)

    # Select another editor.
    w = d.values()[0]
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.numberOfEditors -= 1
    self.selectEditor(w)
#@-node:ekr.20060528113806:deleteEditor
#@+node:ekr.20070425180705:findEditorForChapter (leoBody)
def findEditorForChapter (self,chapter,p):

    '''Return an editor to be assigned to chapter.'''

    d = self.editorWidgets ; values = d.values()

    # First, try to match both the chapter and position.
    if p:
        for w in values:
            if (
                hasattr(w,'leo_chapter') and w.leo_chapter == chapter and
                hasattr(w,'leo_p') and w.leo_p and w.leo_p.equal(p)):
                # g.trace('***',id(w),'match chapter and p',p.headString())
                return w

    # Next, try to match just the chapter.
    for w in values:
        if hasattr(w,'leo_chapter') and w.leo_chapter == chapter:
            # g.trace('***',id(w),'match only chapter',p.headString())
            return w

    # As a last resort, return the present editor widget.
    # g.trace('***',id(self.bodyCtrl),'no match',p.headString())
    return self.bodyCtrl
#@-node:ekr.20070425180705:findEditorForChapter (leoBody)
#@+node:ekr.20060530210057:select/unselectLabel
def unselectLabel (self,w):

    self.createChapterIvar(w)
    self.packEditorLabelWidget(w)
    s = self.computeLabel(w)
    w.leo_label.configure(text=s,bg='LightSteelBlue1')

def selectLabel (self,w):

    if self.numberOfEditors > 1:
        self.createChapterIvar(w)
        self.packEditorLabelWidget(w)
        s = self.computeLabel(w)
        # g.trace(s,g.callers())
        w.leo_label.configure(text=s,bg='white')
    elif w.leo_label:
        w.leo_label.pack_forget()
        w.leo_label = None
#@nonl
#@-node:ekr.20060530210057:select/unselectLabel
#@+node:ekr.20061017083312:selectEditor & helpers
selectEditorLockout = False

def selectEditor(self,w):

    '''Select editor w and node w.leo_p.'''

    #  Called by body.onClick and whenever w must be selected.

    if self.selectEditorLockout or w and self.bodyCtrl == w: return

    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(w)
    finally:
        self.selectEditorLockout = False

    return val # Don't put a return in a finally clause.

#@+node:ekr.20070423102603:selectEditorHelper
def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    if 0:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    self.inactivateActiveEditor(w)

    # The actual switch.
    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return 'break'

    if 0:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    c.frame.tree.expandAllAncestors(w.leo_p)
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls assignPositionToEditor.
    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocusNow()
    return 'break'
#@nonl
#@+node:ekr.20061017083312.1:<< restore the selection, insertion point and the scrollbar >>
# g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)

if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
#@-node:ekr.20061017083312.1:<< restore the selection, insertion point and the scrollbar >>
#@-node:ekr.20070423102603:selectEditorHelper
#@-node:ekr.20061017083312:selectEditor & helpers
#@+node:ekr.20060528132829:assignPositionToEditor
def assignPositionToEditor (self,p):

    '''Called *only* from tree.select to select the present body editor.'''

    c = self.c ; cc = c.chapterController ; w = self.bodyCtrl

    self.updateInjectedIvars(w,p)
    self.selectLabel(w)

    # g.trace('===',id(w),w.leo_chapter.name,w.leo_p.headString())
#@-node:ekr.20060528132829:assignPositionToEditor
#@+node:ekr.20060528131618:updateEditors
# Called from addEditor and assignPositionToEditor

def updateEditors (self):

    c = self.c ; p = c.currentPosition()
    d = self.editorWidgets
    if len(d.keys()) < 2: return # There is only the main widget.

    for key in d.keys():
        w = d.get(key)
        v = w.leo_v
        if v and v == p.v and w != self.bodyCtrl:
            w.delete(0,'end')
            w.insert('end',p.bodyString())
            # g.trace('update',w,v)
            self.recolorWidget(w)
    c.bodyWantsFocus()
#@-node:ekr.20060528131618:updateEditors
#@-node:ekr.20070424053629:entries
#@+node:ekr.20070424053629.1:utils
#@+node:ekr.20070422093128:computeLabel
def computeLabel (self,w):

    s = w.leo_label_s

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        s = '%s: %s' % (w.leo_chapter.name,s)

    return s
#@-node:ekr.20070422093128:computeLabel
#@+node:ekr.20070422094710:createChapterIvar
def createChapterIvar (self,w):

    c = self.c ; cc = c.chapterController

    if not hasattr(w,'leo_chapter') or not w.leo_chapter:
        if cc and self.use_chapters: ### c.config.getBool('use_chapters'):
            w.leo_chapter = cc.getSelectedChapter()
        else:
            w.leo_chapter = None
#@-node:ekr.20070422094710:createChapterIvar
#@+node:ekr.20070424084651:ensurePositionExists
def ensurePositionExists(self,w):

    '''Return True if w.leo_p exists or can be reconstituted.'''

    c = self.c

    if c.positionExists(w.leo_p):
        return True
    else:
        g.trace('***** does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v and p2.v == w.leo_v:
                w.leo_p = p2.copy()
                return True
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            return False
#@-node:ekr.20070424084651:ensurePositionExists
#@+node:ekr.20070424080640:inactivateActiveEditor
def inactivateActiveEditor(self,w):

    '''Inactivate all the previously active editor.'''

    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d.keys():
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            # g.trace('inactivate',id(w2))
            break
    else:
        if trace: g.trace('no active editor!')
#@nonl
#@-node:ekr.20070424080640:inactivateActiveEditor
#@+node:ekr.20060530204135:recolorWidget
def recolorWidget (self,w):

    c = self.c ; old_w = self.bodyCtrl

    # g.trace(id(w),c.currentPosition().headString())

    # Save.
    self.bodyCtrl = self.frame.bodyCtrl = w

    c.recolor_now(interruptable=False) # Force a complete recoloring.

    # Restore.
    self.bodyCtrl = self.frame.bodyCtrl = old_w
#@nonl
#@-node:ekr.20060530204135:recolorWidget
#@+node:ekr.20070424084012:switchToChapter (leoBody)
def switchToChapter (self,w):

    '''select w.leo_chapter.'''

    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            # g.trace('===','old',oldChapter.name,'new',name,w.leo_p)
            cc.selectChapterByName(name)
            c.bodyWantsFocusNow()
#@-node:ekr.20070424084012:switchToChapter (leoBody)
#@+node:ekr.20070424092855:updateInjectedIvars
# Called from addEditor and assignPositionToEditor.

def updateInjectedIvars (self,w,p):

    c = self.c ; cc = c.chapterController ; 

    if cc and self.use_chapters: ### c.config.getBool('use_chapters'):
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None

    w.leo_p = p.copy()
    w.leo_v = w.leo_p.v
    w.leo_label_s = p.headString()

    # g.trace('   ===', id(w),w.leo_chapter and w.leo_chapter.name,p.headString())
#@-node:ekr.20070424092855:updateInjectedIvars
#@-node:ekr.20070424053629.1:utils
#@-node:ekr.20060528100747:Editors (leoBody)
#@+node:ekr.20031218072017.1329:onBodyChanged (leoBody)
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):

    '''Update Leo after the body has been changed.'''

    body = self ; c = self.c
    bodyCtrl = w = body.bodyCtrl
    p = c.currentPosition()
    insert = w.getInsertPoint()
    ch = g.choose(insert==0,'',w.get(insert-1))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = w.getAllText() # Note: getAllText converts to unicode.
    # g.trace('newText',repr(newText),g.callers())
    newSel = w.getSelectionRange()
    if not oldText:
        oldText = p.bodyString() ; changed = True
    else:
        changed = oldText != newText
    # g.trace(repr(ch),'changed:',changed,'newText:',repr(newText))
    if not changed: return
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertPoint()
    << recolor the body >>
    if not c.changed: c.setChanged(True)
    self.updateEditors()
    << redraw the screen if necessary >>
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True

    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    # g.trace('new val:',val,'old val:',hasattr(p.v,'iconVal') and p.v.iconVal or '<None>')
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1329:onBodyChanged (leoBody)
#@+node:ekr.20061109095450.8:onClick
def onClick (self,event):

    c = self.c ; k = c.k ; w = event and event.widget
    wname = c.widget_name(w)

    if wname.startswith('body'):
        # A hack to support middle-button pastes: remember the previous selection.
        k.previousSelection = w.getSelectionRange()
        x,y = g.app.gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        # g.trace(x,y,repr(i))
        w.setSelectionRange(i,i,insert=i)
        c.editCommands.setMoveCol(w,i)
        c.frame.updateStatusLine()
        self.selectEditor(w)
    else:
        g.trace('can not happen')
#@-node:ekr.20061109095450.8:onClick
#@+node:ekr.20031218072017.3658:oops
def oops (self):

    g.trace("leoBody oops:", g.callers(), "should be overridden in subclass")
#@-node:ekr.20031218072017.3658:oops
#@+node:ekr.20031218072017.4018:Text (leoBody)
#@+node:ekr.20031218072017.4030:getInsertLines
def getInsertLines (self):

    """Return before,after where:

    before is all the lines before the line containing the insert point.
    sel is the line containing the insert point.
    after is all the lines after the line containing the insert point.

    All lines end in a newline, except possibly the last line."""

    w = self.bodyCtrl
    s = w.getAllText()
    insert = w.getInsertPoint()
    i,j = g.getLine(s,insert)
    before = s[0:i]
    ins = s[i:j]
    after = s[j:]

    before = g.toUnicode(before,g.app.tkEncoding)
    ins    = g.toUnicode(ins,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)

    return before,ins,after
#@-node:ekr.20031218072017.4030:getInsertLines
#@+node:ekr.20031218072017.4031:getSelectionAreas
def getSelectionAreas (self):

    """Return before,sel,after where:

    before is the text before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is the text after the selected text
    (or the text after the insert point if no selection)"""

    w = self.bodyCtrl
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if i == j: j = i + 1

    before = s[0:i]
    sel    = s[i:j]
    after  = s[j:]

    before = g.toUnicode(before,g.app.tkEncoding)
    sel    = g.toUnicode(sel,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)
    return before,sel,after
#@nonl
#@-node:ekr.20031218072017.4031:getSelectionAreas
#@+node:ekr.20031218072017.2377:getSelectionLines
def getSelectionLines (self):

    """Return before,sel,after where:

    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)"""

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return '','',''

    # At present, called only by c.getBodyLines.
    w = self.bodyCtrl
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if i == j:
        i,j = g.getLine(s,i)
    else:
        i,junk = g.getLine(s,i)
        junk,j = g.getLine(s,j)


    before = g.toUnicode(s[0:i],g.app.tkEncoding)
    sel    = g.toUnicode(s[i:j],g.app.tkEncoding)
    after  = g.toUnicode(s[j:len(s)],g.app.tkEncoding)

    # g.trace(i,j,'sel',repr(s[i:j]),'after',repr(after))
    return before,sel,after # 3 strings.
#@-node:ekr.20031218072017.2377:getSelectionLines
#@+node:ekr.20031218072017.4037:setSelectionAreas
def setSelectionAreas (self,before,sel,after):

    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    w = self.bodyCtrl
    s = w.getAllText()
    before = before or ''
    sel = sel or ''
    after = after or ''
    w.delete(0,len(s))
    w.insert(0,before+sel+after)
    i = len(before)
    j = max(i,len(before)+len(sel)-1)
    # g.trace(i,j,repr(sel))
    w.setSelectionRange(i,j,insert=j)
    return i,j
#@-node:ekr.20031218072017.4037:setSelectionAreas
#@+node:ekr.20031218072017.4038:get/setYScrollPosition
def getYScrollPosition (self):
    return self.bodyCtrl.getYScrollPosition()

def setYScrollPosition (self,scrollPosition):
    if len(scrollPosition) == 2:
        first,last = scrollPosition
    else:
        first = scrollPosition
    self.bodyCtrl.setYScrollPosition(first)
#@-node:ekr.20031218072017.4038:get/setYScrollPosition
#@-node:ekr.20031218072017.4018:Text (leoBody)
#@+node:ekr.20070228080627:Text Wrappers (base class)
def getAllText (self):                  return self.bodyCtrl.getAllText()
def getInsertPoint(self):               return self.bodyCtrl.getInsertPoint()
def getSelectedText (self):             return self.bodyCtrl.getSelectedText()
def getSelectionRange (self,sort=True): return self.bodyCtrl.getSelectionRange(sort)
def hasTextSelection (self):            return self.bodyCtrl.hasSelection()
# def scrollDown (self):                g.app.gui.yscroll(self.bodyCtrl,1,'units')
# def scrollUp (self):                  g.app.gui.yscroll(self.bodyCtrl,-1,'units')
def see (self,index):                   self.bodyCtrl.see(index)
def seeInsertPoint (self):              self.bodyCtrl.seeInsertPoint()
def selectAllText (self,event=None): # This is a command.
    w = g.app.gui.eventWidget(event) or self.bodyCtrl
    return w.selectAllText()
def setInsertPoint (self,pos):          return self.bodyCtrl.setInsertPoint(pos) # was getInsertPoint.
def setSelectionRange (self,sel):       i,j = sel ; self.bodyCtrl.setSelectionRange(i,j)
#@-node:ekr.20070228080627:Text Wrappers (base class)
#@-node:ekr.20061109173021:leoBody: must be defined in the base class
#@-node:ekr.20031218072017.3656:class leoBody
#@+node:ekr.20031218072017.3678:class leoFrame
class leoFrame:

    """The base class for all Leo windows."""

    __pychecker__ = '--no-argsused' # base classes have many unused args.

    instances = 0

    @others
#@+node:ekr.20031218072017.3679:  leoFrame.__init__
def __init__ (self,gui):

    self.c = None # Must be created by subclasses.
    self.title = None # Must be created by subclasses.
    self.gui = gui

    # Objects attached to this frame.
    self.colorPanel = None 
    self.comparePanel = None
    self.findPanel = None
    self.fontPanel = None
    self.iconBar = None
    self.isNullFrame = False
    self.keys = None
    self.menu = None
    self.miniBufferWidget = None # New in 4.4.
    self.prefsPanel = None
    self.statusLine = None
    self.useMiniBufferWidget = False # New in 4.4

    # Gui-independent data
    self.componentsDict = {} # Keys are names, values are componentClass instances.
    self.es_newlines = 0 # newline count for this log stream
    self.openDirectory = ""
    self.requestRecolorFlag = False
    self.saved=False # True if ever saved
    self.splitVerticalFlag,self.ratio, self.secondary_ratio = True,0.5,0.5 # Set by initialRatios later.
    self.startupWindow=False # True if initially opened window
    self.stylesheet = None # The contents of <?xml-stylesheet...?> line.
    self.tab_width = 0 # The tab width in effect in this pane.

#@+node:ekr.20061109120726:leoFrame.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (

    'initialRatios',
    'longFileName',
    'oops',
    'promptForSave',
    'scanForTabWidth',
    'shortFileName',

    # Headline editing.
    'abortEditLabelCommand',
    'endEditLabelCommand',
    'insertHeadlineTime',

    # Cut/Copy/Paste.
    'OnPaste',
    'OnPasteFromMenu',
    'copyText',
    'cutText',
    'pasteText',

    # Icon bar convenience methods.    
    'addIconButton',
    'clearIconBar',
    'createIconBar',
    'getIconBar',
    'getIconBarObject',
    'hideIconBar',

    # Status line convenience methods.
    'createStatusLine',
    'clearStatusLine',
    'disableStatusLine',
    'enableStatusLine',
    'getStatusLine',
    'getStatusObject',
    'putStatusLine',
    'setFocusStatusLine',
    'statusLineIsEnabled',
    'updateStatusLine',
)
#@nonl
#@-node:ekr.20061109120726:leoFrame.mustBeDefinedOnlyInBaseClass
#@+node:ekr.20061109120704:leoFrame.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    #Gui-dependent commands.
    'cascade',
    'contractBodyPane',
    'contractLogPane',
    'contractOutlinePane',
    'contractPane',
    'equalSizedPanes',
    'expandLogPane',
    'expandPane',
    'fullyExpandBodyPane',
    'fullyExpandLogPane',
    'fullyExpandOutlinePane',
    'fullyExpandPane',
    'hideBodyPane',
    'hideLogPane',
    'hideLogWindow',
    'hideOutlinePane',
    'hidePane',
    'leoHelp',
    'minimizeAll',
    'resizeToScreen',
    'toggleActivePane',
    'toggleSplitDirection',
    # Windowutilities...
    'bringToFront',
    'deiconify',
    'get_window_info',
    'lift',
    'update',
    # Config...
    'resizePanesToRatio',
    'setInitialWindowGeometry',
    'setTopGeometry',
)
#@nonl
#@-node:ekr.20061109120704:leoFrame.mustBeDefinedInSubclasses
#@-node:ekr.20031218072017.3679:  leoFrame.__init__
#@+node:ekr.20061109125528.1:Must be defined in base class
#@+node:ekr.20031218072017.3689:initialRatios
def initialRatios (self):

    c = self.c

    s = c.config.get("initial_splitter_orientation","string")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = c.config.getRatio("initial_vertical_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.5
        r2 = c.config.getRatio("initial_vertical_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial_horizontal_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.3
        r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8

    # g.trace(r,r2)
    return verticalFlag,r,r2
#@-node:ekr.20031218072017.3689:initialRatios
#@+node:ekr.20031218072017.3690:longFileName & shortFileName
def longFileName (self):

    return self.c.mFileName

def shortFileName (self):

    return g.shortFileName(self.c.mFileName)
#@-node:ekr.20031218072017.3690:longFileName & shortFileName
#@+node:ekr.20031218072017.3691:oops
def oops(self):

    print "leoFrame oops:", g.callers(3), "should be overridden in subclass"
#@-node:ekr.20031218072017.3691:oops
#@+node:ekr.20031218072017.3692:promptForSave
def promptForSave (self):

    """Prompt the user to save changes.

    Return True if the user vetos the quit or save operation."""

    c = self.c
    name = g.choose(c.mFileName,c.mFileName,self.title)
    theType = g.choose(g.app.quitting, "quitting?", "closing?")

    answer = g.app.gui.runAskYesNoCancelDialog(c,
        "Confirm",
        'Save changes to %s before %s' % (name,theType))

    # print answer
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            << Put up a file save dialog to set mFileName >>
        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.
#@+node:ekr.20031218072017.3693:<< Put up a file save dialog to set mFileName >>
# Make sure we never pass None to the ctor.
if not c.mFileName:
    c.mFileName = ""

c.mFileName = g.app.gui.runSaveFileDialog(
    initialfile = c.mFileName,
    title="Save",
    filetypes=[("Leo files", "*.leo")],
    defaultextension=".leo")
c.bringToFront()
#@-node:ekr.20031218072017.3693:<< Put up a file save dialog to set mFileName >>
#@-node:ekr.20031218072017.3692:promptForSave
#@+node:ekr.20031218072017.1375:scanForTabWidth
# Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << set w and break on @tabwidth >>

    c.frame.setTabWidth(w)
#@+node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
if theDict.has_key("tabwidth"):

    val = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break
#@-node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
#@-node:ekr.20031218072017.1375:scanForTabWidth
#@+node:ekr.20061119120006:Icon area convenience methods
def addIconButton (self,*args,**keys):
    return self.iconBar and self.iconBar.add(*args,**keys)

def clearIconBar (self):
    self.iconBar and self.iconBar.clear()

def createIconBar (self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar

def getIconBar(self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar

getIconBarObject = getIconBar

def hideIconBar (self):
    self.iconBar and self.iconBar.hide()
#@nonl
#@-node:ekr.20061119120006:Icon area convenience methods
#@+node:ekr.20041223105114.1:Status line convenience methods
def createStatusLine (self):
    if not self.statusLine:
        self.statusLine  = self.statusLineClass(self.c,self.outerFrame)
    return self.statusLine

def clearStatusLine (self):
    self.statusLine and self.statusLine.clear()

def disableStatusLine (self,background=None):
    self.statusLine and self.statusLine.disable(background)

def enableStatusLine (self,background="white"):
    self.statusLine and self.statusLine.enable(background)

def getStatusLine (self):
    return self.statusLine

getStatusObject = getStatusLine

def putStatusLine (self,s,color=None):
    self.statusLine and self.statusLine.put(s,color)

def setFocusStatusLine (self):
    self.statusLine and self.statusLine.setFocus()

def statusLineIsEnabled(self):
    return self.statusLine and self.statusLine.isEnabled()

def updateStatusLine(self):
    self.statusLine and self.statusLine.update()
#@nonl
#@-node:ekr.20041223105114.1:Status line convenience methods
#@+node:ekr.20070130115927.4:Cut/Copy/Paste (leoFrame)
#@+node:ekr.20070130115927.5:copyText
def copyText (self,event=None):

    '''Copy the selected text from the widget to the clipboard.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = w.getSelectionRange()
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)

OnCopyFromMenu = copyText
#@-node:ekr.20070130115927.5:copyText
#@+node:ekr.20070130115927.6:leoFrame.cutText
def cutText (self,event=None):

    '''Invoked from the mini-buffer and from shortcuts.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i,j = w.getSelectionRange()

    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        width = f.tree.headWidth(p=None,s=s)
        w.setWidth(width)
    else: pass

OnCutFromMenu = cutText
#@-node:ekr.20070130115927.6:leoFrame.cutText
#@+node:ekr.20070130115927.7:leoFrame.pasteText
def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    # g.trace('isText',g.app.gui.isTextWidget(w),w)
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()

    # print 'pasteText',i,j,middleButton,wname,repr(c.k.previousSelection)

    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()

    singleLine = wname.startswith('head') or wname.startswith('minibuffer')

    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)

        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.getAllText()
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                width = f.tree.headWidth(p=None,s=s)
                w.setWidth(width)
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.

    return 'break' # Essential

OnPasteFromMenu = pasteText
#@-node:ekr.20070130115927.7:leoFrame.pasteText
#@+node:ekr.20061016071937:OnPaste (To support middle-button paste)
def OnPaste (self,event=None):

    return self.pasteText(event=event,middleButton=True)
#@nonl
#@-node:ekr.20061016071937:OnPaste (To support middle-button paste)
#@-node:ekr.20070130115927.4:Cut/Copy/Paste (leoFrame)
#@+node:ekr.20031218072017.3980:Edit Menu... (leoFrame)
#@+node:ekr.20031218072017.3981:abortEditLabelCommand
def abortEditLabelCommand (self,event=None):

    '''End editing of a headline and revert to its previous value.'''

    frame = self ; c = frame.c ; tree = frame.tree
    p = c.currentPosition() ; w = c.edit_widget(p)

    if g.app.batchMode:
        c.notValidInBatchMode("Abort Edit Headline")
        return

    # g.trace('isEditing',p == tree.editPosition(),'revertHeadline',repr(tree.revertHeadline))

    if w and p == tree.editPosition():
        # Revert the headline text.
        w.delete(0,"end")
        w.insert("end",tree.revertHeadline)
        p.initHeadString(tree.revertHeadline)
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectPosition(p)
        finally:
            c.endUpdate()
#@-node:ekr.20031218072017.3981:abortEditLabelCommand
#@+node:ekr.20031218072017.3982:endEditLabelCommand
def endEditLabelCommand (self,event=None):

    '''End editing of a headline and move focus to the body pane.'''

    frame = self ; c = frame.c
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        c.endEditing()
        # g.trace('setting focus')
        if c.config.getBool('stayInTreeAfterEditHeadline'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@-node:ekr.20031218072017.3982:endEditLabelCommand
#@+node:ekr.20031218072017.3983:insertHeadlineTime
def insertHeadlineTime (self,event=None):

    '''Insert a date/time stamp in the headline of the selected node.'''

    frame = self ; c = frame.c ; p = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return

    c.editPosition(p)
    c.frame.tree.setEditLabelState(p)
    w = c.edit_widget(p)
    if w:
        time = c.getTime(body=False)
        if 1: # We can't know if we were already editing, so insert at end.
            w.setSelectionRange('end','end')
            w.insert('end',time)
        else:
            i, j = w.getSelectionRange()
            if i != j: w.delete(i,j)
            w.insert("insert",time)
        c.frame.tree.onHeadChanged(p,'Insert Headline Time')
#@-node:ekr.20031218072017.3983:insertHeadlineTime
#@-node:ekr.20031218072017.3980:Edit Menu... (leoFrame)
#@-node:ekr.20061109125528.1:Must be defined in base class
#@+node:ekr.20031218072017.3680:Must be defined in subclasses
#@+node:ekr.20031218072017.3683:Config...
def resizePanesToRatio (self,ratio,secondary_ratio):    self.oops()
def setInitialWindowGeometry (self):                    self.oops()

def setTopGeometry (self,w,h,x,y,adjustSize=True):
    __pychecker__ = '--no-argsused' # adjustSize used in derived classes.
    self.oops()
#@-node:ekr.20031218072017.3683:Config...
#@+node:ekr.20031218072017.3681:Gui-dependent commands
# In the Edit menu...

def OnCopy  (self,event=None): self.oops()
def OnCut   (self,event=None): self.oops()
def OnCutFromMenu  (self,event=None):     self.oops()
def OnCopyFromMenu (self,event=None):     self.oops()

# Expanding and contracting panes.
def contractPane         (self,event=None): self.oops()
def expandPane           (self,event=None): self.oops()
def contractBodyPane     (self,event=None): self.oops()
def contractLogPane      (self,event=None): self.oops()
def contractOutlinePane  (self,event=None): self.oops()
def expandBodyPane       (self,event=None): self.oops()
def expandLogPane        (self,event=None): self.oops()
def expandOutlinePane    (self,event=None): self.oops()
def fullyExpandBodyPane  (self,event=None): self.oops()
def fullyExpandLogPane   (self,event=None): self.oops()
def fullyExpandPane      (self,event=None): self.oops()
def fullyExpandOutlinePane (self,event=None): self.oops()
def hideBodyPane         (self,event=None): self.oops()
def hideLogPane          (self,event=None): self.oops()
def hidePane             (self,event=None): self.oops()
def hideOutlinePane      (self,event=None): self.oops()

# In the Window menu...
def cascade              (self,event=None): self.oops()
def equalSizedPanes      (self,event=None): self.oops()
def hideLogWindow        (self,event=None): self.oops()
def minimizeAll          (self,event=None): self.oops()
def resizeToScreen       (self,event=None): self.oops()
def toggleActivePane     (self,event=None): self.oops()
def toggleSplitDirection (self,event=None): self.oops()

# In help menu...
def leoHelp (self,event=None): self.oops()
#@-node:ekr.20031218072017.3681:Gui-dependent commands
#@+node:ekr.20031218072017.3682:Window...
# Important: nothing would be gained by calling gui versions of these methods:
#            they can be defined in a gui-dependent way in a subclass.

def bringToFront (self):    self.oops()
def deiconify (self):       self.oops()
def get_window_info(self):  self.oops()
def lift (self):            self.oops()
def update (self):          self.oops()
#@-node:ekr.20031218072017.3682:Window...
#@-node:ekr.20031218072017.3680:Must be defined in subclasses
#@+node:ekr.20061109125528:May be defined in subclasses
#@+node:ekr.20031218072017.3687:setTabWidth
def setTabWidth (self,w):

    # Subclasses may override this to affect drawing.
    self.tab_width = w
#@-node:ekr.20031218072017.3687:setTabWidth
#@+node:ekr.20031218072017.3688:getTitle & setTitle
def getTitle (self):
    return self.title

def setTitle (self,title):
    self.title = title
#@-node:ekr.20031218072017.3688:getTitle & setTitle
#@-node:ekr.20061109125528:May be defined in subclasses
#@+node:ekr.20060206093313:Focus (leoFrame)
# For compatibility with old scripts.
# Using the commander methods directly is recommended.

def getFocus(self):
    return g.app.gui.get_focus(self.c) # Used by wxGui plugin.

def bodyWantsFocus(self):
    return self.c.bodyWantsFocus()

def headlineWantsFocus(self,p):
    return self.c.headlineWantsFocus(p)

def logWantsFocus(self):
    return self.c.logWantsFocus()

def minibufferWantsFocus(self):
    return self.c.minibufferWantsFocus()
#@-node:ekr.20060206093313:Focus (leoFrame)
#@-node:ekr.20031218072017.3678:class leoFrame
#@+node:ekr.20031218072017.3694:class leoLog
class leoLog:

    """The base class for the log pane in Leo windows."""

    __pychecker__ = '--no-argsused' # base classes have many unused args.

    @others
#@+node:ekr.20031218072017.3695: ctor (leoLog)
def __init__ (self,frame,parentFrame):

    self.frame = frame
    if frame: # 7/16/05: Allow no commander for Null logs.
        self.c = frame.c
    else:
        self.c = None
    self.enabled = True
    self.newlines = 0
    self.isNull = False

    # Official status variables.  Can be used by client code.
    self.logCtrl = None # Set below. Same as self.textDict.get(self.tabName)
    self.tabName = None # The name of the active tab.
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)

    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    self.textDict = {}  # Keys are page names. Values are logCtrl's (text widgets).


#@-node:ekr.20031218072017.3695: ctor (leoLog)
#@+node:ekr.20070302101344:Must be defined in the base class
def onActivateLog (self,event=None):

    self.c.setLog()

def disable (self):

    self.enabled = False

def enable (self,enabled=True):

    self.enabled = enabled

#@-node:ekr.20070302101344:Must be defined in the base class
#@+node:ekr.20070302101023:May be overridden
def configure (self,*args,**keys):      pass
def configureBorder(self,border):       pass
def createControl (self,parentFrame):   pass
def finishCreate (self):                pass
def setColorFromConfig (self):          pass
def setFontFromConfig (self):           pass
#@+node:ekr.20070302094848.1:clearTab
def clearTab (self,tabName,wrap='none'):

    self.selectTab(tabName,wrap=wrap)
    w = self.logCtrl
    w and w.delete(0,'end')
#@-node:ekr.20070302094848.1:clearTab
#@+node:ekr.20070302094848.2:createTab
def createTab (self,tabName,createText=True,wrap='none'):

    # g.trace(tabName,wrap)

    c = self.c ; k = c.k

    if createText:
        w = self.createTextWidget(tabFrame)
        self.textDict [tabName] = w
    else:
        self.textDict [tabName] = None
        self.frameDict [tabName] = tabName # tabFrame
#@-node:ekr.20070302094848.2:createTab
#@+node:ekr.20070302094848.4:cycleTabFocus
def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)

    values = d.values()
    if self.numberOfVisibleTabs() > 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = d.keys()[i]
        self.selectTab(tabName)
        return 
#@nonl
#@-node:ekr.20070302094848.4:cycleTabFocus
#@+node:ekr.20070302094848.5:deleteTab
def deleteTab (self,tabName,force=False):

    if tabName == 'Log':
        pass
    elif tabName in ('Find','Spell') and not force:
        self.selectTab('Log')
    else:
        for d in (self.textDict,self.frameDict):
            if tabName in d.keys():
                del d[tabName]
        self.tabName = None
        self.selectTab('Log')

    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
#@-node:ekr.20070302094848.5:deleteTab
#@+node:ekr.20070302094848.6:hideTab
def hideTab (self,tabName):

    __pychecker__ = '--no-argsused' # tabName

    self.selectTab('Log')
#@-node:ekr.20070302094848.6:hideTab
#@+node:ekr.20070302094848.7:getSelectedTab
def getSelectedTab (self):

    return self.tabName
#@-node:ekr.20070302094848.7:getSelectedTab
#@+node:ekr.20070302094848.8:lower/raiseTab
def lowerTab (self,tabName):

    self.c.invalidateFocus()
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
#@-node:ekr.20070302094848.8:lower/raiseTab
#@+node:ekr.20070302094848.9:numberOfVisibleTabs
def numberOfVisibleTabs (self):

    return len([val for val in self.frameDict.values() if val != None])
#@-node:ekr.20070302094848.9:numberOfVisibleTabs
#@+node:ekr.20070302094848.10:renameTab
def renameTab (self,oldName,newName):
    pass
#@-node:ekr.20070302094848.10:renameTab
#@+node:ekr.20070302094848.11:selectTab
def selectTab (self,tabName,createText=True,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c
    tabFrame = self.frameDict.get(tabName)
    if not tabFrame:
        self.createTab(tabName,createText=createText)

    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0:
        # Absolutely do not do this here!
        # It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)

    return tabFrame
#@-node:ekr.20070302094848.11:selectTab
#@-node:ekr.20070302101023:May be overridden
#@+node:ekr.20070302101304:Must be overridden
# All output to the log stream eventually comes here.

def put (self,s,color=None,tabName='Log'):
    self.oops()

def putnl (self,tabName='Log'):
    self.oops()
#@-node:ekr.20070302101304:Must be overridden
#@+node:ekr.20031218072017.3700:leoLog.oops
def oops (self):

    print "leoLog oops:", g.callers(), "should be overridden in subclass"
#@-node:ekr.20031218072017.3700:leoLog.oops
#@-node:ekr.20031218072017.3694:class leoLog
#@+node:ekr.20031218072017.3704:class leoTree
# This would be useful if we removed all the tree redirection routines.
# However, those routines are pretty ingrained into Leo...

class leoTree:

    """The base class for the outline pane in Leo windows."""

    __pychecker__ = '--no-argsused' # base classes have many unused args.

    @others
#@+node:ekr.20031218072017.3705:  tree.__init__ (base class)
def __init__ (self,frame):

    self.frame = frame
    self.c = frame.c

    self.edit_text_dict = {}
        # New in 3.12: keys vnodes, values are edit_widget (Tk.Text widgets)
        # New in 4.2: keys are vnodes, values are pairs (p,Tk.Text).

    # "public" ivars: correspond to setters & getters.
    self._editPosition = None
    self.redrawCount = 0 # For traces
    self.use_chapters = False # May be overridden in subclasses.
#@+node:ekr.20061109164512:leoTree.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    # Getters & setters.
    'editPosition',
    'getEditTextDict',
    'setEditPosition',
    # Others.
    'endEditLabel',
    'expandAllAncestors',
    'injectCallbacks',
    'OnIconDoubleClick',
    'onHeadChanged',
    'onHeadlineKey',
    'updateHead',
    'oops',
)
#@nonl
#@-node:ekr.20061109164512:leoTree.mustBeDefinedOnlyInBaseClass
#@+node:ekr.20061109164610:leoTree.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Colors & fonts.
    'getFont',
    'setFont',
    'setFontFromConfig ',
    # Drawing & scrolling.
    'drawIcon',
    'redraw_now',
    'scrollTo',
    # Headlines.
    'editLabel',
    'setEditLabelState',
    # Selecting.
    # 'select', # Defined in base class, may be overridden in do-nothing subclasses.
)
#@-node:ekr.20061109164610:leoTree.mustBeDefinedInSubclasses
#@-node:ekr.20031218072017.3705:  tree.__init__ (base class)
#@+node:ekr.20031218072017.3706: Must be defined in subclasses
# Colors & fonts.
def getFont(self):                              self.oops()
# def setColorFromConfig (self):                self.oops()
def setFont(self,font=None,fontName=None):      self.oops()
def setFontFromConfig (self):                   self.oops()

# Drawing & scrolling.
def drawIcon(self,v,x=None,y=None):             self.oops()
def redraw_now(self,scroll=True):               self.oops()
def scrollTo(self,p):                           self.oops()
idle_scrollTo = scrollTo # For compatibility.

# Headlines.
def editLabel(self,v,selectAll=False):          self.oops()
def setEditLabelState(self,v,selectAll=False):  self.oops()
#@-node:ekr.20031218072017.3706: Must be defined in subclasses
#@+node:ekr.20061109165848:Must be defined in base class
#@+node:ekr.20031218072017.3716:Getters/Setters (tree)
def getEditTextDict(self,v):
    # New in 4.2: the default is an empty list.
    return self.edit_text_dict.get(v,[])

def editPosition(self):
    return self._editPosition

def setEditPosition(self,p):
    self._editPosition = p
#@-node:ekr.20031218072017.3716:Getters/Setters (tree)
#@+node:ekr.20040803072955.90:head key handlers (leoTree)
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    c = self.c ; u = c.undoer ; w = c.edit_widget(p)
    if c.suppressHeadChanged: return
    if not w: return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace('changed',changed,'old',repr(oldRevert),'new',repr(s))
        if changed:
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(scroll=False) # New in 4.4.1
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):

    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # g.trace(repr(ch),g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):

    '''Update a headline from an event.

    The headline officially changes only when editing ends.'''

    c = self.c ; k = c.k
    ch = event and event.char or ''
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i

    # g.trace('w',w,'ch',repr(ch),g.callers())

    if ch == '\b':
        if i != j:  w.delete(i,j)
        else:       w.delete(ins-1)
        w.setSelectionRange(i-1,i-1,insert=i-1)
    elif ch and ch not in ('\n','\r'):
        if i != j:                              w.delete(i,j)
        elif k.unboundKeyAction == 'overwrite': w.delete(i,i+1)
        w.insert(ins,ch)
        w.setSelectionRange(ins+1,ins+1,insert=ins+1)

    s = w.getAllText()
    if s.endswith('\n'):
        # g.trace('can not happen: trailing newline')
        s = s[:-1]
    w.setWidth(self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.126:endEditLabel
def endEditLabel (self):

    '''End editing of a headline and update p.headString().'''

    c = self.c ; k = c.k ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None

    # Can't call setDefaultUnboundKeyAction here: it might put us in ignore mode!
    # if k:
        # k.setDefaultUnboundKeyAction()
        # k.showStateAndMode() # Destroys UNL info.

    # Important: this will redraw if necessary.
    self.onHeadChanged(p)

    if 0: # This interferes with the find command and interferes with focus generally!
        c.bodyWantsFocus()
#@-node:ekr.20040803072955.126:endEditLabel
#@-node:ekr.20040803072955.90:head key handlers (leoTree)
#@+node:ekr.20040803072955.143:tree.expandAllAncestors
def expandAllAncestors (self,p):

    '''Expand all ancestors without redrawing.

    Return a flag telling whether a redraw is needed.'''

    c = self.c ; cc = c.chapterController ; redraw_flag = False
    inChapter = cc and cc.inChapter()

    c.beginUpdate()
    try:
        for p in p.parents_iter():
            if inChapter and p.headString().startswith('@chapter'):
                break
            if not p.isExpanded():
                p.expand()
                redraw_flag = True
    finally:
        c.endUpdate(False)

    return redraw_flag
#@-node:ekr.20040803072955.143:tree.expandAllAncestors
#@+node:ekr.20040803072955.21:tree.injectCallbacks
def injectCallbacks(self):

    c = self.c

    << define callbacks to be injected in the position class >>

    for f in (OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave):

        g.funcToMethod(f,leoNodes.position)
#@nonl
#@+node:ekr.20040803072955.22:<< define callbacks to be injected in the position class >>
# N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others
#@+node:ekr.20040803072955.23:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event=None,c=c):

    """Callback injected into position class."""

    p = self
    try:
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            c.frame.bodyCtrl.setInsertPoint(0)
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
#@-node:ekr.20040803072955.23:OnHyperLinkControlClick
#@+node:ekr.20040803072955.24:OnHyperLinkEnter
def OnHyperLinkEnter (self,event=None,c=c):

    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperenter1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="green")
        g.doHook("hyperenter2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperenter")
#@-node:ekr.20040803072955.24:OnHyperLinkEnter
#@+node:ekr.20040803072955.25:OnHyperLinkLeave
def OnHyperLinkLeave (self,event=None,c=c):

    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperleave1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="white")
        g.doHook("hyperleave2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperleave")
#@-node:ekr.20040803072955.25:OnHyperLinkLeave
#@-node:ekr.20040803072955.22:<< define callbacks to be injected in the position class >>
#@-node:ekr.20040803072955.21:tree.injectCallbacks
#@+node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url) & helper
def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.bodyString().split('\n')
            url = lines and lines[0] or ''
        else:
            << stop the url after any whitespace >>
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            self.handleUrlInUrlNode(url)
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06
#@nonl
#@+node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i > -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i > -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
#@-node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
#@+node:ekr.20061030161842:handleUrlInUrlNode
def handleUrlInUrlNode(self,url):

    # Note: the UNL plugin has its own notion of what a good url is.

    c = self.c
    # g.trace(url)
    << check the url; return if bad >>
    << pass the url to the web browser >>
#@+node:ekr.20031218072017.2314:<< check the url; return if bad >>
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

if not url or len(url) == 0:
    g.es("no url following @url")
    return

# Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
#@nonl
#@-node:ekr.20031218072017.2314:<< check the url; return if bad >>
#@+node:ekr.20031218072017.2315:<< pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)
    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
    else:
        import webbrowser
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()
#@-node:ekr.20031218072017.2315:<< pass the url to the web browser >>
#@-node:ekr.20061030161842:handleUrlInUrlNode
#@-node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url) & helper
#@-node:ekr.20061109165848:Must be defined in base class
#@+node:ekr.20040803072955.128:leoTree.select & helper
tree_select_lockout = False

def select (self,p,updateBeadList=True,scroll=True):

    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        val = 'break'
        self.tree_select_lockout = True
        val = self.treeSelectHelper(p,updateBeadList,scroll)
    finally:
        self.tree_select_lockout = False

    return val  # Don't put a return in a finally clause.
#@+node:ekr.20070423101911:treeSelectHelper
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def treeSelectHelper (self,p,updateBeadList,scroll):

    c = self.c ; frame = c.frame
    body = w = frame.bodyCtrl
    old_p = c.currentPosition()

    if not p:
        # Bug fix: 5/31/07: do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    # g.trace('      ===',id(w),p and p.headString())
    if self.trace_select and not g.app.unitTesting: g.trace('tree',g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if not body: g.trace('no body!','c.frame',c.frame,'old_p',old_p)

yview = body.getYScrollPosition()
insertSpot = c.frame.body.getInsertPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if c.edit_widget(old_p):
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing newlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
w.setAllText(s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    w.setYScrollPosition(first)

if p.v and p.v.t.insertSpot != None:
    spot = p.v.t.insertSpot
    w.setInsertPoint(spot)
    w.see(spot)
else:
    w.setInsertPoint(0)

# g.trace("select:",p.headString())
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
# c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:

    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()

    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())

        # New in Leo 4.4: limit this list to 100 items.
        if 0: # Doesn't work yet.
            c.beadList = c.beadList [-100:]
            g.trace('len(c.beadList)',len(c.beadList))

    # g.trace(c.beadPointer,p,present_p)
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.headString())

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20070423101911:treeSelectHelper
#@-node:ekr.20040803072955.128:leoTree.select & helper
#@+node:ekr.20031218072017.3718:oops
def oops(self):

    print "leoTree oops:", g.callers(), "should be overridden in subclass"
#@-node:ekr.20031218072017.3718:oops
#@-node:ekr.20031218072017.3704:class leoTree
#@+node:ekr.20070317073627:class leoTreeTab
class leoTreeTab:

    '''A class representing a tabbed outline pane.'''

    @others
#@nonl
#@+node:ekr.20070317073627.1: ctor (leoTreeTab)
def __init__ (self,c,chapterController,parentFrame):

    self.c = c
    self.cc = chapterController
    self.nb = None # Created in createControl.
    self.parentFrame = parentFrame

    self.selectedTabBackgroundColor = c.config.getColor(
        'selected_chapter_tab_background_color') or 'LightSteelBlue2'

    self.selectedTabForegroundColor = c.config.getColor(
        'selected_chapter_tab_foreground_color') or 'black'

    self.unselectedTabBackgroundColor = c.config.getColor(
        'unselected_chapter_tab_background_color') or 'lightgrey'

    self.unselectedTabForegroundColor = c.config.getColor(
        'unselected_chapter_tab_foreground_color') or 'black'
#@-node:ekr.20070317073627.1: ctor (leoTreeTab)
#@+node:ekr.20070317073755:Must be defined in subclasses
def createControl (self):
    self.oops()

def createTab (self,tabName,select=True):
    self.oops()

def destroyTab (self,tabName):
    self.oops()

def selectTab (self,tabName):
    self.oops()

def setTabLabel(self,tabName):
    self.oops()
#@nonl
#@-node:ekr.20070317073755:Must be defined in subclasses
#@+node:ekr.20070317083104:oops
def oops(self):

    print "leoTreeTree oops:", g.callers(), "should be overridden in subclass"
#@-node:ekr.20070317083104:oops
#@-node:ekr.20070317073627:class leoTreeTab
#@+node:ekr.20031218072017.2191:class nullBody (leoBody)
class nullBody (leoBody):

    __pychecker__ = '--no-argsused' # null classes have many unused args.

    @others
#@+node:ekr.20031218072017.2192: nullBody.__init__
def __init__ (self,frame,parentFrame):

    # g.trace('nullBody','frame',frame,g.callers())

    leoBody.__init__ (self,frame,parentFrame) # Init the base class.

    self.insertPoint = 0
    self.selection = 0,0
    self.s = "" # The body text

    w = stringTextWidget(c=self.c,name='body')
    self.bodyCtrl = self.widget = w
    self.editorWidgets['1'] = w
    self.colorizer = leoColor.nullColorizer(self.c)
#@-node:ekr.20031218072017.2192: nullBody.__init__
#@+node:ekr.20031218072017.2193:Utils (internal use)
#@+node:ekr.20031218072017.2194:findStartOfLine
def findStartOfLine (self,lineNumber):

    lines = g.splitLines(self.s)
    i = 0 ; index = 0
    for line in lines:
        if i == lineNumber: break
        i += 1
        index += len(line)
    return index
#@-node:ekr.20031218072017.2194:findStartOfLine
#@+node:ekr.20031218072017.2195:scanToStartOfLine
def scanToStartOfLine (self,i):

    if i <= 0:
        return 0

    assert(self.s[i] != '\n')

    while i >= 0:
        if self.s[i] == '\n':
            return i + 1

    return 0
#@-node:ekr.20031218072017.2195:scanToStartOfLine
#@+node:ekr.20031218072017.2196:scanToEndOfLine
def scanToEndOfLine (self,i):

    if i >= len(self.s):
        return len(self.s)

    assert(self.s[i] != '\n')

    while i < len(self.s):
        if self.s[i] == '\n':
            return i - 1

    return i
#@-node:ekr.20031218072017.2196:scanToEndOfLine
#@-node:ekr.20031218072017.2193:Utils (internal use)
#@+node:ekr.20031218072017.2197:nullBody: leoBody interface
# Birth, death & config
def bind(self,*args,**keys):                pass
def createBindings (self,w=None):           pass
def createControl (self,frame,parentFrame,p): pass
def setColorFromConfig (self,w=None):       pass
def setFontFromConfig (self,w=None):        pass
# Editors...
def addEditor (self,event=None):            pass
def assignPositionToEditor (self,p):        pass
def createEditorFrame (self,w):             pass
def cycleEditorFocus (self,event=None):     pass
def deleteEditor (self,event=None):         pass
def selectEditor(self,w):                   pass
def selectLabel (self,w):                   pass
def setEditorColors (self,bg,fg):           pass
def unselectLabel (self,w):                 pass
def updateEditors (self):                   pass
# Events...
def forceFullRecolor (self,*args,**keys):   pass
def scheduleIdleTimeRoutine (self,function,*args,**keys): pass
# Low-level gui...
def getBodyPaneHeight (self):               return 500
def getBodyPaneWidth (self):                return 600
def hasFocus (self):                        pass
def setFocus (self):                        pass
def tag_add (self,tagName,index1,index2):   pass
def tag_bind (self,tagName,event,callback): pass
def tag_configure (self,colorName,**keys):  pass
def tag_delete(self,tagName):               pass
def tag_remove (self,tagName,index1,index2):pass
#@-node:ekr.20031218072017.2197:nullBody: leoBody interface
#@-node:ekr.20031218072017.2191:class nullBody (leoBody)
#@+node:ekr.20031218072017.2222:class nullFrame
class nullFrame (leoFrame):

    """A null frame class for tests and batch execution."""

    __pychecker__ = '--no-argsused' # null classes have many unused args.

    @others
#@+node:ekr.20040327105706: ctor
def __init__ (self,title,gui,useNullUndoer=False):

    # g.trace('nullFrame')

    leoFrame.__init__(self,gui) # Init the base class.
    assert(self.c is None)

    self.body = None
    self.bodyCtrl = None
    self.iconBar = nullIconBarClass(self.c,self)
    # self.iconBarClass = self.nullIconBarClass
    self.isNullFrame = True
    self.outerFrame = None
    self.statusLineClass = nullStatusLineClass
    self.title = title
    self.useNullUndoer = useNullUndoer

    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
#@-node:ekr.20040327105706: ctor
#@+node:ekr.20041120073824:destroySelf
def destroySelf (self):

    pass
#@-node:ekr.20041120073824:destroySelf
#@+node:ekr.20040327105706.2:finishCreate
def finishCreate(self,c):

    self.c = c

    # print 'nullFrame'

    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)

    c.setLog()

    # Set the official ivar.
    self.bodyCtrl = self.body.bodyCtrl

    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)


#@-node:ekr.20040327105706.2:finishCreate
#@+node:ekr.20061109124552:Overrides
#@+node:ekr.20061109123828:Config...
def resizePanesToRatio (self,ratio,secondary_ratio):    pass
def setInitialWindowGeometry (self):                    pass
def setMinibufferBindings(self):                        pass
#@+node:ekr.20041130065718.1:setTopGeometry
def setTopGeometry (self,w,h,x,y,adjustSize=True):

    __pychecker__ = '--no-argsused' # adjustSize used in derived classes.

    self.w = w
    self.h = h
    self.x = x
    self.y = y
#@-node:ekr.20041130065718.1:setTopGeometry
#@-node:ekr.20061109123828:Config...
#@+node:ekr.20061109124129:Gui-dependent commands
# Expanding and contracting panes.
def contractPane         (self,event=None): pass
def expandPane           (self,event=None): pass
def contractBodyPane     (self,event=None): pass
def contractLogPane      (self,event=None): pass
def contractOutlinePane  (self,event=None): pass
def expandBodyPane       (self,event=None): pass
def expandLogPane        (self,event=None): pass
def expandOutlinePane    (self,event=None): pass
def fullyExpandBodyPane  (self,event=None): pass
def fullyExpandLogPane   (self,event=None): pass
def fullyExpandPane      (self,event=None): pass
def fullyExpandOutlinePane (self,event=None): pass
def hideBodyPane         (self,event=None): pass
def hideLogPane          (self,event=None): pass
def hidePane             (self,event=None): pass
def hideOutlinePane      (self,event=None): pass

# In the Window menu...
def cascade              (self,event=None): pass
def equalSizedPanes      (self,event=None): pass
def hideLogWindow        (self,event=None): pass
def minimizeAll          (self,event=None): pass
def resizeToScreen       (self,event=None): pass
def toggleActivePane     (self,event=None): pass
def toggleSplitDirection (self,event=None): pass

# In help menu...
def leoHelp (self,event=None): pass
#@nonl
#@-node:ekr.20061109124129:Gui-dependent commands
#@+node:ekr.20041130065921:Window...
def bringToFront (self):    pass
def deiconify (self):       pass
def get_window_info(self):  return 0,0,0,0
def lift (self):            pass
def setWrap (self,flag):    pass
def update (self):          pass
#@-node:ekr.20041130065921:Window...
#@-node:ekr.20061109124552:Overrides
#@-node:ekr.20031218072017.2222:class nullFrame
#@+node:ekr.20070301164543:class nullIconBarClass
class nullIconBarClass:

    '''A class representing the singleton Icon bar'''

    @others
#@+node:ekr.20070301164543.1: ctor
def __init__ (self,c,parentFrame):

    self.c = c
    self.parentFrame = parentFrame
#@nonl
#@-node:ekr.20070301164543.1: ctor
#@+node:ekr.20070301164543.2:add
def add(self,*args,**keys):

    '''Add a (virtual) button to the (virtual) icon bar.'''

    command = keys.get('command')
    text = keys.get('text')
    try:    g.app.iconWidgetCount += 1
    except: g.app.iconWidgetCount = 1
    n = g.app.iconWidgetCount
    name = 'nullButtonWidget %d' % n

    if not command:
        def command(name=name):
            print "command for %s" % (name)

    class nullButtonWidget:
        def __init__ (self,c,command,name,text):
            self.c = c
            self.command = command
            self.name = name
            self.text = text
        def __repr__ (self):
            return self.name
        def cget(self,*args,**keys):
            pass
        def configure (self,*args,**keys):
            pass
        def pack (self,*args,**keys):
            pass

    b = nullButtonWidget(self.c,command,name,text)
    return b
#@-node:ekr.20070301164543.2:add
#@+node:ekr.20070301165343:do nothing
def clear(self):
    g.app.iconWidgetCount = 0
    g.app.iconImageRefs = []

def deleteButton (self,w):
    pass

def getFrame (self):
    return None

def pack (self):
    pass

def setCommandForButton(self,b,command):
    b.command = command

def unpack (self):
    pass

hide = unpack
show = pack
#@-node:ekr.20070301165343:do nothing
#@-node:ekr.20070301164543:class nullIconBarClass
#@+node:ekr.20031218072017.2232:class nullLog
class nullLog (leoLog):

    __pychecker__ = '--no-argsused' # null classes have many unused args.

    @others
#@+node:ekr.20070302095500:Birth
#@+node:ekr.20041012083237:nullLog.__init__
def __init__ (self,frame=None,parentFrame=None):

    # Init the base class.
    leoLog.__init__(self,frame,parentFrame)

    self.isNull = True
    self.logCtrl = self.createControl(parentFrame)
#@nonl
#@-node:ekr.20041012083237:nullLog.__init__
#@+node:ekr.20041012083237.1:createControl
def createControl (self,parentFrame):

    return self.createTextWidget(parentFrame)
#@-node:ekr.20041012083237.1:createControl
#@+node:ekr.20070302095121:createTextWidget
def createTextWidget (self,parentFrame=None):

    self.logNumber += 1

    log = g.app.gui.plainTextWidget(
        c = self.c,
        name="log-%d" % self.logNumber,
    )

    return log
#@-node:ekr.20070302095121:createTextWidget
#@-node:ekr.20070302095500:Birth
#@+node:ekr.20041012083237.2:oops
def oops(self):

    g.trace("nullLog:", g.callers())
#@-node:ekr.20041012083237.2:oops
#@+node:ekr.20041012083237.3:put and putnl (nullLog)
def put (self,s,color=None,tabName='Log'):
    if self.enabled:
        ### g.rawPrint(s)
        try:
            print s,
        except UnicodeError:
            s = s.encode('ascii','replace')
            print s,

def putnl (self,tabName='Log'):
    if self.enabled:
        # g.rawPrint("")
        print
#@-node:ekr.20041012083237.3:put and putnl (nullLog)
#@+node:ekr.20060124085830:tabs
def clearTab        (self,tabName):     pass
def createTab (self,tabName,createText=True,wrap='none'): pass
def deleteTab       (self,tabName,force=False):     pass
def getSelectedTab          (self):     pass
def lowerTab        (self,tabName):     pass
def raiseTab        (self,tabName):     pass
def renameTab (self,oldName,newName):   pass
def selectTab (self,tabName,createText=True,wrap='none'): pass
def setTabBindings  (self,tabName):     pass
#@-node:ekr.20060124085830:tabs
#@-node:ekr.20031218072017.2232:class nullLog
#@+node:ekr.20070302171509:class nullStatusLineClass
class nullStatusLineClass:

    '''A do-nothing status line.'''

    @others
#@nonl
#@+node:ekr.20070302171509.2: ctor
def __init__ (self,c,parentFrame):

    self.c = c
    self.enabled = False
    self.parentFrame = parentFrame

    self.textWidget = w = g.app.gui.plainTextWidget(c,name='status-line')

    # Set the official ivars.
    c.frame.statusFrame = None
    c.frame.statusLabel = None
    c.frame.statusText  = self.textWidget
#@-node:ekr.20070302171509.2: ctor
#@+node:ekr.20070302171917:methods
def disable (self,background=None):
    self.enabled = False
    self.c.bodyWantsFocus()

def enable (self,background="white"):
    if w: self.c.widgetWantsFocus(self.textWidget)
    self.enabled = True

def clear (self):                   self.textWidget.delete(0,'end')
def get (self):                     return self.textWidget.getAllText()
def isEnabled(self):                return self.enabled
def getFrame (self):                return None
def onActivate (self,event=None):   pass 
def pack (self):                    pass
def put(self,s,color=None):         self.textWidget.insert('end',s)
def unpack (self):                  pass
def update (self):                  pass

hide = unpack
show = pack
#@-node:ekr.20070302171917:methods
#@-node:ekr.20070302171509:class nullStatusLineClass
#@+node:ekr.20031218072017.2233:class nullTree
class nullTree (leoTree):

    __pychecker__ = '--no-argsused' # null classes have many unused args.

    @others
#@+node:ekr.20031218072017.2234: nullTree.__init__
def __init__ (self,frame):

    leoTree.__init__(self,frame) # Init the base class.

    assert(self.frame)

    self.editWidgetsDict = {} # Keys are tnodes, values are stringTextWidgets.
    self.font = None
    self.fontName = None
    self.canvas = None
    self.stayInTree = True
    self.trace_edit = False
    self.trace_select = False
    self.updateCount = 0
#@-node:ekr.20031218072017.2234: nullTree.__init__
#@+node:ekr.20070228173611:printWidgets
def printWidgets(self):

    d = self.editWidgetsDict
    keys = d.keys()
    for key in keys:
        # keys are tnodes, values are stringTextWidgets.
        w = d.get(key)
        print 'w',w,'t.headString:',key.headString,'s:',repr(w.s)

#@-node:ekr.20070228173611:printWidgets
#@+node:ekr.20031218072017.2236:Overrides
#@+node:ekr.20070228163350:Colors & fonts
def getFont(self):
    return self.font

# def setColorFromConfig (self):
    # pass

def setBindings (self):
    pass

def setFont(self,font=None,fontName=None):
    self.font,self.fontName = font,fontName

def setFontFromConfig (self):
    pass
#@-node:ekr.20070228163350:Colors & fonts
#@+node:ekr.20070228163350.1:Drawing & scrolling
def beginUpdate (self):
    self.updateCount += 1

def endUpdate (self,flag,scroll=False):
    self.updateCount -= 1
    if flag and self.updateCount <= 0:
        self.redraw_now()

def drawIcon(self,v,x=None,y=None):
    pass

def redraw_now(self,scroll=True):
    self.redrawCount += 1
    # g.trace('nullTree')

def scrollTo(self,p):
    pass
#@-node:ekr.20070228163350.1:Drawing & scrolling
#@+node:ekr.20070228163350.2:Headlines
def edit_widget (self,p):
    d = self.editWidgetsDict ; w = d.get(p.v.t)
    if not w:
        d[p.v.t] = w = stringTextWidget(
            c=self.c,
            name='head-%d' % (1 + len(d.keys())))
        w.setAllText(p.headString())
    # g.trace('w',w,'p',p.headString())
    return w

def headWidth(self,p=None,s=''):
    return len(s)

def setEditLabelState(self,v,selectAll=False):
    pass

def setSelectedLabelState(self,*args,**keys):
    pass

def setUnselectedLabelState(self,*args,**keys):
    pass
#@+node:ekr.20070228164730:editLabel (nullTree) same as tkTree)
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c

    if self.editPosition() and p != self.editPosition():
        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(False)

    self.setEditPosition(p) # That is, self._editPosition = p

    if self.trace_edit and not g.app.unitTesting:
        g.trace(p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

    if p and c.edit_widget(p):
        # g.trace('selectAll',selectAll,g.callers())
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
#@-node:ekr.20070228164730:editLabel (nullTree) same as tkTree)
#@+node:ekr.20070228160345:setHeadline (nullTree)
def setHeadline (self,p,s):

    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''

    # g.trace('p',p.headString(),'s',repr(s),g.callers())

    w = self.edit_widget(p)
    if w:
        w.delete(0,'end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        w.insert(0,s)
        self.revertHeadline = s
        # g.trace(repr(s),w.getAllText())
    else:
        g.trace('-'*20,'oops')
#@-node:ekr.20070228160345:setHeadline (nullTree)
#@-node:ekr.20070228163350.2:Headlines
#@-node:ekr.20031218072017.2236:Overrides
#@-node:ekr.20031218072017.2233:class nullTree
#@-node:ekr.20031218072017.3655:@thin leoFrame.py
#@+node:ekr.20031218072017.3719:@thin leoGui.py
@first # -*- coding: utf-8 -*-

"""A module containing the base leoGui class.

This class and its subclasses hides the details of which gui is actually being used.
Leo's core calls this class to allocate all gui objects.

Plugins may define their own gui classes by setting g.app.gui."""

@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import leoFind # for nullFindTab.
import leoFrame # for nullGui.

@others
#@+node:ekr.20031218072017.3720:class leoGui
class leoGui:

    """The base class of all gui classes.

    Subclasses are expected to override all do-nothing methods of this class."""

    __pychecker__ = '--no-argsused' # base classes have many unused args.

    << define leoGui file types >>

    @others
#@+node:ekr.20040131103531:<< define leoGui file types >> (not used yet)
allFullFiletypes = [
    ("All files",   "*"),
    ("C/C++ files", "*.c"),
    ("C/C++ files", "*.cpp"),
    ("C/C++ files", "*.h"),
    ("C/C++ files", "*.hpp"),
    ("Java files",  "*.java"),
    ("Lua files",   "*.lua"),
    ("Pascal files","*.pas"),
    ("Python files","*.py")]
    # To do: *.php, *.php3, *.php4")
pythonFullFiletypes = [
    ("Python files","*.py"),
    ("All files","*"),
    ("C/C++ files","*.c"),
    ("C/C++ files","*.cpp"),
    ("C/C++ files","*.h"),
    ("C/C++ files","*.hpp"),
    ("Java files","*.java"),
    ("Lua files",   "*.lua"),
    ("Pascal files","*.pas")]
    # To do: *.php, *.php3, *.php4")
textFullFiletypes = [
    ("Text files","*.txt"),
    ("C/C++ files","*.c"),
    ("C/C++ files","*.cpp"),
    ("C/C++ files","*.h"),
    ("C/C++ files","*.hpp"),
    ("Java files","*.java"),
    ("Lua files",   "*.lua"),
    ("Pascal files","*.pas"),
    ("Python files","*.py"),
    ("All files","*")]
    # To do: *.php, *.php3, *.php4")
CWEBTextAllFiletypes = [
    ("CWEB files","*.w"),
    ("Text files","*.txt"),
    ("All files", "*")]
leoAllFiletypes = [
    ("Leo files","*.leo"),
    ("All files","*")]
leoFiletypes = [
    ("Leo files","*.leo")]
nowebTextAllFiletypes = [
    ("Noweb files","*.nw"),
    ("Text files", "*.txt"),
    ("All files",  "*")]
textAllFiletypes = [
    ("Text files","*.txt"),
    ("All files", "*")]
#@-node:ekr.20040131103531:<< define leoGui file types >> (not used yet)
#@+node:ekr.20031218072017.3721:app.gui Birth & death
#@+node:ekr.20031218072017.3722: leoGui.__init__
def __init__ (self,guiName):

    # g.trace("leoGui",guiName,g.callers())

    self.lastFrame = None
    self.leoIcon = None
    self.mGuiName = guiName
    self.mainLoop = None
    self.root = None
    self.script = None
    self.utils = None
    self.isNullGui = False
    self.bodyTextWidget = None
    self.plainTextWidget = None
    self.trace = False

#@-node:ekr.20031218072017.3722: leoGui.__init__
#@+node:ekr.20061109211054:leoGui.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    'guiName',
    'oops',
    'setScript',
    'widget_name',
)
#@nonl
#@-node:ekr.20061109211054:leoGui.mustBeDefinedOnlyInBaseClass
#@+node:ekr.20061109211022:leoGui.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Startup & shutdown
    'attachLeoIcon',
    'center_dialog',
    'color',
    #'createComparePanel',          # optional
    #'createFindPanel',             # optional
    'createFindTab',
    'createKeyHandlerClass',
    'createLeoFrame',
    'createRootWindow',
    'create_labeled_frame',
    'destroySelf',
    'eventChar',
    'eventKeysym',
    'eventWidget',
    'eventXY',
    # 'finishCreate', # optional.
    # 'getFontFromParams', # optional
    # 'getFullVersion', # optional.
    'getTextFromClipboard',
    'get_focus',
    'get_window_info',
    'isTextWidget',
    'keysym',
    'killGui',
    # 'makeScriptButton', # optional
    'recreateRootWindow',
    'replaceClipboardWith',
    'runAboutLeoDialog',
    'runAskLeoIDDialog',
    'runAskOkCancelNumberDialog',
    'runAskOkDialog',
    'runAskYesNoCancelDialog',
    'runAskYesNoDialog',
    'runMainLoop',
    'runOpenFileDialog',
    'runSaveFileDialog',
    'set_focus',
    #'setIdleTimeHook',             # optional       
    #'setIdleTimeHookAfterDelay',   # optional
)
#@-node:ekr.20061109211022:leoGui.mustBeDefinedInSubclasses
#@-node:ekr.20031218072017.3721:app.gui Birth & death
#@+node:ekr.20061109212618.1:Must be defined only in base class
#@+node:ekr.20031218072017.3740:guiName
def guiName(self):

    try:
        return self.mGuiName
    except:
        return "invalid gui name"
#@-node:ekr.20031218072017.3740:guiName
#@+node:ekr.20031218072017.2231:setScript
def setScript (self,script=None,scriptFileName=None):

    self.script = script
    self.scriptFileName = scriptFileName
#@-node:ekr.20031218072017.2231:setScript
#@-node:ekr.20061109212618.1:Must be defined only in base class
#@+node:ekr.20061109212618:Must be defined in subclasses
#@+node:ekr.20031218072017.3723:app.gui create & destroy
#@+node:ekr.20031218072017.3724:createRootWindow
def createRootWindow(self):

    """Create the hidden root window for the gui.

    Nothing needs to be done if the root window need not exist."""

    self.oops()
#@-node:ekr.20031218072017.3724:createRootWindow
#@+node:ekr.20031218072017.3725:destroySelf
def destroySelf (self):

    self.oops()
#@-node:ekr.20031218072017.3725:destroySelf
#@+node:ekr.20031218072017.3727:killGui
def killGui(self,exitFlag=True):

    """Destroy the gui.

    The entire Leo application should terminate if exitFlag is True."""

    self.oops()
#@-node:ekr.20031218072017.3727:killGui
#@+node:ekr.20031218072017.3728:recreateRootWindow
def recreateRootWindow(self):

    """Create the hidden root window of the gui
    after a previous gui has terminated with killGui(False)."""

    self.oops()
#@-node:ekr.20031218072017.3728:recreateRootWindow
#@+node:ekr.20031218072017.3729:runMainLoop
def runMainLoop(self):

    """Run the gui's main loop."""

    self.oops()
#@-node:ekr.20031218072017.3729:runMainLoop
#@-node:ekr.20031218072017.3723:app.gui create & destroy
#@+node:ekr.20031218072017.3730:app.gui dialogs
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run Leo's About Leo dialog."""
    self.oops()

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskOkCancelStringDialog(self,c,title,message):
    """Create and run askOkCancelString dialog ."""
    self.oops()

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()
#@-node:ekr.20031218072017.3730:app.gui dialogs
#@+node:ekr.20061031173016:app.gui.createKeyHandlerClass
def createKeyHandlerClass (self,c,useGlobalKillbuffer=True,useGlobalRegisters=True):

    self.oops()

    # import leoKeys # Do this here to break a circular dependency.

    # return leoKeys.keyHandlerClass(c,useGlobalKillbuffer,useGlobalRegisters)
#@nonl
#@-node:ekr.20061031173016:app.gui.createKeyHandlerClass
#@+node:ekr.20031218072017.3731:app.gui file dialogs
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an open file dialog ."""

    self.oops()

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run a save file dialog ."""

    self.oops()
#@-node:ekr.20031218072017.3731:app.gui file dialogs
#@+node:ekr.20031218072017.3732:app.gui panels
def createComparePanel(self,c):
    """Create Compare panel."""
    self.oops()

def createFindPanel(self,c):
    """Create a hidden Find panel."""
    self.oops()

def createFindTab (self,c,parentFrame):
    """Create a Tkinter find tab in the indicated frame."""
    self.oops()

def createLeoFrame(self,title):
    """Create a new Leo frame."""
    self.oops()
#@-node:ekr.20031218072017.3732:app.gui panels
#@+node:ekr.20031218072017.3733:app.gui utils
@ Subclasses are expected to subclass all of the following methods.

These are all do-nothing methods: callers are expected to check for None returns.

The type of commander passed to methods depends on the type of frame or dialog being created.  The commander may be a Commands instance or one of its subcommanders.
#@+node:ekr.20031218072017.3734:Clipboard (leoGui)
def replaceClipboardWith (self,s):

    self.oops()

def getTextFromClipboard (self):

    self.oops()
#@-node:ekr.20031218072017.3734:Clipboard (leoGui)
#@+node:ekr.20061031132712.1:color
# g.es calls gui.color to do the translation,
# so most code in Leo's core can simply use Tk color names.

def color (self,color):
    '''Return the gui-specific color corresponding to the Tk color name.'''
    return color # Do not call oops: this method is essential for the config classes.
#@-node:ekr.20061031132712.1:color
#@+node:ekr.20031218072017.3735:Dialog utils
def attachLeoIcon (self,window):
    """Attach the Leo icon to a window."""
    self.oops()

def center_dialog(self,dialog):
    """Center a dialog."""
    self.oops()

def create_labeled_frame (self,parent,caption=None,relief="groove",bd=2,padx=0,pady=0):
    """Create a labeled frame."""
    self.oops()

def get_window_info (self,window):
    """Return the window information."""
    self.oops()
#@-node:ekr.20031218072017.3735:Dialog utils
#@+node:ekr.20061031132907:Events (leoGui)
def event_generate(self,w,kind,*args,**keys):
    '''Generate an event.'''
    return w.event_generate(kind,*args,**keys)

def eventChar (self,event,c=None):
    '''Return the char field of an event.'''
    return event and event.char or ''

def eventKeysym (self,event,c=None):
    '''Return the keysym value of an event.'''
    return event and event.keysym

def eventWidget (self,event,c=None):
    '''Return the widget field of an event.'''   
    return event and event.widget

def eventXY (self,event,c=None):
    if event:
        return event.x,event.y
    else:
        return 0,0
#@nonl
#@-node:ekr.20061031132907:Events (leoGui)
#@+node:ekr.20070212145124:getFullVersion
def getFullVersion (self,c):

    return 'leoGui: dummy version'
#@-node:ekr.20070212145124:getFullVersion
#@+node:ekr.20031218072017.3737:Focus
def get_focus(self,frame):
    """Return the widget that has focus, or the body widget if None."""
    self.oops()

def set_focus(self,commander,widget):
    """Set the focus of the widget in the given commander if it needs to be changed."""
    self.oops()
#@-node:ekr.20031218072017.3737:Focus
#@+node:ekr.20031218072017.3736:Font (leoGui)
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):

    pass
    # self.oops()
#@-node:ekr.20031218072017.3736:Font (leoGui)
#@+node:ekr.20031218072017.3739:Idle time
def setIdleTimeHook (self,idleTimeHookHandler):

    # print 'leoGui:setIdleTimeHook'
    pass # Not an error.

def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):

    # print 'leoGui:setIdleTimeHookAfterDelay'
    pass # Not an error.
#@-node:ekr.20031218072017.3739:Idle time
#@+node:ekr.20070212070820:makeScriptButton
def makeScriptButton (
    self,c,
    p=None,
    script=None,
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,
    bg='LightSteelBlue1',
    define_g=True,
    define_name='__main__',
    silent=False, 
):

    self.oops()
#@-node:ekr.20070212070820:makeScriptButton
#@-node:ekr.20031218072017.3733:app.gui utils
#@-node:ekr.20061109212618:Must be defined in subclasses
#@+node:ekr.20070228154059:May be defined in subclasses
#@+node:ekr.20070219084912:finishCreate (may be overridden in subclasses)
def finishCreate (self):

    pass
#@nonl
#@-node:ekr.20070219084912:finishCreate (may be overridden in subclasses)
#@+node:ekr.20031218072017.3741:oops
def oops (self):

    # It is not usually an error to call methods of this class.
    # However, this message is useful when writing gui plugins.
    if 1:
        print "leoGui oops", g.callers(), "should be overridden in subclass"
#@-node:ekr.20031218072017.3741:oops
#@+node:ekr.20051206103652:widget_name (leoGui)
def widget_name (self,w):

    # First try the widget's getName method.
    if hasattr(w,'getName'):
        return w.getName()
    elif hasattr(w,'_name'):
        return w._name
    else:
        return repr(w)
#@-node:ekr.20051206103652:widget_name (leoGui)
#@+node:ekr.20070228160107:class leoKeyEvent (leoGui)
class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c):

        # g.trace('leoKeyEvent(leoGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        self.widget = self.w

    def __repr__ (self):

        return 'leoGui.leoKeyEvent: char: %s, keysym: %s' % (repr(self.char),repr(self.keysym))
#@nonl
#@-node:ekr.20070228160107:class leoKeyEvent (leoGui)
#@-node:ekr.20070228154059:May be defined in subclasses
#@-node:ekr.20031218072017.3720:class leoGui
#@+node:ekr.20031218072017.2223:class nullGui (leoGui)
class nullGui(leoGui):

    """Null gui class."""

    __pychecker__ = '--no-argsused' # This class has many unused args.

    @others
#@+node:ekr.20031218072017.2224:Birth & death
#@+node:ekr.20031218072017.2225: nullGui.__init__
def __init__ (self,guiName):

    leoGui.__init__ (self,guiName) # init the base class.

    self.clipboardContents = ''
    self.dict = {}
    self.focusWidget = None
    self.script = None
    self.lastFrame = None
    self.isNullGui = True
    self.bodyTextWidget  = leoFrame.stringTextWidget
    self.plainTextWidget = leoFrame.stringTextWidget
#@-node:ekr.20031218072017.2225: nullGui.__init__
#@+node:ekr.20070123092623:nullGui.createKeyHandlerClass
def createKeyHandlerClass (self,c,useGlobalKillbuffer=True,useGlobalRegisters=True):

    import leoKeys # Do this here to break a circular dependency.

    return leoKeys.keyHandlerClass(c,useGlobalKillbuffer,useGlobalRegisters)
#@nonl
#@-node:ekr.20070123092623:nullGui.createKeyHandlerClass
#@+node:ekr.20031218072017.2229:runMainLoop
def runMainLoop(self):

    """Run the gui's main loop."""

    if self.script:
        frame = self.lastFrame
        g.app.log = frame.log
        # g.es("Start of batch script...\n")
        self.lastFrame.c.executeScript(script=self.script)
        # g.es("\nEnd of batch script")

    # Getting here will terminate Leo.
#@-node:ekr.20031218072017.2229:runMainLoop
#@-node:ekr.20031218072017.2224:Birth & death
#@+node:ekr.20070228155807:isTextWidget
def isTextWidget (self,w):

    '''Return True if w is a Text widget suitable for text-oriented commands.'''

    return w and isinstance(w,leoFrame.baseTextWidget)
#@-node:ekr.20070228155807:isTextWidget
#@+node:ekr.20031218072017.2230:oops
def oops(self):

    """Default do-nothing method for nullGui class.

    It is NOT an error to use this method."""

    # It is not usually an error to call methods of this class.
    # However, this message is useful when writing gui plugins.
    if 1:
        g.trace("nullGui",g.callers())
#@-node:ekr.20031218072017.2230:oops
#@+node:ekr.20070301171901:do nothings
def attachLeoIcon (self,w):
    pass

def createRootWindow(self):
    pass

def destroySelf (self):
    pass

def finishCreate (self):
    pass

def getTextFromClipboard (self):
    return self.clipboardContents

def get_focus(self,frame):
    return self.focusWidget or frame.body.bodyCtrl

def get_window_info (self,window):
    return 0,0,0,0

def replaceClipboardWith (self,s):
    self.clipboardContents = s

def set_focus(self,commander,widget):
    self.focusWidget = widget
#@nonl
#@-node:ekr.20070301171901:do nothings
#@+node:ekr.20070301172456:app.gui panels
def createComparePanel(self,c):
    """Create Compare panel."""
    self.oops()

def createFindPanel(self,c):
    """Create a hidden Find panel."""
    self.oops()

def createFindTab (self,c,parentFrame):
    """Create a Tkinter find tab in the indicated frame."""
    return leoFind.nullFindTab(c,parentFrame)

def createLeoFrame(self,title):
    """Create a null Leo Frame."""
    gui = self
    self.lastFrame = leoFrame.nullFrame(title,gui)
    return self.lastFrame
#@-node:ekr.20070301172456:app.gui panels
#@+node:ekr.20031218072017.3744:dialogs (nullGui)
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    return self.simulateDialog("aboutLeoDialog")

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog")

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    return self.simulateDialog("okDialog","Ok")

def runAskOkCancelNumberDialog(self,c,title,message):
    return self.simulateDialog("numberDialog",-1)

def runAskOkCancelStringDialog(self,c,title,message):
    return self.simulateDialog("stringDialog",'')

def runCompareDialog(self,c):
    return self.simulateDialog("compareDialog",'')

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):
    return self.simulateDialog("openFileDialog")

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):
    return self.simulateDialog("saveFileDialog")

def runAskYesNoDialog(self,c,title,message=None):
    return self.simulateDialog("yesNoDialog","no")

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    return self.simulateDialog("yesNoCancelDialog","cancel")
#@-node:ekr.20031218072017.3744:dialogs (nullGui)
#@+node:ekr.20031218072017.3747:simulateDialog
def simulateDialog (self,key,defaultVal=None):

    val = self.dict.get(key,defaultVal)

    if self.trace:
        print key, val

    return val
#@-node:ekr.20031218072017.3747:simulateDialog
#@-node:ekr.20031218072017.2223:class nullGui (leoGui)
#@+node:ekr.20031218072017.3742:class unitTestGui (nullGui)
class unitTestGui(nullGui):

    '''A gui class for use by unit tests.'''

    # Presently used only by the import/export unit tests.

    @others
#@+node:ekr.20031218072017.3743: ctor (unitTestGui)
def __init__ (self,dict={},trace=False):

    self.oldGui = g.app.gui

    # Init the base class
    nullGui.__init__ (self,"unitTestGui")

    # Use the same kind of widgets as the old gui.
    self.bodyTextWidget = self.oldGui.bodyTextWidget
    self.plainTextWidget = self.oldGui.plainTextWidget

    self.dict = dict
    self.trace = trace
    g.app.gui = self

def destroySelf (self):

    g.app.gui = self.oldGui
#@-node:ekr.20031218072017.3743: ctor (unitTestGui)
#@-node:ekr.20031218072017.3742:class unitTestGui (nullGui)
#@-node:ekr.20031218072017.3719:@thin leoGui.py
#@+node:ekr.20061031131434:@thin leoKeys.py
"""Gui-independent keystroke handling for Leo.""" 

@language python
@tabwidth -4
@pagewidth 80

<< imports >>
<< about 'internal' bindings >>
<< about key dicts >>

@others
#@+node:ekr.20061031131434.1:<< imports >>
import leoGlobals as g
import leoEditCommands

import glob
import inspect
import os
import re
import string
import sys
import types

# The following imports _are_ used.
__pychecker__ = '--no-import'

try:
    # These do not exist in IronPython or Python 2.4
    import compiler
    import parser
except ImportError:
    pass
#@-node:ekr.20061031131434.1:<< imports >>
#@+node:ekr.20061031131434.2:<< about 'internal' bindings >>
@nocolor
@

Here are the rules for translating key bindings (in leoSettings.leo) into keys for k.bindingsDict:

1.  The case of plain letters is significant:  a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore (with a
warning) the shift prefix applied to any other binding, e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is *not*
significant. Thus, the Shift- prefix is required if you want an upper-case
letter (with the exception of 'bare' uppercase letters.)

The following table illustrates these rules. In each row, the first entry is the
key (for k.bindingsDict) and the other entries are equivalents that the user may
specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is consistent
with Tk's key-event specifiers). It is also, I think, the least confusing set of
rules.
#@nonl
#@-node:ekr.20061031131434.2:<< about 'internal' bindings >>
#@+node:ekr.20061031131434.3:<< about key dicts >>
@nocolor
@

ivars:

c.commandsDict:
    Keys are emacs command names; values are functions f.

k.inverseCommandsDict:
    Keys are f.__name__; values are emacs command names.

k.bindingsDict:
    Keys are shortcuts; values are *lists* of g.bunch(func,name,warningGiven)

k.masterBindingsDict:
    Keys are scope names: 'all','text',etc. or mode names.
    Values are dicts:  keys are strokes, values are g.Bunch(commandName,func,pane,stroke)

k.masterGuiBindingsDict:
    Keys are strokes; value is a list of widgets for which stroke is bound.

k.settingsNameDict:
    Keys are lowercase settings; values are 'real' Tk key specifiers.
    Important: this table has no inverse.

not an ivar (computed by k.computeInverseBindingDict):

inverseBindingDict
    Keys are emacs command names; values are *lists* of shortcuts.
#@-node:ekr.20061031131434.3:<< about key dicts >>
#@+node:ekr.20061031131434.4:class autoCompleterClass
class autoCompleterClass:

    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
#@+node:ekr.20061031131434.5: ctor (autocompleter)
def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.object = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('<class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z

    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@+node:ekr.20061031131434.7:defineObjectDict
def defineObjectDict (self):

    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p),             
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        if not obj:
            if key not in ('cc',):
                g.trace('bad object',obj)
            continue
        for z in idList:
            self.objectDict[z]=obj
            # g.trace(obj)
#@-node:ekr.20061031131434.7:defineObjectDict
#@-node:ekr.20061031131434.5: ctor (autocompleter)
#@+node:ekr.20061031131434.8:Top level
#@+node:ekr.20061031131434.9:autoComplete
def autoComplete (self,event=None,force=False):

    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k ; gui = g.app.gui
    w = gui.eventWidget(event) or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)

    # Don't allow autocompletion in headlines.
    if not c.widget_name(w).startswith('head'):
        self.language = g.scanForAtLanguage(c,c.currentPosition())
        if w and self.language == 'python' and (k.enable_autocompleter or force):
            self.start(event=event,w=w)

    return 'break'
#@-node:ekr.20061031131434.9:autoComplete
#@+node:ekr.20061031131434.10:autoCompleteForce
def autoCompleteForce (self,event=None):

    '''Show autocompletion, even if autocompletion is not presently enabled.'''

    return self.autoComplete(event,force=True)
#@-node:ekr.20061031131434.10:autoCompleteForce
#@+node:ekr.20061031131434.11:autoCompleterStateHandler
def autoCompleterStateHandler (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.object) == types.DictType:
            self.membersList = self.object.keys()
        elif type(self.object) in (types.ListType,types.TupleType):
            self.membersList = self.object
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
#@-node:ekr.20061031131434.11:autoCompleterStateHandler
#@+node:ekr.20061031131434.12:enable/disable/toggleAutocompleter/Calltips
def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()

def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()

def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
#@-node:ekr.20061031131434.12:enable/disable/toggleAutocompleter/Calltips
#@+node:ekr.20061031131434.13:showCalltips
def showCalltips (self,event=None,force=False):

    '''Show the calltips at the cursor.'''

    c = self.c ; k = c.k ; w = g.app.gui.eventWidget(event)
    if not w: return

    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        self.leadinWord = self.findCalltipWord(w)
        # g.trace(self.leadinWord)
        self.object = None
        self.membersList = None
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)

    return 'break'
#@-node:ekr.20061031131434.13:showCalltips
#@+node:ekr.20061031131434.14:showCalltipsForce
def showCalltipsForce (self,event=None):

    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''

    return self.showCalltips(event,force=True)
#@-node:ekr.20061031131434.14:showCalltipsForce
#@+node:ekr.20061031131434.15:showAutocompleter/CalltipsStatus
def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''

    k = self.k
    g.es('Autocompleter %s' % (g.choose(k.enable_autocompleter,'On','Off')),color='red')

def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    g.es('Calltips %s' % (g.choose(k.enable_calltips,'On','Off')),color='red')
#@nonl
#@-node:ekr.20061031131434.15:showAutocompleter/CalltipsStatus
#@-node:ekr.20061031131434.8:Top level
#@+node:ekr.20061031131434.16:Helpers
#@+node:ekr.20061031131434.17:.abort & exit (autocompleter) (test)
def abort (self):

    k = self.k
    k.keyboardQuit(event=None)
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.

    k = self ; c = self.c 
    w = self.widget or c.frame.body.bodyCtrl
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    if restore:
        if i != j: w.delete(i,j)
        w.insert(i,self.selectedText)
    w.setSelectionRange(j,j,insert=j)

    self.clear()
    self.object = None
#@-node:ekr.20061031131434.17:.abort & exit (autocompleter) (test)
#@+node:ekr.20061031131434.18:append/begin/popTabName
def appendTabName (self,word):

    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    if word == 'self' and self.selfClassName:
        word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')

def clearTabName (self):

    self.setTabName('AutoComplete ')

def popTabName (self):

    s = self.tabName
    i = s.rfind('.',0,-1)
    if i > -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_','') or ''
    c.frame.log.clearTab(self.tabName)
#@-node:ekr.20061031131434.18:append/begin/popTabName
#@+node:ekr.20061031131434.19:appendToKnownObjects
def appendToKnownObjects (self,obj):

    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)
#@-node:ekr.20061031131434.19:appendToKnownObjects
#@+node:ekr.20061031131434.20:calltip
def calltip (self,obj=None):

    c = self.c
    w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        << try to set s from a Python global function >>

    if not s:
        << get s using inspect >>

    << remove 'self' from s, but not from args >>
    if isStringMethod:
        << remove 's' from s *and* args >>

    s = s.rstrip(')') # Convenient.
    << insert the text and set j1 and j2 >>

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    if 1: # Seems to be more useful.
        w.setSelectionRange(j1,j2,insert=j2)
    else:
        w.setInsertPoint(j2)
    << put the status line >>
#@+node:ekr.20061031131434.21:<< try to set s from a Python global function >>
# The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i > -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
#@-node:ekr.20061031131434.21:<< try to set s from a Python global function >>
#@+node:ekr.20061031131434.22:<< get s using inspect >>
isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    # g.es('inspect failed:',repr(obj))
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
#@-node:ekr.20061031131434.22:<< get s using inspect >>
#@+node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
#@-node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
#@+node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
#@-node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
#@+node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
junk,j = w.getSelectionRange() # Returns insert point if no selection.
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')
j1 = j + 1 ; j2 = j + len(s)
#@-node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
#@+node:ekr.20061031131434.26:<< put the status line >>
c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
#@-node:ekr.20061031131434.26:<< put the status line >>
#@-node:ekr.20061031131434.20:calltip
#@+node:ekr.20061031131434.27:chain
def chain (self):

    c = self.c ; w = self.widget
    word = w.getSelectedText()
    old_obj = self.object

    if word and old_obj and type(old_obj) == type([]) and old_obj == sys.modules:
        obj = old_obj.get(word)
        if obj:
            self.object = obj
            self.clearTabName()
    elif word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.object = obj = self.getAttr(old_obj,word)
    else: obj = None

    if obj:
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = w.getInsertPoint()
        w.setSelectionRange(i,i,insert=i)
        # g.trace('chaining to',word,self.object)
        # Similar to start logic.
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        if self.membersList:
            # self.autoCompleterStateHandler(event=None)
            self.computeCompletionList()
            return
    self.extendSelection('.')
    self.finish()
#@-node:ekr.20061031131434.27:chain
#@+node:ekr.20061031131434.28:computeCompletionList
def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) < 25:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in d.keys()] ; aList.sort()
            self.tabList = aList

    c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
    if self.tabList:
        self.tabListIndex = -1 # The next item will be item 0.
        self.setSelection(common_prefix)
    for name in self.tabList:
        g.es('%s' % (name),tabName=self.tabName)
#@-node:ekr.20061031131434.28:computeCompletionList
#@+node:ekr.20061031131434.29:doBackSpace (autocompleter)
def doBackSpace (self):

    '''Cut back to previous prefix.'''

    # g.trace(self.prefix,self.object,self.prevObjects)

    c = self.c
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.object:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.object
        # g.trace(self.object,obj)
        w = self.widget
        s = w.getAllText()
        i,junk = w.getSelectionRange()
        ch = 0 <= i-1 < len(s) and s[i-1] or ''
        # g.trace(ch)
        if ch == '.':
            self.object = obj
            w.delete(i-1)
            c.frame.body.onBodyChanged(undoType='Typing')
            i,j = g.getWord(s,i-2)
            word = s[i:j]
            # g.trace(i,j,repr(word))
            w.setSelectionRange(i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()            
#@nonl
#@-node:ekr.20061031131434.29:doBackSpace (autocompleter)
#@+node:ekr.20061031131434.30:doTabCompletion (autocompleter)
def doTabCompletion (self):

    '''Handle tab completion when the user hits a tab.'''

    c = self.c ; w = self.widget
    s = w.getSelectedText()

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex >= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)
#@-node:ekr.20061031131434.30:doTabCompletion (autocompleter)
#@+node:ekr.20061031131434.31:extendSelection
def extendSelection (self,s):

    '''Append s to the presently selected text.'''

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    i,j = w.getSelectionRange()
    w.insert(j,s)
    j += 1
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')
#@nonl
#@-node:ekr.20061031131434.31:extendSelection
#@+node:ekr.20061031131434.32:findAnchor
def findAnchor (self,w):

    '''Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    while i > 0 and s[i-1] == '.':
        i,j = g.getWord(s,i-2)

    word = s[i:j]
    if word == '.': word = None

    # g.trace(i,j,repr(word))
    return j,word
#@nonl
#@-node:ekr.20061031131434.32:findAnchor
#@+node:ekr.20061031131434.33:findCalltipWord
def findCalltipWord (self,w):

    i = w.getInsertPoint()
    s = w.getAllText()
    if i > 0:
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        return word
    else:
        return ''
#@nonl
#@-node:ekr.20061031131434.33:findCalltipWord
#@+node:ekr.20061031131434.34:finish
def finish (self):

    c = self.c ; k = self.k

    k.keyboardQuit(event=None)

    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)

    c.frame.body.onBodyChanged('Typing')
    c.recolor()
    self.clear()
    self.object = None
#@-node:ekr.20061031131434.34:finish
#@+node:ekr.20061031131434.35:getAttr and hasAttr
# The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):

    '''Simulate getattr function, regardless of langauge.'''

    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):

    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList
#@-node:ekr.20061031131434.35:getAttr and hasAttr
#@+node:ekr.20061031131434.36:getLeadinWord
def getLeadinWord (self,w):

    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = w.getInsertPoint()
    s = w.getAllText()
    start -= 1
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    # g.trace(word,self.object,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.object:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while 0 <= i < start and i <len(s):
            if s[i] != '.':
                return False
            i,j = g.getWord(s,i+1)
            word = s[i:j]
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.object:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
#@-node:ekr.20061031131434.36:getLeadinWord
#@+node:ekr.20061031131434.37:getMembersList
def getMembersList (self,obj):

    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []
#@-node:ekr.20061031131434.37:getMembersList
#@+node:ekr.20061031131434.38:info
def info (self):

    c = self.c ; doc = None ; obj = self.object ; w = self.widget

    word = w.getSelectedText()

    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word): return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es(doc,tabName='Info')
#@-node:ekr.20061031131434.38:info
#@+node:ekr.20061031131434.39:insertNormalChar
def insertNormalChar (self,ch,keysym):

    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = w.getSelectedText() + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = w.getSelectedText()
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = w.getSelectedText()
        if ch == '(':
            # Similar to chain logic.
            obj = self.object
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.object)
                self.object = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
#@-node:ekr.20061031131434.39:insertNormalChar
#@+node:ekr.20061031131434.40:push, pop, clear, stackNames
def push (self,obj):

    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())

def pop (self):

    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj

def clear (self):

    self.prevObjects = []
    # g.trace(g.callers())

def stackNames (self):

    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList
#@-node:ekr.20061031131434.40:push, pop, clear, stackNames
#@+node:ekr.20061031131434.41:setObjectAndMembersList & helpers
def setObjectAndMembersList (self,word):

    c = self.c

    if not word:
        # Leading dot shows all classes.
        self.leadinWord = None
        self.object = sys.modules
        self.membersList = sys.modules.keys()
        self.beginTabName('Modules')
    elif word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.object)
        self.object = 'aString'
        self.membersList = self.getMembersList(self.object)
    elif self.object:
        self.getObjectFromAttribute(word)
    # elif word == 'self':
        # self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.object,len(self.membersList))
#@+node:ekr.20061031131434.42:getObjectFromAttribute
def getObjectFromAttribute (self,word):

    obj = self.object

    if obj and self.hasAttr(obj,word):
        self.push(self.object)
        self.object = self.getAttr(obj,word)
        self.appendToKnownObjects(self.object)
        self.membersList = self.getMembersList(self.object)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.object = None
#@-node:ekr.20061031131434.42:getObjectFromAttribute
#@+node:ekr.20061031131434.43:completeSelf
def completeSelf (self):

    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfTnodesDict [p.v.t] = obj
    if obj:
        self.selfClassName = className
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.object = None
        self.clear()
        self.membersList = []
#@-node:ekr.20061031131434.43:completeSelf
#@+node:ekr.20061031131434.44:completeFromObject
def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.object = None
        self.clear()
        self.membersList = []
#@-node:ekr.20061031131434.44:completeFromObject
#@-node:ekr.20061031131434.41:setObjectAndMembersList & helpers
#@+node:ekr.20061031131434.45:setSelection
def setSelection (self,s):

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
    else:
        i = w.getInsertPoint()

    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n > -1: s = s[:n]

    w.insert(i,s)
    j = i + len(s)
    w.setSelectionRange(i,j,insert=j)

    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor_now(c.currentPosition(),incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
#@-node:ekr.20061031131434.45:setSelection
#@+node:ekr.20061031131434.46:start
def start (self,event=None,w=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = ''
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i > 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        self.autoCompleterStateHandler(event)
    else:
        self.abort()
#@-node:ekr.20061031131434.46:start
#@-node:ekr.20061031131434.16:Helpers
#@+node:ekr.20061031131434.47:Scanning
# Not used at present, but soon.
#@+node:ekr.20061031131434.48:initialScan
# Don't call this finishCreate: the startup logic would call it too soon.

def initialScan (self):

    g.trace(g.callers())

    self.scan(thread=True)
#@-node:ekr.20061031131434.48:initialScan
#@+node:ekr.20061031131434.49:scan
def scan (self,event=None,verbose=True,thread=True):

    __pychecker__ = '--no-argsused' # thread arg not used at present.

    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return

    # g.trace('autocompleter')

    if 0: # thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)

        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)
#@-node:ekr.20061031131434.49:scan
#@+node:ekr.20061031131434.50:definePatterns
def definePatterns (self):

    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))

    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars 
#@nonl
#@-node:ekr.20061031131434.50:definePatterns
#@+node:ekr.20061031131434.51:scanOutline
def scanOutline (self,verbose=True):

    '''Traverse an outline and build the autocommander database.'''

    if verbose: g.es_print('Scanning for auto-completer...')

    c = self.c ; k = self.k ; count = 0
    for p in c.allNodes_iter():
        if verbose:
            count += 1 ;
            if (count % 200) == 0: g.es('.',newline=False)
        language = g.scanForAtLanguage(c,p)
        # g.trace('language',language,p.headString())
        s = p.bodyString()
        if k.enable_autocompleter:
            self.scanForAutoCompleter(s)
        if k.enable_calltips:
            self.scanForCallTip(s,language)

    if 0:
        g.trace('watchwords...\n\n')
        keys = self.watchwords.keys() ; keys.sort()
        for key in keys:
            aList = self.watchwords.get(key)
            g.trace('%s:\n\n' % (key), g.listToString(aList))
    if 0:
        g.trace('calltips...\n\n')
        keys = self.calltips.keys() ; keys.sort()
        for key in keys:
            d = self.calltips.get(key)
            if d:
                g.trace('%s:\n\n' % (key), g.dictToString(d))

    if verbose:        
        g.es_print('\nauto-completer scan complete',color='blue')
#@-node:ekr.20061031131434.51:scanOutline
#@+node:ekr.20061031131434.52:scanForCallTip
def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')

    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, junk = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if str(z) not in aList:
            aList.append(str(z))
            d [a] = aList

    self.calltips [language] = d
#@-node:ekr.20061031131434.52:scanForCallTip
#@+node:ekr.20061031131434.53:scanForAutoCompleter
def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = [] ; t1 = s.split('.')

    if 1: # Slightly faster.
        t1 = s.split('.') ; 
        i = 0 ; n = len(t1)-1
        while i < n:
            self.makeAutocompletionList(t1[i],t1[i+1],aList)
            i += 1
    else:
        reduce(lambda a,b: self.makeAutocompletionList(a,b,aList),t1)

    if aList:
        for a, b in aList:
            z = self.watchwords.get(a,[])
            if str(b) not in z:
                z.append(str(b))
                self.watchwords [a] = z
#@+node:ekr.20061031131434.54:makeAutocompletionList
def makeAutocompletionList (self,a,b,glist):

    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''

    if 1: # Do everything inline.  It's a few percent faster.

        # Compute reverseFindWhitespace inline.
        i = len(a) -1
        while i >= 0:
            if a[i].isspace() or a [i] == '.':
                a1 = a [i+1:] ; break
            i -= 1
        else:
            a1 = a

        # Compute getCleanString inline.
        i = 0
        for ch in b:
            if ch not in self.okchars:
                b1 = b[:i] ; break
            i += 1
        else:
            b1 = b

        if b1:
            glist.append((a1,b1),)

        return b # Not needed unless we are using reduce.
    else:
        a1 = self.reverseFindWhitespace(a)
        if a1:
            b1 = self.getCleanString(b)
            if b1:
                glist.append((a1,b1))
        return b
#@+node:ekr.20061031131434.55:reverseFindWhitespace
def reverseFindWhitespace (self,s):

    '''Return the longest tail of s containing no whitespace or period.'''

    i = len(s) -1
    while i >= 0:
        if s[i].isspace() or s [i] == '.': return s [i+1:]
        i -= 1

    return s
#@-node:ekr.20061031131434.55:reverseFindWhitespace
#@+node:ekr.20061031131434.56:getCleanString
def getCleanString (self,s):

    '''Return the prefix of s containing only chars in okchars.'''

    i = 0
    for ch in s:
        if ch not in self.okchars:
            return s[:i]
        i += 1

    return s
#@-node:ekr.20061031131434.56:getCleanString
#@-node:ekr.20061031131434.54:makeAutocompletionList
#@-node:ekr.20061031131434.53:scanForAutoCompleter
#@-node:ekr.20061031131434.47:Scanning
#@+node:ekr.20061031131434.57:Proxy classes and objects
#@+node:ekr.20061031131434.58:createProxyObjectFromClass
def createProxyObjectFromClass (self,className,theClass):

    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in xrange(n)]

    def dummyCtor (self):
        pass

    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')

    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj
#@-node:ekr.20061031131434.58:createProxyObjectFromClass
#@+node:ekr.20061031131434.59:createClassObjectFromString
def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec s

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in computeProxyObject')
            g.es_exception()
        return None
#@-node:ekr.20061031131434.59:createClassObjectFromString
#@-node:ekr.20061031131434.57:Proxy classes and objects
#@+node:ekr.20061031131434.60:class forgivingParserClass
class forgivingParserClass:

    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''

    @others
#@+node:ekr.20061031131434.61:ctor (forgivingParserClass)
def __init__ (self,c):

    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.
#@-node:ekr.20061031131434.61:ctor (forgivingParserClass)
#@+node:ekr.20061031131434.62:parse
def parse (self,p):

    '''The top-level parser method.

    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''

    c = self.c

    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody

    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody

    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody

    return s # Bug fix: 4/29/07: Don't put a return in a finally clause.


#@-node:ekr.20061031131434.62:parse
#@+node:ekr.20061031131434.63:forgivingParser
def forgivingParser (self,p):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            val = compiler.parse(s+'\n')
            break
        except (parser.ParserError,SyntaxError):
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                g.es_print('Syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('Syntax error: deleting %s' % p.headString())
                self.excludedTnodesList.append(p.v.t)
                s = g.getScript(c,root,useSelectedText=False)
    return s or ''
#@-node:ekr.20061031131434.63:forgivingParser
#@+node:ekr.20061031131434.64:computeErrorNode
def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n >= len(lines):
        return root

    vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        lines, n, root, scriptFind = True)

    if vnodeName:
        for p in root.self_and_subtree_iter():
            if p.matchHeadline(vnodeName):
                return p

    return None
#@-node:ekr.20061031131434.64:computeErrorNode
#@+node:ekr.20061031131434.65:newPutBody
def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v.t in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.headString())
    else:
        self.old_putBody(p,oneNodeOnly,fromString)
#@-node:ekr.20061031131434.65:newPutBody
#@-node:ekr.20061031131434.60:class forgivingParserClass
#@+node:ekr.20061031131434.66:class classScannerClass
class classScannerClass:

    '''A class to find class definitions in a node or its parents.'''

    @others
#@+node:ekr.20061031131434.67:ctor
def __init__ (self,c):

    self.c = c

    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False
#@-node:ekr.20061031131434.67:ctor
#@+node:ekr.20061031131434.68:scan
def scan (self):

    c = self.c

    className,obj,p = self.findParentClass(c.currentPosition())
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None

    return className,obj,p,s
#@-node:ekr.20061031131434.68:scan
#@+node:ekr.20061031131434.69:findParentClass
def findParentClass (self,root):

    autoCompleter = self.c.k.autoCompleter

    # First, see if any parent has already been scanned.
    for p in root.self_and_parents_iter():
        obj = autoCompleter.selfTnodesDict.get(p.v.t)
        if obj:
            # g.trace('found',obj,'in',p.headString())
            return None,obj,p

    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents_iter():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.headString())
            return className,None,p

    return None,None,None
#@-node:ekr.20061031131434.69:findParentClass
#@+node:ekr.20061031131434.70:findClass & helpers
def findClass (self,p):

    lines = g.splitLines(p.bodyString())
    inDoc = self.start_in_doc
    # g.trace(p.headString())
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None
#@+node:ekr.20061031131434.71:endsDoc
def endsDoc (self,s):

    return s.startswith('@c')
#@-node:ekr.20061031131434.71:endsDoc
#@+node:ekr.20061031131434.72:startsClass
def startsClass (self,s):

    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None
#@-node:ekr.20061031131434.72:startsClass
#@+node:ekr.20061031131434.73:startsDoc
def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False
#@-node:ekr.20061031131434.73:startsDoc
#@-node:ekr.20061031131434.70:findClass & helpers
#@-node:ekr.20061031131434.66:class classScannerClass
#@-node:ekr.20061031131434.4:class autoCompleterClass
#@+node:ekr.20061031131434.74:class keyHandlerClass
class keyHandlerClass:

    '''A class to support emacs-style commands.'''

    # Gui-independent class vars.

    global_killbuffer = []
        # Used only if useGlobalKillbuffer arg to Emacs ctor is True.
        # Otherwise, each Emacs instance has its own local kill buffer.

    global_registers = {}
        # Used only if useGlobalRegisters arg to Emacs ctor is True.
        # Otherwise each Emacs instance has its own set of registers.

    lossage = []
        # A case could be made for per-instance lossage, but this is not supported.

    @others
#@+node:ekr.20061031131434.75: Birth (keyHandler)
#@+node:ekr.20061031131434.76: ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):

    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.

    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''

    # g.trace('base keyHandler',g.callers())

    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '

    # These must be defined here to avoid memory leaks.
    self.enable_autocompleter           = c.config.getBool('enable_autocompleter_initially')
    self.enable_calltips                = c.config.getBool('enable_calltips_initially')
    self.ignore_caps_lock               = c.config.getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = c.config.getBool('ignore_unbound_non_ascii_keys')
    self.swap_mac_keys                  = c.config.getBool('swap_mac_keys')
    self.trace_bind_key_exceptions      = c.config.getBool('trace_bind_key_exceptions')
    self.trace_masterClickHandler       = c.config.getBool('trace_masterClickHandler')
    self.traceMasterCommand             = c.config.getBool('trace_masterCommand')
    self.trace_masterKeyHandler         = c.config.getBool('trace_masterKeyHandler')
    self.trace_masterKeyHandlerGC       = c.config.getBool('trace_masterKeyHandlerGC')
    self.trace_key_event                = c.config.getBool('trace_key_event')
    self.trace_minibuffer               = c.config.getBool('trace_minibuffer')
    self.warn_about_redefined_shortcuts = c.config.getBool('warn_about_redefined_shortcuts')
    << define externally visible ivars >>
    << define internal ivars >>

    self.defineTkNames()
    self.defineSpecialKeys()
    self.autoCompleter = autoCompleterClass(self)
    self.setDefaultUnboundKeyAction()
#@+node:ekr.20061031131434.78:<< define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.previousSelection = None # A hack for middle-button paste: set by masterClickHandler, used by pasteText.
self.state = g.bunch(kind=None,n=None,handler=None)
#@-node:ekr.20061031131434.78:<< define externally visible ivars >>
#@+node:ekr.20061031131434.79:<< define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
#@-node:ekr.20061031131434.79:<< define internal ivars >>
#@-node:ekr.20061031131434.76: ctor (keyHandler)
#@+node:ekr.20061031131434.80:k.finishCreate & helpers
def finishCreate (self):

    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''

    k = self ; c = k.c
    # g.trace('keyHandler')
    k.createInverseCommandsDict()

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'

    k.command_mode_bg_color = c.config.getColor('command_mode_bg_color') or bg
    k.command_mode_fg_color = c.config.getColor('command_mode_fg_color') or fg
    k.insert_mode_bg_color = c.config.getColor('insert_mode_bg_color') or bg
    k.insert_mode_fg_color = c.config.getColor('insert_mode_fg_color') or fg
    k.overwrite_mode_bg_color = c.config.getColor('overwrite_mode_bg_color') or bg
    k.overwrite_mode_fg_color = c.config.getColor('overwrite_mode_fg_color') or fg

    # g.trace(k.insert_mode_bg_color,k.insert_mode_fg_color,k)

    k.setInputState(self.unboundKeyAction)
#@nonl
#@+node:ekr.20061031131434.81:createInverseCommandsDict
def createInverseCommandsDict (self):

    '''Add entries to k.inverseCommandsDict using c.commandDict.

    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))

        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())
#@-node:ekr.20061031131434.81:createInverseCommandsDict
#@-node:ekr.20061031131434.80:k.finishCreate & helpers
#@+node:ekr.20061031131434.82:setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction (self):

    k = self ; c = k.c

    # g.trace(g.callers())

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()

    if defaultAction in ('command','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
        self.unboundKeyAction = 'insert'

    k.setInputState(self.unboundKeyAction)
#@-node:ekr.20061031131434.82:setDefaultUnboundKeyAction
#@+node:ekr.20070123143428:k.defineTkNames
def defineTkNames (self):

    k = self

    # These names are used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        'BackSpace','Begin','Break',
        'Caps_Lock','Clear',
        'Delete','Down',
        'End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'Home',
        'Left','Linefeed',
        'Next','Num_Lock',
        'Prior',
        'Return','Right',
        'Tab',
        'Up',
        # 'space',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace',
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s


@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.
Note: the Tk documentation states that not all of these may be available on all platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
#@-node:ekr.20070123143428:k.defineTkNames
#@+node:ekr.20070123085931:k.defineSpecialKeys
def defineSpecialKeys (self):

    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''

    k = self

    # g.trace('base keyHandler')

    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&" : "ampersand",
        "^" : "asciicircum",
        "~" : "asciitilde",
        "*" : "asterisk",
        "@" : "at",
        "\\": "backslash",
        "|" : "bar",
        "{" : "braceleft",
        "}" : "braceright",
        "[" : "bracketleft",
        "]" : "bracketright",
        ":" : "colon",      # removed from code.
        "," : "comma",
        "$" : "dollar",
        "=" : "equal",
        "!" : "exclam",     # removed from code.
        ">" : "greater",
        "<" : "less",
        "-" : "minus",
        "#" : "numbersign",
        '"' : "quotedbl",
        "'" : "quoteright",
        "(" : "parenleft",
        ")" : "parenright", # removed from code.
        "%" : "percent",
        "." : "period",     # removed from code.
        "+" : "plus",
        "?" : "question",
        "`" : "quoteleft",
        ";" : "semicolon",
        "/" : "slash",
        " " : "space",      # removed from code.
        "_" : "underscore",
    }

    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s

    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict.keys():
        k.guiBindNamesInverseDict [k.guiBindNamesDict.get(key)] = key

#@-node:ekr.20070123085931:k.defineSpecialKeys
#@+node:ekr.20061101071425:oops
def oops (self):

    g.trace('Should be defined in subclass:',g.callers())
#@-node:ekr.20061101071425:oops
#@-node:ekr.20061031131434.75: Birth (keyHandler)
#@+node:ekr.20061031131434.88:Binding (keyHandler)
#@+node:ekr.20061031131434.89:bindKey
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.'''

    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    << trace bindings >>
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('Ignoring invalid key binding: %s = %s' % (
                commandName,shortcut),color='blue')
            return
#@-node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
#@+node:ekr.20061031131434.91:<< trace bindings >>
if c.config.getBool('trace_bindings_verbose'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,shortcut,commandName)
#@-node:ekr.20061031131434.91:<< trace bindings >>
#@+node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
if not modeFlag and self.warn_about_redefined_shortcuts:
    redefs = [str(b2.commandName) for b2 in bunchList
        if b2.commandName != commandName and pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]
    for z in redefs:
        g.es_print('redefining %s in %s to %s in %s' % (
            z,b2.pane,commandName,pane),color='red')

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@-node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
#@-node:ekr.20061031131434.89:bindKey
#@+node:ekr.20061031131434.93:bindKeyToDict
def bindKeyToDict (self,pane,stroke,func,commandName):

    k = self
    d =  k.masterBindingsDict.get(pane,{})

    stroke = g.stripBrackets(stroke)

    if 0:
        g.trace('%-4s %-18s %-40s %s' % (
            pane,repr(stroke),commandName,func and func.__name__))

    # New in Leo 4.4.1: Allow redefintions.
    d [stroke] = g.Bunch(commandName=commandName,func=func,pane=pane,stroke=stroke)
    k.masterBindingsDict [pane] = d
#@-node:ekr.20061031131434.93:bindKeyToDict
#@+node:ekr.20061031131434.94:bindOpenWith
def bindOpenWith (self,shortcut,name,data):

    '''Register an open-with command.'''

    k = self ; c = k.c

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,data=data):
        return c.openWith(data=data)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
#@-node:ekr.20061031131434.94:bindOpenWith
#@+node:ekr.20061031131434.95:checkBindings
def checkBindings (self):

    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''

    k = self ; c = k.c

    if not c.config.getBool('warn_about_missing_settings'): return

    names = c.commandsDict.keys() ; names.sort()

    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
#@-node:ekr.20061031131434.95:checkBindings
#@+node:ekr.20070218130238:dumpMasterBindingsDict
def dumpMasterBindingsDict (self):

    k = self ; d = k.masterBindingsDict

    print ; print 'k.masterBindingsDict...' ; print
    keys = d.keys()
    keys.sort()
    for key in keys:
        print key, '-' * 40
        d2 = d.get(key)
        keys2 = d2.keys()
        keys2.sort()
        for key2 in keys2:
            b = d2.get(key2)
            print '%20s %s' % (key2,b.commandName)
#@-node:ekr.20070218130238:dumpMasterBindingsDict
#@+node:ekr.20061031131434.96:k.completeAllBindingsForWidget
def completeAllBindingsForWidget (self,w):

    k = self ; d = k.bindingsDict

    # g.trace('w',w,d.has_key('Alt+Key-4'))

    for stroke in d.keys():
        k.makeMasterGuiBinding(stroke,w=w)
#@-node:ekr.20061031131434.96:k.completeAllBindingsForWidget
#@+node:ekr.20061031131434.97:k.completeAllBindings
def completeAllBindings (self,w=None):

    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''

    # g.trace(w)

    k = self
    for stroke in k.bindingsDict.keys():
        k.makeMasterGuiBinding(stroke,w=w)
#@-node:ekr.20061031131434.97:k.completeAllBindings
#@+node:ekr.20061031131434.98:k.makeAllBindings
def makeAllBindings (self):

    k = self ; c = k.c

    # g.trace(c.fileName(),g.callers())

    k.bindingsDict = {}
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()
#@-node:ekr.20061031131434.98:k.makeAllBindings
#@+node:ekr.20061031131434.99:k.initAbbrev
def initAbbrev (self):

    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d.keys():
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

def initOneAbbrev (self,commandName,key):
    k = self ; c = k.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.es_print('bad abbrev: %s: unknown command name: %s' %
                (key,commandName),color='blue')
#@-node:ekr.20061031131434.99:k.initAbbrev
#@+node:ekr.20061031131434.100:addModeCommands (enterModeCallback)
def addModeCommands (self):

    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.

    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        # g.trace('leoCommands %24s = %s' % (f.__name__,key))
#@-node:ekr.20061031131434.100:addModeCommands (enterModeCallback)
#@+node:ekr.20061031131434.101:initSpecialIvars
def initSpecialIvars (self):

    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn  = c.config.getBool('warn_about_missing_settings')

    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
    ):
        junk, bunchList = c.config.getShortcut(commandName)
        bunchList = bunchList or [] ; found = False
        for pane in ('text','all'):
            for bunch in bunchList:
                if bunch.pane == pane:
                    stroke = k.strokeFromSetting(bunch.val)
                    if trace: g.trace(commandName,stroke)
                    setattr(k,ivar,stroke) ; found = True ;break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
#@-node:ekr.20061031131434.101:initSpecialIvars
#@+node:ekr.20061031131434.102:makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c ; d = c.commandsDict
    keys = d.keys() ; keys.sort()

    for commandName in keys:
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'keyboard-quit': g.trace(key,bunchList)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)

    # g.trace(g.listToString(k.bindingsDict.keys(),sort=True))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@-node:ekr.20061031131434.102:makeBindingsFromCommandsDict
#@+node:ekr.20061031131434.103:k.makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    k = self ; c = k.c ; f = c.frame

    bindStroke = k.tkbindingFromStroke(stroke)
    # g.trace('stroke',stroke,'bindStroke',bindStroke)

    if w:
        widgets = [w]
    else:
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None     
        if 1: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
            canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke)
        return k.masterKeyHandler(event,stroke=stroke)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                w.bind(bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding %s to %s' % (
                    bindStroke, c.widget_name(w)), color = 'blue')
                if g.app.unitTesting: raise
#@-node:ekr.20061031131434.103:k.makeMasterGuiBinding
#@-node:ekr.20061031131434.88:Binding (keyHandler)
#@+node:ekr.20061031131434.104:Dispatching (keyHandler)
#@+node:ekr.20061031131434.105:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = False or k.traceMasterCommand
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
#@nonl
#@+node:ekr.20061031131434.106:<< define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@nonl
#@-node:ekr.20061031131434.106:<< define specialKeysyms >>
#@+node:ekr.20061031131434.107:<< add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
#@-node:ekr.20061031131434.107:<< add character to history >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None

    # g.trace(k.state.kind)

    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.109:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
#@-node:ekr.20061031131434.109:callKeystrokeFunction (not used)
#@+node:ekr.20061031131434.110:handleDefaultChar
def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: pass # Ignore the key.
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@-node:ekr.20061031131434.110:handleDefaultChar
#@-node:ekr.20061031131434.105:masterCommand & helpers
#@+node:ekr.20061031131434.111:fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = False or c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'
#@+node:ekr.20061031131434.112:callAltXFunction
def callAltXFunction (self,event):

    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # print 'callAltXFunc',func

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@-node:ekr.20061031131434.112:callAltXFunction
#@-node:ekr.20061031131434.111:fullCommand (alt-x) & helper
#@+node:ekr.20061031131434.113:endCommand
def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''

    # pychecker complains about initAllEditCommanders.

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # print 'endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers()
            k.newMinibufferWidget = None
#@-node:ekr.20061031131434.113:endCommand
#@-node:ekr.20061031131434.104:Dispatching (keyHandler)
#@+node:ekr.20061031131434.114:Externally visible commands
#@+node:ekr.20061031131434.115:digitArgument & universalArgument
def universalArgument (self,event):

    '''Prompt for a universal argument.'''
    k = self
    k.setLabelBlue('Universal Argument: ',protect=True)
    k.universalDispatcher(event)

def digitArgument (self,event):

    '''Prompt for a digit argument.'''
    k = self
    k.setLabelBlue('Digit Argument: ',protect=True)
    k.universalDispatcher(event)
#@-node:ekr.20061031131434.115:digitArgument & universalArgument
#@+node:ekr.20061031131434.116:k.show/hide/toggleMinibuffer
def hideMinibuffer (self,event):
    '''Hide the minibuffer.'''
    k = self ; c = k.c
    c.frame.hideMinibuffer()
    g.es('Minibuffer hidden',color='red')
    for commandName in ('show-mini-buffer','toggle-mini-buffer'):
        shortcut = k.getShortcutForCommandName(commandName)
        if shortcut:
            g.es('%s is bound to: %s' % (commandName,shortcut))

def showMinibuffer (self,event):
    '''Show the minibuffer.'''
    k = self ; c = k.c
    c.frame.showMinibuffer()

def toggleMinibuffer (self,event):
    '''Show or hide the minibuffer.'''
    k = self ; c = k.c
    if c.frame.minibufferVisible:
        k.hideMinibuffer(event)
    else:
        k.showMinibuffer(event)
#@-node:ekr.20061031131434.116:k.show/hide/toggleMinibuffer
#@+node:ekr.20061031131434.117:negativeArgument (redo?)
def negativeArgument (self,event):

    '''Prompt for a negative digit argument.'''

    k = self ; state = k.getState('neg-arg')

    if state == 0:
        k.setLabelBlue('Negative Argument: ',protect=True)
        k.setState('neg-arg',1,k.negativeArgument)
    else:
        k.clearState()
        k.resetLabel()
        func = k.negArgFunctions.get(k.stroke)
        if func:
            func(event)

    return 'break'
#@-node:ekr.20061031131434.117:negativeArgument (redo?)
#@+node:ekr.20061031131434.118:numberCommand
def numberCommand (self,event,stroke,number):

    k = self ; k.stroke = stroke ; w = event.widget
    k.universalDispatcher(event)
    g.app.gui.event_generate(w,'<Key>',keysym=number)
    return 'break'

def numberCommand0 (self,event):
    '''Execute command number 0.'''
    return self.numberCommand (event,None,0)

def numberCommand1 (self,event):
    '''Execute command number 1.'''
    return self.numberCommand (event,None,1)

def numberCommand2 (self,event):
    '''Execute command number 2.'''
    return self.numberCommand (event,None,2)

def numberCommand3 (self,event):
    '''Execute command number 3.'''
    return self.numberCommand (event,None,3)

def numberCommand4 (self,event):
    '''Execute command number 4.'''
    return self.numberCommand (event,None,4)

def numberCommand5 (self,event):
    '''Execute command number 5.'''
    return self.numberCommand (event,None,5)

def numberCommand6 (self,event):
    '''Execute command number 6.'''
    return self.numberCommand (event,None,6)

def numberCommand7 (self,event):
    '''Execute command number 7.'''
    return self.numberCommand (event,None,7)

def numberCommand8 (self,event):
    '''Execute command number 8.'''
    return self.numberCommand (event,None,8)

def numberCommand9 (self,event):
    '''Execute command number 9.'''
    return self.numberCommand (event,None,9)
#@-node:ekr.20061031131434.118:numberCommand
#@+node:ekr.20061031131434.119:printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    if not keys: return g.es('no bindings')
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)

    # Print keys by type:
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        g.es('%s %s' % (sep, prefix),tabName=tabName)
        self.printBindingsHelper(data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    g.es('%s %s' % (sep, 'Plain Keys',),tabName=tabName)
    self.printBindingsHelper(data,n1,n2,prefix=None)
    state = k.unboundKeyAction 
    k.showStateAndMode()
#@+node:ekr.20061031131434.120:printBindingsHelper
def printBindingsHelper (self,data,n1,n2,prefix):

    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.

    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) >  1]
        # The list of all other items.

    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(lambda x,y: cmp(x[1],y[1]))
        for s1,s2,s3 in data:
            g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
#@-node:ekr.20061031131434.120:printBindingsHelper
#@-node:ekr.20061031131434.119:printBindings & helper
#@+node:ekr.20061031131434.121:printCommands
def printCommands (self,event=None):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'

    c.frame.log.clearTab(tabName)

    inverseBindingDict = k.computeInverseBindingDict()
    commandNames = c.commandsDict.keys() ; commandNames.sort()

    data = [] ; n1 = 4 ; n2 = 20
    for commandName in commandNames:
        dataList = inverseBindingDict.get(commandName,[('',''),])
        for z in dataList:
            pane, key = z
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)

    # This isn't perfect in variable-width fonts.
    for s1,s2,s3 in data:
        g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName=tabName)
#@-node:ekr.20061031131434.121:printCommands
#@+node:ekr.20061031131434.122:repeatComplexCommand & helper
def repeatComplexCommand (self,event):

    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command',1,handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.es('No previous command',color='blue')
    return 'break'

def repeatComplexCommandHelper (self,event):

    k = self ; c = k.c ; gui = g.app.gui

    keysym = gui.eventKeysym(event)
    # g.trace('state',k.state.kind,'event',repr(event),g.callers())
    if keysym == 'Return' and k.mb_history:
    # if k.mb_history:
        last = k.mb_history [0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict [last](event)
        return 'break'
    else:
        g.trace('oops')
        return k.keyboardQuit(event)
#@-node:ekr.20061031131434.122:repeatComplexCommand & helper
#@+node:ekr.20061031131434.123:set-xxx-State
def setCommandState (self,event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command',showState=True)

def setInsertState (self,event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert',showState=True)

def setOverwriteState (self,event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite',showState=True)
#@-node:ekr.20061031131434.123:set-xxx-State
#@+node:ekr.20061031131434.124:toggle-input-state
def toggleInputState (self,event=None):

    '''The toggle-input-state command.'''

    k = self ; c = k.c
    default = c.config.getString('top_level_unbound_key_action') or 'insert'
    state = k.unboundKeyAction

    if default == 'insert':
        state = g.choose(state=='insert','command','insert')
    elif default == 'overwrite':
        state = g.choose(state=='overwrite','command','overwrite')
    else:
        state = g.choose(state=='command','insert','command') # prefer insert to overwrite.

    k.setInputState(state)
#@-node:ekr.20061031131434.124:toggle-input-state
#@-node:ekr.20061031131434.114:Externally visible commands
#@+node:ekr.20061031131434.125:Externally visible helpers
#@+node:ekr.20061031131434.126:manufactureKeyPressForCommandName
def manufactureKeyPressForCommandName (self,w,commandName):

    '''Implement a command by passing a keypress to Tkinter.'''

    k = self ; c = k.c

    stroke = k.getShortcutForCommandName(commandName)

    if stroke and w:
        # g.trace(stroke)
        g.app.gui.event_generate(w,stroke)
    else:
        g.trace('no shortcut for %s' % (commandName),color='red')
#@-node:ekr.20061031131434.126:manufactureKeyPressForCommandName
#@+node:ekr.20061031131434.127:simulateCommand
def simulateCommand (self,commandName):

    k = self ; c = k.c

    func = c.commandsDict.get(commandName)

    if func:
        # g.trace(commandName,func.__name__)
        stroke = None
        if commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.bunch(c=c,keysym='',char='',widget=None)
        k.masterCommand(event,func,stroke)
        return k.funcReturn
    else:
        g.trace('no command for %s' % (commandName),color='red')
        if g.app.unitTesting:
            raise AttributeError
        else:
            return None
#@-node:ekr.20061031131434.127:simulateCommand
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer and k.useTextWidget: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or stroke in k.getArgEscapes:
        if stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20061031131434.130:keyboardQuit
def keyboardQuit (self,event,hideTabs=True,setDefaultUnboundKeyAction=True):

    '''This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.'''

    k = self ; c = k.c

    if g.app.quitting:
        return

    if hideTabs:
        k.autoCompleter.exit()
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')

    # Completely clear the mode.
    if k.inputModeName:
        k.endMode(event)

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()

    if setDefaultUnboundKeyAction: k.setDefaultUnboundKeyAction()
    k.showStateAndMode()
    c.endEditing()
    c.bodyWantsFocus()
#@-node:ekr.20061031131434.130:keyboardQuit
#@+node:ekr.20061031131434.131:k.registerCommand
def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''

    k = self ; c = k.c
    f = c.commandsDict.get(commandName)
    verbose = (False or verbose) and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('Redefining %s' % (commandName), color='red')

    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    # g.trace('leoCommands %24s = %s' % (func.__name__,commandName))

    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None

    if stroke:
        # g.trace('stroke',stroke,'pane',pane,commandName,g.callers())
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok:
            g.es_print('@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif verbose:
        g.es_print('@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in d.values():
            for key in d.keys():
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@-node:ekr.20061031131434.131:k.registerCommand
#@-node:ekr.20061031131434.125:Externally visible helpers
#@+node:ekr.20061031131434.145:Master event handlers (keyHandler)
#@+node:ekr.20061031131434.146:masterKeyHandler
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    if keysym in special_keys: return None

    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = (False or self.trace_masterKeyHandlerGC) and not g.app.unitTesting
    if traceGC: g.printNewObjects('masterKey 1')
    if trace:
        g.trace('stroke:',repr(stroke),'keysym:',repr(event.keysym),'ch:',repr(event.char),
            'state.kind:',k.state.kind,'\n',g.callers())
        # if (self.master_key_count % 100) == 0: g.printGcSummary()

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        # g.trace('special case')
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    if traceGC: g.printNewObjects('masterKey 2')

    << handle per-pane bindings >>
    << handle keys without bindings >>
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event: event = gui.leoKeyEvent(event,c)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.149:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'

# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            ok = k.handleMiniBindings(event,state,stroke)
            if ok:
                return 'break'
            elif stroke and len(stroke) == 1:
                # if trace: g.trace('calling modeHelp')
                k.modeHelp(event)
                return 'break'
            else:
                # End the mode and fall through to the pane bindings!
                k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@-node:ekr.20061031131434.149:<< handle mode bindings >>
#@+node:ekr.20061031131434.150:<< handle per-pane bindings >>
keyStatesTuple = ('command','insert','overwrite')
isPlain =  k.isPlainKey(stroke)

# g.trace('w_name',w_name,'w',w,'isTextWidget(w)',g.app.gui.isTextWidget(w))
# g.trace('button',k.masterBindingsDict.get('button'))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d.keys())
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20061031131434.150:<< handle per-pane bindings >>
#@+node:ekr.20061031131434.151:<< handle keys without bindings >>
if traceGC: g.printNewObjects('masterKey 5')

modesTuple = ('insert','overwrite')

if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
    # insert/overwrite normal character.  <Return> is *not* a normal character.
    if trace: g.trace('plain key in insert mode',repr(stroke))
    if traceGC: g.printNewObjects('masterKey 4')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'

elif keysym.find('Escape') != -1:
    # Never insert escape characters.
    return 'break'

else:
    if trace: g.trace(repr(stroke),'no func')
    if traceGC: g.printNewObjects('masterKey 6')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20061031131434.151:<< handle keys without bindings >>
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or self.trace_masterKeyHandler and not g.app.unitTesting

    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                if not k.silentMode:
                    c.minibufferWantsFocus()
                return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@-node:ekr.20061031131434.146:masterKeyHandler
#@+node:ekr.20061031131434.153:masterClickHandler
def masterClickHandler (self,event,func=None):

    k = self ; c = k.c ; gui = g.app.gui
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = not g.app.unitTesting and (False or k.trace_masterClickHandler)

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1

    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        c.frame.body.onClick(event) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x,y = gui.eventXY(event)
        x = w.xyToPythonIndex(x,y)
        i,j = k.getEditableTextRange()
        if i <= x <= j:
            w.setSelectionRange(x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'
    if event and func:
        if trace: g.trace(func.__name__)
        val = func(event) # Don't even *think* of overriding this.
        c.masterFocusHandler()
        if trace: g.trace('val:',val,g.callers())
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
#@-node:ekr.20061031131434.153:masterClickHandler
#@+node:ekr.20061031131434.154:masterDoubleClickHandler
def masterDoubleClickHandler (self,event,func=None):

    k = self ; c = k.c ; w = event and event.widget

    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        gui = g.app.gui
        x,y = gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        s = w.getAllText()
        start,end = g.getWord(s,i)
        w.setSelectionRange(start,end)
        return 'break'
#@-node:ekr.20061031131434.154:masterDoubleClickHandler
#@+node:ekr.20061031131434.155:masterMenuHandler
def masterMenuHandler (self,stroke,func,commandName):

    k = self ; c = k.c ; w = c.frame.getFocus()

    # g.trace('stroke',stroke,'func',func and func.__name__,commandName,g.callers())

    # Create a minimal event for commands that require them.
    event = g.Bunch(c=c,char='',keysym='',widget=w)

    if stroke:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
#@-node:ekr.20061031131434.155:masterMenuHandler
#@-node:ekr.20061031131434.145:Master event handlers (keyHandler)
#@+node:ekr.20061031170011.3:Minibuffer (keyHandler)
# These may be overridden, but this code is now gui-independent.
#@nonl
#@+node:ekr.20061031131434.135:k.minibufferWantsFocus/Now
def minibufferWantsFocus(self):

    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocus(c.miniBufferWidget)
    else:
        c.bodyWantsFocus()

def minibufferWantsFocusNow(self):

    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocusNow(c.miniBufferWidget)
    else:
        c.bodyWantsFocusNow()
#@-node:ekr.20061031131434.135:k.minibufferWantsFocus/Now
#@+node:ekr.20061031170011.5:getLabel
def getLabel (self,ignorePrompt=False):

    k = self ; w = self.widget
    if not w: return ''

    if self.useTextWidget:
        s = w.getAllText()
    else:
        s = k.svar and k.svar.get()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
#@-node:ekr.20061031170011.5:getLabel
#@+node:ekr.20061031170011.6:protectLabel
def protectLabel (self):

    k = self ; w = self.widget
    if not w: return

    if self.useTextWidget:
        k.mb_prefix = w.getAllText()
    else:
        if k.svar:
            k.mb_prefix = k.svar.get()
#@-node:ekr.20061031170011.6:protectLabel
#@+node:ekr.20061031170011.7:resetLabel
def resetLabel (self):

    k = self
    k.setLabelGrey('')
    k.mb_prefix = ''
#@-node:ekr.20061031170011.7:resetLabel
#@+node:ekr.20061031170011.8:setLabel
def setLabel (self,s,protect=False):

    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace(repr(s),g.callers())

    if self.useTextWidget:
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n,n,insert=n)
        c.masterFocusHandler() # Restore to the previously requested focus.
    else:
        if k.svar: k.svar.set(s)

    if protect:
        k.mb_prefix = s
#@-node:ekr.20061031170011.8:setLabel
#@+node:ekr.20061031170011.9:extendLabel
def extendLabel(self,s,select=False,protect=False):

    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace(repr(s))
    if not s: return

    if self.useTextWidget:
        c.widgetWantsFocusNow(w)
        w.insert('end',s)
        if select:
            i,j = k.getEditableTextRange()
            w.setSelectionRange(i,j,insert=j)
        if protect:
            k.protectLabel()
#@-node:ekr.20061031170011.9:extendLabel
#@+node:ekr.20061031170011.10:setLabelBlue
def setLabelBlue (self,label=None,protect=False):

    k = self ; w = k.widget
    if not w: return

    w.setBackgroundColor('lightblue')

    if label is not None:
        k.setLabel(label,protect)
#@-node:ekr.20061031170011.10:setLabelBlue
#@+node:ekr.20061031170011.11:setLabelGrey
def setLabelGrey (self,label=None):

    k = self ; w = self.widget
    if not w: return

    w.setBackgroundColor('lightgrey')

    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
#@-node:ekr.20061031170011.11:setLabelGrey
#@+node:ekr.20061031170011.12:updateLabel
def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''

    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)

    if ch and ch not in ('\n','\r'):
        if self.useTextWidget:
            c.widgetWantsFocusNow(w)
            i,j = w.getSelectionRange()
            ins = w.getInsertPoint()
            if i != j:
                w.delete(i,j)
            if ch == '\b':
                s = w.getAllText()
                if len(s) > len(k.mb_prefix):
                    w.delete(i-1)
            else:
                w.insert(ins,ch)
            # g.trace(k.mb_prefix)       
        else:
            # Just add the character.
            k.setLabel(k.getLabel() + ch)
#@-node:ekr.20061031170011.12:updateLabel
#@+node:ekr.20061031170011.13:getEditableTextRange
def getEditableTextRange (self):

    k = self ; w = self.widget
    s = w.getAllText()
    # g.trace(len(s),repr(s))

    i = len(k.mb_prefix)
    j = len(s)
    return i,j
#@nonl
#@-node:ekr.20061031170011.13:getEditableTextRange
#@-node:ekr.20061031170011.3:Minibuffer (keyHandler)
#@+node:ekr.20061031131434.156:Modes
#@+node:ekr.20061031131434.157:badMode
def badMode(self,modeName):

    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
#@-node:ekr.20061031131434.157:badMode
#@+node:ekr.20061031131434.158:createModeBindings
def createModeBindings (self,modeName,d,w):

    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''

    __pychecker__ = '--no-argsused' # w not used (except for debugging).

    k = self ; c = k.c

    # g.trace(g.listToString(d.keys()))

    for commandName in d.keys():
        if commandName == '*entry-commands*': continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('No such command: %s. Referenced from %s' % (
                commandName,modeName))
            continue
        bunchList = d.get(commandName,[])
        for bunch in bunchList:
            stroke = bunch.val
            # Important: bunch.val is a stroke returned from k.strokeFromSetting.
            # Do not call k.strokeFromSetting again here!
            if stroke and stroke not in ('None','none',None):
                if 0:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        bunch.nextMode)

                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.Bunch(
                    commandName=commandName,
                    func=func,
                    nextMode=bunch.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2
#@-node:ekr.20061031131434.158:createModeBindings
#@+node:ekr.20061031131434.159:endMode
def endMode(self,event):

    k = self ; c = k.c

    c.frame.log.deleteTab('Mode')

    k.endCommand(event,k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.
#@-node:ekr.20061031131434.159:endMode
#@+node:ekr.20061031131434.160:enterNamedMode
def enterNamedMode (self,event,commandName):

    k = self ; c = k.c
    modeName = commandName[6:]
    k.generalModeHandler(event,modeName=modeName)
#@-node:ekr.20061031131434.160:enterNamedMode
#@+node:ekr.20061031131434.161:exitNamedMode
def exitNamedMode (self,event):

    k = self

    if k.inState():
        k.endMode(event)

    k.showStateAndMode()
#@-node:ekr.20061031131434.161:exitNamedMode
#@+node:ekr.20061031131434.162:generalModeHandler
def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = False or c.config.getBool('trace_modes')

    if trace: g.trace(modeName,'state',state)

    if state == 0:
        # self.initMode(event,modeName)
        k.inputModeName = modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
            if k.useTextWidget:
                c.minibufferWantsFocus()
            else:
                c.restoreRequestedFocus()
    elif not func:
        g.trace('No func: improper key binding')
        return 'break'
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            self.endMode(event)
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.widget = k.modeWidget
            else:
                event = g.Bunch(widget = k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.

    return 'break'
#@-node:ekr.20061031131434.162:generalModeHandler
#@+node:ekr.20061031131434.163:initMode
def initMode (self,event,modeName):

    k = self ; c = k.c
    trace = c.config.getBool('trace_modes')
    if trace: g.trace(modeName)

    if not modeName:
        g.trace('oops: no modeName')
        return

    d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    if not d:
        self.badMode(modeName)
        return
    else:
        k.modeBindingsDict = d

    k.inputModeName = modeName
    k.silentMode = False

    entryCommands = d.get('*entry-commands*',[])
    if entryCommands:
        for commandName in entryCommands:
            if trace: g.trace('entry command:',commandName)
            k.simulateCommand(commandName)

    # Create bindings after we know whether we are in silent mode.
    w = g.choose(k.silentMode,k.modeWidget,k.widget)
    k.createModeBindings(modeName,d,w)

    if k.silentMode:
        k.showStateAndMode()
    else:
        k.setLabelBlue(modeName+': ',protect=True)
        k.showStateAndMode()
        if k.useTextWidget:
            c.minibufferWantsFocus()
        else:
            pass # Do *not* change the focus here!
#@-node:ekr.20061031131434.163:initMode
#@+node:ekr.20061031131434.164:reinitMode
def reinitMode (self,modeName):

    k = self ; c = k.c

    d = k.modeBindingsDict

    k.inputModeName = modeName
    w = g.choose(k.silentMode,k.modeWidget,k.widget)
    k.createModeBindings(modeName,d,w)

    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName+': ',protect=True)
        if k.useTextWidget:
            c.minibufferWantsFocus()
        else:
            pass # Do *not* change the focus here!
#@-node:ekr.20061031131434.164:reinitMode
#@+node:ekr.20061031131434.165:modeHelp
def modeHelp (self,event):

    '''The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''

    k = self ; c = k.c

    c.endEditing()

    # g.trace(k.inputModeName)

    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)

    if k.useTextWidget and not k.silentMode:
        c.minibufferWantsFocus()

    return 'break'
#@+node:ekr.20061031131434.166:modeHelpHelper
def modeHelpHelper (self,d):

    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    keys = d.keys() ; keys.sort()

    data = [] ; n = 20
    for key in keys:
        if key != '*entry-commands*':
            bunchList = d.get(key)
            for bunch in bunchList:
                shortcut = bunch.val
                if shortcut not in (None,'None'):
                    s1 = key ; s2 = k.prettyPrintKey(shortcut,brief=True)
                    n = max(n,len(s1))
                    data.append((s1,s2),)

    data.sort()

    # g.es('%s\n\n' % (k.inputModeName),tabName=tabName)

    modeName = k.inputModeName.replace('-',' ')
    if modeName.endswith('mode'): modeName = modeName[:-4].strip()

    g.es('%s mode\n\n' % modeName,tabName=tabName)

    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s %s' % (n,s1,s2),tabName=tabName)
#@-node:ekr.20061031131434.166:modeHelpHelper
#@-node:ekr.20061031131434.165:modeHelp
#@-node:ekr.20061031131434.156:Modes
#@+node:ekr.20061031131434.167:Shared helpers
#@+node:ekr.20061031131434.175:k.computeCompletionList
# Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.

        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)

        inverseBindingDict = k.computeInverseBindingDict()
        data = [] ; n1 = 20; n2 = 4
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1 = commandName
                s2 = pane
                s3 = k.prettyPrintKey(key)
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)
        for s1,s2,s3 in data:
            g.es('%*s %*s %s' % (-(min(20,n1)),s1,n2,s2,s3),tabName=tabName)

    c.bodyWantsFocus()
#@-node:ekr.20061031131434.175:k.computeCompletionList
#@+node:ekr.20061031131434.176:computeInverseBindingDict
def computeInverseBindingDict (self):

    k = self ; d = {}

    # keys are minibuffer command names, values are shortcuts.
    for shortcut in k.bindingsDict.keys():
        bunchList = k.bindingsDict.get(shortcut,[])
        for b in bunchList:
            shortcutList = d.get(b.commandName,[])
            bunchList = k.bindingsDict.get(shortcut,[g.Bunch(pane='all')])
            for b in bunchList:
                #pane = g.choose(b.pane=='all','','%s:' % (b.pane))
                pane = '%s:' % (b.pane)
                data = (pane,shortcut)
                if data not in shortcutList:
                    shortcutList.append(data)

            d [b.commandName] = shortcutList

    return d
#@-node:ekr.20061031131434.176:computeInverseBindingDict
#@+node:ekr.20061031131434.168:getFileName & helpers
def getFileName (self,event=None,handler=None,prefix='',filterExt='.leo'):

    '''Similar to k.getArg, but uses completion to indicate files on the file system.'''

    k = self ; c = k.c ; gui = g.app.gui
    tag = 'getFileName' ; state = k.getState(tag)
    tabName = 'Completion'
    keysym = gui.eventKeysym(event)
    # g.trace('state',state,'keysym',keysym)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        k.getFileNameHandler = handler
        k.setState(tag,1,k.getFileName)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        c.frame.log.clearTab(tabName)
        c.minibufferWantsFocusNow()
    elif keysym == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        handler = k.getFileNameHandler
        c.frame.log.deleteTab(tabName)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doFileNameTab()
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doFileNameBackSpace() 
        c.minibufferWantsFocus()
    else:
        k.doFileNameChar(event)
    return 'break'
#@+node:ekr.20061031131434.169:<< init altX vars >>
k.filterExt = filterExt
k.mb_prefix = (prefix or k.getLabel())
k.mb_prompt = prefix or k.getLabel()
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
theDir = g.os_path_abspath(os.curdir)
k.extendLabel(theDir,select=False,protect=False)

k.mb_tabListPrefix = k.getLabel()
#@-node:ekr.20061031131434.169:<< init altX vars >>
#@+node:ekr.20061031131434.170:k.doFileNameBackSpace
def doFileNameBackSpace (self):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c

    if 0:
        g.trace(
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    if len(k.mb_tabListPrefix) > len(k.mb_prefix):
        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)
#@-node:ekr.20061031131434.170:k.doFileNameBackSpace
#@+node:ekr.20061031131434.171:k.doFileNameChar
def doFileNameChar (self,event):

    k = self

    # Clear the list, any other character besides tab indicates that a new prefix is in effect.
    k.mb_tabList = []
    k.updateLabel(event)
    k.mb_tabListPrefix = k.getLabel()

    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
    else:
        # Restore everything.
        old = k.getLabel(ignorePrompt=True)[:-1]
        k.setLabel(k.mb_prompt + old)
#@-node:ekr.20061031131434.171:k.doFileNameChar
#@+node:ekr.20061031131434.172:k.doFileNameTab
def doFileNameTab (self):

    k = self
    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
#@-node:ekr.20061031131434.172:k.doFileNameTab
#@+node:ekr.20061031131434.173:k.computeFileNameCompletionList
# This code must not change mb_tabListPrefix.
def computeFileNameCompletionList (self):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    path = k.getLabel(ignorePrompt=True)
    sep = os.path.sep
    tabList = []
    for f in glob.glob(path+'*'):
        if g.os_path_isdir(f):
            tabList.append(f + sep)
        else:
            junk,ext = g.os_path_splitext(f)
            if not ext or ext == k.filterExt:
                tabList.append(f)
    k.mb_tabList = tabList
    junk,common_prefix = g.itemsMatchingPrefixInList(path,tabList)
    if tabList:
        c.frame.log.clearTab(tabName)
        k.showFileNameTabList()
    return common_prefix
#@-node:ekr.20061031131434.173:k.computeFileNameCompletionList
#@+node:ekr.20061031131434.174:k.showFileNameTabList
def showFileNameTabList (self):

    k = self ; tabName = 'Completion'

    for path in k.mb_tabList:
        theDir,fileName = g.os_path_split(path)
        s = g.choose(path.endswith('\\'),theDir,fileName)
        s = fileName or g.os_path_basename(theDir) + '\\'
        g.es(s,tabName=tabName)
#@-node:ekr.20061031131434.174:k.showFileNameTabList
#@-node:ekr.20061031131434.168:getFileName & helpers
#@+node:ekr.20061031131434.179:getShortcutForCommand/Name (should return lists)
def getShortcutForCommandName (self,commandName):

    k = self ; c = k.c

    command = c.commandsDict.get(commandName)

    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == commandName:
                    return k.tkbindingFromStroke(key)
    return ''

def getShortcutForCommand (self,command):

    k = self ; c = k.c

    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == command.__name__:
                     return k.tkbindingFromStroke(key)
    return ''
#@-node:ekr.20061031131434.179:getShortcutForCommand/Name (should return lists)
#@+node:ekr.20061031131434.177:k.doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c

    if 0:
        g.trace('completion',completion,
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    if completion:
        if len(k.mb_tabListPrefix) > len(k.mb_prefix):
            k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
            k.setLabel(k.mb_tabListPrefix)
            k.computeCompletionList(defaultCompletionList,backspace=True)
        # else:
            # k.keyboardQuit(event=None)
    else:
        s = k.getLabel(ignorePrompt=False)
        # g.trace(repr(s),repr(k.mb_prefix))
        if s and len(s) > len(k.mb_prefix):
            k.setLabel(s[:-1])
#@-node:ekr.20061031131434.177:k.doBackSpace
#@+node:ekr.20061031131434.178:k.doTabCompletion
# Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True):

    '''Handle tab completion when the user hits a tab.'''

    k = self ; c = k.c ; s = k.getLabel().strip()

    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        # g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex >= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            k.computeCompletionList(defaultTabList,backspace=False)

    c.minibufferWantsFocusNow()
#@-node:ekr.20061031131434.178:k.doTabCompletion
#@+node:ekr.20061031131434.180:traceBinding
def traceBinding (self,bunch,shortcut,w):

    k = self ; c = k.c ; gui = g.app.gui

    if not c.config.getBool('trace_bindings'): return

    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return

    pane_filter = c.config.getString('trace_bindings_pane_filter')

    if not pane_filter or pane_filter.lower() == bunch.pane:
         g.trace(bunch.pane,shortcut,bunch.commandName,gui.widget_name(w))
#@-node:ekr.20061031131434.180:traceBinding
#@-node:ekr.20061031131434.167:Shared helpers
#@+node:ekr.20061031131434.133:setInputState
def setInputState (self,state,showState=False):

    k = self ; c = k.c ; body = c.frame.body ; w = body.bodyCtrl

    # g.trace(state,g.callers())
    k.unboundKeyAction = state
    k.showStateAndMode()
    assert state in ('insert','command','overwrite')

    if w:
        if state == 'insert':
            bg = k.insert_mode_bg_color ; fg = k.insert_mode_fg_color
        elif state == 'command':
            bg = k.command_mode_bg_color ; fg = k.command_mode_fg_color
        elif state == 'overwrite':
            bg = k.overwrite_mode_bg_color, fg = k.overwrite_mode_fg_color

        # g.trace(id(w),bg,fg,self)

        body.setEditorColors(bg=bg,fg=fg)
#@nonl
#@-node:ekr.20061031131434.133:setInputState
#@+node:ekr.20061031131434.181:Shortcuts (keyHandler)
#@+node:ekr.20061031131434.182:isPlainKey & test
def isPlainKey (self,shortcut):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self ; shortcut = shortcut or ''

    for s in ('Alt','Ctrl','Command'):
        if shortcut.find(s) != -1:
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('<') and shortcut.endswith('>'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut == 'Tab'
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain
#@+node:ekr.20061031131434.183:test_isPlainKey
def test_isPlainKey (self):

    # pychecker complains about c not being used.

    import string

    k = c.k # self is a dummy argument

    for ch in (string.printable):
        if ch == '\n': continue # A special case.
        assert k.isPlainKey(ch), 'wrong: not plain: %s' % (ch)

    special = (
        'Return', # A special case.
        'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
        'KP_F1','KP_F2','KP_F3','KP_F4',
        'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
        'Home','Left','Linefeed','Next','Num_Lock',
        'PageDn','PageUp','Pause','Prior','Right','Up',
        'Sys_Req',
    )

    for ch in special:
        assert not k.isPlainKey(ch), 'wrong: is plain: %s' % (ch)
#@-node:ekr.20061031131434.183:test_isPlainKey
#@-node:ekr.20061031131434.182:isPlainKey & test
#@+node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
def shortcutFromSetting (self,setting):

    k = self

    if not setting:
        return None

    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    # g.trace(setting,shortcut)
    return shortcut

canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting = shortcutFromSetting
#@+node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
#@-node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
#@+node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
#@-node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
#@+node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
#@-node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
#@+node:ekr.20061031131434.188:<< compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    # g.trace(last,last2)
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()

        # New in Leo 4.4.2: Alt-2 is not a key event!
        if last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
#@-node:ekr.20061031131434.188:<< compute the last field >>
#@+node:ekr.20061031131434.189:<< compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])
#@-node:ekr.20061031131434.189:<< compute shortcut >>
#@-node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
#@+node:ekr.20061031131434.190:k.tkbindingFromStroke
def tkbindingFromStroke (self,stroke):

    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''

    stroke = g.stripBrackets(stroke)

    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)

    # g.trace('<%s>' % stroke)
    return '<%s>' % stroke
#@-node:ekr.20061031131434.190:k.tkbindingFromStroke
#@+node:ekr.20061031131434.191:k.prettyPrintKey
def prettyPrintKey (self,stroke,brief=False):

    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0

    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    return g.choose(brief,s,'<%s>' % s)
#@-node:ekr.20061031131434.191:k.prettyPrintKey
#@-node:ekr.20061031131434.181:Shortcuts (keyHandler)
#@+node:ekr.20061031131434.192:showStateAndMode
def showStateAndMode(self):

    k = self ; c = k.c ; frame = c.frame
    state = k.unboundKeyAction
    mode = k.getStateKind()

    if hasattr(frame,'clearStatusLine') and not state.capitalize()=='Insert':
        frame.clearStatusLine()
        put = frame.putStatusLine
        put('Key state: ',color='blue')
        put('%s' % state.capitalize())
        if mode:
            # put(' mode: ',color='blue')
            if mode.endswith('-mode'): mode = mode[:-5]
            mode = mode.replace('-',' ').capitalize()
            put(' Mode: ',color='blue')
            put(mode)

        # Restore the focus.
        c.restoreFocus()
#@-node:ekr.20061031131434.192:showStateAndMode
#@+node:ekr.20061031131434.193:States
#@+node:ekr.20061031131434.194:clearState
def clearState (self):

    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
#@-node:ekr.20061031131434.194:clearState
#@+node:ekr.20061031131434.195:getStateHandler
def getStateHandler (self):

    return self.state.handler
#@-node:ekr.20061031131434.195:getStateHandler
#@+node:ekr.20061031131434.196:getState
def getState (self,kind):

    k = self
    val = g.choose(k.state.kind == kind,k.state.n,0)
    # g.trace(state,'returns',val)
    return val
#@-node:ekr.20061031131434.196:getState
#@+node:ekr.20061031131434.197:getStateKind
def getStateKind (self):

    return self.state.kind
#@-node:ekr.20061031131434.197:getStateKind
#@+node:ekr.20061031131434.198:inState
def inState (self,kind=None):

    k = self

    if kind:
        return k.state.kind == kind and k.state.n != None
    else:
        return k.state.kind and k.state.n != None
#@-node:ekr.20061031131434.198:inState
#@+node:ekr.20061031131434.199:setState
def setState (self,kind,n,handler=None):

    k = self
    if kind and n != None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()

    # k.showStateAndMode()
#@-node:ekr.20061031131434.199:setState
#@-node:ekr.20061031131434.193:States
#@+node:ekr.20061031131434.200:universalDispatcher & helpers
def universalDispatcher (self,event):

    '''Handle accumulation of universal argument.'''

    << about repeat counts >>

    k = self ; gui = g.app.gui
    state = k.getState('u-arg')

    if state == 0:
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        stroke = k.stroke ; keysym = gui.eventKeysym(event)
            # Stroke is <Key> for plain keys, <Control-u> (k.universalArgKey)
        # g.trace(state,stroke)
        if stroke == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif stroke == '<Key>' and (keysym.isdigit() or keysym == u'-'):
            k.updateLabel(event)
        elif stroke == '<Key>' and keysym in (
            'Alt_L','Alt_R',
            'Control_L','Control_R',
            'Shift_L','Shift_R',
        ):
             # g.trace('stroke',k.stroke,'keysym',keysym)
             k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            # g.trace('stroke',k.stroke,'keysym',keysym)
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            # g.trace('val',repr(val),'n',n,'k.repeatCount',k.repeatCount)
            k.clearState()
            k.executeNTimes(event,n)
            k.clearState()
            k.setLabelGrey()
            if 0: # Not ready yet.
                # This takes us to macro state.
                # For example Control-u Control-x ( will execute the last macro and begin editing of it.
                if stroke == '<Control-x>':
                    k.setState('uC',2,k.universalDispatcher)
                    return k.doControlU(event,stroke)
    elif state == 2:
        k.doControlU(event,stroke)

    return 'break'
#@+node:ekr.20061031131434.201:<< about repeat counts >>
@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
#@-node:ekr.20061031131434.201:<< about repeat counts >>
#@+node:ekr.20061031131434.202:executeNTimes
def executeNTimes (self,event,n):

    __pychecker__ = '--no-local' # z is used just for a repeat count.

    k = self ; stroke = k.stroke ; w = event.widget
    # g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        bunchList = k.bindingsDict.get(stroke,[])
        if bunchList:
            b = bunchList[0]
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    # ev = Tk.Event()
                    event = g.Bunch(
                        c = self.c,
                        widget = event.widget,
                        keysym = event.keysym,
                        keycode = event.keycode,
                        char = event.char,
                    )
                k.masterCommand(event,b.f,'<%s>' % stroke)
        else:
            for z in xrange(n):
                g.app.gui.event_generate(w,'<Key>',keycode=event.keycode,keysym=event.keysym)

#@-node:ekr.20061031131434.202:executeNTimes
#@+node:ekr.20061031131434.203:doControlU
def doControlU (self,event,stroke):

    k = self ; c = k.c
    ch = g.app.gui.eventChar(event)

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if ch == '(':
        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
#@-node:ekr.20061031131434.203:doControlU
#@-node:ekr.20061031131434.200:universalDispatcher & helpers
#@-node:ekr.20061031131434.74:class keyHandlerClass
#@-node:ekr.20061031131434:@thin leoKeys.py
#@+node:ekr.20031218072017.3749:@thin leoMenu.py
"""Gui-independent menu handling for Leo."""

@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import string
import sys

@others
#@+node:ekr.20031218072017.3750:class leoMenu
class leoMenu:

    """The base class for all Leo menus."""

    __pychecker__ = '--no-argsused' # base classes have many unused args.

    @others
#@+node:ekr.20031218072017.3751: leoMenu.__init__
def __init__ (self,frame):

    # g.trace('leoMenu',g.callers())

    self.c = c = frame.c
    self.frame = frame
    self.menus = {} # Menu dictionary.
    self.menuShortcuts = {}

    # To aid transition to emacs-style key handling.
    self.useCmdMenu = c.config.getBool('useCmdMenu')

    self.newBinding = True
        # True if using new binding scheme.
        # You can set this to False in an emergency to revert to the old way.

    if 0: # Must be done much later.
        self.defineMenuTables()
#@-node:ekr.20031218072017.3751: leoMenu.__init__
#@+node:ekr.20031218072017.3775:oops
def oops (self):

    print "leoMenu oops:", g.callers(), "should be overridden in subclass"
#@-node:ekr.20031218072017.3775:oops
#@+node:ekr.20031218072017.3776:Gui-independent menu enablers
#@+node:ekr.20031218072017.3777:updateAllMenus
def updateAllMenus (self):

    """The Tk "postcommand" callback called when a click happens in any menu.

    Updates (enables or disables) all menu items."""

    # Allow the user first crack at updating menus.
    c = self.c

    if c and c.exists:
        c.setLog()
        p = c.currentPosition()

        if not g.doHook("menu2",c=c,p=p,v=p):
            self.updateFileMenu()
            self.updateEditMenu()
            self.updateOutlineMenu()
#@nonl
#@-node:ekr.20031218072017.3777:updateAllMenus
#@+node:ekr.20031218072017.3778:updateFileMenu
def updateFileMenu (self):

    c = self.c ; frame = c.frame
    if not c: return

    try:
        enable = frame.menu.enableMenu
        menu = frame.menu.getMenu("File")
        enable(menu,"Revert To Saved", c.canRevert())
        enable(menu,"Open With...", g.app.hasOpenWithMenu)
    except:
        g.es("exception updating File menu")
        g.es_exception()
#@-node:ekr.20031218072017.3778:updateFileMenu
#@+node:ekr.20031218072017.836:updateEditMenu
def updateEditMenu (self):

    c = self.c ; frame = c.frame
    w = c.frame.body.bodyCtrl
    if not c: return
    try:
        # Top level Edit menu...
        enable = frame.menu.enableMenu
        menu = frame.menu.getMenu("Edit")
        c.undoer.enableMenuItems()
        << enable cut/paste >>
        if 0: # Always on for now.
            menu = frame.menu.getMenu("Find...")
            enable(menu,"Find Next",c.canFind())
            flag = c.canReplace()
            enable(menu,"Replace",flag)
            enable(menu,"Replace, Then Find",flag)
        # Edit Body submenu...
        menu = frame.menu.getMenu("Edit Body...")
        enable(menu,"Extract Section",c.canExtractSection())
        enable(menu,"Extract Names",c.canExtractSectionNames())
        enable(menu,"Extract",c.canExtract())
        enable(menu,"Match Brackets",c.canFindMatchingBracket())
    except:
        g.es("exception updating Edit menu")
        g.es_exception()
#@+node:ekr.20040130164211:<< enable cut/paste >>
if frame.body.hasFocus():
    data = w.getSelectedText()
    canCut = data and len(data) > 0
else:
    # This isn't strictly correct, but we can't get the Tk headline selection.
    canCut = True

enable(menu,"Cut",canCut)
enable(menu,"Copy",canCut)

data = g.app.gui.getTextFromClipboard()
canPaste = data and len(data) > 0
enable(menu,"Paste",canPaste)
#@-node:ekr.20040130164211:<< enable cut/paste >>
#@-node:ekr.20031218072017.836:updateEditMenu
#@+node:ekr.20031218072017.3779:updateOutlineMenu
def updateOutlineMenu (self):

    c = self.c ; frame = c.frame
    if not c: return

    p = c.currentPosition()
    hasParent = p.hasParent()
    hasBack = p.hasBack()
    hasNext = p.hasNext()
    hasChildren = p.hasChildren()
    isExpanded = p.isExpanded()
    isCloned = p.isCloned()
    isMarked = p.isMarked()

    try:
        enable = frame.menu.enableMenu
        << enable top level outline menu >>
        << enable expand/contract submenu >>
        << enable move submenu >>
        << enable go to submenu >>
        << enable mark submenu >>
    except:
        g.es("exception updating Outline menu")
        g.es_exception()
#@+node:ekr.20040131171020:<< enable top level outline menu >>
menu = frame.menu.getMenu("Outline")
enable(menu,"Cut Node",c.canCutOutline())
enable(menu,"Delete Node",c.canDeleteHeadline())
enable(menu,"Paste Node",c.canPasteOutline())
enable(menu,"Paste Node As Clone",c.canPasteOutline())
enable(menu,"Clone Node",c.canClone()) # 1/31/04
enable(menu,"Sort Siblings",c.canSortSiblings())
enable(menu,"Hoist",c.canHoist())
enable(menu,"De-Hoist",c.canDehoist())
#@-node:ekr.20040131171020:<< enable top level outline menu >>
#@+node:ekr.20040131171020.1:<< enable expand/Contract submenu >>
menu = frame.menu.getMenu("Expand/Contract...")
enable(menu,"Contract Parent",c.canContractParent())
enable(menu,"Contract Node",hasChildren and isExpanded)
enable(menu,"Contract Or Go Left",(hasChildren and isExpanded) or hasParent)
enable(menu,"Expand Node",hasChildren and not isExpanded)
enable(menu,"Expand Prev Level",hasChildren and isExpanded)
enable(menu,"Expand Next Level",hasChildren)
enable(menu,"Expand To Level 1",hasChildren and isExpanded)
enable(menu,"Expand Or Go Right",hasChildren)
for i in xrange(2,9):
    frame.menu.enableMenu(menu,"Expand To Level " + str(i), hasChildren)
#@-node:ekr.20040131171020.1:<< enable expand/Contract submenu >>
#@+node:ekr.20040131171020.2:<< enable move submenu >>
menu = frame.menu.getMenu("Move...")
enable(menu,"Move Down",c.canMoveOutlineDown())
enable(menu,"Move Left",c.canMoveOutlineLeft())
enable(menu,"Move Right",c.canMoveOutlineRight())
enable(menu,"Move Up",c.canMoveOutlineUp())
enable(menu,"Promote",c.canPromote())
enable(menu,"Demote",c.canDemote())
#@-node:ekr.20040131171020.2:<< enable move submenu >>
#@+node:ekr.20040131171020.3:<< enable go to submenu >>
menu = frame.menu.getMenu("Go To...")
enable(menu,"Go Prev Visited",c.beadPointer > 1)
enable(menu,"Go Next Visited",c.beadPointer + 1 < len(c.beadList))
enable(menu,"Go To Prev Visible",c.canSelectVisBack())
enable(menu,"Go To Next Visible",c.canSelectVisNext())
if 0: # These are too slow.
    enable(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
    enable(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())
enable(menu,"Go To Next Clone",isCloned)
enable(menu,"Go To Prev Node",c.canSelectThreadBack())
enable(menu,"Go To Next Node",c.canSelectThreadNext())
enable(menu,"Go To Parent",hasParent)
enable(menu,"Go To Prev Sibling",hasBack)
enable(menu,"Go To Next Sibling",hasNext)
#@-node:ekr.20040131171020.3:<< enable go to submenu >>
#@+node:ekr.20040131171020.4:<< enable mark submenu >>
menu = frame.menu.getMenu("Mark/Unmark...")
label = g.choose(isMarked,"Unmark","Mark")
frame.menu.setMenuLabel(menu,0,label)
enable(menu,"Mark Subheads",hasChildren)
if 0: # These are too slow.
    enable(menu,"Mark Changed Items",c.canMarkChangedHeadlines())
    enable(menu,"Mark Changed Roots",c.canMarkChangedRoots())
enable(menu,"Mark Clones",isCloned)
#@-node:ekr.20040131171020.4:<< enable mark submenu >>
#@-node:ekr.20031218072017.3779:updateOutlineMenu
#@+node:ekr.20031218072017.3780:hasSelection
# Returns True if text in the outline or body text is selected.

def hasSelection (self):

    c = self.c ; w = c.frame.body.bodyCtrl

    if c.frame.body:
        first,last = w.getSelectionRange()
        return first != last
    else:
        return False
#@-node:ekr.20031218072017.3780:hasSelection
#@-node:ekr.20031218072017.3776:Gui-independent menu enablers
#@+node:ekr.20031218072017.3781:Gui-independent menu routines
#@+node:ekr.20060926213642:capitalizeMinibufferMenuName
def capitalizeMinibufferMenuName (self,s,removeHyphens):

    result = []
    for i in xrange(len(s)):
        ch = s[i]
        prev = i > 0 and s[i-1] or ''
        prevprev = i > 1 and s[i-2] or ''
        if (
            i == 0 or
            i == 1 and prev == '&' or
            prev == '-' or
            prev == '&' and prevprev == '-'
        ):
            result.append(ch.capitalize())
        elif removeHyphens and ch == '-':
            result.append(' ')
        else:
            result.append(ch)
    return ''.join(result)
#@nonl
#@-node:ekr.20060926213642:capitalizeMinibufferMenuName
#@+node:ekr.20031218072017.3785:createMenusFromTables & helpers
def createMenusFromTables (self):

    c = self.c

    self.defineMenuTables()

    self.createFileMenuFromTable()
    self.createEditMenuFromTable()
    self.createOutlineMenuFromTable()

    g.doHook("create-optional-menus",c=c)

    if self.useCmdMenu:
        self.createCmndsMenuFromTable()

    self.createWindowMenuFromTable()
    self.createHelpMenuFromTable()
#@+node:ekr.20031218072017.3790:createFileMenuFromTable
def createFileMenuFromTable (self):

    c = self.c
    fileMenu = self.createNewMenu("&File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    << create the recent files submenu >>
    self.add_separator(fileMenu)
    << create the read/write submenu >>
    << create the tangle submenu >>
    << create the untangle submenu >>
    << create the import submenu >>
    << create the export submenu >>
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)
#@+node:ekr.20031218072017.3791:<< create the recent files submenu >>
self.createNewMenu("Recent &Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
#@-node:ekr.20031218072017.3791:<< create the recent files submenu >>
#@+node:ekr.20031218072017.3792:<< create the read/write submenu >>
readWriteMenu = self.createNewMenu("&Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)
#@-node:ekr.20031218072017.3792:<< create the read/write submenu >>
#@+node:ekr.20031218072017.3793:<< create the tangle submenu >>
tangleMenu = self.createNewMenu("Tan&gle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)
#@-node:ekr.20031218072017.3793:<< create the tangle submenu >>
#@+node:ekr.20031218072017.3794:<< create the untangle submenu >>
untangleMenu = self.createNewMenu("&Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)
#@-node:ekr.20031218072017.3794:<< create the untangle submenu >>
#@+node:ekr.20031218072017.3795:<< create the import submenu >>
importMenu = self.createNewMenu("&Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)
#@-node:ekr.20031218072017.3795:<< create the import submenu >>
#@+node:ekr.20031218072017.3796:<< create the export submenu >>
exportMenu = self.createNewMenu("&Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)
#@-node:ekr.20031218072017.3796:<< create the export submenu >>
#@-node:ekr.20031218072017.3790:createFileMenuFromTable
#@+node:ekr.20031218072017.3786:createEditMenuFromTable
def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    << create the edit body submenu >>
    << create the edit headline submenu >>
    << create the find submenu >>

    self.createMenuEntries(editMenu,self.editMenuTop2Table)
#@+node:ekr.20031218072017.3787:<< create the edit body submenu >>
editBodyMenu = self.createNewMenu("Edit &Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)
#@-node:ekr.20031218072017.3787:<< create the edit body submenu >>
#@+node:ekr.20031218072017.3788:<< create the edit headline submenu >>
editHeadlineMenu = self.createNewMenu("Edit &Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)
#@-node:ekr.20031218072017.3788:<< create the edit headline submenu >>
#@+node:ekr.20031218072017.3789:<< create the find submenu >>
findMenu = self.createNewMenu("&Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)
#@-node:ekr.20031218072017.3789:<< create the find submenu >>
#@-node:ekr.20031218072017.3786:createEditMenuFromTable
#@+node:ekr.20031218072017.3797:createOutlineMenuFromTable
def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&Outline")

    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)

    << create check submenu >>
    << create expand/contract submenu >>
    << create move submenu >>
    << create mark submenu >>
    << create goto submenu >>
#@+node:ekr.20040711140738.1:<< create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
#@-node:ekr.20040711140738.1:<< create check submenu >>
#@+node:ekr.20031218072017.3798:<< create expand/contract submenu >>
expandMenu = self.createNewMenu("E&xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
#@-node:ekr.20031218072017.3798:<< create expand/contract submenu >>
#@+node:ekr.20031218072017.3799:<< create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
#@-node:ekr.20031218072017.3799:<< create move submenu >>
#@+node:ekr.20031218072017.3800:<< create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
#@-node:ekr.20031218072017.3800:<< create mark submenu >>
#@+node:ekr.20031218072017.3801:<< create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
#@-node:ekr.20031218072017.3801:<< create goto submenu >>
#@-node:ekr.20031218072017.3797:createOutlineMenuFromTable
#@+node:ekr.20050921103736:createCmndsMenuFromTable
def createCmndsMenuFromTable (self):

    cmdsMenu = self.createNewMenu('&Cmds')

    if 0: # Now in the minibuffer table.
        # Used in top table: q,u,x
        self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t,u
        ('&Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&ditors',       self.cmdsMenuBodyEditorsTable),
        ('&Buffers...',         self.cmdsMenuBuffersTable),
        ('&Chapters...',        self.cmdsMenuChaptersTable),
        ('C&ursor/Selection...',[]),
        ('&Focus...',           self.cmdsMenuFocusTable),
        ('&Macro...',           self.cmdsMenuMacroTable),
        ('M&inibuffer',         self.cmdsMenuMinibufferTable),
        #('&Panes...',           self.cmdsMenuPanesTable),
        ('&Pickers...',         self.cmdsMenuPickersTable),
        ('&Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&gisters...',       self.cmdsMenuRegistersTable),
        ('R&un Script/Tests',   self.cmdsMenuRunTable),
        ('Scr&olling...',       self.cmdsMenuScrollTable),
        ('Spell C&heck...',     self.cmdsMenuSpellCheckTable),
        ('&Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&ngs',    self.cmdsMenuToggleTable),
    ):
        if table == self.cmdsMenuChaptersTable and not self.c.chapterController:
            continue
        menu = self.createNewMenu(name,'&Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &: b,e,f,s,t,x
        ('Cursor &Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &To...',                self.cursorMenuExtendTable),
        ('Cursor &Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&ursor/Selection...')
        self.createMenuEntries(menu,table)
#@nonl
#@-node:ekr.20050921103736:createCmndsMenuFromTable
#@+node:ekr.20031218072017.3802:createWindowMenuFromTable
def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&Window")

    self.createMenuEntries(windowMenu,self.windowMenuTopTable)
#@-node:ekr.20031218072017.3802:createWindowMenuFromTable
#@+node:ekr.20031218072017.3803:createHelpMenuFromTable
def createHelpMenuFromTable (self):

    if sys.platform == 'darwin':
        self.getMacHelpMenu()
    else:
        helpMenu = self.createNewMenu("&Help")
        self.createMenuEntries(helpMenu,self.helpMenuTable)
#@nonl
#@-node:ekr.20031218072017.3803:createHelpMenuFromTable
#@-node:ekr.20031218072017.3785:createMenusFromTables & helpers
#@+node:ekr.20031218072017.3752:defineMenuTables & helpers
def defineMenuTables (self):

    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()

#@+node:ekr.20031218072017.3753:defineEditMenuTables & helpers
def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
#@+node:ekr.20031218072017.839:defineEditMenuTopTable
def defineEditMenuTopTable (self):

    self.editMenuTopTable = [
        # &: u,r reserved for undo/redo: a,d,p,t,y.
        # & (later): e,g,n,v.
        ("Can't Undo",'undo'),
        ("Can't Redo",'redo'), 
        '-',
        ('Cu&t','cut-text'),
        ('Cop&y','copy-text'),
        ('&Paste','paste-text'),
        ('&Delete','backward-delete-char'),
        ('Select &All','select-all'),
        '-',
    ]
#@-node:ekr.20031218072017.839:defineEditMenuTopTable
#@+node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
def defineEditMenuEditBodyTable (self):

    self.editMenuEditBodyTable = [
        # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
        '*extract-&section',
        '*extract-&names',
        '*&extract',
        '-',
        '*convert-all-b&lanks',
        '*convert-all-t&abs',
        '*convert-&blanks',
        '*convert-&tabs',
        '*insert-body-&time',
        '*&reformat-paragraph',
        '-',
        '*&indent-region',
        '*&unindent-region',
        '*&match-brackets',
        '*add-comments',
        '*delete-comments',
    ]
#@-node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
#@+node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
def defineEditMenuEditHeadlineTable (self):

    self.editMenuEditHeadlineTable = [
        '*edit-&headline',
        '*&end-edit-headline',
        '*&abort-edit-headline',
        '*insert-headline-&time',
        '*toggle-&angle-brackets',
    ]
#@-node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
#@+node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):

    self.editMenuFindMenuTable = [
        # &: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,u,w,x
        '*&open-find-tab',
        '*&hide-find-tab',
        '*search-&with-present-options',
        '-',
        '*find-&next',
        '*find-&prev',
        '*&change',
        '*find-&all',
        '*clone-fi&nd-all',
        '*change-a&ll',
        '-',
        '*&find-character',
        '*find-character-extend-&selection',
        '*&backward-find-character',
        '*backward-find-character-&extend-selection',
        '-',
        '*&isearch-forward',
        '*isea&rch-backward',
        '*isearch-forward-rege&xp',
        '*isearch-backward-regex&p',
        '-',
        '*&query-replace',
        '*q&uery-replace-regex',
    ]
#@-node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
#@+node:ekr.20031218072017.3757:defineEditMenuTop2Table
def defineEditMenuTop2Table (self):

    c = self.c

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&visibles","Show In&visibles")

    self.editMenuTop2Table = [
        '*&goto-global-line',
        '*&execute-script',
        (label,'toggle-invisibles'),
        ("Setti&ngs",'open-leoSettings-leo'),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
#@-node:ekr.20031218072017.3757:defineEditMenuTop2Table
#@-node:ekr.20031218072017.3753:defineEditMenuTables & helpers
#@+node:ekr.20031218072017.3758:defineFileMenuTables & helpers
def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
#@+node:ekr.20031218072017.3759:defineFileMenuTopTable
def defineFileMenuTopTable (self):

    self.fileMenuTopTable = [
        '*&new',
        ('&Open...','open-outline'),
    ]
#@-node:ekr.20031218072017.3759:defineFileMenuTopTable
#@+node:ekr.20031218072017.3760:defineFileMenuTop2Table
def defineFileMenuTop2Table (self):

    self.fileMenuTop2Table = [
        '-',
        ('&Close','close-window'),
        ('&Save','save-file'),
        ('Save &As','save-file-as'),
        ('Save As &Unzipped','save-file-as-unzipped'),
        ('Save As &Zipped','save-file-as-zipped'),
        ('Save &To','save-file-to'),
        ('Re&vert To Saved','revert'),
    ]
#@-node:ekr.20031218072017.3760:defineFileMenuTop2Table
#@+node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
def defineFileMenuReadWriteMenuTable (self):

    self.fileMenuReadWriteMenuTable = [
        '*&read-outline-only',
        ('Read @file &Nodes','read-at-file-nodes'),
        ('Write &Dirty @file Nodes','write-dirty-at-file-nodes'),
        ('Write &Missing @file Nodes','write-missing-at-file-nodes'),
        '*write-&outline-only',
        ('&Write @file Nodes','write-at-file-nodes'),
    ]
#@-node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
#@+node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
def defineFileMenuTangleMenuTable (self):

    self.fileMenuTangleMenuTable = [
        '*tangle-&all',
        '*tangle-&marked',
        '*&tangle',
    ]
#@-node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
#@+node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
def defineFileMenuUntangleMenuTable (self):

    self.fileMenuUntangleMenuTable = [
        '*untangle-&all',
        '*untangle-&marked',
        '*&untangle',
    ]
#@-node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
#@+node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
def defineFileMenuImportMenuTable (self):

    self.fileMenuImportMenuTable = [
        #&: c,d,f,n,o,r,
        '*import-&derived-file',
        ('Import To @&file','import-at-file'),
        ('Import To @&root','import-at-root'),
        '*import-&cweb-files',
        '*import-&noweb-files',
        '*import-flattened-&outline',
    ]
#@-node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
#@+node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
def defineFileMenuExportMenuTable (self):

    self.fileMenuExportMenuTable = [
        '*export-&headlines',
        '*outline-to-&cweb',
        '*outline-to-&noweb',
        '*&flatten-outline',
        '*&remove-sentinels',
        '*&weave',
    ]
#@-node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
#@+node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
def defineFileMenuTop3MenuTable (self):

    self.fileMenuTop3MenuTable = [
        ('E&xit','exit-leo'),
    ]
#@-node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
#@-node:ekr.20031218072017.3758:defineFileMenuTables & helpers
#@+node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
#@+node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
def defineOutlineMenuTopMenuTable (self):

    self.outlineMenuTopMenuTable = [
        '*c&ut-node',
        '*c&opy-node',
        '*&paste-node',
        ('Pas&te Node As Clone','paste-retaining-clones'),
        '*&delete-node',
        '-',
        '*&insert-node',
        '*&clone-node',
        '*sort-childre&n',
        '*&sort-siblings',
        '-',
        '*&hoist',
        ('D&e-Hoist','de-hoist'), # To preserve the '-' in De-Hoist.
        '-',
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
#@-node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
#@+node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
def defineOutlineMenuCheckOutlineMenuTable (self):

    self.outlineMenuCheckOutlineMenuTable = [
        # &: a,c,d,o
        '*check-&outline',
        '*&dump-outline',
        '-',
        '*check-&all-python-code',
        '*&check-python-code',
    ]
#@-node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
#@+node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
def defineOutlineMenuExpandContractMenuTable (self):

    self.outlineMenuExpandContractMenuTable = [
        '*&contract-all',
        '*contract-&node',
        '*contract-&parent',
        '*contract-or-go-&left',
        '-',
        '*expand-p&rev-level',
        '*expand-n&ext-level',
        '*expand-and-go-right',
        '*expand-or-go-right',
        '-',
        '*expand-to-level-&1',
        '*expand-to-level-&2',
        '*expand-to-level-&3',
        '*expand-to-level-&4',
        '*expand-to-level-&5',
        '*expand-to-level-&6',
        '*expand-to-level-&7',
        '*expand-to-level-&8',
        '-',
        '*expand-&all',
        '*expand-n&ode',
    ]
#@-node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
#@+node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
def defineOutlineMenuMoveMenuTable (self):

    self.outlineMenuMoveMenuTable = [
        ('Move &Down','move-outline-down'),
        ('Move &Left','move-outline-left'),
        ('Move &Right','move-outline-right'),
        ('Move &Up','move-outline-up'),
        '-',
        '*&promote',
        '*&demote',
    ]
#@-node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
#@+node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
def defineOutlineMenuMarkMenuTable (self):

    self.outlineMenuMarkMenuTable = [
        '*&mark',
        '*mark-&subheads',
        '*mark-changed-&items',
        '*mark-changed-&roots',
        '*mark-&clones',
        '*&unmark-all',
    ]
#@-node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
#@+node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
def defineOutlineMenuGoToMenuTable (self):

    self.outlineMenuGoToMenuTable = [
        # &: a,c,d,e,g,i,l,m,n,o,p,r,s,t,v,x
        ('Go Prev Visite&d','go-back'),
        ('Go Next Visited','go-forward'),
        ('Go To P&rev Node','goto-prev-node'),
        ('Go To N&ext Node','goto-next-node'),
        '-',
        ('Go To Next &Marked','goto-next-marked'),
        ('Go To Next &Changed','goto-next-changed'),
        ('Go To Next &Clone','goto-next-clone'),
        '-',
        ('&Go To First Node','goto-first-node'),
        ('G&o To Prev Visible','goto-prev-visible'),
        ('Go To Ne&xt Visible','goto-next-visible'),
        ('Go To L&ast Node','goto-last-node'),
        ('Go To Last &Visible','goto-last-visible'),
        '-',
        ('Go To &Parent','goto-parent'),
        ('Go To First &Sibling','goto-first-sibling'),
        ('Go To Last S&ibling','goto-last-sibling'),
        ('Go To Prev Sibli&ng','goto-prev-sibling'),
        ('Go To Next Siblin&g','goto-next-sibling'),
    ]
#@-node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
#@-node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
#@+node:ekr.20050921103230:defineCmdsMenuTables & helpers
def defineCmdsMenuTables (self):

    if 0: # Replaced by minibuffer submenu.
        self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuChaptersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuMinibufferTable()
    self.defineCmdsMenuPickersTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuRunTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()
#@nonl
#@+node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable
def defineCmdsMenuAbbrevTable (self):

    self.cmdsMenuAbbrevTable = [
        # &: a,e,i,k,l,r,w,v
        'abbre&v-mode',
        '-',
        '&list-abbrevs',
        '&read-abbrev-file',
        '&write-abbrev-file',
        '-',
        '&add-global-abbrev',
        '&inverse-add-global-abbrev',
        '&kill-all-abbrevs',
        '-',
        # 'expand-abbrev', # Not a command
        '&expand-region-abbrevs',
    ]
#@-node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable
#@+node:ekr.20060912093104:defineCmdsMenuBodyEditorsTable
def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &: a,c,d
        '&add-editor',
        '&cycle-editor-focus',
        '&delete-editor',
    ]
#@nonl
#@-node:ekr.20060912093104:defineCmdsMenuBodyEditorsTable
#@+node:ekr.20060117095212:defineCmdsMenuBufferTable
def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&append-to-buffer',
        '&kill-buffer',
        'list-&buffers',
        '&list-buffers-alphabetically',
        '&prepend-to-buffer',
        '&rename-buffer',
        '&switch-to-buffer',
    ]
#@-node:ekr.20060117095212:defineCmdsMenuBufferTable
#@+node:ekr.20070604205927:defineCmdsMenuChaptersTable
def defineCmdsMenuChaptersTable (self):

    self.cmdsMenuChaptersTable = [
        '&clone-node-to-chapter',
        'c&opy-node-to-chapter',
        'c&reate-chapter',
        '&move-node-to-chapter',
        '&remove-chapter',
        '&select-chapter',
    ]
#@-node:ekr.20070604205927:defineCmdsMenuChaptersTable
#@+node:ekr.20060924124119:defineCmdsMenuCursorTable
def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &: b,c,l,p,s,v,w
        'back-&char',
        'back-&paragraph',
        'back-&sentence',
        'back-&word',
        '-',
        'beginning-of-&buffer',
        'beginning-of-&line',
        '-',
        'pre&vious-line',
    ]

    self.cursorMeuuBackExtendTable = [
        # &: b,c,l,p,s,v,w
        'back-&char-extend-selection',
        'back-&paragraph-extend-selection',
        'back-&sentence-extend-selection',
        'back-&word-extend-selection',
        '-',
        'beginning-of-&buffer-extend-selection',
        'beginning-of-&line-extend-selection',
        '-',
        'pre&vious-line-extend-selection',
    ]

    self.cursorMenuExtendTable = [
        # &: l,p,s,w
        'extend-to-&line',
        'extend-to-&paragraph',
        'extend-to-&sentence',
        'extend-to-&word',
    ]

    self.cursorMenuForwardTable = [
        # &: b,c,e,l,n,p,s,w
        'end-of-&buffer',
        'end-of-&line',
        '-',
        'forward-&char',
        'forward-&paragraph',
        'forward-&sentence',
        'forward-&end-word',
        'forward-&word',
        '-',
        '&next-line',
    ]

    self.cursorMenuForwardExtendTable = [
        # &: b,c,e,l,n,p,s,w
        'end-of-&buffer-extend-selection',
        'end-of-&line-extend-selection',
        '-',
        'forward-&char-extend-selection',
        'forward-&paragraph-extend-selection',
        'forward-&sentence-extend-selection',
        'forward-&end-word-extend-selection',
        'forward-&word-extend-selection',#
        '-',
        '&next-line-extend-selection',    
    ]
#@nonl
#@-node:ekr.20060924124119:defineCmdsMenuCursorTable
#@+node:ekr.20060923060822:defineCmdsMenuFocusTable
def defineCmdsMenuFocusTable (self):

    self.cmdsMenuFocusTable = [
        '&cycle-all-focus',
        'focus-to-&body',          
        'focus-to-&log',             
        'focus-to-&minibuffer',     
        'focus-to-&tree',             
    ]
#@-node:ekr.20060923060822:defineCmdsMenuFocusTable
#@+node:ekr.20060117114315:defineCmdsMenuMacroTable
def defineCmdsMenuMacroTable (self):

    self.cmdsMenuMacroTable = [
        '&load-file',
        '-',
        '&start-kbd-macro',
        '&end-kbd-macro',
        '&name-last-kbd-macro',
        '-',
        '&call-last-keyboard-macro',
        '&insert-keyboard-macro',
    ]
#@-node:ekr.20060117114315:defineCmdsMenuMacroTable
#@+node:ekr.20061011084101.1:defineCmdsMenuMinibufferTable
def defineCmdsMenuMinibufferTable (self):

    self.cmdsMenuMinibufferTable = [
        # &: f,h,i,q,r,s,v
        '&full-command',
        'keyboard-&quit',
        '&repeat-complex-command',
        '&view-lossage',
        '-',
        '&show-mini-buffer',
        'h&ide-mini-buffer',
        '-',
        '&help-for-minibuffer',
    ]
#@-node:ekr.20061011084101.1:defineCmdsMenuMinibufferTable
#@+node:ekr.20061011085641:defineCmdsMenuPickersTable
def defineCmdsMenuPickersTable (self):

    self. cmdsMenuPickersTable = [
        'show-&colors',
        'show-find-&options',
        'show-&fonts',
    ]
#@nonl
#@-node:ekr.20061011085641:defineCmdsMenuPickersTable
#@+node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable
def defineCmdsMenuRectanglesTable (self):

    self.cmdsMenuRectanglesTable = [
        '&clear-rectangle',
        'c&lose-rectangle',
        '&delete-rectangle',
        '&kill-rectangle',
        '&open-rectangle',
        '&string-rectangle',
        '&yank-rectangle',
    ]
#@-node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable
#@+node:ekr.20060117095212.1:defineCmdsMenuRegistersTable
def defineCmdsMenuRegistersTable (self):

    self.cmdsMenuRegistersTable = [
        # &: a,c,e,i,j,n,p,r,v
        '&append-to-register',
        'copy-r&ectangle-to-register',
        '&copy-to-register',
        'i&ncrement-register',
        '&insert-register',
        '&jump-to-register',
        # 'number-to-register',
        '&point-to-register',
        'p&repend-to-register',
        '&view-register',
    ]
#@-node:ekr.20060117095212.1:defineCmdsMenuRegistersTable
#@+node:ekr.20061119061958:defineCmdsMenuRunTable
def defineCmdsMenuRunTable (self):

    self.cmdsMenuRunTable = [
    # &: e,r
    '&execute-script',
    '&run-unit-tests',
    ]
#@-node:ekr.20061119061958:defineCmdsMenuRunTable
#@+node:ekr.20060923060822.1:defineCmdsMenuScrollTable
def defineCmdsMenuScrollTable (self):

    self.cmdsMenuScrollTable = [
        # &: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&line',
        'scroll-outline-down-&page',
        'scroll-outline-le&ft',
        'scroll-outline-&right',
        's&croll-outline-up-line',
        'scr&oll-outline-up-page',
        '-',
        'scroll-&down',
        'scroll-&up',
        '-',
        'scroll-down-&extend-selection',
        'scroll-up-e&xtend-selection',
    ]
#@nonl
#@-node:ekr.20060923060822.1:defineCmdsMenuScrollTable
#@+node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
def defineCmdsMenuSpellCheckTable (self):

    self.cmdsMenuSpellCheckTable = [
        '&open-spell-tab',
        'spell-&change',
        'spell-change-&then-find',
        'spell-&find',
        'spell-&ignore',
    ]
#@-node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
#@+node:ekr.20060924161901:defineCmdsMenuTextTable
def defineCmdsMenuTextTable (self):

    self.cmdsMenuTextTable = [
        # &: a,b,c,d,e,f,g,i,l,m,n,o,p,r,s,u
        '&beautify',
        'beautify-&all',
        '-',
        'center-&line',
        'center-&region',
        '-',
        '&capitalize-word',
        '&downcase-word',
        '&upcase-word',
        '-',
        'd&owncase-region',
        'u&pcase-region',
        '-',
        '&indent-region',
        'indent-r&elative',
        'indent-ri&gidly',
        'u&nindent-region',
        '-',
        'sort-colu&mns',
        'sort-&fields',
        '&sort-lines',
    ]
#@nonl
#@-node:ekr.20060924161901:defineCmdsMenuTextTable
#@+node:ekr.20060926161940:defineCmdsMenuToggleTable
def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &: d,e,m,s,t,u,v
        'toggle-a&utocompleter',
        'toggle-call&tips',
        'toggle-&extend-mode',
        'toggle-input-&state',
        'toggle-in&visibles',
        'toggle-&mini-buffer',
        'toggle-split-&direction',
        '-',
        # &: a,b,c,f,h,i,r,w,x
        'toggle-find-&ignore-case-option',
        'toggle-find-in-&body-option',
        'toggle-find-in-&headline-option',
        'toggle-find-mark-&changes-option',
        'toggle-find-mark-&finds-option',
        'toggle-find-rege&x-option',
        'toggle-find-&reverse-option',
        'toggle-find-&word-option',
        'toggle-find-wrap-&around-option',
    ]
#@-node:ekr.20060926161940:defineCmdsMenuToggleTable
#@-node:ekr.20050921103230:defineCmdsMenuTables & helpers
#@+node:ekr.20031218072017.3773:defineWindowMenuTables
def defineWindowMenuTables (self):

    self.windowMenuTopTable = [
        # &: a,b,c,d,e,f,l,m,n,o,p,r,s,t,u,w,x,y
        '*&equal-sized-panes',
        '*&toggle-active-pane',
        '*toggle-&split-direction',
        '-',
        '*contract-&body-pane',
        '*contract-&log-pane',
        '*contract-&outline-pane',
        '*contract-&pane',
        '-',
        '*expand-bo&dy-pane',
        '*expand-lo&g-pane',
        '*expand-o&utline-pane',
        '*expand-pa&ne',
        '-',
        '*&fully-expand-body-pane',
        '*full&y-expand-log-pane',
        '*fully-e&xpand-outline-pane',
        '*fully-exp&and-pane',
        '-',
        '*&resize-to-screen',
        '*&cascade-windows',
        '*&minimize-all',
        '-',
        '*open-compare-window',
        '*open-python-&window',
    ]
#@-node:ekr.20031218072017.3773:defineWindowMenuTables
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):

    self.helpMenuTable = [
        # &: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&About Leo...',           'about-leo'),
        ('Online &Home Page',       'open-online-home'),
        '*open-online-&tutorial',
        '*open-&users-guide',
        '-',
        ('Open Leo&Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&Settings.leo',   'open-leoSettings-leo'),
        ('Open &myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&ipts.leo',       'open-scripts-leo'),
        # ('Open t&est.leo',          'open-test-leo'),
        '-',
        '*he&lp-for-minibuffer',
        '*help-for-&command',
        '-',
        '*&apropos-autocompletion',
        '*apropos-&bindings',
        '*apropos-&debugging-commands',
        '*apropos-&find-commands',
        '-',
        '*pri&nt-bindings',
        '*print-c&ommands',
    ]
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20031218072017.3752:defineMenuTables & helpers
#@-node:ekr.20031218072017.3781:Gui-independent menu routines
#@+node:ekr.20051022053758.1:Helpers
#@+node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
def canonicalizeMenuName (self,name):

    return ''.join([ch for ch in name.lower() if ch.isalnum()])

def canonicalizeTranslatedMenuName (self,name):

    return ''.join([ch for ch in name.lower() if ch not in u'& \t\n\r'])

#@-node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
#@+node:ekr.20051022044950:computeOldStyleShortcutKey
def computeOldStyleShortcutKey (self,s):

    '''Compute the old-style shortcut key for @shortcuts entries.'''

    return ''.join([ch for ch in s.strip().lower() if ch.isalnum()])
#@-node:ekr.20051022044950:computeOldStyleShortcutKey
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    # g.trace('c',self.c)

    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
#@+node:ekr.20051021091958:<< get label & command or continue >>
if type(data) == type(''):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20031218072017.3784:createMenuItemsFromTable
def createMenuItemsFromTable (self,menuName,table,dynamicMenu=False):

    try:
        menu = self.getMenu(menuName)
        if menu == None:
            if not g.app.gui.isNullGui:
                print "menu does not exist: ",menuName
                g.es("menu does not exist: ",menuName)
            return
        self.createMenuEntries(menu,table,dynamicMenu=dynamicMenu)
    except:
        s = "exception creating items for %s menu" % menuName
        g.es_print(s)
        g.es_exception()

    g.app.menuWarningsGiven = True
#@-node:ekr.20031218072017.3784:createMenuItemsFromTable
#@+node:ekr.20031218072017.3804:createNewMenu
def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName) # parent may be None.
        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists: " + menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&")
            label = label.replace("&","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&")
                index_label = index_label.replace("&","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating " + menuName + " menu")
        g.es_exception()
        return None
#@-node:ekr.20031218072017.3804:createNewMenu
#@+node:ekr.20031218072017.4116:createOpenWithMenuFromTable & helper
def createOpenWithMenuFromTable (self,table):

    '''Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.'''

    c = self.c
    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except: return
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    self.setMenu("Open With...",openWithMenu)
    # Create the menu items in of the Open With menu.
    for entry in table:
        if len(entry) != 3: # 6/22/03
            g.es("createOpenWithMenuFromTable: invalid data",color="red")
            return
    self.createOpenWithMenuItemsFromTable(openWithMenu,table)
    for entry in table:
        name,shortcut,data = entry
        c.k.bindOpenWith (shortcut,name,data)
#@+node:ekr.20051022043608.1:createOpenWithMenuItemsFromTable
def createOpenWithMenuItemsFromTable (self,menu,table):

    '''Create an entry in the Open with Menu from the table.

    Each entry should be a sequence with 2 or 3 elements.'''

    c = self.c ; k = c.k

    if g.app.unitTesting: return

    for data in table:
        << get label, accelerator & command or continue >>
        # g.trace(label,accelerator)
        realLabel = self.getRealMenuName(label)
        underline=realLabel.find("&")
        realLabel = realLabel.replace("&","")
        callback = self.defineOpenWithMenuCallback(openWithData)

        self.add_command(menu,label=realLabel,
            accelerator=accelerator or '',
            command=callback,underline=underline)
#@+node:ekr.20051022043713.1:<< get label, accelerator & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)

if ok:
    if len(data) == 2:
        label,openWithData = data ; accelerator = None
    else:
        label,accelerator,openWithData = data
        accelerator = k.shortcutFromSetting(accelerator)
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
else:
    g.trace('bad data in Open With table: %s' % repr(data))
    continue # Ignore bad data
#@-node:ekr.20051022043713.1:<< get label, accelerator & command or continue >>
#@-node:ekr.20051022043608.1:createOpenWithMenuItemsFromTable
#@-node:ekr.20031218072017.4116:createOpenWithMenuFromTable & helper
#@+node:ekr.20031218072017.2078:createRecentFilesMenuItems (leoMenu)
def createRecentFilesMenuItems (self):

    c = self.c
    recentFilesMenu = self.getMenu("Recent Files...")

    # Delete all previous entries.
    self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)

    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table)

    # Create all the other entries (a maximum of 36).
    accel_ch = string.digits + string.ascii_uppercase # Not a unicode problem.
    i = 0 ; n = len(accel_ch)
    for name in c.recentFiles[:n]:
        def recentFilesCallback (event=None,c=c,name=name):
            __pychecker__ = '--no-argsused' # event not used, but must be present.
            c.openRecentFile(name)
        label = "%s %s" % (accel_ch[i],g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=recentFilesCallback,underline=0)
        i += 1
#@-node:ekr.20031218072017.2078:createRecentFilesMenuItems (leoMenu)
#@+node:ekr.20031218072017.4117:defineMenuCallback
def defineMenuCallback(self,command,name,minibufferCommand):

    if minibufferCommand:

        # Create a dummy event as a signal to doCommand.
        event = g.Bunch(keysym='',char='',widget='')

        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.

            c = self.c
            return c.doCommand(command,label,event)

        return minibufferMenuCallback

    else:

        # The first parameter must be event, and it must default to None.
        def legacyMenuCallback(event=None,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.

            c = self.c
            return c.doCommand(command,label)

        return legacyMenuCallback
#@-node:ekr.20031218072017.4117:defineMenuCallback
#@+node:ekr.20031218072017.4118:defineOpenWithMenuCallback
def defineOpenWithMenuCallback(self,data):

    # The first parameter must be event, and it must default to None.
    def openWithMenuCallback(event=None,self=self,data=data):
        return self.c.openWith(data=data)

    return openWithMenuCallback
#@-node:ekr.20031218072017.4118:defineOpenWithMenuCallback
#@+node:ekr.20031218072017.3805:deleteMenu
def deleteMenu (self,menuName):

    try:
        menu = self.getMenu(menuName)
        if menu:
            self.destroy(menu)
            self.destroyMenu(menuName)
        else:
            g.es("can't delete menu: " + menuName)
    except:
        g.es("exception deleting " + menuName + " menu")
        g.es_exception()
#@-node:ekr.20031218072017.3805:deleteMenu
#@+node:ekr.20031218072017.3806:deleteMenuItem
def deleteMenuItem (self,itemName,menuName="top"):

    """Delete itemName from the menu whose name is menuName."""

    try:
        menu = self.getMenu(menuName)
        if menu:
            realItemName = self.getRealMenuName(itemName)
            self.delete(menu,realItemName)
        else:
            g.es("menu not found: " + menuName)
    except:
        g.es("exception deleting " + itemName + " from " + menuName + " menu")
        g.es_exception()
#@-node:ekr.20031218072017.3806:deleteMenuItem
#@+node:ekr.20031218072017.3782:get/setRealMenuName & setRealMenuNamesFromTable
# Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):

    cmn = self.canonicalizeTranslatedMenuName(menuName)
    return g.app.realMenuNameDict.get(cmn,menuName)

def setRealMenuName (self,untrans,trans):

    cmn = self.canonicalizeTranslatedMenuName(untrans)
    g.app.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

    try:
        for untrans,trans in table:
            self.setRealMenuName(untrans,trans)
    except:
        g.es("exception in setRealMenuNamesFromTable")
        g.es_exception()
#@-node:ekr.20031218072017.3782:get/setRealMenuName & setRealMenuNamesFromTable
#@+node:ekr.20031218072017.3807:getMenu, setMenu, destroyMenu
def getMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    return self.menus.get(cmn)

def setMenu (self,menuName,menu):

    cmn = self.canonicalizeMenuName(menuName)
    self.menus [cmn] = menu

def destroyMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    del self.menus[cmn]
#@-node:ekr.20031218072017.3807:getMenu, setMenu, destroyMenu
#@-node:ekr.20051022053758.1:Helpers
#@+node:ekr.20031218072017.3808:Must be overridden in menu subclasses
#@+node:ekr.20031218072017.3809:9 Routines with Tk spellings
def add_cascade (self,parent,label,menu,underline):
    self.oops()

def add_command (self,menu,**keys):
    self.oops()

def add_separator(self,menu):
    self.oops()

def bind (self,bind_shortcut,callback):
    self.oops()

def delete (self,menu,realItemName):
    self.oops()

def delete_range (self,menu,n1,n2):
    self.oops()

def destroy (self,menu):
    self.oops()

def insert (self,menuName,position,label,command,underline=None): # New in Leo 4.4.3 a1
    self.oops()

def insert_cascade (self,parent,index,label,menu,underline):
    self.oops()

def new_menu(self,parent,tearoff=0):
    self.oops()
#@-node:ekr.20031218072017.3809:9 Routines with Tk spellings
#@+node:ekr.20031218072017.3810:9 Routines with new spellings
def activateMenu (self,menuName): # New in Leo 4.4b2.
    self.oops()

def clearAccel (self,menu,name):
    self.oops()

def createMenuBar (self,frame):
    self.oops()

if 0: # Now defined in the base class
    def createOpenWithMenuFromTable (self,table):
        self.oops()

    def defineMenuCallback(self,command,name):
        self.oops()

    def defineOpenWithMenuCallback(self,command):
        self.oops()

def disableMenu (self,menu,name):
    self.oops()

def enableMenu (self,menu,name,val):
    self.oops()

def getManuLabel (self,menu):
    __pychecker__ = '--no-argsused' # menu not used.
    self.oops()

def setMenuLabel (self,menu,name,label,underline=-1):
    self.oops()
#@-node:ekr.20031218072017.3810:9 Routines with new spellings
#@-node:ekr.20031218072017.3808:Must be overridden in menu subclasses
#@-node:ekr.20031218072017.3750:class leoMenu
#@+node:ekr.20031218072017.3811:class nullMenu
class nullMenu(leoMenu):

    """A null menu class for testing and batch execution."""

    __pychecker__ = '--no-argsused' # This calss has many unused args.

    @others
#@+node:ekr.20050104094308:ctor
def __init__ (self,frame):

    # Init the base class.
    leoMenu.__init__(self,frame)
#@-node:ekr.20050104094308:ctor
#@+node:ekr.20050104094029:oops
def oops (self):

    # g.trace("leoMenu", g.callers())
    pass
#@-node:ekr.20050104094029:oops
#@-node:ekr.20031218072017.3811:class nullMenu
#@-node:ekr.20031218072017.3749:@thin leoMenu.py
#@-node:ekr.20031218072017.3625:Gui Base classes
#@+node:ekr.20031218072017.3821:Gui Tkinter classes
#@+node:ekr.20031218072017.3838:@thin leoTkinterComparePanel.py
"""Leo's base compare class."""

@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import leoCompare
import leoTkinterDialog
import Tkinter as Tk
import tkFileDialog

class leoTkinterComparePanel (leoCompare.leoCompare,leoTkinterDialog.leoTkinterDialog):

    """A class that creates Leo's compare panel."""

    @others
#@+node:ekr.20031218072017.3839:Birth...
#@+node:ekr.20031218072017.3840: tkinterComparePanel.__init__
def __init__ (self,c):

    # Init the base class.
    leoCompare.leoCompare.__init__ (self,c)
    leoTkinterDialog.leoTkinterDialog.__init__(self,c,"Compare files and directories",resizeable=False)

    if g.app.unitTesting: return

    self.c = c

    << init tkinter compare ivars >>

    # These ivars are set from Entry widgets.
    self.limitCount = 0
    self.limitToExtension = None

    # The default file name in the "output file name" browsers.
    self.defaultOutputFileName = "CompareResults.txt"

    self.createTopFrame()
    self.createFrame()
#@+node:ekr.20031218072017.3841:<< init tkinter compare ivars >>
# Ivars pointing to Tk elements.
self.browseEntries = []
self.extensionEntry = None
self.countEntry = None
self.printButtons = []

# No corresponding ivar in the leoCompare class.
self.useOutputFileVar = Tk.IntVar()

# These all correspond to ivars in leoCompare
self.appendOutputVar             = Tk.IntVar()

self.ignoreBlankLinesVar         = Tk.IntVar()
self.ignoreFirstLine1Var         = Tk.IntVar()
self.ignoreFirstLine2Var         = Tk.IntVar()
self.ignoreInteriorWhitespaceVar = Tk.IntVar()
self.ignoreLeadingWhitespaceVar  = Tk.IntVar()
self.ignoreSentinelLinesVar      = Tk.IntVar()

self.limitToExtensionVar         = Tk.IntVar()
self.makeWhitespaceVisibleVar    = Tk.IntVar()

self.printBothMatchesVar         = Tk.IntVar()
self.printMatchesVar             = Tk.IntVar()
self.printMismatchesVar          = Tk.IntVar()
self.printTrailingMismatchesVar  = Tk.IntVar()
self.stopAfterMismatchVar        = Tk.IntVar()
#@-node:ekr.20031218072017.3841:<< init tkinter compare ivars >>
#@-node:ekr.20031218072017.3840: tkinterComparePanel.__init__
#@+node:ekr.20031218072017.3842:finishCreate (tkComparePanel)
# Initialize ivars from config parameters.

def finishCreate (self):

    c = self.c

    # File names.
    for i,option in (
        (0,"compare_file_1"),
        (1,"compare_file_2"),
        (2,"output_file") ):

        name = c.config.getString(option)
        if name and len(name) > 0:
            e = self.browseEntries[i]
            e.delete(0,"end")
            e.insert(0,name)

    name = c.config.getString("output_file")
    b = g.choose(name and len(name) > 0,1,0)
    self.useOutputFileVar.set(b)

    # File options.
    b = c.config.getBool("ignore_first_line_of_file_1")
    if b == None: b = 0
    self.ignoreFirstLine1Var.set(b)

    b = c.config.getBool("ignore_first_line_of_file_2")
    if b == None: b = 0
    self.ignoreFirstLine2Var.set(b)

    b = c.config.getBool("append_output_to_output_file")
    if b == None: b = 0
    self.appendOutputVar.set(b)

    ext = c.config.getString("limit_directory_search_extension")
    b = ext and len(ext) > 0
    b = g.choose(b and b != 0,1,0)
    self.limitToExtensionVar.set(b)
    if b:
        e = self.extensionEntry
        e.delete(0,"end")
        e.insert(0,ext)

    # Print options.
    b = c.config.getBool("print_both_lines_for_matches")
    if b == None: b = 0
    self.printBothMatchesVar.set(b)

    b = c.config.getBool("print_matching_lines")
    if b == None: b = 0
    self.printMatchesVar.set(b)

    b = c.config.getBool("print_mismatching_lines")
    if b == None: b = 0
    self.printMismatchesVar.set(b)

    b = c.config.getBool("print_trailing_lines")
    if b == None: b = 0
    self.printTrailingMismatchesVar.set(b)

    n = c.config.getInt("limit_count")
    b = n and n > 0
    b = g.choose(b and b != 0,1,0)
    self.stopAfterMismatchVar.set(b)
    if b:
        e = self.countEntry
        e.delete(0,"end")
        e.insert(0,str(n))

    # bool options...
    for option,var,default in (
        # Whitespace options.
        ("ignore_blank_lines",self.ignoreBlankLinesVar,1),
        ("ignore_interior_whitespace",self.ignoreInteriorWhitespaceVar,0),
        ("ignore_leading_whitespace",self.ignoreLeadingWhitespaceVar,0),
        ("ignore_sentinel_lines",self.ignoreSentinelLinesVar,0),
        ("make_whitespace_visible", self.makeWhitespaceVisibleVar,0),
    ):
        b = c.config.getBool(option)
        if b is None: b = default
        var.set(b)

    if 0: # old code
        b = c.config.getBool("ignore_blank_lines")
        if b == None: b = 1 # unusual default.
        self.ignoreBlankLinesVar.set(b)

        b = c.config.getBool("ignore_interior_whitespace")
        if b == None: b = 0
        self.ignoreInteriorWhitespaceVar.set(b)

        b = c.config.getBool("ignore_leading_whitespace")
        if b == None: b = 0
        self.ignoreLeadingWhitespaceVar.set(b)

        b = c.config.getBool("ignore_sentinel_lines")
        if b == None: b = 0
        self.ignoreSentinelLinesVar.set(b)

        b = c.config.getBool("make_whitespace_visible")
        if b == None: b = 0
        self.makeWhitespaceVisibleVar.set(b)
#@-node:ekr.20031218072017.3842:finishCreate (tkComparePanel)
#@+node:ekr.20031218072017.3843:createFrame (tkComparePanel)
def createFrame (self):

    gui = g.app.gui ; top = self.top

    << create the organizer frames >>
    << create the browser rows >>
    << create the extension row >>
    << create the whitespace options frame >>
    << create the print options frame >>
    << create the compare buttons >>

    gui.center_dialog(top) # Do this _after_ building the dialog!
    self.finishCreate()
    top.protocol("WM_DELETE_WINDOW", self.onClose)
#@+node:ekr.20031218072017.3844:<< create the organizer frames >>
outer = Tk.Frame(self.frame, bd=2,relief="groove")
outer.pack(pady=4)

row1 = Tk.Frame(outer)
row1.pack(pady=4)

row2 = Tk.Frame(outer)
row2.pack(pady=4)

row3 = Tk.Frame(outer)
row3.pack(pady=4)

row4 = Tk.Frame(outer)
row4.pack(pady=4,expand=1,fill="x") # for left justification.

options = Tk.Frame(outer)
options.pack(pady=4)

ws = Tk.Frame(options)
ws.pack(side="left",padx=4)

pr = Tk.Frame(options)
pr.pack(side="right",padx=4)

lower = Tk.Frame(outer)
lower.pack(pady=6)
#@-node:ekr.20031218072017.3844:<< create the organizer frames >>
#@+node:ekr.20031218072017.3845:<< create the browser rows >>
for row,text,text2,command,var in (
    (row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
    (row2,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
    (row3,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

    lab = Tk.Label(row,anchor="e",text=text,width=13)
    lab.pack(side="left",padx=4)

    e = Tk.Entry(row)
    e.pack(side="left",padx=2)
    self.browseEntries.append(e)

    b = Tk.Button(row,text="browse...",command=command)
    b.pack(side="left",padx=6)

    b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
    b.pack(side="left")
#@-node:ekr.20031218072017.3845:<< create the browser rows >>
#@+node:ekr.20031218072017.3846:<< create the extension row >>
b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
    text="Limit directory compares to type:")
b.pack(side="left",padx=4)

self.extensionEntry = e = Tk.Entry(row4,width=6)
e.pack(side="left",padx=2)

b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
    text="Append output to output file")
b.pack(side="left",padx=4)
#@-node:ekr.20031218072017.3846:<< create the extension row >>
#@+node:ekr.20031218072017.3847:<< create the whitespace options frame >>
w,f = gui.create_labeled_frame(ws,caption="Whitespace options",relief="groove")

for text,var in (
    ("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
    ("Ignore blank lines",        self.ignoreBlankLinesVar),
    ("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
    ("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
    ("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):

    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w")

spacer = Tk.Frame(f)
spacer.pack(padx="1i")
#@-node:ekr.20031218072017.3847:<< create the whitespace options frame >>
#@+node:ekr.20031218072017.3848:<< create the print options frame >>
w,f = gui.create_labeled_frame(pr,caption="Print options",relief="groove")

row = Tk.Frame(f)
row.pack(expand=1,fill="x")

b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
b.pack(side="left",anchor="w")

self.countEntry = e = Tk.Entry(row,width=4)
e.pack(side="left",padx=2)
e.insert(01,"1")

lab = Tk.Label(row,text="mismatches")
lab.pack(side="left",padx=2)

for padx,text,var in (    
    (0,  "Print matched lines",           self.printMatchesVar),
    (20, "Show both matching lines",      self.printBothMatchesVar),
    (0,  "Print mismatched lines",        self.printMismatchesVar),
    (0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):

    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w",padx=padx)
    self.printButtons.append(b)

# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
b.configure(command=self.onPrintMatchedLines)

spacer = Tk.Frame(f)
spacer.pack(padx="1i")
#@-node:ekr.20031218072017.3848:<< create the print options frame >>
#@+node:ekr.20031218072017.3849:<< create the compare buttons >>
for text,command in (
    ("Compare files",      self.onCompareFiles),
    ("Compare directories",self.onCompareDirectories) ):

    b = Tk.Button(lower,text=text,command=command,width=18)
    b.pack(side="left",padx=6)
#@-node:ekr.20031218072017.3849:<< create the compare buttons >>
#@-node:ekr.20031218072017.3843:createFrame (tkComparePanel)
#@+node:ekr.20031218072017.3850:setIvarsFromWidgets
def setIvarsFromWidgets (self):

    # File paths: checks for valid file name.
    e = self.browseEntries[0]
    self.fileName1 = e.get()

    e = self.browseEntries[1]
    self.fileName2 = e.get()

    # Ignore first line settings.
    self.ignoreFirstLine1 = self.ignoreFirstLine1Var.get()
    self.ignoreFirstLine2 = self.ignoreFirstLine2Var.get()

    # Output file: checks for valid file name.
    if self.useOutputFileVar.get():
        e = self.browseEntries[2]
        name = e.get()
        if name != None and len(name) == 0:
            name = None
        self.outputFileName = name
    else:
        self.outputFileName = None

    # Extension settings.
    if self.limitToExtensionVar.get():
        self.limitToExtension = self.extensionEntry.get()
        if len(self.limitToExtension) == 0:
            self.limitToExtension = None
    else:
        self.limitToExtension = None

    self.appendOutput = self.appendOutputVar.get()

    # Whitespace options.
    self.ignoreBlankLines         = self.ignoreBlankLinesVar.get()
    self.ignoreInteriorWhitespace = self.ignoreInteriorWhitespaceVar.get()
    self.ignoreLeadingWhitespace  = self.ignoreLeadingWhitespaceVar.get()
    self.ignoreSentinelLines      = self.ignoreSentinelLinesVar.get()
    self.makeWhitespaceVisible    = self.makeWhitespaceVisibleVar.get()

    # Print options.
    self.printMatches            = self.printMatchesVar.get()
    self.printMismatches         = self.printMismatchesVar.get()
    self.printTrailingMismatches = self.printTrailingMismatchesVar.get()

    if self.printMatches:
        self.printBothMatches = self.printBothMatchesVar.get()
    else:
        self.printBothMatches = False

    if self.stopAfterMismatchVar.get():
        try:
            count = self.countEntry.get()
            self.limitCount = int(count)
        except: self.limitCount = 0
    else:
        self.limitCount = 0
#@-node:ekr.20031218072017.3850:setIvarsFromWidgets
#@-node:ekr.20031218072017.3839:Birth...
#@+node:ekr.20031218072017.3851:bringToFront
def bringToFront(self):

    self.top.deiconify()
    self.top.lift()
#@-node:ekr.20031218072017.3851:bringToFront
#@+node:ekr.20031218072017.3852:browser
def browser (self,n):

    types = [
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py"),
        ("Text files","*.txt"),
        ("All files","*") ]

    fileName = tkFileDialog.askopenfilename(
        title="Choose compare file" + n,
        filetypes=types,
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        # The dialog also warns about this, so this may never happen.
        if not g.os_path_exists(fileName):
            self.show("not found: " + fileName)
            fileName = None
    else: fileName = None

    return fileName
#@-node:ekr.20031218072017.3852:browser
#@+node:ekr.20031218072017.3853:Event handlers...
#@+node:ekr.20031218072017.3854:onBrowse...
def onBrowse1 (self):

    fileName = self.browser("1")
    if fileName:
        e = self.browseEntries[0]
        e.delete(0,"end")
        e.insert(0,fileName)
    self.top.deiconify()

def onBrowse2 (self):

    fileName = self.browser("2")
    if fileName:
        e = self.browseEntries[1]
        e.delete(0,"end")
        e.insert(0,fileName)
    self.top.deiconify()

def onBrowse3 (self): # Get the name of the output file.

    fileName = tkFileDialog.asksaveasfilename(
        initialfile = self.defaultOutputFileName,
        title="Set output file",
        filetypes=[("Text files", "*.txt")],
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        self.defaultOutputFileName = fileName
        self.useOutputFileVar.set(1) # The user will expect this.
        e = self.browseEntries[2]
        e.delete(0,"end")
        e.insert(0,fileName)
#@-node:ekr.20031218072017.3854:onBrowse...
#@+node:ekr.20031218072017.3855:onClose
def onClose (self):

    self.top.withdraw()
#@-node:ekr.20031218072017.3855:onClose
#@+node:ekr.20031218072017.3856:onCompare...
def onCompareDirectories (self):

    self.setIvarsFromWidgets()
    self.compare_directories(self.fileName1,self.fileName2)

def onCompareFiles (self):

    self.setIvarsFromWidgets()
    self.compare_files(self.fileName1,self.fileName2)
#@-node:ekr.20031218072017.3856:onCompare...
#@+node:ekr.20031218072017.3857:onPrintMatchedLines
def onPrintMatchedLines (self):

    v = self.printMatchesVar.get()
    b = self.printButtons[1]
    state = g.choose(v,"normal","disabled")
    b.configure(state=state)
#@-node:ekr.20031218072017.3857:onPrintMatchedLines
#@-node:ekr.20031218072017.3853:Event handlers...
#@-node:ekr.20031218072017.3838:@thin leoTkinterComparePanel.py
#@+node:ekr.20031218072017.3858:@thin leoTkinterDialog.py
@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import string

import Tkinter as Tk

Pmw = g.importExtension("Pmw",    pluginName='LeoTkinterDialog',verbose=True,required=True)

@others
#@+node:ekr.20031218072017.3859: class leoTkinterDialog
class leoTkinterDialog:
    """The base class for all Leo Tkinter dialogs"""
    @others
#@+node:ekr.20031218072017.3860:__init__ (tkDialog)
def __init__(self,c,title="",resizeable=True,canClose=True,show=True):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.c = c # For use by delayed focus methods in c.frame.
    self.resizeable = resizeable
    self.title = title
    self.modal = None

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # g.app.root
    self.showFlag = show
    self.top = None # The toplevel Tk widget.
    self.focus_widget = None # The widget to get the first focus.
    self.canClose = canClose
#@-node:ekr.20031218072017.3860:__init__ (tkDialog)
#@+node:ekr.20031218072017.3861:cancelButton, noButton, okButton, yesButton
def cancelButton(self):

    """Do default click action in cancel button."""

    self.answer="cancel"
    self.top.destroy()

def noButton(self):

    """Do default click action in no button."""

    self.answer="no"
    self.top.destroy()

def okButton(self):

    """Do default click action in ok button."""

    self.answer="ok"
    self.top.destroy()

def yesButton(self):

    """Do default click action in yes button."""

    self.answer="yes"
    self.top.destroy()
#@-node:ekr.20031218072017.3861:cancelButton, noButton, okButton, yesButton
#@+node:ekr.20031218072017.3862:center
def center(self):

    """Center any leoTkinterDialog."""

    g.app.gui.center_dialog(self.top)
#@-node:ekr.20031218072017.3862:center
#@+node:ekr.20031218072017.3863:createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@-node:ekr.20031218072017.3863:createButtons
#@+node:ekr.20031218072017.3864:createMessageFrame
def createMessageFrame (self,message):

    """Create a frame containing a Tk.Label widget."""

    label = Tk.Label(self.frame,text=message)
    label.pack(pady=10)
#@-node:ekr.20031218072017.3864:createMessageFrame
#@+node:ekr.20031218072017.3865:createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    if g.app.unitTesting: return

    self.root = g.app.root
    # g.trace("leoTkinterDialog",'root',self.root)

    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)

    if not self.resizeable:
        self.top.resizable(0,0) # neither height or width is resizable.

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    if not self.canClose:
        self.top.protocol("WM_DELETE_WINDOW", self.onClose)

    # Do this at idle time.
    def attachIconCallback(top=self.top):
        g.app.gui.attachLeoIcon(top)

    self.top.after_idle(attachIconCallback)
#@-node:ekr.20031218072017.3865:createTopFrame
#@+node:ekr.20040731065422:onClose
def onClose (self):

    """Disable all attempts to close this frame with the close box."""

    pass
#@-node:ekr.20040731065422:onClose
#@+node:ekr.20031218072017.3866:run (tkDialog)
def run (self,modal):

    """Run a leoTkinterDialog."""

    if g.app.unitTesting: return None

    c = self.c ; self.modal = modal

    self.center() # Do this after all packing complete.
    if self.showFlag:
        self.top.lift()
    else:
        self.top.withdraw()

    # Get all keystrokes.
    if self.modal:
        self.top.grab_set() # Make the dialog a modal dialog.

    if self.focus_widget == None:
        self.focus_widget = self.top

    c and c.widgetWantsFocusNow(self.focus_widget)

    self.root.wait_window(self.top)

    if self.modal:
        return self.answer
    else:
        return None
#@-node:ekr.20031218072017.3866:run (tkDialog)
#@-node:ekr.20031218072017.3859: class leoTkinterDialog
#@+node:ekr.20031218072017.3867:class tkinterAboutLeo
class tkinterAboutLeo (leoTkinterDialog):

    """A class that creates the Tkinter About Leo dialog."""

    @others
#@+node:ekr.20031218072017.3868:tkinterAboutLeo.__init__
def __init__ (self,c,version,theCopyright,url,email):

    """Create a Tkinter About Leo dialog."""

    leoTkinterDialog.__init__(self,c,"About Leo",resizeable=True) # Initialize the base class.

    if g.app.unitTesting: return

    self.copyright = theCopyright
    self.email = email
    self.url = url
    self.version = version

    c.inCommand = False # Allow the app to close immediately.

    self.createTopFrame()
    self.createFrame()
#@-node:ekr.20031218072017.3868:tkinterAboutLeo.__init__
#@+node:ekr.20031218072017.3869:tkinterAboutLeo.createFrame
def createFrame (self):

    """Create the frame for an About Leo dialog."""

    if g.app.unitTesting: return

    frame = self.frame
    theCopyright = self.copyright ; email = self.email
    url = self.url ; version = self.version

    # Calculate the approximate height & width. (There are bugs in Tk here.)
    lines = string.split(theCopyright,'\n')
    height = len(lines) + 8 # Add lines for version,url,email,spacing.
    width = 0
    for line in lines:
        width = max(width,len(line))
    width = max(width,len(url))
    width += 10 # 9/9/02

    frame.pack(padx=6,pady=4)

    self.text = w = g.app.gui.plainTextWidget(
        frame,height=height,width=width,bd=0,bg=frame.cget("background"))
    w.pack(pady=10)

    try:
        bitmap_name = g.os_path_join(g.app.loadDir,"..","Icons","Leoapp.GIF") # 5/12/03
        image = Tk.PhotoImage(file=bitmap_name)
        w.image_create("1.0",image=image,padx=10)
    except Exception:
        pass # This can sometimes happen for mysterious reasons.

    w.insert("end",version) #,tag="version")
    w.tag_add('version','end-%dc' %(len(version)+1),'end-1c')
    w.insert("end",theCopyright) #,tag="copyright")
    w.tag_add('copyright','end-%dc' %(len(theCopyright)+1),'end-1c')
    w.insert("end",'\n')
    w.insert("end",url)
    w.tag_add('url','end-%dc' %(len(url)+1),'end-1c')
    w.insert("end",'\n')
    w.insert("end",email)
    w.tag_add('url','end-%dc' %(len(email)+1),'end-1c')

    w.tag_config("version",justify="center")
    w.tag_config("copyright",justify="center",spacing1="3")
    w.tag_config("url",underline=1,justify="center",spacing1="10")

    w.tag_bind("url","<Button-1>",self.onAboutLeoUrl)
    w.tag_bind("url","<Enter>",self.setArrowCursor)
    w.tag_bind("url","<Leave>",self.setDefaultCursor)

    w.tag_config("email",underline=1,justify="center",spacing1="10")
    w.tag_bind("email","<Button-1>",self.onAboutLeoEmail)
    w.tag_bind("email","<Enter>",self.setArrowCursor)
    w.tag_bind("email","<Leave>",self.setDefaultCursor)

    w.configure(state="disabled")
#@-node:ekr.20031218072017.3869:tkinterAboutLeo.createFrame
#@+node:ekr.20031218072017.3870:tkinterAboutLeo.onAboutLeoEmail
def onAboutLeoEmail(self,event=None):

    """Handle clicks in the email link in an About Leo dialog."""

    __pychecker__ = '--no-argsused' # the event param must be present.

    try:
        import webbrowser
        webbrowser.open("mailto:" + self.email)
    except:
        g.es("not found: " + self.email)
#@-node:ekr.20031218072017.3870:tkinterAboutLeo.onAboutLeoEmail
#@+node:ekr.20031218072017.3871:tkinterAboutLeo.onAboutLeoUrl
def onAboutLeoUrl(self,event=None):

    """Handle clicks in the url link in an About Leo dialog."""

    __pychecker__ = '--no-argsused' # the event param must be present.

    try:
        import webbrowser
        webbrowser.open(self.url)
    except:
        g.es("not found: " + self.url)
#@-node:ekr.20031218072017.3871:tkinterAboutLeo.onAboutLeoUrl
#@+node:ekr.20031218072017.3872:tkinterAboutLeo: setArrowCursor, setDefaultCursor
def setArrowCursor (self,event=None):

    """Set the cursor to an arrow in an About Leo dialog."""

    __pychecker__ = '--no-argsused' # the event param must be present.

    self.text.configure(cursor="arrow")

def setDefaultCursor (self,event=None):

    """Set the cursor to the default cursor in an About Leo dialog."""

    __pychecker__ = '--no-argsused' # the event param must be present.

    self.text.configure(cursor="xterm")
#@-node:ekr.20031218072017.3872:tkinterAboutLeo: setArrowCursor, setDefaultCursor
#@-node:ekr.20031218072017.3867:class tkinterAboutLeo
#@+node:ekr.20031218072017.1983:class tkinterAskLeoID
class tkinterAskLeoID (leoTkinterDialog):

    """A class that creates the Tkinter About Leo dialog."""

    @others
#@+node:ekr.20031218072017.1984:tkinterAskLeoID.__init__
def __init__(self,c=None):

    """Create the Leo Id dialog."""

    # Initialize the base class: prevent clicks in the close box from closing.
    leoTkinterDialog.__init__(self,c,"Enter unique id",resizeable=False,canClose=False)

    if g.app.unitTesting: return

    self.id_entry = None
    self.answer = None

    self.createTopFrame()
    self.top.bind("<Key>", self.onKey)

    message = (
        "leoID.txt not found\n\n" +
        "Please enter an id that identifies you uniquely.\n" +
        "Your cvs login name is a good choice.\n\n" +
        "Your id must contain only letters and numbers\n" +
        "and must be at least 3 characters in length.")
    self.createFrame(message)
    self.focus_widget = self.id_entry

    buttons = {"text":"OK","command":self.onButton,"default":True}, # Singleton tuple.
    buttonList = self.createButtons(buttons)
    self.ok_button = buttonList[0]
    self.ok_button.configure(state="disabled")
#@-node:ekr.20031218072017.1984:tkinterAskLeoID.__init__
#@+node:ekr.20031218072017.1985:tkinterAskLeoID.createFrame
def createFrame(self,message):

    """Create the frame for the Leo Id dialog."""

    if g.app.unitTesting: return

    f = self.frame

    label = Tk.Label(f,text=message)
    label.pack(pady=10)

    self.id_entry = text = Tk.Entry(f,width=20)
    text.pack()
#@-node:ekr.20031218072017.1985:tkinterAskLeoID.createFrame
#@+node:ekr.20031218072017.1987:tkinterAskLeoID.onButton
def onButton(self):

    """Handle clicks in the Leo Id close button."""

    s = self.id_entry.get().strip()
    if len(s) < 3:  # Require at least 3 characters in an id.
        return

    self.answer = g.app.leoID = s

    self.top.destroy() # terminates wait_window
    self.top = None
#@-node:ekr.20031218072017.1987:tkinterAskLeoID.onButton
#@+node:ekr.20031218072017.1988:tkinterAskLeoID.onKey
def onKey(self,event):

    """Handle keystrokes in the Leo Id dialog."""

    << eliminate invalid characters >>
    << enable the ok button if there are 3 or more valid characters >>

    ch = event.char.lower()
    if ch in ('\n','\r'):
        self.onButton()
    return "break"
#@+node:ekr.20031218072017.1989:<< eliminate invalid characters >>
e = self.id_entry
s = e.get().strip()
i = 0 ; ok = True
while i < len(s):
    ch = s[i]
    if not ch.isalnum():
        e.delete(str(i))
        s = e.get()
        ok = False
    else:
        i += 1
if not ok: return
#@-node:ekr.20031218072017.1989:<< eliminate invalid characters >>
#@+node:ekr.20031218072017.1990:<< enable the ok button if there are 3 or more valid characters >>
e = self.id_entry
b = self.ok_button

if len(e.get().strip()) >= 3:
    b.configure(state="normal")
else:
    b.configure(state="disabled")
#@-node:ekr.20031218072017.1990:<< enable the ok button if there are 3 or more valid characters >>
#@-node:ekr.20031218072017.1988:tkinterAskLeoID.onKey
#@-node:ekr.20031218072017.1983:class tkinterAskLeoID
#@+node:ekr.20031218072017.3873:class tkinterAskOk
class tkinterAskOk(leoTkinterDialog):

    """A class that creates a Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20031218072017.3874:class tkinterAskOk.__init__
def __init__ (self,c,title,message=None,text="Ok",resizeable=False):

    """Create a dialog with one button"""

    leoTkinterDialog.__init__(self,c,title,resizeable) # Initialize the base class.

    if g.app.unitTesting: return

    self.text = text
    self.createTopFrame()
    self.top.bind("<Key>", self.onKey)

    if message:
        self.createMessageFrame(message)

    buttons = {"text":text,"command":self.okButton,"default":True}, # Singleton tuple.
    self.createButtons(buttons)
#@-node:ekr.20031218072017.3874:class tkinterAskOk.__init__
#@+node:ekr.20031218072017.3875:class tkinterAskOk.onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    ch = event.char.lower()

    if ch in (self.text[0].lower(),'\n','\r'):
        self.okButton()

    return "break"
#@-node:ekr.20031218072017.3875:class tkinterAskOk.onKey
#@-node:ekr.20031218072017.3873:class tkinterAskOk
#@+node:ekr.20031218072017.3876:class tkinterAskOkCancelNumber
class  tkinterAskOkCancelNumber (leoTkinterDialog):

    """Create and run a modal Tkinter dialog to get a number."""

    @others
#@+node:ekr.20031218072017.3877:tkinterAskOKCancelNumber.__init__
def __init__ (self,c,title,message):

    """Create a number dialog"""

    leoTkinterDialog.__init__(self,c,title,resizeable=False) # Initialize the base class.

    if g.app.unitTesting: return

    self.answer = -1
    self.number_entry = None

    self.createTopFrame()
    self.top.bind("<Key>", self.onKey)

    self.createFrame(message)
    self.focus_widget = self.number_entry

    buttons = (
            {"text":"Ok",    "command":self.okButton,     "default":True},
            {"text":"Cancel","command":self.cancelButton} )
    buttonList = self.createButtons(buttons)
    self.ok_button = buttonList[0] # Override the default kind of Ok button.
#@-node:ekr.20031218072017.3877:tkinterAskOKCancelNumber.__init__
#@+node:ekr.20031218072017.3878:tkinterAskOKCancelNumber.createFrame
def createFrame (self,message):

    """Create the frame for a number dialog."""

    if g.app.unitTesting: return

    c = self.c

    lab = Tk.Label(self.frame,text=message)
    lab.pack(pady=10,side="left")

    self.number_entry = w = Tk.Entry(self.frame,width=20)
    w.pack(side="left")

    c.set_focus(w)
#@-node:ekr.20031218072017.3878:tkinterAskOKCancelNumber.createFrame
#@+node:ekr.20031218072017.3879:tkinterAskOKCancelNumber.okButton, cancelButton
def okButton(self):

    """Handle clicks in the ok button of a number dialog."""

    s = self.number_entry.get().strip()

    try:
        self.answer=int(s)
    except:
        self.answer=-1 # Cancel the operation.

    self.top.destroy()

def cancelButton(self):

    """Handle clicks in the cancel button of a number dialog."""

    self.answer=-1
    self.top.destroy()
#@-node:ekr.20031218072017.3879:tkinterAskOKCancelNumber.okButton, cancelButton
#@+node:ekr.20031218072017.3880:tkinterAskOKCancelNumber.onKey
def onKey (self,event):

    << eliminate non-numbers >>

    ch = event.char.lower()

    if ch in ('o','\n','\r'):
        self.okButton()
    elif ch == 'c':
        self.cancelButton()

    return "break"
#@+node:ekr.20031218072017.3881:<< eliminate non-numbers >>
e = self.number_entry
s = e.get().strip()

i = 0
while i < len(s):
    ch = s[i]
    if not ch.isdigit():
        e.delete(str(i))
        s = e.get()
    else:
        i += 1
#@-node:ekr.20031218072017.3881:<< eliminate non-numbers >>
#@-node:ekr.20031218072017.3880:tkinterAskOKCancelNumber.onKey
#@-node:ekr.20031218072017.3876:class tkinterAskOkCancelNumber
#@+node:ekr.20070122103505:class tkinterAskOkCancelString
class  tkinterAskOkCancelString (leoTkinterDialog):

    """Create and run a modal Tkinter dialog to get a string."""

    @others
#@+node:ekr.20070122103505.1:tkinterAskOKCancelString.__init__
def __init__ (self,c,title,message):

    """Create a number dialog"""

    leoTkinterDialog.__init__(self,c,title,resizeable=False) # Initialize the base class.

    if g.app.unitTesting: return

    self.answer = -1
    self.number_entry = None

    self.createTopFrame()
    self.top.bind("<Key>", self.onKey)

    self.createFrame(message)
    self.focus_widget = self.number_entry

    buttons = (
            {"text":"Ok",    "command":self.okButton,     "default":True},
            {"text":"Cancel","command":self.cancelButton} )
    buttonList = self.createButtons(buttons)
    self.ok_button = buttonList[0] # Override the default kind of Ok button.
#@-node:ekr.20070122103505.1:tkinterAskOKCancelString.__init__
#@+node:ekr.20070122103505.2:tkinterAskOkCancelString.createFrame
def createFrame (self,message):

    """Create the frame for a number dialog."""

    if g.app.unitTesting: return

    c = self.c

    lab = Tk.Label(self.frame,text=message)
    lab.pack(pady=10,side="left")

    self.number_entry = w = Tk.Entry(self.frame,width=20)
    w.pack(side="left")

    c.set_focus(w)
#@-node:ekr.20070122103505.2:tkinterAskOkCancelString.createFrame
#@+node:ekr.20070122103505.3:tkinterAskOkCancelString.okButton, cancelButton
def okButton(self):

    """Handle clicks in the ok button of a string dialog."""

    self.answer = self.number_entry.get().strip()
    self.top.destroy()

def cancelButton(self):

    """Handle clicks in the cancel button of a string dialog."""

    self.answer=''
    self.top.destroy()
#@-node:ekr.20070122103505.3:tkinterAskOkCancelString.okButton, cancelButton
#@+node:ekr.20070122103505.4:tkinterAskOkCancelString.onKey
def onKey (self,event):

    ch = event.char.lower()

    if ch in ('o','\n','\r'):
        self.okButton()
    elif ch == 'c':
        self.cancelButton()

    return "break"
#@-node:ekr.20070122103505.4:tkinterAskOkCancelString.onKey
#@-node:ekr.20070122103505:class tkinterAskOkCancelString
#@+node:ekr.20031218072017.3882:class tkinterAskYesNo
class tkinterAskYesNo (leoTkinterDialog):

    """A class that creates a Tkinter dialog with two buttons: Yes and No."""

    @others
#@+node:ekr.20031218072017.3883:tkinterAskYesNo.__init__
def __init__ (self,c,title,message=None,resizeable=False):

    """Create a dialog having yes and no buttons."""

    leoTkinterDialog.__init__(self,c,title,resizeable) # Initialize the base class.

    if g.app.unitTesting: return

    self.createTopFrame()
    self.top.bind("<Key>",self.onKey)

    if message:
        self.createMessageFrame(message)

    buttons = (
        {"text":"Yes","command":self.yesButton,  "default":True},
        {"text":"No", "command":self.noButton} )
    self.createButtons(buttons)
#@-node:ekr.20031218072017.3883:tkinterAskYesNo.__init__
#@+node:ekr.20031218072017.3884:tkinterAskYesNo.onKey
def onKey(self,event):

    """Handle keystroke events in dialogs having yes and no buttons."""

    ch = event.char.lower()

    if ch in ('y','\n','\r'):
        self.yesButton()
    elif ch == 'n':
        self.noButton()

    return "break"
#@-node:ekr.20031218072017.3884:tkinterAskYesNo.onKey
#@-node:ekr.20031218072017.3882:class tkinterAskYesNo
#@+node:ekr.20031218072017.3885:class tkinterAskYesNoCancel
class tkinterAskYesNoCancel(leoTkinterDialog):

    """A class to create and run Tkinter dialogs having three buttons.

    By default, these buttons are labeled Yes, No and Cancel."""

    @others
#@+node:ekr.20031218072017.3886:askYesNoCancel.__init__
def __init__ (self,c,title,
    message=None,
    yesMessage="Yes",
    noMessage="No",
    defaultButton="Yes",
    resizeable=False):

    """Create a dialog having three buttons."""

    leoTkinterDialog.__init__(self,c,title,resizeable,canClose=False) # Initialize the base class.

    if g.app.unitTesting: return

    self.yesMessage,self.noMessage = yesMessage,noMessage
    self.defaultButton = defaultButton

    self.createTopFrame()
    self.top.bind("<Key>",self.onKey)

    if message:
        self.createMessageFrame(message)

    buttons = (
        {"text":yesMessage,"command":self.yesButton,   "default":yesMessage==defaultButton},
        {"text":noMessage, "command":self.noButton,    "default":noMessage==defaultButton},
        {"text":"Cancel",  "command":self.cancelButton,"default":"Cancel"==defaultButton} )
    self.createButtons(buttons)
#@-node:ekr.20031218072017.3886:askYesNoCancel.__init__
#@+node:ekr.20031218072017.3887:askYesNoCancel.onKey
def onKey(self,event):

    """Handle keystrokes in dialogs with three buttons."""

    ch = event.char.lower()

    if ch in ('\n','\r'):
        ch = self.defaultButton[0].lower()

    if ch == self.yesMessage[0].lower():
        self.yesButton()
    elif ch == self.noMessage[0].lower():
        self.noButton()
    elif ch == 'c':
        self.cancelButton()

    return "break"
#@-node:ekr.20031218072017.3887:askYesNoCancel.onKey
#@+node:ekr.20031218072017.3888:askYesNoCancel.noButton & yesButton
def noButton(self):

    """Handle clicks in the 'no' (second) button in a dialog with three buttons."""

    self.answer=self.noMessage.lower()
    self.top.destroy()

def yesButton(self):

    """Handle clicks in the 'yes' (first) button in a dialog with three buttons."""

    self.answer=self.yesMessage.lower()
    self.top.destroy()
#@-node:ekr.20031218072017.3888:askYesNoCancel.noButton & yesButton
#@-node:ekr.20031218072017.3885:class tkinterAskYesNoCancel
#@+node:ekr.20031218072017.3889:class tkinterListboxDialog
class tkinterListBoxDialog (leoTkinterDialog):

    """A base class for Tkinter dialogs containing a Tk Listbox"""

    @others
#@+node:ekr.20031218072017.3890:tkinterListboxDialog.__init__
def __init__ (self,c,title,label):

    """Constructor for the base listboxDialog class."""

    leoTkinterDialog.__init__(self,c,title,resizeable=True) # Initialize the base class.

    if g.app.unitTesting: return

    self.createTopFrame()
    self.top.protocol("WM_DELETE_WINDOW", self.destroy)

    # Initialize common ivars.
    self.label = label
    self.positionList = []
    self.buttonFrame = None

    # Fill in the frame.
    self.createFrame()
    self.fillbox()

    # Make the common bindings after creating self.box.

    self.box.bind("<Double-Button-1>",self.go)
#@-node:ekr.20031218072017.3890:tkinterListboxDialog.__init__
#@+node:ekr.20031218072017.3891:addStdButtons
def addStdButtons (self,frame):

    """Add stanadard buttons to a listBox dialog."""

    # Create the ok and cancel buttons.
    self.ok = ok = Tk.Button(frame,text="Go",width=6,command=self.go)
    self.hide = hide = Tk.Button(frame,text="Hide",width=6,command=self.hide)

    ok.pack(side="left",pady=2,padx=5)
    hide.pack(side="left",pady=2,padx=5)
#@-node:ekr.20031218072017.3891:addStdButtons
#@+node:ekr.20031218072017.3892:createFrame
def createFrame(self):

    """Create the essentials of a listBoxDialog frame

    Subclasses will add buttons to self.buttonFrame"""

    if g.app.unitTesting: return

    self.outerFrame = f = Tk.Frame(self.frame)
    f.pack(expand=1,fill="both")

    if self.label:
        labf = Tk.Frame(f)
        labf.pack(pady=2)
        lab = Tk.Label(labf,text=self.label)
        lab.pack()

    f2 = Tk.Frame(f)
    f2.pack(expand=1,fill="both")

    self.box = box = Tk.Listbox(f2,height=20,width=30)
    box.pack(side="left",expand=1,fill="both")

    bar = Tk.Scrollbar(f2)
    bar.pack(side="left", fill="y")

    bar.config(command=box.yview)
    box.config(yscrollcommand=bar.set)
#@-node:ekr.20031218072017.3892:createFrame
#@+node:ekr.20031218072017.3893:destroy
def destroy (self,event=None):

    """Hide, do not destroy, a listboxDialog window

    subclasses may override to really destroy the window"""

    __pychecker__ = '--no-argsused' # event not used, but must be present.

    self.top.withdraw() # Don't allow this window to be destroyed.
#@-node:ekr.20031218072017.3893:destroy
#@+node:ekr.20031218072017.3894:hide
def hide (self):

    """Hide a list box dialog."""

    self.top.withdraw()
#@-node:ekr.20031218072017.3894:hide
#@+node:ekr.20031218072017.3895:fillbox
def fillbox(self,event=None):

    """Fill a listbox from information.

    Overridden by subclasses"""

    __pychecker__ = '--no-argsused' # the event param must be present.

    pass
#@-node:ekr.20031218072017.3895:fillbox
#@+node:ekr.20031218072017.3896:go
def go(self,event=None):

    """Handle clicks in the "go" button in a list box dialog."""

    __pychecker__ = '--no-argsused' # the event param must be present.

    c = self.c ; box = self.box

    # Work around an old Python bug.  Convert strings to ints.
    items = box.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        p = self.positionList[n]
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectPosition(p,updateBeadList=True)
                # A case could be made for updateBeadList=False
        finally:
            c.endUpdate()
#@-node:ekr.20031218072017.3896:go
#@-node:ekr.20031218072017.3889:class tkinterListboxDialog
#@-node:ekr.20031218072017.3858:@thin leoTkinterDialog.py
#@+node:ekr.20031218072017.3897:@thin leoTkinterFind.py
@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import leoFind

import sys

import leoTkinterDialog
import Tkinter as Tk

Pmw = g.importExtension('Pmw',pluginName=None,verbose=False)

@others
#@+node:ekr.20041025152343:class underlinedTkButton
class underlinedTkButton:

    @others
#@+node:ekr.20041025152712:__init__
def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    << set self.hotKey if '&' is in the string >>

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")

    self.text = text # for traces
#@+node:ekr.20041025152712.2:<< set self.hotKey if '&' is in the string >>
index = text.find('&')

if index > -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]
#@-node:ekr.20041025152712.2:<< set self.hotKey if '&' is in the string >>
#@-node:ekr.20041025152712:__init__
#@+node:ekr.20041026080125:bindHotKey
def bindHotKey (self,widget):

    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.buttonCallback)
#@-node:ekr.20041026080125:bindHotKey
#@+node:ekr.20041025152717:buttonCallback
# The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):

    # g.trace(self.text)
    self.button.invoke ()

    # See if this helps.
    return 'break'
#@-node:ekr.20041025152717:buttonCallback
#@-node:ekr.20041025152343:class underlinedTkButton
#@+node:ekr.20041025152343.1:class leoTkinterFind
class leoTkinterFind (leoFind.leoFind,leoTkinterDialog.leoTkinterDialog):

    """A class that implements Leo's tkinter find dialog."""

    @others
#@+node:ekr.20031218072017.3898:Birth & death
#@+node:ekr.20031218072017.3899:__init__
def __init__(self,c,resizeable=False,title=None,show=True):

    # g.trace('leoTkinterFind',g.callers())

    # Init the base classes...
    leoFind.leoFind.__init__(self,c,title=title)
    leoTkinterDialog.leoTkinterDialog.__init__(self,c,self.title,resizeable,show=show)

    << create the tkinter intVars >>

    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 

    self.createTopFrame() # Create the outer tkinter dialog frame.
    self.createFrame()
    if self.top and not show:
        self.top.withdraw()
    self.init(c) # New in 4.3: init only once.
#@+node:ekr.20031218072017.3900:<< create the tkinter intVars >>
self.svarDict = {}

for key in self.intKeys:
    self.svarDict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.svarDict[key] = Tk.StringVar()
#@-node:ekr.20031218072017.3900:<< create the tkinter intVars >>
#@-node:ekr.20031218072017.3899:__init__
#@+node:ekr.20031218072017.2059:tkFind.init
def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.svarDict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@+node:ekr.20031218072017.2060:<< set find/change widgets >>
self.find_ctrl.delete(0,"end")
self.change_ctrl.delete(0,"end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@-node:ekr.20031218072017.2060:<< set find/change widgets >>
#@+node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.svarDict[var].get()
    if val:
        self.svarDict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.svarDict["radio-find-type"].set("plain-search")

found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only"),
):
    val = self.svarDict[var].get()
    if val:
        self.svarDict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.svarDict["radio-search-scope"].set("entire-outline")
#@-node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
#@-node:ekr.20031218072017.2059:tkFind.init
#@+node:ekr.20031218072017.3901:destroySelf
def destroySelf (self):

    self.top.destroy()
#@-node:ekr.20031218072017.3901:destroySelf
#@+node:ekr.20031218072017.3902:find.createFrame
def createFrame (self):

    # g.trace('legacy')

    # Create the find panel...
    outer = Tk.Frame(self.frame,relief="groove",bd=2)
    outer.pack(padx=2,pady=2)

    << Create the Find and Change panes >>
    << Create four columns of radio and checkboxes >>
    << Create two rows of buttons >>

    if self.top: # self.top may not exist during unit testing.
        self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)
#@+node:ekr.20031218072017.3904:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1)
cpane = Tk.Frame(fc, bd=1)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
self.find_ctrl   = ftxt = g.app.gui.plainTextWidget(
    fpane,bd=1,relief="groove",height=4,width=20)
self.change_ctrl = ctxt = g.app.gui.plainTextWidget(
    cpane,bd=1,relief="groove",height=4,width=20)

<< Bind Tab and control-tab >>

fBar = Tk.Scrollbar(fpane,name='findBar')
cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
    txt['yscrollcommand'] = bar.set
    bar['command'] = txt.yview
    bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="both")
ftxt.pack(side="right", expand=1, fill="both")
#@+node:ekr.20041026092141:<< Bind Tab and control-tab >>
def setFocus(w):
    c = self.c
    c.widgetWantsFocus(w)
    w.setSelectionRange(0,0)
    return "break"

def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)

def insertTab(w):
    data = w.getSelectionRange()
    if data: start,end = data
    else: start = end = w.getInsertPoint()
    w.replace(start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("<Tab>",toChange)
ctxt.bind("<Tab>",toFind)
ftxt.bind("<Control-Tab>",insertFindTab)
ctxt.bind("<Control-Tab>",insertChangeTab)
#@-node:ekr.20041026092141:<< Bind Tab and control-tab >>
#@-node:ekr.20031218072017.3904:<< Create the Find and Change panes >>
#@+node:ekr.20031218072017.3903:<< Create four columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    (self.svarDict["radio-find-type"],"P&Lain Search","plain-search"),  
    (self.svarDict["radio-find-type"],"&Pattern Match Search","pattern-search"),
    (self.svarDict["radio-find-type"],"&Script Search","script-search")]
checkLists[0] = [
    ("Scrip&t Change",self.svarDict["script_change"])]
checkLists[1] = [
    ("&Whole Word",  self.svarDict["whole_word"]),
    ("&Ignore Case", self.svarDict["ignore_case"]),
    ("Wrap &Around", self.svarDict["wrap"]),
    ("&Reverse",     self.svarDict["reverse"])]
radioLists[2] = [
    (self.svarDict["radio-search-scope"],"&Entire Outline","entire-outline"),
    (self.svarDict["radio-search-scope"],"Suboutline &Only","suboutline-only"),  
    (self.svarDict["radio-search-scope"],"&Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.svarDict["radio-search-scope"],"Selection Only",None)] #,"selection-only")]
checkLists[2] = []
checkLists[3] = [
    ("Search &Headline Text", self.svarDict["search_headline"]),
    ("Search &Body Text",     self.svarDict["search_body"]),
    ("&Mark Finds",           self.svarDict["mark_finds"]),
    ("Mark &Changes",         self.svarDict["mark_changes"])]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = underlinedTkButton("radio",columns[i],anchor="w",text=name,variable=var,value=val)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = underlinedTkButton("check",columns[i],anchor="w",text=name,variable=var)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3903:<< Create four columns of radio and checkboxes >>
#@+node:ekr.20031218072017.3905:<< Create two rows of buttons >>
# Create the button panes
buttons  = Tk.Frame(outer,bd=1)
buttons2 = Tk.Frame(outer,bd=1)
buttons.pack (anchor="n",expand=1,fill="x")
buttons2.pack(anchor="n",expand=1,fill="x")

# In 4.4 it's dubious to define these keys.  For example, Alt-x must be reserved!
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w
# HotKeys used for plain buttons (enter),d,g,t

def findButtonCallback(event=None,self=self):
    self.findButton()
    return 'break'

# Create the first row of buttons
findButton=Tk.Button(buttons,
    width=9,text="Find",bd=4,command=findButtonCallback) # The default.

findButton.pack(pady="1p",padx="25p",side="left")

contextBox = underlinedTkButton("check",buttons,
    anchor="w",text="Show Conte&xt",variable=self.svarDict["batch"])
contextBox.button.pack(pady="1p",side="left",expand=1)
contextBox.bindHotKey(ftxt)
contextBox.bindHotKey(ctxt)

findAllButton = underlinedTkButton("button",buttons,
    width=9,text="Fin&d All",command=self.findAllButton)
findAllButton.button.pack(pady="1p",padx="25p",side="right",fill="x")
findAllButton.bindHotKey(ftxt)
findAllButton.bindHotKey(ctxt)

# Create the second row of buttons
changeButton = underlinedTkButton("button",buttons2,
    width=10,text="Chan&Ge",command=self.changeButton)
changeButton.button.pack(pady="1p",padx="25p",side="left")
changeButton.bindHotKey(ftxt)
changeButton.bindHotKey(ctxt)

changeFindButton = underlinedTkButton("button",buttons2,
    text="Change, &Then Find",command=self.changeThenFindButton)
changeFindButton.button.pack(pady="1p",side="left",expand=1)
changeFindButton.bindHotKey(ftxt)
changeFindButton.bindHotKey(ctxt)

changeAllButton = underlinedTkButton("button",buttons2,
    width=10,text="Change All",command=self.changeAllButton)
changeAllButton.button.pack(pady="1p",padx="25p",side="right")
changeAllButton.bindHotKey(ftxt)
changeAllButton.bindHotKey(ctxt)
#@-node:ekr.20031218072017.3905:<< Create two rows of buttons >>
#@-node:ekr.20031218072017.3902:find.createFrame
#@+node:ekr.20060207080537:find.createBindings
def createBindings (self):

    # Legacy bindings.  Can be overwritten in subclasses.

    # g.trace('legacy')

    def findButtonCallback2(event,self=self):
        self.findButton()
        return 'break'

    for widget in (self.find_ctrl, self.change_ctrl):
        widget.bind ("<Button-1>",  self.resetWrap)
        widget.bind("<Key>",        self.resetWrap)
        widget.bind("<Control-a>",  self.selectAllFindText)

    for widget in (self.find_ctrl, self.change_ctrl):
        widget.bind("<Key-Return>", findButtonCallback2)
        widget.bind("<Key-Escape>", self.onCloseWindow)
#@-node:ekr.20060207080537:find.createBindings
#@-node:ekr.20031218072017.3898:Birth & death
#@+node:ekr.20031218072017.3906:onCloseWindow
def onCloseWindow(self,event=None):

    __pychecker__ = '--no-argsused' # the event param must be present.

    self.top.withdraw()
#@-node:ekr.20031218072017.3906:onCloseWindow
#@+node:ekr.20051013084256:dismiss
def dismiss (self):

    self.top.withdraw()
#@-node:ekr.20051013084256:dismiss
#@+node:ekr.20031218072017.3907:bringToFront (tkFind)
def bringToFront (self):

    """Bring the tkinter Find Panel to the front."""

    c = self.c ; w = self.find_ctrl

    self.top.withdraw() # Helps bring the window to the front.
    self.top.deiconify()
    self.top.lift()

    c.widgetWantsFocusNow(w)
    w.selectAllText()
#@-node:ekr.20031218072017.3907:bringToFront (tkFind)
#@-node:ekr.20041025152343.1:class leoTkinterFind
#@+node:ekr.20061212085958:class tkFindTab (findTab)
class tkFindTab (leoFind.findTab):

    '''A subclass of the findTab class containing all Tk code.'''

    @others
#@nonl
#@+node:ekr.20061212085958.1: Birth
if 0: # We can use the base-class ctor.

    def __init__ (self,c,parentFrame):

        leoFind.findTab.__init__(self,c,parentFrame)
            # Init the base class.
            # Calls initGui, createFrame, createBindings & init(c), in that order.
#@+node:ekr.20070212091209:tkFindTab.init
def init (self,c):

    # g.trace('tkFindTab',g.callers())

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.svarDict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@+node:ekr.20070212091209.1:<< set find/change widgets >>
self.find_ctrl.delete(0,"end")
self.change_ctrl.delete(0,"end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@-node:ekr.20070212091209.1:<< set find/change widgets >>
#@+node:ekr.20070212091209.2:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.svarDict[var].get()
    if val:
        self.svarDict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.svarDict["radio-find-type"].set("plain-search")

found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only"),
):
    val = self.svarDict[var].get()
    if val:
        self.svarDict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.svarDict["radio-search-scope"].set("entire-outline")
#@-node:ekr.20070212091209.2:<< set radio buttons from ivars >>
#@-node:ekr.20070212091209:tkFindTab.init
#@+node:ekr.20051020120306.12:initGui
def initGui (self):

    self.svarDict = {}

    for key in self.intKeys:
        self.svarDict[key] = Tk.IntVar()

    for key in self.newStringKeys:
        self.svarDict[key] = Tk.StringVar()

#@-node:ekr.20051020120306.12:initGui
#@+node:ekr.20051020120306.13:createFrame (tkFindTab)
def createFrame (self,parentFrame):

    c = self.c

    # g.trace('findTab')

    << Create the outer frames >>
    << Create the Find and Change panes >>
    << Create two columns of radio and checkboxes >>

    if  self.optionsOnly:
        buttons = []
    else:
        << Create two columns of buttons >>

    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)
#@+node:ekr.20051020120306.14:<< Create the outer frames >>
configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)
#@-node:ekr.20051020120306.14:<< Create the outer frames >>
#@+node:ekr.20051020120306.15:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

if self.optionsOnly:
    # Use one-line boxes.
    self.find_ctrl = ftxt = g.app.gui.plainTextWidget(
        fpane,bd=1,relief="groove",height=1,width=25,name='find-text')
    self.change_ctrl = ctxt = g.app.gui.plainTextWidget(
        cpane,bd=1,relief="groove",height=1,width=25,name='change-text')
else:
    # Use bigger boxes for scripts.
    self.find_ctrl = ftxt = g.app.gui.plainTextWidget(
        fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
    self.change_ctrl = ctxt = g.app.gui.plainTextWidget(
        cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
<< Bind Tab and control-tab >>

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')

    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")

if self.optionsOnly:
    flab.pack(side="left") ; ftxt.pack(side="left")
    clab.pack(side="left") ; ctxt.pack(side="left")
else:
    flab.pack(side="left") ; ftxt.pack(side="right", expand=1, fill="x")
    clab.pack(side="left") ; ctxt.pack(side="right", expand=1, fill="x")
#@+node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
def setFocus(w):
    c = self.c
    c.widgetWantsFocusNow(w)
    w.setSelectionRange(0,0)
    return "break"

def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)

def insertTab(w):
    data = w.getSelectionRange()
    if data: start,end = data
    else: start = end = w.getInsertPoint()
    w.replace(start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("<Tab>",toChange)
ctxt.bind("<Tab>",toFind)
ftxt.bind("<Control-Tab>",insertFindTab)
ctxt.bind("<Control-Tab>",insertChangeTab)
#@-node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
#@-node:ekr.20051020120306.15:<< Create the Find and Change panes >>
#@+node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = []

checkLists[0] = [
    # ("Scrip&t Change",self.svarDict["script_change"]),
    ("Whole &Word", self.svarDict["whole_word"]),
    ("&Ignore Case",self.svarDict["ignore_case"]),
    ("Wrap &Around",self.svarDict["wrap"]),
    ("&Reverse",    self.svarDict["reverse"]),
    ('Rege&xp',     self.svarDict['pattern_match']),
    ("Mark &Finds", self.svarDict["mark_finds"]),
]

radioLists[1] = [
    (self.svarDict["radio-search-scope"],"&Entire Outline","entire-outline"),
    (self.svarDict["radio-search-scope"],"&Suboutline Only","suboutline-only"),  
    (self.svarDict["radio-search-scope"],"&Node Only","node-only"),
]

checkLists[1] = [
    ("Search &Headline", self.svarDict["search_headline"]),
    ("Search &Body",     self.svarDict["search_body"]),
    ("Mark &Changes",    self.svarDict["mark_changes"]),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<Button-1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<Button-1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@-node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
#@+node:ekr.20051020120306.18:<< Create two columns of buttons >>
# Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)
#@-node:ekr.20051020120306.18:<< Create two columns of buttons >>
#@-node:ekr.20051020120306.13:createFrame (tkFindTab)
#@+node:ekr.20051023181449:createBindings (tkFindTab)
def createBindings (self):

    c = self.c ; k = c.k

    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        return k.masterKeyHandler(event)

    def findButtonBindingCallback(event=None,self=self):
        self.findButton()
        return 'break'

    table = (
        ('<Button-1>',  k.masterClickHandler),
        ('<Double-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClickHandler),
        ('<Double-3>',  k.masterClickHandler),
        ('<Key>',       resetWrapCallback),
        ('<Return>',    findButtonBindingCallback),
        ("<Escape>",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)
#@-node:ekr.20051023181449:createBindings (tkFindTab)
#@-node:ekr.20061212085958.1: Birth
#@+node:ekr.20070212092458:Support for minibufferFind class (tkFindTab)
#@+node:ekr.20070212093026:getOption
def getOption (self,ivar):

    var = self.svarDict.get(ivar)

    if var:
        val = var.get()
        # g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
#@-node:ekr.20070212093026:getOption
#@+node:ekr.20070212092525:setOption
def setOption (self,ivar,val):

    if ivar in self.intKeys:
        if val is not None:
            var = self.svarDict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
#@-node:ekr.20070212092525:setOption
#@+node:ekr.20070212093026.1:toggleOption
def toggleOption (self,ivar):

    if ivar in self.intKeys:
        var = self.svarDict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
#@-node:ekr.20070212093026.1:toggleOption
#@-node:ekr.20070212092458:Support for minibufferFind class (tkFindTab)
#@-node:ekr.20061212085958:class tkFindTab (findTab)
#@+node:ekr.20051025071455.22:class tkSpellTab
class tkSpellTab:

    @others
#@+node:ekr.20070212132230.1:tkSpellTab.__init__
def __init__ (self,c,handler,tabName):

    self.c = c
    self.handler = handler
    self.tabName = tabName

    self.createFrame()
    self.createBindings()
    self.fillbox([])
#@-node:ekr.20070212132230.1:tkSpellTab.__init__
#@+node:ekr.20051025120920:createBindings
def createBindings (self):

    c = self.c ; k = c.k
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:

        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.handler.hide),
            ('spell-add',               self.handler.add),
            ('spell-find',              self.handler.find),
            ('spell-ignore',            self.handler.ignore),
            ('spell-change-then-find',  self.handler.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut = k.shortcutFromSetting(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)

    self.listBox.bind("<Double-1>",self.onChangeThenFindButton)
    self.listBox.bind("<Button-1>",self.onSelectListBox)
    self.listBox.bind("<Map>",self.onMap)
#@nonl
#@-node:ekr.20051025120920:createBindings
#@+node:ekr.20070212132230.2:createFrame
def createFrame (self):

    c = self.c ; log = c.frame.log ; tabName = self.tabName

    parentFrame = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'

    fontSize = g.choose(sys.platform.startswith('win'),9,14)

    << Create the outer frames >>
    << Create the text and suggestion panes >>
    << Create the spelling buttons >>

    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
#@+node:ekr.20051113090322:<< Create the outer frames >>
self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)
#@-node:ekr.20051113090322:<< Create the outer frames >>
#@+node:ekr.20051025071455.23:<< Create the text and suggestion panes >>
f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',fontSize,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',fontSize,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')
#@-node:ekr.20051025071455.23:<< Create the text and suggestion panes >>
#@+node:ekr.20051025071455.24:<< Create the spelling buttons >>
# Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = []
font = ('verdana',fontSize,'normal')
width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList
#@-node:ekr.20051025071455.24:<< Create the spelling buttons >>
#@-node:ekr.20070212132230.2:createFrame
#@+node:ekr.20051025071455.29:Event handlers
#@+node:ekr.20051025071455.30:onAddButton
def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.handler.add()
#@-node:ekr.20051025071455.30:onAddButton
#@+node:ekr.20051025071455.32:onChangeButton & onChangeThenFindButton
def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.handler.change()
    self.updateButtons()


def onChangeThenFindButton(self,event=None):

    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.handler.change():
        self.handler.find()
    self.updateButtons()
#@-node:ekr.20051025071455.32:onChangeButton & onChangeThenFindButton
#@+node:ekr.20051025071455.33:onFindButton
def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    c = self.c
    self.handler.find()
    self.updateButtons()
    c.invalidateFocus()
    c.bodyWantsFocusNow()
#@-node:ekr.20051025071455.33:onFindButton
#@+node:ekr.20051025071455.34:onHideButton
def onHideButton(self):

    """Handle a click in the Hide button in the Spell tab."""

    self.handler.hide()
#@-node:ekr.20051025071455.34:onHideButton
#@+node:ekr.20051025071455.31:onIgnoreButton
def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.handler.ignore()
#@-node:ekr.20051025071455.31:onIgnoreButton
#@+node:ekr.20051025071455.49:onMap
def onMap (self, event=None):
    """Respond to a Tk <Map> event."""

    self.update(show= False, fill= False)
#@-node:ekr.20051025071455.49:onMap
#@+node:ekr.20051025071455.50:onSelectListBox
def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""

    c = self.c
    self.updateButtons()
    c.bodyWantsFocus()
#@-node:ekr.20051025071455.50:onSelectListBox
#@-node:ekr.20051025071455.29:Event handlers
#@+node:ekr.20051025071455.42:Helpers
#@+node:ekr.20051025071455.43:bringToFront
def bringToFront (self):

    self.c.frame.log.selectTab('Spell')
#@-node:ekr.20051025071455.43:bringToFront
#@+node:ekr.20051025071455.44:fillbox
def fillbox(self, alts, word=None):
    """Update the suggestions listBox in the Check Spelling dialog."""

    self.suggestions = alts

    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])

    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1)
#@-node:ekr.20051025071455.44:fillbox
#@+node:ekr.20051025071455.48:getSuggestion
def getSuggestion(self):
    """Return the selected suggestion from the listBox."""

    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None
#@-node:ekr.20051025071455.48:getSuggestion
#@+node:ekr.20051025071455.51:update
def update(self,show=True,fill=False):

    """Update the Spell Check dialog."""

    c = self.c

    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.bodyWantsFocus()
#@-node:ekr.20051025071455.51:update
#@+node:ekr.20051025071455.52:updateButtons (spellTab)
def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c ; w = c.frame.body.bodyCtrl

    start, end = w.getSelectionRange()
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
#@-node:ekr.20051025071455.52:updateButtons (spellTab)
#@-node:ekr.20051025071455.42:Helpers
#@-node:ekr.20051025071455.22:class tkSpellTab
#@-node:ekr.20031218072017.3897:@thin leoTkinterFind.py
#@+node:ekr.20031218072017.3939:@thin leoTkinterFrame.py
@first # -*- coding: utf-8 -*-

@language python
@tabwidth -4
@pagewidth 80

<< imports >>

@others
#@+node:ekr.20041221070525:<< imports >>
import leoGlobals as g

import leoChapters
import leoColor
import leoFrame
import leoNodes
import leoTkinterMenu
import leoTkinterTree

import Tkinter as Tk
import tkFont
import os
import string
import sys

Pmw = g.importExtension("Pmw",pluginName="leoTkinterFrame.py",verbose=False)
tkColorChooser = g.importExtension('tkColorChooser',pluginName=None,verbose=False)

# The following imports _are_ used.
__pychecker__ = '--no-import'
import threading
import time
#@-node:ekr.20041221070525:<< imports >>
#@+node:ekr.20031218072017.3996:class leoTkinterBody
class leoTkinterBody (leoFrame.leoBody):

    """A class that represents the body pane of a Tkinter window."""

    @others
#@+node:ekr.20031218072017.3997: Birth & death
#@+node:ekr.20031218072017.2182:tkBody. __init__
def __init__ (self,frame,parentFrame):

    # g.trace("leoTkinterBody")

    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)

    c = self.c ; p = c.currentPosition()
    self.editor_name = None
    self.editor_v = None

    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    self.bodyCtrl = self.createControl(frame,parentFrame,p)
    self.colorizer = leoColor.colorizer(c)
#@-node:ekr.20031218072017.2182:tkBody. __init__
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self,w=None):

    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''

    frame = self.frame ; c = self.c ; k = c.k
    if not w: w = self.bodyCtrl

    w.bind('<Key>', k.masterKeyHandler)

    for kind,func,handler in (
        ('<Button-1>',  frame.OnBodyClick,          k.masterClickHandler),
        ('<Button-3>',  frame.OnBodyRClick,         k.masterClick3Handler),
        ('<Double-1>',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        ('<Double-3>',  None,                       k.masterDoubleClick3Handler),
        ('<Button-2>',  frame.OnPaste,              k.masterClickHandler),
    ):
        def bodyClickCallback(event,handler=handler,func=func):
            return handler(event,func)

        w.bind(kind,bodyClickCallback)
#@nonl
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@+node:ekr.20031218072017.3998:tkBody.createControl
def createControl (self,frame,parentFrame,p):

    c = self.c

    # New in 4.4.1: make the parent frame a Pmw.PanedWidget.
    self.numberOfEditors = 1 ; name = '1'
    self.totalNumberOfEditors = 1

    orient = c.config.getString('editor_orientation') or 'horizontal'
    if orient not in ('horizontal','vertical'): orient = 'horizontal'

    self.pb = pb = Pmw.PanedWidget(parentFrame,orient=orient)
    parentFrame = pb.add(name)
    pb.pack(expand=1,fill='both') # Must be done after the first page created.

    w = self.createTextWidget(frame,parentFrame,p,name)
    self.editorWidgets[name] = w

    return w
#@-node:ekr.20031218072017.3998:tkBody.createControl
#@+node:ekr.20060528100747.3:tkBody.createTextWidget
def createTextWidget (self,frame,parentFrame,p,name):

    # pychecker complains that there is no leo_p attribute.

    c = self.c

    parentFrame.configure(bg='LightSteelBlue1')

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")

    # Setgrid=1 cause severe problems with the font panel.
    body = w = leoTkTextWidget (parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)

    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar

    def yscrollCallback(x,y,bodyBar=bodyBar,w=w):
        # g.trace(x,y,g.callers())
        if hasattr(w,'leo_scrollBarSpot'):
            w.leo_scrollBarSpot = (x,y)
        return bodyBar.set(x,y)

    body['yscrollcommand'] = yscrollCallback # bodyBar.set

    bodyBar['command'] =  body.yview
    bodyBar.pack(side="right", fill="y")

    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar

    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")

    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)

    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = body.leo_p.v
            # pychecker complains body.leo_p does not exist.
    w.leo_active = True
    w.leo_chapter = None
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w
#@nonl
#@-node:ekr.20060528100747.3:tkBody.createTextWidget
#@-node:ekr.20031218072017.3997: Birth & death
#@+node:ekr.20041217135735.1:tkBody.setColorFromConfig
def setColorFromConfig (self,w=None):

    c = self.c
    if w is None: w = self.bodyCtrl

    bg = c.config.getColor("body_text_background_color") or 'white'
    # g.trace(id(w),bg)

    try: w.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()

    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: w.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: w.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()

    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try: w.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try: w.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()

    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: w.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()
#@-node:ekr.20041217135735.1:tkBody.setColorFromConfig
#@+node:ekr.20031218072017.2183:tkBody.setFontFromConfig
def setFontFromConfig (self,w=None):

    c = self.c

    if not w: w = self.bodyCtrl

    font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    w.configure(font=font)

    # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
#@-node:ekr.20031218072017.2183:tkBody.setFontFromConfig
#@+node:ekr.20031218072017.4003:Focus (tkBody)
def hasFocus (self):

    return self.bodyCtrl == self.frame.top.focus_displayof()

def setFocus (self):

    self.c.widgetWantsFocus(self.bodyCtrl)
#@-node:ekr.20031218072017.4003:Focus (tkBody)
#@+node:ekr.20031218072017.3999:forceRecolor
def forceFullRecolor (self):

    self.forceFullRecolorFlag = True
#@-node:ekr.20031218072017.3999:forceRecolor
#@+node:ekr.20031218072017.4000:Tk bindings (tkBbody)
#@+node:ekr.20031218072017.4002:Color tags (Tk spelling)
def tag_add (self,tagName,index1,index2):
    self.bodyCtrl.tag_add(tagName,index1,index2)

def tag_bind (self,tagName,event,callback):
    self.bodyCtrl.tag_bind(tagName,event,callback)

def tag_configure (self,colorName,**keys):
    self.bodyCtrl.tag_configure(colorName,keys)

def tag_delete(self,tagName):
    self.bodyCtrl.tag_delete(tagName)

def tag_names(self,*args): # New in Leo 4.4.1.
    return self.bodyCtrl.tag_names(*args)

def tag_remove (self,tagName,index1,index2):
    return self.bodyCtrl.tag_remove(tagName,index1,index2)
#@-node:ekr.20031218072017.4002:Color tags (Tk spelling)
#@+node:ekr.20031218072017.2184:Configuration (Tk spelling)
def cget(self,*args,**keys):

    val = self.bodyCtrl.cget(*args,**keys)

    if g.app.trace:
        g.trace(val,args,keys)

    return val

def configure (self,*args,**keys):

    # g.trace(args,keys)

    return self.bodyCtrl.configure(*args,**keys)
#@-node:ekr.20031218072017.2184:Configuration (Tk spelling)
#@+node:ekr.20031218072017.4004:Height & width
def getBodyPaneHeight (self):

    return self.bodyCtrl.winfo_height()

def getBodyPaneWidth (self):

    return self.bodyCtrl.winfo_width()
#@-node:ekr.20031218072017.4004:Height & width
#@+node:ekr.20031218072017.4005:Idle time...
def scheduleIdleTimeRoutine (self,function,*args,**keys):

    self.bodyCtrl.after_idle(function,*args,**keys)
#@-node:ekr.20031218072017.4005:Idle time...
#@+node:ekr.20031218072017.4017:Menus
def bind (self,*args,**keys):

    return self.bodyCtrl.bind(*args,**keys)
#@-node:ekr.20031218072017.4017:Menus
#@+node:ekr.20070228081242:Text (now in base class)
# def getAllText (self):              return self.bodyCtrl.getAllText()
# def getInsertPoint(self):           return self.bodyCtrl.getInsertPoint()
# def getSelectedText (self):         return self.bodyCtrl.getSelectedText()
# def getSelectionRange (self,sort=True): return self.bodyCtrl.getSelectionRange(sort)
# def hasTextSelection (self):        return self.bodyCtrl.hasSelection()
# # def scrollDown (self):            g.app.gui.yscroll(self.bodyCtrl,1,'units')
# # def scrollUp (self):              g.app.gui.yscroll(self.bodyCtrl,-1,'units')
# def see (self,index):               self.bodyCtrl.see(index)
# def seeInsertPoint (self):          self.bodyCtrl.seeInsertPoint()
# def selectAllText (self,event=None):
    # w = g.app.gui.eventWidget(event) or self.bodyCtrl
    # return w.selectAllText()
# def setInsertPoint (self,pos):      return self.bodyCtrl.getInsertPoint(pos)
# def setSelectionRange (self,sel):
    # i,j = sel
    # self.bodyCtrl.setSelectionRange(i,j)
#@nonl
#@-node:ekr.20070228081242:Text (now in base class)
#@-node:ekr.20031218072017.4000:Tk bindings (tkBbody)
#@+node:ekr.20070424053629.2:Editors (tkBody)
#@+node:ekr.20070424054235:createEditorFrame
def createEditorFrame (self,pane):

    f = Tk.Frame(pane)
    f.pack(side='top',expand=1,fill='both')
    return f
#@-node:ekr.20070424054235:createEditorFrame
#@+node:ekr.20070424054810:packEditorLabelWidget
def packEditorLabelWidget (self,w):

    '''Create a Tk label widget.'''

    if not hasattr(w,'leo_label') or not w.leo_label:
        # g.trace('w.leo_frame',id(w.leo_frame))
        w.pack_forget()
        w.leo_label = Tk.Label(w.leo_frame)
        w.leo_label.pack(side='top')
        w.pack(expand=1,fill='both')
#@nonl
#@-node:ekr.20070424054810:packEditorLabelWidget
#@+node:ekr.20060606090542:setEditorColors
def setEditorColors (self,bg,fg):

    c = self.c ; d = self.editorWidgets

    for key in d.keys():
        w2 = d.get(key)
        # g.trace(id(w2),bg,fg)
        try:
            w2.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
            pass
#@-node:ekr.20060606090542:setEditorColors
#@-node:ekr.20070424053629.2:Editors (tkBody)
#@-node:ekr.20031218072017.3996:class leoTkinterBody
#@+node:ekr.20031218072017.3940:class leoTkinterFrame
class leoTkinterFrame (leoFrame.leoFrame):

    """A class that represents a Leo window rendered in Tk/tkinter."""

    @others
#@+node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20031218072017.1801:__init__ (tkFrame)
def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title

    leoTkinterFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBarClass = self.tkIconBarClass
    self.statusLineClass = self.tkStatusLineClass
    self.iconBar = None

    self.trace_status_line = None # Set in finishCreate.

    << set the leoTkinterFrame ivars >>
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
# "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
# self.treeBar = None # Replaced by injected frame.canvas.leo_treeBar.

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
#@-node:ekr.20031218072017.1801:__init__ (tkFrame)
#@+node:ekr.20031218072017.3942:__repr__ (tkFrame)
def __repr__ (self):

    return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:__repr__ (tkFrame)
#@+node:ekr.20031218072017.2176:tkFrame.finishCreate & helpers
def finishCreate (self,c):

    f = self ; f.c = c
    # g.trace('tkFrame','c',c,g.callers())

    self.trace_status_line = c.config.getBool('trace_status_line')
    self.use_chapters      = c.config.getBool('use_chapters')
    self.use_chapter_tabs  = c.config.getBool('use_chapter_tabs')

    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBar()
    f.createSplitterComponents()
    f.createStatusLine()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()

    # f.enableTclTraces()
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.

    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)

    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("<Button-1>", f.OnActivateLeoEvent)

    f.top.bind("<Control-KeyPress>",f.OnControlKeyDown)
    f.top.bind("<Control-KeyRelease>",f.OnControlKeyUp)

    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    # f.top.bind("<Activate>",f.OnActivateLeoEvent)
    # f.top.bind("<Deactivate>",f.OnDeactivateLeoEvent)

    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
#@nonl
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20051009045208:createSplitterComponents
def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)

    # Create the canvas, tree, log and body.
    if f.use_chapters:
        c.chapterController = cc = leoChapters.chapterController(c)

    if self.use_chapters and self.use_chapter_tabs:
        cc.tt = leoTkinterTreeTab(c,f.split2Pane1,cc)

    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)

    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl

    # Configure.
    f.setTabWidth(c.tab_width)
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
#@-node:ekr.20051009045208:createSplitterComponents
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):

    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot(oldRoot=None)
    c.setRootPosition(p) # New in 4.4.2.
    c.editPosition(p)
#@-node:ekr.20051009045404:createFirstTreeNode
#@+node:ekr.20051121092320:f.enableTclTraces
def enableTclTraces (self):

    c = self.c

    # pychecker complains that trace/untracewidget are not used.

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)

    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)

    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("<FocusIn>")
    # c.frame.bar1.unbind_all("<FocusOut>")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("<FocusIn>", focusIn)
        w.bind_all("<FocusOut>", focusOut)
    else:
        w.bind_all("<Control-1>", tracewidget)
        w.bind_all("<Control-Shift-1>", untracewidget)
#@-node:ekr.20051121092320:f.enableTclTraces
#@-node:ekr.20031218072017.2176:tkFrame.finishCreate & helpers
#@+node:ekr.20031218072017.3944:tkFrame.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):

    c = self.c

    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)
    self.setCanvasColorFromConfig(canvas)

    return canvas
#@nonl
#@+node:ekr.20041221071131.1:f.createTkTreeCanvas & callbacks
def createTkTreeCanvas (self,parentFrame,scrolls,pack):

    frame = self

    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    treeBar = Tk.Scrollbar(parentFrame,name="treeBar")

    # New in Leo 4.4.3 b1: inject the ivar into the canvas.
    canvas.leo_treeBar = treeBar

    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>

    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")

    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 0:
        << do scrolling by hand in a separate thread >>

    # g.print_bindings("canvas",canvas)
    return canvas
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')

def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay

def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@+node:ekr.20031218072017.998:Scrolling callbacks (tkFrame)
def setCallback (self,*args,**keys):

    """Callback to adjust the scrollbar.

    Args is a tuple of two floats describing the fraction of the visible area."""

    #g.trace(self.tree.redrawCount,args,g.callers())

    apply(self.canvas.leo_treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)

def yviewCallback (self,*args,**keys):

    """Tell the canvas to scroll"""

    #g.trace(vyiewCallback,args,keys,g.callers())

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (tkFrame)
#@-node:ekr.20041221071131.1:f.createTkTreeCanvas & callbacks
#@+node:ekr.20070327094252:f.setCanvasColorFromConfig
def setCanvasColorFromConfig (self,canvas):

    c = self.c

    bg = c.config.getColor("outline_pane_background_color") or 'white'

    try:
        canvas.configure(bg=bg)
    except:
        g.es("exception setting outline pane background color")
        g.es_exception()
#@-node:ekr.20070327094252:f.setCanvasColorFromConfig
#@-node:ekr.20031218072017.3944:tkFrame.createCanvas & helpers
#@+node:ekr.20041221123325:tkFrame.createLeoSplitters & helpers
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these
invariants. So most of this code is specialized for Leo's window. OTOH, creating
a single splitter window would be much easier than this code.
@c

def createLeoSplitters (self,parentFrame):

    # Splitter 1 is the main splitter containing splitter2 and the body pane.
    f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
        parentFrame,self.splitVerticalFlag,'splitter1')

    self.f1,self.bar1 = f1,bar1
    self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

    # Splitter 2 is the secondary splitter containing the tree and log panes.
    f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
        split1Pane1,not self.splitVerticalFlag,'splitter2')

    self.f2,self.bar2 = f2,bar2
    self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):

    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)

    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot = top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax = top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot = top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax = top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@-node:ekr.20031218072017.3952:placeSplitter
#@-node:ekr.20041221123325:tkFrame.createLeoSplitters & helpers
#@+node:ekr.20031218072017.3964:Destroying the tkFrame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # g.printGcAll()

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    if c.chapterController: # New in Leo 4.4.3 b1.
        g.clearAllIvars(c.chapterController)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.keyHandler) # New in Leo 4.4.3 b1.
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)

    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)

#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""

    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf (tkFrame)
def destroySelf (self):

    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c

    # Indicate that the commander is no longer valid.
    c.exists = False 

    # g.trace(self)

    # Important: this destroys all the objects of the commander too.
    self.destroyAllObjects()

    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()
#@-node:ekr.20031218072017.1974:destroySelf (tkFrame)
#@-node:ekr.20031218072017.3964:Destroying the tkFrame
#@-node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20041223104933:class tkStatusLineClass
class tkStatusLineClass:

    '''A class representing the status line.'''

    @others
#@+node:ekr.20031218072017.3961: ctor
def __init__ (self,c,parentFrame):

    self.c = c
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)

    bg = self.statusFrame.cget("background")
    self.textWidget = w = g.app.gui.bodyTextWidget(
        self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove",name='status-line')
    self.textWidget.pack(side="left",expand=1,fill="x")
    w.bind("<Button-1>", self.onActivate)
    self.show()

    c.frame.statusFrame = self.statusFrame
    c.frame.statusLabel = self.labelWidget
    c.frame.statusText  = self.textWidget
#@-node:ekr.20031218072017.3961: ctor
#@+node:ekr.20031218072017.3962:clear
def clear (self):

    w = self.textWidget
    if not w: return

    w.configure(state="normal")
    w.delete(0,"end")
    w.configure(state="disabled")
#@-node:ekr.20031218072017.3962:clear
#@+node:EKR.20040424153344:enable, disable & isEnabled
def disable (self,background=None):

    c = self.c ; w = self.textWidget
    if w:
        if not background:
            background = self.statusFrame.cget("background")
        w.configure(state="disabled",background=background)
    self.enabled = False
    c.bodyWantsFocus()

def enable (self,background="white"):

    # g.trace()
    c = self.c ; w = self.textWidget
    if w:
        w.configure(state="normal",background=background)
        c.widgetWantsFocus(w)
    self.enabled = True

def isEnabled(self):
    return self.enabled
#@nonl
#@-node:EKR.20040424153344:enable, disable & isEnabled
#@+node:ekr.20041026132435:get
def get (self):

    w = self.textWidget
    if w:
        return w.getAllText()
    else:
        return ""
#@-node:ekr.20041026132435:get
#@+node:ekr.20041223114744:getFrame
def getFrame (self):

    return self.statusFrame
#@-node:ekr.20041223114744:getFrame
#@+node:ekr.20050120093555:onActivate
def onActivate (self,event=None):

    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)
#@-node:ekr.20050120093555:onActivate
#@+node:ekr.20041223111916:pack & show
def pack (self):

    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)

show = pack
#@-node:ekr.20041223111916:pack & show
#@+node:ekr.20031218072017.3963:put (leoTkinterFrame:statusLineClass)
def put(self,s,color=None):

    # g.trace('tkStatusLine',self.textWidget,s)

    w = self.textWidget
    if not w:
        g.trace('tkStatusLine','***** disabled')
        return

    w.configure(state="normal")
    w.insert("end",s)

    if color:
        if color not in self.colorTags:
            self.colorTags.append(color)
            w.tag_config(color,foreground=color)
        w.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        w.tag_config("black",foreground="black")
        w.tag_add("black","end")

    w.configure(state="disabled")
#@-node:ekr.20031218072017.3963:put (leoTkinterFrame:statusLineClass)
#@+node:ekr.20041223111916.1:unpack & hide
def unpack (self):

    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
#@-node:ekr.20041223111916.1:unpack & hide
#@+node:ekr.20031218072017.1733:update (statusLine)
def update (self):

    c = self.c ; bodyCtrl = c.frame.body.bodyCtrl

    if g.app.killed or not self.isVisible:
        return

    s = bodyCtrl.getAllText()    
    index = bodyCtrl.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,index)
    if col > 0:
        s2 = s[index-col:index]
        s2 = g.toUnicode(s2,g.app.tkEncoding)
        col = g.computeWidth (s2,c.tab_width)

    # Important: this does not change the focus because labels never get focus.
    self.labelWidget.configure(text="line %d, col %d" % (row,col))
    self.lastRow = row
    self.lastCol = col
#@-node:ekr.20031218072017.1733:update (statusLine)
#@-node:ekr.20041223104933:class tkStatusLineClass
#@+node:ekr.20041223102225:class tkIconBarClass
class tkIconBarClass:

    '''A class representing the singleton Icon bar'''

    @others
#@+node:ekr.20041223102225.1: ctor
def __init__ (self,c,parentFrame):

    self.c = c

    self.buttons = {}
    self.iconFrame = w = Tk.Frame(parentFrame,height="5m",bd=2,relief="groove")
    self.c.frame.iconFrame = self.iconFrame
    self.parentFrame = parentFrame
    self.visible = False
    self.show()
#@-node:ekr.20041223102225.1: ctor
#@+node:ekr.20031218072017.3958:add
def add(self,*args,**keys):

    """Add a button containing text or a picture to the icon bar.

    Pictures take precedence over text"""

    f = self.iconFrame
    text = keys.get('text')
    imagefile = keys.get('imagefile')
    image = keys.get('image')
    command = keys.get('command')
    bg = keys.get('bg')

    if not imagefile and not image and not text: return

    # First define n.
    try:
        g.app.iconWidgetCount += 1
        n = g.app.iconWidgetCount
    except:
        n = g.app.iconWidgetCount = 1

    if not command:
        def command():
            print "command for widget %s" % (n)

    if imagefile or image:
        << create a picture >>
    elif text:
        b = Tk.Button(f,text=text,relief="groove",bd=2,command=command)
        # if sys.platform != 'darwin':
            # width = max(6,len(text))
            # b.configure(width=width)
        if sys.platform.startswith('win'):
            width = max(6,len(text))
            # width = int(len(text) * 0.95)
            # width = max(6,width)
            b.configure(width=width,font=('verdana',7,'bold'))
            if bg: b.configure(bg=bg)
        b.pack(side="left", fill="none")
        return b

    return None
#@+node:ekr.20031218072017.3959:<< create a picture >>
try:
    if imagefile:
        # Create the image.  Throws an exception if file not found
        imagefile = g.os_path_join(g.app.loadDir,imagefile)
        imagefile = g.os_path_normpath(imagefile)
        image = Tk.PhotoImage(master=g.app.root,file=imagefile)

        # Must keep a reference to the image!
        try:
            refs = g.app.iconImageRefs
        except:
            refs = g.app.iconImageRefs = []

        refs.append((imagefile,image),)

    if not bg:
        bg = f.cget("bg")

    b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
    b.pack(side="left",fill="y")
    return b

except:
    g.es_exception()
    return None
#@-node:ekr.20031218072017.3959:<< create a picture >>
#@-node:ekr.20031218072017.3958:add
#@+node:ekr.20031218072017.3956:clear
def clear(self):

    """Destroy all the widgets in the icon bar"""

    f = self.iconFrame

    for slave in f.pack_slaves():
        slave.destroy()
    self.visible = False

    f.configure(height="5m") # The default height.
    g.app.iconWidgetCount = 0
    g.app.iconImageRefs = []
#@-node:ekr.20031218072017.3956:clear
#@+node:ekr.20061213091114.1:deleteButton (new in Leo 4.4.3)
def deleteButton (self,w):

    w.pack_forget()
#@-node:ekr.20061213091114.1:deleteButton (new in Leo 4.4.3)
#@+node:ekr.20041223114821:getFrame
def getFrame (self):

    return self.iconFrame
#@-node:ekr.20041223114821:getFrame
#@+node:ekr.20041223102225.2:pack (show)
def pack (self):

    """Show the icon bar by repacking it"""

    if not self.visible:
        self.visible = True
        self.iconFrame.pack(fill="x",pady=2)

show = pack
#@-node:ekr.20041223102225.2:pack (show)
#@+node:ekr.20061213092103:setCommandForButton (new in Leo 4.4.3)
def setCommandForButton(self,b,command):

    b.configure(command=command)
#@-node:ekr.20061213092103:setCommandForButton (new in Leo 4.4.3)
#@+node:ekr.20031218072017.3955:unpack (hide)
def unpack (self):

    """Hide the icon bar by unpacking it.

    A later call to show will repack it in a new location."""

    if self.visible:
        self.visible = False
        self.iconFrame.pack_forget()

hide = unpack
#@-node:ekr.20031218072017.3955:unpack (hide)
#@-node:ekr.20041223102225:class tkIconBarClass
#@+node:ekr.20051014154752:Minibuffer methods
#@+node:ekr.20060203115311:showMinibuffer
def showMinibuffer (self):

    '''Make the minibuffer visible.'''

    frame = self

    if not frame.minibufferVisible:
        frame.minibufferFrame.pack(side='bottom',fill='x')
        frame.minibufferVisible = True
#@-node:ekr.20060203115311:showMinibuffer
#@+node:ekr.20060203115311.1:hideMinibuffer
def hideMinibuffer (self):

    '''Hide the minibuffer.'''

    frame = self
    if frame.minibufferVisible:
        frame.minibufferFrame.pack_forget()
        frame.minibufferVisible = False
#@-node:ekr.20060203115311.1:hideMinibuffer
#@+node:ekr.20050920094212:f.createMiniBufferWidget
def createMiniBufferWidget (self):

    '''Create the minbuffer below the status line.'''

    frame = self ; c = frame.c

    frame.minibufferFrame = f = Tk.Frame(frame.outerFrame,relief='flat',borderwidth=0)
    if c.showMinibuffer:
        f.pack(side='bottom',fill='x')

    lab = Tk.Label(f,text='mini-buffer',justify='left',anchor='nw',foreground='blue')
    lab.pack(side='left')

    if c.useTextMinibuffer:
        label = g.app.gui.plainTextWidget(
            f,height=1,relief='groove',background='lightgrey',name='minibuffer')
        label.pack(side='left',fill='x',expand=1,padx=2,pady=1)
    else:
        label = Tk.Label(f,relief='groove',justify='left',anchor='w',name='minibuffer')
        label.pack(side='left',fill='both',expand=1,padx=2,pady=1)

    frame.minibufferVisible = c.showMinibuffer

    return label
#@-node:ekr.20050920094212:f.createMiniBufferWidget
#@+node:ekr.20060203114017:f.setMinibufferBindings
def setMinibufferBindings (self):

    '''Create bindings for the minibuffer..'''

    f = self ; c = f.c ; k = c.k ; w = f.miniBufferWidget

    if not c.useTextMinibuffer: return

    for kind,callback in (
        ('<Key>',           k.masterKeyHandler),
        ('<Button-1>',      k.masterClickHandler),
        ('<Button-3>',      k.masterClick3Handler),
        ('<Double-1>',      k.masterDoubleClickHandler),
        ('<Double-3>',      k.masterDoubleClick3Handler),
    ):
        w.bind(kind,callback)

    if 0:
        if sys.platform.startswith('win'):
            # Support Linux middle-button paste easter egg.
            w.bind("<Button-2>",frame.OnPaste)
#@-node:ekr.20060203114017:f.setMinibufferBindings
#@-node:ekr.20051014154752:Minibuffer methods
#@+node:ekr.20031218072017.3967:Configuration (tkFrame)
#@+node:ekr.20031218072017.3968:configureBar
def configureBar (self,bar,verticalFlag):

    c = self.c

    # Get configuration settings.
    w = c.config.getInt("split_bar_width")
    if not w or w < 1: w = 7
    relief = c.config.get("split_bar_relief","relief")
    if not relief: relief = "flat"
    color = c.config.getColor("split_bar_color")
    if not color: color = "LightSteelBlue2"

    try:
        if verticalFlag:
            # Panes arranged vertically; horizontal splitter bar
            bar.configure(relief=relief,height=w,bg=color,cursor="sb_v_double_arrow")
        else:
            # Panes arranged horizontally; vertical splitter bar
            bar.configure(relief=relief,width=w,bg=color,cursor="sb_h_double_arrow")
    except: # Could be a user error. Use all defaults
        g.es("exception in user configuration for splitbar")
        g.es_exception()
        if verticalFlag:
            # Panes arranged vertically; horizontal splitter bar
            bar.configure(height=7,cursor="sb_v_double_arrow")
        else:
            # Panes arranged horizontally; vertical splitter bar
            bar.configure(width=7,cursor="sb_h_double_arrow")
#@-node:ekr.20031218072017.3968:configureBar
#@+node:ekr.20031218072017.3969:configureBarsFromConfig
def configureBarsFromConfig (self):

    c = self.c

    w = c.config.getInt("split_bar_width")
    if not w or w < 1: w = 7

    relief = c.config.get("split_bar_relief","relief")
    if not relief or relief == "": relief = "flat"

    color = c.config.getColor("split_bar_color")
    if not color or color == "": color = "LightSteelBlue2"

    if self.splitVerticalFlag:
        bar1,bar2=self.bar1,self.bar2
    else:
        bar1,bar2=self.bar2,self.bar1

    try:
        bar1.configure(relief=relief,height=w,bg=color)
        bar2.configure(relief=relief,width=w,bg=color)
    except: # Could be a user error.
        g.es("exception in user configuration for splitbar")
        g.es_exception()
#@-node:ekr.20031218072017.3969:configureBarsFromConfig
#@+node:ekr.20031218072017.2246:reconfigureFromConfig
def reconfigureFromConfig (self):

    frame = self ; c = frame.c

    frame.tree.setFontFromConfig()
    ### frame.tree.setColorFromConfig()

    frame.configureBarsFromConfig()

    frame.body.setFontFromConfig()
    frame.body.setColorFromConfigt()

    frame.setTabWidth(c.tab_width)
    frame.log.setFontFromConfig()
    frame.log.setColorFromConfig()

    c.redraw_now()
#@-node:ekr.20031218072017.2246:reconfigureFromConfig
#@+node:ekr.20031218072017.1625:setInitialWindowGeometry
def setInitialWindowGeometry(self):

    """Set the position and size of the frame to config params."""

    c = self.c

    h = c.config.getInt("initial_window_height") or 500
    w = c.config.getInt("initial_window_width") or 600
    x = c.config.getInt("initial_window_left") or 10
    y = c.config.getInt("initial_window_top") or 10

    if h and w and x and y:
        self.setTopGeometry(w,h,x,y)
#@-node:ekr.20031218072017.1625:setInitialWindowGeometry
#@+node:ekr.20031218072017.722:setTabWidth
def setTabWidth (self, w):

    try: # This can fail when called from scripts
        # Use the present font for computations.
        font = self.bodyCtrl.cget("font")
        root = g.app.root # 4/3/03: must specify root so idle window will work properly.
        font = tkFont.Font(root=root,font=font)
        tabw = font.measure(" " * abs(w)) # 7/2/02
        self.bodyCtrl.configure(tabs=tabw)
        self.tab_width = w
        # g.trace(w,tabw)
    except:
        g.es_exception()
        pass
#@-node:ekr.20031218072017.722:setTabWidth
#@+node:ekr.20031218072017.1540:f.setWrap
def setWrap (self,p):

    c = self.c
    theDict = g.scanDirectives(c,p)
    if not theDict: return

    wrap = theDict.get("wrap")
    if self.body.wrapState == wrap: return

    self.body.wrapState = wrap
    # g.trace(wrap)
    if wrap:
        self.bodyCtrl.configure(wrap="word")
        self.bodyXBar.pack_forget()
    else:
        self.bodyCtrl.configure(wrap="none")
        # Bug fix: 3/10/05: We must unpack the text area to make the scrollbar visible.
        self.bodyCtrl.pack_forget()
        self.bodyXBar.pack(side="bottom", fill="x")
        self.bodyCtrl.pack(expand=1,fill="both")
#@-node:ekr.20031218072017.1540:f.setWrap
#@+node:ekr.20031218072017.2307:setTopGeometry
def setTopGeometry(self,w,h,x,y,adjustSize=True):

    # Put the top-left corner on the screen.
    x = max(10,x) ; y = max(10,y)

    if adjustSize:
        top = self.top
        sw = top.winfo_screenwidth()
        sh = top.winfo_screenheight()

        # Adjust the size so the whole window fits on the screen.
        w = min(sw-10,w)
        h = min(sh-10,h)

        # Adjust position so the whole window fits on the screen.
        if x + w > sw: x = 10
        if y + h > sh: y = 10

    geom = "%dx%d%+d%+d" % (w,h,x,y)

    self.top.geometry(geom)
#@-node:ekr.20031218072017.2307:setTopGeometry
#@+node:ekr.20031218072017.3970:reconfigurePanes (use config bar_width)
def reconfigurePanes (self):

    c = self.c

    border = c.config.getInt('additional_body_text_border')
    if border == None: border = 0

    # The body pane needs a _much_ bigger border when tiling horizontally.
    border = g.choose(self.splitVerticalFlag,2+border,6+border)
    self.bodyCtrl.configure(bd=border)

    # The log pane needs a slightly bigger border when tiling vertically.
    border = g.choose(self.splitVerticalFlag,4,2) 
    self.log.configureBorder(border)
#@-node:ekr.20031218072017.3970:reconfigurePanes (use config bar_width)
#@+node:ekr.20060915124834:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):

    # g.trace(ratio,ratio2,g.callers())

    self.divideLeoSplitter(self.splitVerticalFlag,ratio)
    self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@-node:ekr.20060915124834:resizePanesToRatio
#@-node:ekr.20031218072017.3967:Configuration (tkFrame)
#@+node:ekr.20031218072017.3971:Event handlers (tkFrame)
#@+node:ekr.20031218072017.3972:frame.OnCloseLeoEvent
# Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):

    f = self ; c = f.c

    if c.inCommand:
        # g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)
#@-node:ekr.20031218072017.3972:frame.OnCloseLeoEvent
#@+node:ekr.20031218072017.3973:frame.OnControlKeyUp/Down
def OnControlKeyDown (self,event=None):

    __pychecker__ = '--no-argsused' # event not used.

    self.controlKeyIsDown = True

def OnControlKeyUp (self,event=None):

    __pychecker__ = '--no-argsused' # event not used.

    self.controlKeyIsDown = False
#@-node:ekr.20031218072017.3973:frame.OnControlKeyUp/Down
#@+node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
def OnActivateBody (self,event=None):

    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; c = frame.c
        c.setLog()
        w = c.get_focus()
        if w != c.frame.body.bodyCtrl:
            frame.tree.OnDeactivate()
        c.bodyWantsFocus()
    except:
        g.es_event_exception("activate body")

    return 'break'
#@-node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
#@+node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
def OnActivateLeoEvent(self,event=None):

    '''Handle a click anywhere in the Leo window.'''

    __pychecker__ = '--no-argsused' # event.

    self.c.setLog()

def OnDeactivateLeoEvent(self,event=None):

    pass # This causes problems on the Mac.
#@-node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
#@+node:ekr.20031218072017.3976:OnActivateTree
def OnActivateTree (self,event=None):

    try:
        frame = self ; c = frame.c
        c.setLog()

        if 0: # Do NOT do this here!
            # OnActivateTree can get called when the tree gets DE-activated!!
            c.bodyWantsFocus()

    except:
        g.es_event_exception("activate tree")
#@-node:ekr.20031218072017.3976:OnActivateTree
#@+node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
def OnBodyClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyclick1",c=c,p=p,v=p,event=event):
            self.OnActivateBody(event=event)
        g.doHook("bodyclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyrclick1",c=c,p=p,v=p,event=event):
            pass # By default Leo does nothing.
        g.doHook("bodyrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
#@-node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
#@+node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if event and not g.doHook("bodydclick1",c=c,p=p,v=p,event=event):
            c.editCommands.extendToWord(event) # Handles unicode properly.
        g.doHook("bodydclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodydclick")

    return "break" # Restore this to handle proper double-click logic.
#@-node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
#@+node:ekr.20031218072017.1803:OnMouseWheel (Tomaz Ficko)
# Contributed by Tomaz Ficko.  This works on some systems.
# On XP it causes a crash in tcl83.dll.  Clearly a Tk bug.

def OnMouseWheel(self, event=None):

    try:
        if event.delta < 1:
            self.canvas.yview(Tk.SCROLL, 1, Tk.UNITS)
        else:
            self.canvas.yview(Tk.SCROLL, -1, Tk.UNITS)
    except:
        g.es_event_exception("scroll wheel")

    return "break"
#@-node:ekr.20031218072017.1803:OnMouseWheel (Tomaz Ficko)
#@-node:ekr.20031218072017.3971:Event handlers (tkFrame)
#@+node:ekr.20031218072017.3979:Gui-dependent commands
#@+node:ekr.20060209110128:Minibuffer commands... (tkFrame)

#@+node:ekr.20060209110128.1:contractPane
def contractPane (self,event=None):

    '''Contract the selected pane.'''

    f = self ; c = f.c
    w = c.get_requested_focus()
    wname = c.widget_name(w)

    # g.trace(wname)
    if not w: return

    if wname.startswith('body'):
        f.contractBodyPane()
    elif wname.startswith('log'):
        f.contractLogPane()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.contractOutlinePane()
#@-node:ekr.20060209110128.1:contractPane
#@+node:ekr.20060209110128.2:expandPane
def expandPane (self,event=None):

    '''Expand the selected pane.'''

    f = self ; c = f.c

    w = c.get_requested_focus()
    wname = c.widget_name(w)

    # g.trace(wname)
    if not w: return

    if wname.startswith('body'):
        f.expandBodyPane()
    elif wname.startswith('log'):
        f.expandLogPane()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.expandOutlinePane()
#@-node:ekr.20060209110128.2:expandPane
#@+node:ekr.20060210123852:fullyExpandPane
def fullyExpandPane (self,event=None):

    '''Fully expand the selected pane.'''

    f = self ; c = f.c

    w = c.get_requested_focus()
    wname = c.widget_name(w)

    # g.trace(wname)
    if not w: return

    if wname.startswith('body'):
        f.fullyExpandBodyPane()
    elif wname.startswith('log'):
        f.fullyExpandLogPane()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.fullyExpandOutlinePane()
#@-node:ekr.20060210123852:fullyExpandPane
#@+node:ekr.20060209143933:hidePane
def hidePane (self,event=None):

    '''Completely contract the selected pane.'''

    f = self ; c = f.c

    w = c.get_requested_focus()
    wname = c.widget_name(w)

    g.trace(wname)
    if not w: return

    if wname.startswith('body'):
        f.hideBodyPane()
        c.treeWantsFocusNow()
    elif wname.startswith('log'):
        f.hideLogPane()
        c.bodyWantsFocusNow()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.hideOutlinePane()
        c.bodyWantsFocusNow()
#@-node:ekr.20060209143933:hidePane
#@+node:ekr.20060209110936:expand/contract/hide...Pane
@ The first arg to divideLeoSplitter means the following:

    f.splitVerticalFlag: use the primary   (tree/body) ratio.
not f.splitVerticalFlag: use the secondary (tree/log) ratio.
@c

def contractBodyPane (self,event=None):
    '''Contract the body pane.'''
    f = self ; r = min(1.0,f.ratio+0.1)
    f.divideLeoSplitter(f.splitVerticalFlag,r)

def contractLogPane (self,event=None):
    '''Contract the log pane.'''
    f = self ; r = min(1.0,f.ratio+0.1)
    f.divideLeoSplitter(not f.splitVerticalFlag,r)

def contractOutlinePane (self,event=None):
    '''Contract the outline pane.'''
    f = self ; r = max(0.0,f.ratio-0.1)
    f.divideLeoSplitter(f.splitVerticalFlag,r)

def expandBodyPane (self,event=None):
    '''Expand the body pane.'''
    self.contractOutlinePane()

def expandLogPane(self,event=None):
    '''Expand the log pane.'''
    f = self ; r = max(0.0,f.ratio-0.1)
    f.divideLeoSplitter(not f.splitVerticalFlag,r)

def expandOutlinePane (self,event=None):
    '''Expand the outline pane.'''
    self.contractBodyPane()
#@-node:ekr.20060209110936:expand/contract/hide...Pane
#@+node:ekr.20060210123852.1:fullyExpand/hide...Pane
def fullyExpandBodyPane (self,event=None):
    '''Fully expand the body pane.'''
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,0.0)

def fullyExpandLogPane (self,event=None):
    '''Fully expand the log pane.'''
    f = self ; f.divideLeoSplitter(not f.splitVerticalFlag,0.0)

def fullyExpandOutlinePane (self,event=None):
    '''Fully expand the outline pane.'''
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,1.0)

def hideBodyPane (self,event=None):
    '''Completely contract the body pane.'''
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,1.0)

def hideLogPane (self,event=None):
    '''Completely contract the log pane.'''
    f = self ; f.divideLeoSplitter(not f.splitVerticalFlag,1.0)

def hideOutlinePane (self,event=None):
    '''Completely contract the outline pane.'''
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,0.0)
#@-node:ekr.20060210123852.1:fullyExpand/hide...Pane
#@-node:ekr.20060209110128:Minibuffer commands... (tkFrame)
#@+node:ekr.20031218072017.3984:Window Menu...
#@+node:ekr.20031218072017.3985:toggleActivePane
def toggleActivePane (self,event=None):

    '''Toggle the focus between the outline and body panes.'''

    frame = self ; c = frame.c

    if c.get_focus() == frame.bodyCtrl:
        c.treeWantsFocusNow()
    else:
        c.endEditing()
        c.bodyWantsFocusNow()
#@-node:ekr.20031218072017.3985:toggleActivePane
#@+node:ekr.20031218072017.3986:cascade
def cascade (self,event=None):

    '''Cascade all Leo windows.'''

    x,y,delta = 10,10,10
    for frame in g.app.windowList:
        top = frame.top

        # Compute w,h
        top.update_idletasks() # Required to get proper info.
        geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
        dim,junkx,junky = string.split(geom,'+')
        w,h = string.split(dim,'x')
        w,h = int(w),int(h)

        # Set new x,y and old w,h
        frame.setTopGeometry(w,h,x,y,adjustSize=False)

        # Compute the new offsets.
        x += 30 ; y += 30
        if x > 200:
            x = 10 + delta ; y = 40 + delta
            delta += 10
#@-node:ekr.20031218072017.3986:cascade
#@+node:ekr.20031218072017.3987:equalSizedPanes
def equalSizedPanes (self,event=None):

    '''Make the outline and body panes have the same size.'''

    frame = self
    frame.resizePanesToRatio(0.5,frame.secondary_ratio)
#@-node:ekr.20031218072017.3987:equalSizedPanes
#@+node:ekr.20031218072017.3988:hideLogWindow
def hideLogWindow (self,event=None):

    frame = self
    frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)
#@-node:ekr.20031218072017.3988:hideLogWindow
#@+node:ekr.20031218072017.3989:minimizeAll
def minimizeAll (self,event=None):

    '''Minimize all Leo's windows.'''

    self.minimize(g.app.pythonFrame)
    for frame in g.app.windowList:
        self.minimize(frame)
        self.minimize(frame.findPanel)

def minimize(self,frame):

    if frame and frame.top.state() == "normal":
        frame.top.iconify()
#@-node:ekr.20031218072017.3989:minimizeAll
#@+node:ekr.20031218072017.3990:toggleSplitDirection (tkFrame)
# The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.

def toggleSplitDirection (self,event=None):

    '''Toggle the split direction in the present Leo window.'''

    # Switch directions.
    c = self.c
    self.splitVerticalFlag = not self.splitVerticalFlag
    orientation = g.choose(self.splitVerticalFlag,"vertical","horizontal")
    c.config.set("initial_splitter_orientation","string",orientation)

    self.toggleTkSplitDirection(self.splitVerticalFlag)
#@+node:ekr.20041221122440.2:toggleTkSplitDirection
def toggleTkSplitDirection (self,verticalFlag):

    # Abbreviations.
    frame = self
    bar1 = self.bar1 ; bar2 = self.bar2
    split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
    split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
    # Reconfigure the bars.
    bar1.place_forget()
    bar2.place_forget()
    self.configureBar(bar1,verticalFlag)
    self.configureBar(bar2,not verticalFlag)
    # Make the initial placements again.
    self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
    self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
    # Adjust the log and body panes to give more room around the bars.
    self.reconfigurePanes()
    # Redraw with an appropriate ratio.
    vflag,ratio,secondary_ratio = frame.initialRatios()
    self.resizePanesToRatio(ratio,secondary_ratio)
#@-node:ekr.20041221122440.2:toggleTkSplitDirection
#@-node:ekr.20031218072017.3990:toggleSplitDirection (tkFrame)
#@+node:EKR.20040422130619:resizeToScreen
def resizeToScreen (self,event=None):

    '''Resize the Leo window so it fill the entire screen.'''

    top = self.top

    w = top.winfo_screenwidth()
    h = top.winfo_screenheight()

    if sys.platform == 'darwin':
        # Must leave room to get at very small resizing area.
        geom = "%dx%d%+d%+d" % (w-20,h-55,10,25)
    else:
        # Fill almost the entire screen.
        # Works on Windows. YMMV for other platforms.
        geom = "%dx%d%+d%+d" % (w-8,h-46,0,0)

    top.geometry(geom)
#@-node:EKR.20040422130619:resizeToScreen
#@-node:ekr.20031218072017.3984:Window Menu...
#@+node:ekr.20031218072017.3991:Help Menu...
#@+node:ekr.20031218072017.3992:leoHelp
def leoHelp (self,event=None):

    '''Open Leo's offline tutorial.'''

    frame = self ; c = frame.c

    theFile = g.os_path_join(g.app.loadDir,"..","doc","sbooks.chm")

    if g.os_path_exists(theFile):
        os.startfile(theFile)
    else:
        answer = g.app.gui.runAskYesNoDialog(c,
            "Download Tutorial?",
            "Download tutorial (sbooks.chm) from SourceForge?")

        if answer == "yes":
            try:
                if 0: # Download directly.  (showProgressBar needs a lot of work)
                    url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
                    import urllib
                    self.scale = None
                    urllib.urlretrieve(url,theFile,self.showProgressBar)
                    if self.scale:
                        self.scale.destroy()
                        self.scale = None
                else:
                    url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
                    import webbrowser
                    os.chdir(g.app.loadDir)
                    webbrowser.open_new(url)
            except:
                g.es("exception dowloading sbooks.chm")
                g.es_exception()
#@+node:ekr.20031218072017.3993:showProgressBar
def showProgressBar (self,count,size,total):

    # g.trace("count,size,total:",count,size,total)
    if self.scale == None:
        << create the scale widget >>
    self.scale.set(count*size)
    self.scale.update_idletasks()
#@+node:ekr.20031218072017.3994:<< create the scale widget >>
top = Tk.Toplevel()
top.title("Download progress")
self.scale = scale = Tk.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
scale.pack()
top.lift()
#@-node:ekr.20031218072017.3994:<< create the scale widget >>
#@-node:ekr.20031218072017.3993:showProgressBar
#@-node:ekr.20031218072017.3992:leoHelp
#@-node:ekr.20031218072017.3991:Help Menu...
#@-node:ekr.20031218072017.3979:Gui-dependent commands
#@+node:ekr.20050120083053:Delayed Focus (tkFrame)
@ New in 4.3. The proper way to change focus is to call c.frame.xWantsFocus.

Important: This code never calls select, so there can be no race condition here
that alters text improperly.
#@-node:ekr.20050120083053:Delayed Focus (tkFrame)
#@+node:ekr.20031218072017.3995:Tk bindings...
def bringToFront (self):
    # g.trace(g.callers())
    self.top.deiconify()
    self.top.lift()

def getFocus(self):
    """Returns the widget that has focus, or body if None."""
    try:
        # This method is unreliable while focus is changing.
        # The call to update_idletasks may help.  Or not.
        self.top.update_idletasks()
        f = self.top.focus_displayof()
    except Exception:
        f = None
    if f:
        return f
    else:
        return self.bodyCtrl

def getTitle (self):
    return self.top.title()

def setTitle (self,title):
    return self.top.title(title)

def get_window_info(self):
    return g.app.gui.get_window_info(self.top)

def iconify(self):
    self.top.iconify()

def deiconify (self):
    self.top.deiconify()

def lift (self):
    self.top.lift()

def update (self):
    self.top.update()
#@-node:ekr.20031218072017.3995:Tk bindings...
#@-node:ekr.20031218072017.3940:class leoTkinterFrame
#@+node:ekr.20031218072017.4039:class leoTkinterLog
class leoTkinterLog (leoFrame.leoLog):

    """A class that represents the log pane of a Tkinter window."""

    @others
#@+node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20031218072017.4040:tkLog.__init__
def __init__ (self,frame,parentFrame):

    # g.trace("leoTkinterLog")

    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)

    self.c = c = frame.c # Also set in the base constructor, but we need it here.

    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")

    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.menu = None # A menu that pops up on right clicks in the hull or in tabs.

    self.logCtrl = self.createControl(parentFrame)
    self.setFontFromConfig()
    self.setColorFromConfig()



#@-node:ekr.20031218072017.4040:tkLog.__init__
#@+node:ekr.20031218072017.4042:tkLog.createControl
def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        return self.onRightClick(event,menu)

    self.nb.bind('<Button-3>',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # Create and activate the default tabs.

    return self.logCtrl
#@-node:ekr.20031218072017.4042:tkLog.createControl
#@+node:ekr.20070114070939:tkLog.finishCreate
def finishCreate (self):

    # g.trace('tkLog')

    c = self.c ; log = self

    c.searchCommands.openFindTab(show=False)
    c.spellCommands.openSpellTab()
    log.selectTab('Log')
#@-node:ekr.20070114070939:tkLog.finishCreate
#@+node:ekr.20051016103459:tkLog.createTextWidget
def createTextWidget (self,parentFrame):

    self.logNumber += 1
    log = g.app.gui.plainTextWidget(
        parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")

    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview

    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log
#@-node:ekr.20051016103459:tkLog.createTextWidget
#@+node:ekr.20051019134106.1:tkLog.makeTabMenu
def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    # g.trace(tabName,g.callers())

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.

    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)

    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            return self.deleteTab(tabName)

        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)

        def renameTabCallback():
            return self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu
#@-node:ekr.20051019134106.1:tkLog.makeTabMenu
#@-node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
def configureBorder(self,border):

    self.logCtrl.configure(bd=border)

def configureFont(self,font):

    self.logCtrl.configure(font=font)
#@-node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
#@+node:ekr.20031218072017.4043:tkLog.getFontConfig
def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font
#@-node:ekr.20031218072017.4043:tkLog.getFontConfig
#@+node:ekr.20041222043017:tkLog.restoreAllState
def restoreAllState (self,d):

    '''Restore the log from a dict created by saveAllState.'''

    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)
#@-node:ekr.20041222043017:tkLog.restoreAllState
#@+node:ekr.20041222043017.1:tkLog.saveAllState
def saveAllState (self):

    '''Return a dict containing all data needed to recreate the log in another widget.'''

    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.getAllText()

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)

    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d
#@-node:ekr.20041222043017.1:tkLog.saveAllState
#@+node:ekr.20041217135735.2:tkLog.setColorFromConfig
def setColorFromConfig (self):

    c = self.c

    bg = c.config.getColor("log_pane_background_color") or 'white'

    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()
#@-node:ekr.20041217135735.2:tkLog.setColorFromConfig
#@+node:ekr.20031218072017.4046:tkLog.setFontFromConfig
def SetWidgetFontFromConfig (self,logCtrl=None):

    c = self.c

    if not logCtrl: logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant", "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)

    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass

    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass

setFontFromConfig = SetWidgetFontFromConfig # Renaming supresses a pychecker warning.
#@-node:ekr.20031218072017.4046:tkLog.setFontFromConfig
#@-node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20031218072017.4045:tkLog.onActivateLog
def onActivateLog (self,event=None):

    try:
        self.c.setLog()
        self.frame.tree.OnDeactivate()
        self.c.logWantsFocus()
    except:
        g.es_event_exception("activate log")
#@-node:ekr.20031218072017.4045:tkLog.onActivateLog
#@+node:ekr.20031218072017.4044:tkLog.hasFocus
def hasFocus (self):

    return self.c.get_focus() == self.logCtrl
#@-node:ekr.20031218072017.4044:tkLog.hasFocus
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.logCtrl.update_idletasks()
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20051016101927:put & putnl (tkLog)
@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...
#@+node:ekr.20031218072017.1473:put
# All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):

    c = self.c

    # print 'tkLog.put',self.c.shortFileName(),tabName,g.callers()

    if g.app.quitting or not c or not c.exists:
        return

    if tabName:
        self.selectTab(tabName)

    if self.logCtrl:
        << put s to log control >>
        self.logCtrl.update_idletasks()
    else:
        << put s to logWaiting and print s >>
#@+node:EKR.20040423082910:<< put s to log control >>
if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see('end')
self.forceLogUpdate(s)
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@-node:ekr.20031218072017.1473:put
#@+node:ekr.20051016101927.1:putnl
def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)

    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see('end')
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
#@-node:ekr.20051016101927.1:putnl
#@-node:ekr.20051016101927:put & putnl (tkLog)
#@+node:ekr.20051018061932:Tab (TkLog)
#@+node:ekr.20051017212057:clearTab
def clearTab (self,tabName,wrap='none'):

    self.selectTab(tabName,wrap=wrap)
    w = self.logCtrl
    w and w.delete(0,'end')
#@-node:ekr.20051017212057:clearTab
#@+node:ekr.20051024173701:createTab
def createTab (self,tabName,createText=True,wrap='none'):

    # g.trace(tabName,wrap)

    c = self.c ; k = c.k
    tabFrame = self.nb.add(tabName)
    self.menu = self.makeTabMenu(tabName)
    if createText:
        << Create the tab's text widget >>
        if tabName != 'Log':
            # c.k doesn't exist when the log pane is created.
            # k.makeAllBindings will call setTabBindings('Log')
            self.setTabBindings(tabName)
    else:
        self.textDict [tabName] = None
        self.frameDict [tabName] = tabFrame
#@+node:ekr.20051018072306:<< Create the tab's text widget >>
w = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'

if wrap not in ('none','char','word'): wrap = 'none'
try: w.configure(bg=bg,wrap=wrap)
except Exception: pass # Could be a user error.

self.SetWidgetFontFromConfig(logCtrl=w)

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = w

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]

self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags
#@-node:ekr.20051018072306:<< Create the tab's text widget >>
#@-node:ekr.20051024173701:createTab
#@+node:ekr.20060613131217:cycleTabFocus
def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)
    values = d.values()
    if self.numberOfVisibleTabs() > 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = d.keys()[i]
        self.selectTab(tabName)
        return 
#@nonl
#@-node:ekr.20060613131217:cycleTabFocus
#@+node:ekr.20051018102027:deleteTab
def deleteTab (self,tabName,force=False):

    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell') and not force:
        self.selectTab('Log')

    elif tabName in self.nb.pagenames():
        # g.trace(tabName,force)
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')

    # New in Leo 4.4b1.
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
#@-node:ekr.20051018102027:deleteTab
#@+node:ekr.20060204124347:hideTab
def hideTab (self,tabName):

    __pychecker__ = '--no-argsused' # tabName

    self.selectTab('Log')
#@-node:ekr.20060204124347:hideTab
#@+node:ekr.20051027114433:getSelectedTab
def getSelectedTab (self):

    return self.tabName
#@-node:ekr.20051027114433:getSelectedTab
#@+node:ekr.20051018061932.1:lower/raiseTab
def lowerTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
#@-node:ekr.20051018061932.1:lower/raiseTab
#@+node:ekr.20060613131345:numberOfVisibleTabs
def numberOfVisibleTabs (self):

    return len([val for val in self.frameDict.values() if val != None])
#@-node:ekr.20060613131345:numberOfVisibleTabs
#@+node:ekr.20051019170806:renameTab
def renameTab (self,oldName,newName):

    # g.trace('newName',newName)

    label = self.nb.tab(oldName)
    label.configure(text=newName)
#@-node:ekr.20051019170806:renameTab
#@+node:ekr.20051016101724.1:selectTab
def selectTab (self,tabName,createText=True,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c

    tabFrame = self.frameDict.get(tabName)
    logCtrl = self.textDict.get(tabName)

    if tabFrame and logCtrl:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    elif not tabFrame:
        self.createTab(tabName,createText=createText,wrap=wrap)

    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0: # Absolutely do not do this here!  It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)
    return tabFrame
#@-node:ekr.20051016101724.1:selectTab
#@+node:ekr.20051022162730:setTabBindings
def setTabBindings (self,tabName):

    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    w = self.textDict.get(tabName)

    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('<Key>',       k.masterKeyHandler),
        ('<Button-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClick3Handler),
    ):
        w.bind(kind,handler)

    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        return self.onRightClick(event,menu)

    def tabMenuClickCallback(event,tabName=tabName):
        return self.onClick(event,tabName)

    tab.bind('<Button-1>',tabMenuClickCallback)
    tab.bind('<Button-3>',tabMenuRightClickCallback)

    k.completeAllBindingsForWidget(w)
#@-node:ekr.20051022162730:setTabBindings
#@+node:ekr.20051019134106:Tab menu callbacks & helpers
#@+node:ekr.20051019134422:onRightClick & onClick
def onRightClick (self,event,menu):

    c = self.c
    menu.post(event.x_root,event.y_root)


def onClick (self,event,tabName):

    self.selectTab(tabName)
#@-node:ekr.20051019134422:onRightClick & onClick
#@+node:ekr.20051019140004.1:newTabFromMenu
def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)

    # This is called by getTabName.
    def selectTabCallback (newName):
        return self.selectTab(newName)

    self.getTabName(selectTabCallback)
#@-node:ekr.20051019140004.1:newTabFromMenu
#@+node:ekr.20051019165401:renameTabFromMenu
def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            return self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)
#@-node:ekr.20051019165401:renameTabFromMenu
#@+node:ekr.20051019172811:getTabName
def getTabName (self,exitCallback):

    canvas = self.nb.component('hull')

    # Overlay what is there!
    c = self.c
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)

    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)

    def closeTabNameCallback (event=None):
        f.pack_forget()

    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)

    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    g.app.gui.set_focus(c,e)
    e.bind('<Return>',getNameCallback)
#@-node:ekr.20051019172811:getTabName
#@-node:ekr.20051019134106:Tab menu callbacks & helpers
#@-node:ekr.20051018061932:Tab (TkLog)
#@+node:ekr.20051019183105.3:tkLog color tab stuff
def createColorPicker (self,tabName):

    log = self

    << define colors >>

    parent = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    colors = list(colors)
    bg = parent.cget('background')

    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)

    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')

    label = g.app.gui.plainTextWidget(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    << create optionMenu and callback >>
    << create picker button and callback >>
#@+node:ekr.20051019183105.4:<< create optionMenu and callback >>
colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)
#@-node:ekr.20051019183105.4:<< create optionMenu and callback >>
#@+node:ekr.20051019183105.5:<< create picker button and callback >>
def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)
#@-node:ekr.20051019183105.5:<< create picker button and callback >>
#@+node:ekr.20051019183105.2:<< define colors >>
colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )
#@-node:ekr.20051019183105.2:<< define colors >>
#@-node:ekr.20051019183105.3:tkLog color tab stuff
#@+node:ekr.20070212102521:tkLog font tab stuff
#@+node:ekr.20051019201809.1:createFontPicker
def createFontPicker (self,tabName):

    log = self
    parent = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    bg = parent.cget('background')
    font = self.getFont()
    << create the frames >>
    << create the family combo box >>
    << create the size entry >>
    << create the weight combo box >>
    << create the slant combo box >>
    << create the sample text widget >>
    << create and bind the callbacks >>
    self.createBindings()
#@+node:ekr.20051019202139:<< create the frames >>
f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')
#@-node:ekr.20051019202139:<< create the frames >>
#@+node:ekr.20051019201809.2:<< create the family combo box >>
names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'<None>')

self.familyBox = familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.2:<< create the family combo box >>
#@+node:ekr.20051019201809.3:<< create the size entry >>
Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4)
sizeEntry.insert(0,'12')
sizeEntry.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.3:<< create the size entry >>
#@+node:ekr.20051019201809.4:<< create the weight combo box >>
weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.4:<< create the weight combo box >>
#@+node:ekr.20051019201809.5:<< create the slant combo box>>
slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.5:<< create the slant combo box>>
#@+node:ekr.20051019202139.1:<< create the sample text widget >>
self.sampleWidget = sample = g.app.gui.plainTextWidget(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert(0,s)
#@-node:ekr.20051019202139.1:<< create the sample text widget >>
#@+node:ekr.20051019202328:<< create and bind the callbacks >>
def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('<Return>',fontCallback)
#@-node:ekr.20051019202328:<< create and bind the callbacks >>
#@-node:ekr.20051019201809.1:createFontPicker
#@+node:ekr.20060726133852:createBindings (fontPicker)
def createBindings (self):

    c = self.c ; k = c.k

    table = (
        ('<Button-1>',  k.masterClickHandler),
        ('<Double-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClickHandler),
        ('<Double-3>',  k.masterClickHandler),
        ('<Key>',       k.masterKeyHandler),
        ("<Escape>",    self.hideFontTab),
    )

    w = self.sampleWidget
    for event, callback in table:
        w.bind(event,callback)

    k.completeAllBindingsForWidget(w)
#@-node:ekr.20060726133852:createBindings (fontPicker)
#@+node:ekr.20051019201809.6:getFont
def getFont(self,family=None,size=12,slant='roman',weight='normal'):

    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@-node:ekr.20051019201809.6:getFont
#@+node:ekr.20051019201809.7:setFont
def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):

    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','<none>',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)
#@-node:ekr.20051019201809.7:setFont
#@+node:ekr.20060726134339:hideFontTab
def hideFontTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@-node:ekr.20060726134339:hideFontTab
#@-node:ekr.20070212102521:tkLog font tab stuff
#@-node:ekr.20031218072017.4039:class leoTkinterLog
#@+node:ekr.20070317073627.3:class leoTkinterTreeTab
class leoTkinterTreeTab (leoFrame.leoTreeTab):

    '''A class representing a tabbed outline pane drawn with Tkinter.'''

    @others
#@nonl
#@+node:ekr.20070320090557.1: Birth & death
#@+node:ekr.20070317073819.1: ctor (leoTreeTab)
def __init__ (self,c,parentFrame,chapterController):

    leoFrame.leoTreeTab.__init__ (self,c,chapterController,parentFrame)
        # Init the base class.  Sets self.c, self.cc and self.parentFrame.

    self.tabNames = [] # The list of tab names.  Changes when tabs are renamed.

    self.createControl()
#@-node:ekr.20070317073819.1: ctor (leoTreeTab)
#@+node:ekr.20070317073819.2:tt.createControl
def createControl (self):

    tt = self ; c = tt.c

    # Create the main container.
    tt.frame = Tk.Frame(c.frame.iconFrame)
    tt.frame.pack(side="left")

    # Create the chapter menu.
    self.chapterVar = var = Tk.StringVar()
    var.set('main')

    tt.chapterMenu = menu = Pmw.OptionMenu(tt.frame,
        labelpos = 'w', label_text = 'chapter',
        menubutton_textvariable = var,
        items = [],
        command = tt.selectTab,
    )
    menu.pack(side='left',padx=5)
#@nonl
#@-node:ekr.20070317073819.2:tt.createControl
#@-node:ekr.20070320090557.1: Birth & death
#@+node:ekr.20070320093038:Tabs...
#@+node:ekr.20070317074824:tt.createTab
def createTab (self,tabName,select=True):

    tt = self

    if tabName not in tt.tabNames:
        tt.tabNames.append(tabName)
        tt.setNames()
#@-node:ekr.20070317074824:tt.createTab
#@+node:ekr.20070317074824.1:tt.destroyTab
def destroyTab (self,tabName):

    tt = self

    if tabName in tt.tabNames:
        tt.tabNames.remove(tabName)
        tt.setNames()
#@-node:ekr.20070317074824.1:tt.destroyTab
#@+node:ekr.20070317074824.3:tt.selectTab
def selectTab (self,tabName):

    tt = self

    if tabName not in self.tabNames:
        tt.createTab(tabName)

    tt.cc.selectChapterByName(tabName)
#@-node:ekr.20070317074824.3:tt.selectTab
#@+node:ekr.20070604192627:tt.setTabLabel
def setTabLabel (self,tabName):

    tt = self
    tt.chapterVar.set(tabName)
#@-node:ekr.20070604192627:tt.setTabLabel
#@+node:ekr.20070604210618:tt.setNames
def setNames (self):

    '''Recreate the list of items.'''

    tt = self
    names = tt.tabNames[:]
    if 'main' in names: names.remove('main')
    names.sort()
    names.insert(0,'main')
    tt.chapterMenu.setitems(names)
#@-node:ekr.20070604210618:tt.setNames
#@-node:ekr.20070320093038:Tabs...
#@-node:ekr.20070317073627.3:class leoTkinterTreeTab
#@+node:ekr.20061113151148.1:class leoTkTextWidget (Tk.Text)
class leoTkTextWidget (Tk.Text):

    '''A class to wrap the Tk.Text widget.
    Translates Python (integer) indices to and from Tk (string) indices.

    This class inherits almost all tkText methods: you call use them as usual.'''

    # The signatures of tag_add and insert are different from the Tk.Text signatures.
    __pychecker__ = '--no-override' # suppress warning about changed signature.

    def __repr__(self):
        name = hasattr(self,'_name') and self._name or '<no name>'
        return 'leoTkTextWidget id: %s name: %s' % (id(self),name)

    @others
#@nonl
#@+node:ekr.20070213170836:plainTextWidget.__init__
if 0:
    def __init__ (self,c,*args,**keys):

        w = self

        # Create the actual gui widget.
        self.widget = Tk.Text(*args,**keys)

        # Init the base class.
        name = keys.get('name') or '<unknown plainTextWidget>'
        baseTextWidget.__init__(self,c=c,
            baseClassName='plainTextWidget',name=name,widget=self.widget)

        # self.defaultFont = font = wx.Font(pointSize=10,
            # family = wx.FONTFAMILY_TELETYPE, # wx.FONTFAMILY_ROMAN,
            # style  = wx.FONTSTYLE_NORMAL,
            # weight = wx.FONTWEIGHT_NORMAL,)
#@-node:ekr.20070213170836:plainTextWidget.__init__
#@+node:ekr.20070213170937:bindings (not used)
# Specify the names of widget-specific methods.
# These particular names are the names of wx.TextCtrl methods.

# def _appendText(self,s):            return self.widget.insert(s)
# def _get(self,i,j):                 return self.widget.get(i,j)
# def _getAllText(self):              return self.widget.get('1.0','end')
# def _getFocus(self):                return self.widget.focus_get()
# def _getInsertPoint(self):          return self.widget.index('insert')
# def _getLastPosition(self):         return self.widget.index('end')
# def _getSelectedText(self):         return self.widget.get('sel.start','sel.end')
# def _getSelectionRange(self):       return self.widget.index('sel.start'),self.widget.index('sel.end')
# def _hitTest(self,pos):             pass ###
# def _insertText(self,i,s):          return self.widget.insert(i,s)
# def _scrollLines(self,n):           pass ###
# def _see(self,i):                   return self.widget.see(i)
# def _setAllText(self,s):            self.widget.delete('1.0','end') ; self.widget.insert('1.0',s)
# def _setBackgroundColor(self,color): return self.widget.configure(background=color)
# def _setFocus(self):                return self.widget.focus_set()
# def _setInsertPoint(self,i):        return self.widget.mark_set('insert',i)
# # def _setSelectionRange(self,i,j):   return self.widget.SetSelection(i,j)
#@-node:ekr.20070213170937:bindings (not used)
#@+node:ekr.20061113151148.2:Index conversion (leoTextWidget)
#@+node:ekr.20061117085824:w.toGuiIndex
def toGuiIndex (self,i):
    '''Convert a Python index to a Tk index as needed.'''
    w = self
    if i is None:
        g.trace('can not happen: i is None',g.callers())
        return '1.0'
    elif type(i) == type(99):
        # This *must* be 'end-1c', even if other code must change.
        s = Tk.Text.get(w,'1.0','end-1c')
        row,col = g.convertPythonIndexToRowCol(s,i)
        i = '%s.%s' % (row+1,col)
        # g.trace(len(s),i,repr(s))
    else:
        try:
            i = Tk.Text.index(w,i)
        except Exception:
            # g.es_exception()
            g.trace('Tk.Text.index failed:',repr(i),g.callers())
            i = '1.0'
    return i
#@nonl
#@-node:ekr.20061117085824:w.toGuiIndex
#@+node:ekr.20061117085824.1:w.toPythonIndex
def toPythonIndex (self,i):
    '''Convert a Tk index to a Python index as needed.'''
    w =self
    if i is None:
        g.trace('can not happen: i is None')
        return 0
    elif type(i) in (type('a'),type(u'a')):
        s = Tk.Text.get(w,'1.0','end') # end-1c does not work.
        i = Tk.Text.index(w,i) # Convert to row/column form.
        row,col = i.split('.')
        row,col = int(row),int(col)
        row -= 1
        i = g.convertRowColToPythonIndex(s,row,col)
        #g.es_print(i)
    return i
#@-node:ekr.20061117085824.1:w.toPythonIndex
#@+node:ekr.20061117085824.2:w.rowColToGuiIndex
# This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):

    return '%s.%s' % (row+1,col)
#@nonl
#@-node:ekr.20061117085824.2:w.rowColToGuiIndex
#@-node:ekr.20061113151148.2:Index conversion (leoTextWidget)
#@+node:ekr.20061117160129:getName (Tk.Text)
def getName (self):

    w = self
    return hasattr(w,'_name') and w._name or repr(w)
#@nonl
#@-node:ekr.20061117160129:getName (Tk.Text)
#@+node:ekr.20070213171850:_setSelectionRange
if 0:
    def _setSelectionRange (self,i,j,insert=None):

        w = self.widget

        i,j = w.toGuiIndex(i),w.toGuiIndex(j)

        # g.trace('i,j,insert',repr(i),repr(j),repr(insert),g.callers())

        # g.trace('i,j,insert',i,j,repr(insert))
        if w.compare(w,i, ">", j): i,j = j,i
        w.tag_remove(w,"sel","1.0",i)
        w.tag_add(w,"sel",i,j)
        w.tag_remove(w,"sel",j,"end")

        if insert is not None:
            w.setInsertPoint(insert)
#@-node:ekr.20070213171850:_setSelectionRange
#@+node:ekr.20061113151148.3:Wrapper methods (leoTextWidget)
#@+node:ekr.20061113151148.4:delete
def delete(self,i,j=None):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.delete(w,i)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.delete(w,i,j)
#@-node:ekr.20061113151148.4:delete
#@+node:ekr.20061113151148.12:flashCharacter
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75): # tkTextWidget.

    w = self

    def addFlashCallback(w,count,index):
        # g.trace(count,index)
        i,j = w.toGuiIndex(index),w.toGuiIndex(index+1)
        Tk.Text.tag_add(w,'flash',i,j)
        Tk.Text.after(w,delay,removeFlashCallback,w,count-1,index)

    def removeFlashCallback(w,count,index):
        # g.trace(count,index)
        Tk.Text.tag_remove(w,'flash','1.0','end')
        if count > 0:
            Tk.Text.after(w,delay,addFlashCallback,w,count,index)

    try:
        Tk.Text.tag_configure(w,'flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass ; g.es_exception()
#@nonl
#@-node:ekr.20061113151148.12:flashCharacter
#@+node:ekr.20061113151148.5:get
def get(self,i,j=None):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        return Tk.Text.get(w,i)
    else:
        j = w.toGuiIndex(j)
        return Tk.Text.get(w,i,j)
#@-node:ekr.20061113151148.5:get
#@+node:ekr.20061113151148.13:getAllText
def getAllText (self): # tkTextWidget.

    """Return all the text of Tk.Text widget w converted to unicode."""

    w = self
    s = Tk.Text.get(w,"1.0","end-1c") # New in 4.4.1: use end-1c.

    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@-node:ekr.20061113151148.13:getAllText
#@+node:ekr.20061113151148.14:getInsertPoint
def getInsertPoint(self): # tkTextWidget.

    w = self
    i = Tk.Text.index(w,'insert')
    i = w.toPythonIndex(i)
    return i
#@-node:ekr.20061113151148.14:getInsertPoint
#@+node:ekr.20061113151148.15:getSelectedText
def getSelectedText (self): # tkTextWidget.

    w = self
    i,j = w.getSelectionRange()
    if i != j:
        i,j = w.toGuiIndex(i),w.toGuiIndex(j)
        s = Tk.Text.get(w,i,j)
        return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""
#@-node:ekr.20061113151148.15:getSelectedText
#@+node:ekr.20061113151148.16:getSelectionRange
def getSelectionRange (self,sort=True): # tkTextWidget.

    """Return a tuple representing the selected range.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self
    sel = Tk.Text.tag_ranges(w,"sel")
    if len(sel) == 2:
        i,j = sel
    else:
        i = j = Tk.Text.index(w,"insert")

    i,j = w.toPythonIndex(i),w.toPythonIndex(j)  
    if sort and i > j: i,j = j,i
    return i,j
#@nonl
#@-node:ekr.20061113151148.16:getSelectionRange
#@+node:ekr.20070211185433.1:getYScrollPosition
def getYScrollPosition (self):

     w = self
     return w.yview()
#@-node:ekr.20070211185433.1:getYScrollPosition
#@+node:ekr.20070212204016:getWidth
def getWidth (self):

    '''Return the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    return w.cget('width')
#@-node:ekr.20070212204016:getWidth
#@+node:ekr.20061113151148.17:hasSelection
def hasSelection (self):

    w = self
    i,j = w.getSelectionRange()
    return i != j
#@-node:ekr.20061113151148.17:hasSelection
#@+node:ekr.20061113151148.6:insert
# The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toGuiIndex(i)
    Tk.Text.insert(w,i,s)

#@-node:ekr.20061113151148.6:insert
#@+node:ekr.20070213104858.1:indexIsVisible
def indexIsVisible (self,i):

    w = self

    return w.dlineinfo(i)
#@nonl
#@-node:ekr.20070213104858.1:indexIsVisible
#@+node:ekr.20061113151148.7:mark_set NO LONGER USED
# def mark_set(self,markName,i):

    # w = self
    # i = w.toGuiIndex(i)
    # Tk.Text.mark_set(w,markName,i)
#@-node:ekr.20061113151148.7:mark_set NO LONGER USED
#@+node:ekr.20061113151148.18:replace
def replace (self,i,j,s): # tkTextWidget

    w = self
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)

    Tk.Text.delete(w,i,j)
    Tk.Text.insert(w,i,s)
#@-node:ekr.20061113151148.18:replace
#@+node:ekr.20061113180616:see
def see (self,i): # tkTextWidget.

    w = self
    i = w.toGuiIndex(i)
    Tk.Text.see(w,i)
#@-node:ekr.20061113180616:see
#@+node:ekr.20061113175002:seeInsertPoint
def seeInsertPoint (self): # tkTextWidget.

    w = self
    Tk.Text.see(w,'insert')
#@-node:ekr.20061113175002:seeInsertPoint
#@+node:ekr.20061113151148.19:selectAllText
def selectAllText (self,insert=None): # tkTextWidget

    '''Select all text of the widget, *not* including the extra newline.'''

    w = self ; s = w.getAllText()
    if insert is None: insert = len(s)
    w.setSelectionRange(0,len(s),insert=insert)
#@-node:ekr.20061113151148.19:selectAllText
#@+node:ekr.20061113151148.20:setAllText
def setAllText (self,s): # tkTextWidget

    w = self

    state = Tk.Text.cget(w,"state")
    Tk.Text.configure(w,state="normal")

    Tk.Text.delete(w,'1.0','end')
    Tk.Text.insert(w,'1.0',s)

    Tk.Text.configure(w,state=state)
#@-node:ekr.20061113151148.20:setAllText
#@+node:ekr.20070218122857:setBackgroundColor
def setBackgroundColor (self,color):

    w = self
    w.configure(background=color)
#@nonl
#@-node:ekr.20070218122857:setBackgroundColor
#@+node:ekr.20061113151148.21:setInsertPoint
def setInsertPoint (self,i): # tkTextWidget.

    w = self
    i = w.toGuiIndex(i)
    # g.trace(i,g.callers())
    Tk.Text.mark_set(w,'insert',i)
#@-node:ekr.20061113151148.21:setInsertPoint
#@+node:ekr.20061113151148.22:setSelectionRange
def setSelectionRange (self,i,j,insert=None): # tkTextWidget

    w = self

    i,j = w.toGuiIndex(i),w.toGuiIndex(j)

    # g.trace('i,j,insert',repr(i),repr(j),repr(insert),g.callers())

    # g.trace('i,j,insert',i,j,repr(insert))
    if Tk.Text.compare(w,i, ">", j): i,j = j,i
    Tk.Text.tag_remove(w,"sel","1.0",i)
    Tk.Text.tag_add(w,"sel",i,j)
    Tk.Text.tag_remove(w,"sel",j,"end")

    if insert is not None:
        w.setInsertPoint(insert)
#@-node:ekr.20061113151148.22:setSelectionRange
#@+node:ekr.20070211185433:setYScrollPosition
def setYScrollPosition (self,i):

     w = self
     w.yview('moveto',i)
#@nonl
#@-node:ekr.20070211185433:setYScrollPosition
#@+node:ekr.20070212081121:setWidth
def setWidth (self,width):

    '''Set the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    w.configure(width=width)
#@-node:ekr.20070212081121:setWidth
#@+node:ekr.20061113151148.8:tag_add
# The signature is slightly different than the Tk.Text.insert method.

def tag_add(self,tagName,i,j=None,*args):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.tag_add(w,tagName,i,*args)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.tag_add(w,tagName,i,j,*args)

#@-node:ekr.20061113151148.8:tag_add
#@+node:ekr.20061113151148.9:tag_ranges
def tag_ranges(self,tagName):

    w = self
    aList = Tk.Text.tag_ranges(w,tagName)
    aList = [w.toPythonIndex(z) for z in aList]
    return tuple(aList)
#@-node:ekr.20061113151148.9:tag_ranges
#@+node:ekr.20070116073907:tag_remove
def tag_remove (self,tagName,i,j=None,*args):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.tag_remove(w,tagName,i,*args)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.tag_remove(w,tagName,i,j,*args)


#@-node:ekr.20070116073907:tag_remove
#@+node:ekr.20061113151148.11:w.deleteTextSelection
def deleteTextSelection (self): # tkTextWidget

    w = self
    sel = Tk.Text.tag_ranges(w,"sel")
    if len(sel) == 2:
        start,end = sel
        if Tk.Text.compare(w,start,"!=",end):
            Tk.Text.delete(w,start,end)
#@-node:ekr.20061113151148.11:w.deleteTextSelection
#@+node:ekr.20061113151148.23:xyToGui/PythonIndex
def xyToGuiIndex (self,x,y): # tkTextWidget

    w = self
    return Tk.Text.index(w,"@%d,%d" % (x,y))

def xyToPythonIndex(self,x,y): # tkTextWidget

    w = self
    i = Tk.Text.index(w,"@%d,%d" % (x,y))
    i = w.toPythonIndex(i)
    return i
#@-node:ekr.20061113151148.23:xyToGui/PythonIndex
#@-node:ekr.20061113151148.3:Wrapper methods (leoTextWidget)
#@-node:ekr.20061113151148.1:class leoTkTextWidget (Tk.Text)
#@-node:ekr.20031218072017.3939:@thin leoTkinterFrame.py
#@+node:ekr.20031218072017.4047:@thin leoTkinterGui.py
@first # -*- coding: utf-8 -*-

"""Leo's Tkinter Gui module."""

@language python
@tabwidth -4
@pagewidth 80

<< imports >>

class tkinterGui(leoGui.leoGui):

    """A class encapulating all calls to tkinter."""

    @others
#@+node:ekr.20041228050845:<< imports >>
import leoGlobals as g
import leoGui
import leoTkinterComparePanel
import leoTkinterDialog
import leoTkinterFind
import leoTkinterFrame
import tkFont
import tkFileDialog
import os
import string
import sys
import Tkinter as Tk

Pmw = g.importExtension('Pmw',    pluginName='leoTkinterGui',verbose=True)
#@-node:ekr.20041228050845:<< imports >>
#@+node:ekr.20031218072017.4048:tkGui birth & death
#@+node:ekr.20031218072017.837: tkGui.__init__
def __init__ (self):

    # Initialize the base class.
    leoGui.leoGui.__init__(self,"tkinter")

    self.bitmap_name = None
    self.bitmap = None
    self.win32clipboard = None
    self.defaultFont = None
    self.defaultFontFamily = None
    self.bodyTextWidget =  leoTkinterFrame.leoTkTextWidget
    self.plainTextWidget = leoTkinterFrame.leoTkTextWidget

    if 0: # This seems both dangerous and non-functional.
        if sys.platform == "win32":
            try:
                import win32clipboard
                self.win32clipboard = win32clipboard
            except:
                g.es_exception()
#@-node:ekr.20031218072017.837: tkGui.__init__
#@+node:ekr.20061031172934:createKeyHandlerClass (tkGui)
def createKeyHandlerClass (self,c,useGlobalKillbuffer=True,useGlobalRegisters=True):

    import leoTkinterKeys # Do this here to break any circular dependency.

    return leoTkinterKeys.tkinterKeyHandlerClass(c,useGlobalKillbuffer,useGlobalRegisters)
#@nonl
#@-node:ekr.20061031172934:createKeyHandlerClass (tkGui)
#@+node:ekr.20031218072017.4049:createRootWindow & allies
def createRootWindow(self):

    """Create a hidden Tk root window."""

    if 0: # Use Tix.
        import Tix
        self.root = root = Tix.Tk()
        << fix problems with menus (XP) >>
    else: # Use Tkinter.
        # g.trace('Pmw.init')
        self.root = root = Tk.Tk()
        Pmw.initialise(self.root)

    root.title("Leo Main Window")
    root.withdraw()

    self.setDefaultIcon()
    if g.app.config:
        self.getDefaultConfigFont(g.app.config)

    root.withdraw()

    return root
#@+node:ekr.20041125050302:<< fix problems with menus (XP) >>
try:
    import WmDefault
    WmDefault.setup(root)
    d = {'activebackground':'DarkBlue','activeforeground':'white'} # works
    # d = {'activebackground':'','activeforeground':''} # doesn't work
    WmDefault.addoptions(root,d)
except ImportError:
    g.trace("can not import WMDefault")
#@-node:ekr.20041125050302:<< fix problems with menus (XP) >>
#@+node:ekr.20031218072017.1856:setDefaultIcon
def setDefaultIcon(self):

    """Set the icon to be used in all Leo windows.

    This code does nothing for Tk versions before 8.4.3."""

    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        # g.trace(repr(version),g.CheckVersion(version,"8.4.3"))
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32":

            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()
#@-node:ekr.20031218072017.1856:setDefaultIcon
#@+node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
def getDefaultConfigFont(self,config):

    """Get the default font from a new text widget."""

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        w = g.app.gui.plainTextWidget()
        fn = w.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # print '***** getDefaultConfigFont',repr(family)

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily
#@-node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
#@-node:ekr.20031218072017.4049:createRootWindow & allies
#@+node:ekr.20031218072017.4051:destroySelf
def destroySelf (self):

    if 0: # Works in Python 2.1 and 2.2.  Leaves Python window open.
        self.root.destroy()

    else: # Works in Python 2.3.  Closes Python window.
        self.root.quit()
#@-node:ekr.20031218072017.4051:destroySelf
#@+node:ekr.20031218072017.4053:killGui (not used)
def killGui(self,exitFlag=True):

    """Destroy a gui and terminate Leo if exitFlag is True."""

    pass # Not ready yet.
#@-node:ekr.20031218072017.4053:killGui (not used)
#@+node:ekr.20031218072017.4054:recreateRootWindow (not used)
def recreateRootWindow(self):
    """A do-nothing base class to create the hidden root window of a gui

    after a previous gui has terminated with killGui(False)."""
    pass
#@-node:ekr.20031218072017.4054:recreateRootWindow (not used)
#@+node:ekr.20031218072017.4055:runMainLoop (tkGui)
def runMainLoop(self):

    """Run tkinter's main loop."""

    if self.script:
        log = g.app.log
        if log:
            print 'Start of batch script...\n'
            log.c.executeScript(script=self.script)
            print 'End of batch script'
        else:
            print 'no log, no commander for executeScript in tkInterGui.runMainLoop'
    else:
         # g.trace("tkinterGui")
        self.root.mainloop()
#@-node:ekr.20031218072017.4055:runMainLoop (tkGui)
#@-node:ekr.20031218072017.4048:tkGui birth & death
#@+node:ekr.20031218072017.4056:tkGui dialogs & panels
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run a Tkinter About Leo dialog."""
    d = leoTkinterDialog.tkinterAboutLeo(c,version,theCopyright,url,email)
    return d.run(modal=False)

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    d = leoTkinterDialog.tkinterAskLeoID()
    return d.run(modal=True)

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run a Tkinter an askOK dialog ."""
    d = leoTkinterDialog.tkinterAskOk(c,title,message,text)
    return d.run(modal=True)

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    d = leoTkinterDialog.tkinterAskOkCancelNumber(c,title,message)
    return d.run(modal=True)

def runAskOkCancelStringDialog(self,c,title,message):
    """Create and run askOkCancelString dialog ."""
    d = leoTkinterDialog.tkinterAskOkCancelString(c,title,message)
    return d.run(modal=True)

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    d = leoTkinterDialog.tkinterAskYesNo(c,title,message)
    return d.run(modal=True)

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    d = leoTkinterDialog.tkinterAskYesNoCancel(
        c,title,message,yesMessage,noMessage,defaultButton)
    return d.run(modal=True)

# The compare panel has no run dialog.

# def runCompareDialog(self,c):
    # """Create and run an askYesNo dialog."""
    # if not g.app.unitTesting:
        # leoTkinterCompareDialog(c)
#@+node:ekr.20070212132230:tkGui.createSpellTab
def createSpellTab(self,c,spellHandler,tabName):

    return leoTkinterFind.tkSpellTab(c,spellHandler,tabName)
#@-node:ekr.20070212132230:tkGui.createSpellTab
#@+node:ekr.20031218072017.4057:tkGui file dialogs
# We no longer specify default extensions so that we can open and save files without extensions.
#@+node:ekr.20060212061804:runOpenFileDialog
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""

    __pychecker__ = '--no-argsused' # defaultextension not used.

    initialdir = g.app.globalOpenDir or g.os_path_abspath(os.getcwd())

    if multiple:
        # askopenfilenames requires Python 2.3 and Tk 8.4.
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        if (
            g.CheckVersion(version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(
                title=title,filetypes=filetypes,initialdir=initialdir)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(
                title=title,filetypes=filetypes,initialdir=initialdir)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(
            title=title,filetypes=filetypes,initialdir=initialdir)
#@-node:ekr.20060212061804:runOpenFileDialog
#@+node:ekr.20060212061804.1:runSaveFileDialog
def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""

    __pychecker__ = '--no-argsused' # defaultextension not used.

    initialdir=g.app.globalOpenDir or g.os_path_abspath(os.getcwd()),

    return tkFileDialog.asksaveasfilename(
        initialdir=initialdir,initialfile=initialfile,
        title=title,filetypes=filetypes)
#@-node:ekr.20060212061804.1:runSaveFileDialog
#@-node:ekr.20031218072017.4057:tkGui file dialogs
#@+node:ekr.20031218072017.4058:tkGui panels
def createComparePanel(self,c):
    """Create a Tkinter color picker panel."""
    return leoTkinterComparePanel.leoTkinterComparePanel(c)

def createFindPanel(self,c):
    """Create a hidden Tkinter find panel."""
    panel = leoTkinterFind.leoTkinterFind(c)
    panel.top.withdraw()
    return panel

def createFindTab (self,c,parentFrame):
    """Create a Tkinter find tab in the indicated frame."""
    return leoTkinterFind.tkFindTab(c,parentFrame)

def createLeoFrame(self,title):
    """Create a new Leo frame."""
    # print 'tkGui.createLeoFrame'
    gui = self
    return leoTkinterFrame.leoTkinterFrame(title,gui)
#@-node:ekr.20031218072017.4058:tkGui panels
#@-node:ekr.20031218072017.4056:tkGui dialogs & panels
#@+node:ekr.20031218072017.4059:tkGui utils
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20061109215304:color
# g.es calls gui.color to do the translation,
# so most code in Leo's core can simply use Tk color names.

def color (self,color):
    '''Return the gui-specific color corresponding to the Tk color name.'''
    return color

#@-node:ekr.20061109215304:color
#@+node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4061:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):

    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)

    return w,h,x,y
#@-node:ekr.20031218072017.4061:get_window_info
#@+node:ekr.20031218072017.4062:center_dialog
def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)

    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))

    return w,h,x,y
#@-node:ekr.20031218072017.4062:center_dialog
#@+node:ekr.20031218072017.4063:create_labeled_frame
# Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")

    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)

    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")

    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")

    # Add the caption.
    if caption and len(caption) > 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f
#@-node:ekr.20031218072017.4063:create_labeled_frame
#@-node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20061109215734:Events (tkGui)
def event_generate(self,w,kind,*args,**keys):
    '''Generate an event.'''
    return w.event_generate(kind,*args,**keys)

def eventChar (self,event,c=None):
    '''Return the char field of an event.'''
    return event and event.char or ''

def eventKeysym (self,event,c=None):
    '''Return the keysym value of an event.'''
    return event and event.keysym

def eventWidget (self,event,c=None):
    '''Return the widget field of an event.'''   
    return event and event.widget

def eventXY (self,event,c=None):
    if event:
        return event.x,event.y
    else:
        return 0,0
#@nonl
#@-node:ekr.20061109215734:Events (tkGui)
#@+node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4065:tkGui.get_focus
def get_focus(self,c):

    """Returns the widget that has focus, or body if None."""

    return c.frame.top.focus_displayof()
#@-node:ekr.20031218072017.4065:tkGui.get_focus
#@+node:ekr.20031218072017.2373:tk.Gui.set_focus
set_focus_count = 0

def set_focus(self,c,w):

    __pychecker__ = '--no-argsused' # c not used at present.

    """Put the focus on the widget."""

    if not g.app.unitTesting and c and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        # Do not call trace here: that might affect focus!
        print 'gui.set_focus: %4d %10s %s' % (
            self.set_focus_count,c and c.shortFileName(),
            c and c.widget_name(w)), g.callers(5)

    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
#@-node:ekr.20031218072017.2373:tk.Gui.set_focus
#@-node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):

    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family

    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@-node:ekr.20031218072017.4066:Font
#@+node:ekr.20070212144559:getFullVersion
def getFullVersion (self,c):

    tkLevel = c.frame.top.getvar("tk_patchLevel")

    return 'Tk %s, Pmw %s' % (tkLevel,Pmw.version())
#@-node:ekr.20070212144559:getFullVersion
#@+node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
def attachLeoIcon (self,w):

    """Try to attach a Leo icon to the Leo Window.

    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None

    if self.bitmap == None:
        try:
            << try to use the PIL and tkIcon packages to draw the icon >>
        except:
            # import traceback ; traceback.print_exc()
            # g.es_exception()
            self.leoIcon = None
#@+node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon # pychecker complains, but this *is* used.

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("<Visibility>",visibilityCallback)

if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)
#@-node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
#@+node:ekr.20031218072017.4070:createLeoIcon
# This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):

    try:
        import Image,_tkicon

        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None
#@-node:ekr.20031218072017.4070:createLeoIcon
#@-node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
#@-node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)
#@-node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
#@+node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):

    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)
#@-node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
#@-node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20051220144507:isTextWidget
def isTextWidget (self,w):

    '''Return True if w is a Text widget suitable for text-oriented commands.'''

    return w and isinstance(w,Tk.Text)
#@-node:ekr.20051220144507:isTextWidget
#@+node:ekr.20060621164312:makeScriptButton
def makeScriptButton (self,c,
    p=None, # A node containing the script.
    script=None, # The script itself.
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,bg='LightSteelBlue1',
    define_g=True,define_name='__main__',silent=False, # Passed on to c.executeScript.
):

    '''Create a script button for the script in node p.
    The button's text defaults to p.headString'''

    k = c.k
    if p and not buttonText: buttonText = p.headString().strip()
    if not buttonText: buttonText = 'Unnamed Script Button'
    << create the button b >>
    << define the callbacks for b >>
    b.configure(command=executeScriptCallback)
    b.bind('<3>',deleteButtonCallback)
    if shortcut:
        << bind the shortcut to executeScriptCallback >>
    << create press-buttonText-button command >>
#@+node:ekr.20060621164312.1:<< create the button b >>
iconBar = c.frame.getIconBarObject()
b = iconBar.add(text=buttonText)

if balloonText and balloonText != buttonText:
    Pmw = g.importExtension('Pmw',pluginName='gui.makeScriptButton',verbose=False)
    if Pmw:
        balloon = Pmw.Balloon(b,initwait=100)
        balloon.bind(b,balloonText)

if sys.platform == "win32":
    width = int(len(buttonText) * 0.9)
    b.configure(width=width,font=('verdana',7,'bold'),bg=bg)
#@-node:ekr.20060621164312.1:<< create the button b >>
#@+node:ekr.20060621164312.2:<< define the callbacks for b >>
def deleteButtonCallback(event=None,b=b,c=c):
    if b: b.pack_forget()
    c.bodyWantsFocus()

def executeScriptCallback (event=None,
    b=b,c=c,buttonText=buttonText,p=p and p.copy(),script=script):

    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
    else:
        g.app.scriptDict = {}
        c.executeScript(p=p,script=script,
        define_g= define_g,define_name=define_name,silent=silent)
        # Remove the button if the script asks to be removed.
        if g.app.scriptDict.get('removeMe'):
            g.es("Removing '%s' button at its request" % buttonText)
            b.pack_forget()
    # Do not assume the script will want to remain in this commander.
#@-node:ekr.20060621164312.2:<< define the callbacks for b >>
#@+node:ekr.20060621164312.3:<< bind the shortcut to executeScriptCallback >>
func = executeScriptCallback
shortcut = k.canonicalizeShortcut(shortcut)
ok = k.bindKey ('button', shortcut,func,buttonText)
if ok:
    g.es_print('Bound @button %s to %s' % (buttonText,shortcut),color='blue')
#@-node:ekr.20060621164312.3:<< bind the shortcut to executeScriptCallback >>
#@+node:ekr.20060621164312.4:<< create press-buttonText-button command >>
aList = [g.choose(ch.isalnum(),ch,'-') for ch in buttonText]

buttonCommandName = ''.join(aList)
buttonCommandName = buttonCommandName.replace('--','-')
buttonCommandName = 'press-%s-button' % buttonCommandName.lower()

# This will use any shortcut defined in an @shortcuts node.
k.registerCommand(buttonCommandName,None,executeScriptCallback,pane='button',verbose=False)
#@-node:ekr.20060621164312.4:<< create press-buttonText-button command >>
#@-node:ekr.20060621164312:makeScriptButton
#@-node:ekr.20031218072017.4059:tkGui utils
#@+node:ekr.20061112152012.2:class leoKeyEvent (tkGui)
class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c):

        # g.trace('leoKeyEvent(tkGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        self.widget = self.w

    def __repr__ (self):

        return 'tkGui.leoKeyEvent: char: %s, keysym: %s' % (repr(self.char),repr(self.keysym))
#@nonl
#@-node:ekr.20061112152012.2:class leoKeyEvent (tkGui)
#@-node:ekr.20031218072017.4047:@thin leoTkinterGui.py
#@+node:ekr.20031218072017.4099:@thin leoTkinterKeys.py
"""Tkinter keystroke handling for Leo."""

@language python
@tabwidth -4
@pagewidth 80
import leoGlobals as g
import Tkinter as Tk
import leoKeys

class tkinterKeyHandlerClass (leoKeys.keyHandlerClass):
    '''Tkinter overrides of base keyHandlerClass.'''
    @others
#@nonl
#@+node:ekr.20061031170011:tkKeys.ctor
def __init__(self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):

    # Init the base class.
    leoKeys.keyHandlerClass.__init__(self,c,useGlobalKillbuffer,useGlobalRegisters)

    # Create
    self.createTkIvars()
#@-node:ekr.20061031170011:tkKeys.ctor
#@+node:ekr.20061031170011.1:createTkIvars
def createTkIvars(self):

    if not self.useTextWidget and self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
    else:
        self.svar = None
#@-node:ekr.20061031170011.1:createTkIvars
#@-node:ekr.20031218072017.4099:@thin leoTkinterKeys.py
#@+node:ekr.20031218072017.4100:@thin leoTkinterMenu.py
"""Tkinter menu handling for Leo."""

@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import leoMenu
import Tkinter as Tk
import tkFont

class leoTkinterMenu (leoMenu.leoMenu):
    """A class that represents a Leo window."""
    @others
#@+node:ekr.20031218072017.4101:Birth & death
#@+node:ekr.20031218072017.4102:leoTkinterMenu.__init__
def __init__ (self,frame):

    # Init the base class.
    leoMenu.leoMenu.__init__(self,frame)

    self.top = frame.top
    self.c = c = frame.c
    self.frame = frame

    self.font = c.config.getFontFromParams(
        'menu_text_font_family', 'menu_text_font_size',
        'menu_text_font_slant',  'menu_text_font_weight',
        c.config.defaultMenuFontSize)
#@-node:ekr.20031218072017.4102:leoTkinterMenu.__init__
#@-node:ekr.20031218072017.4101:Birth & death
#@+node:ekr.20060211101811:Activate menu commands
#@+node:ekr.20060211100905.1:tkMenu.activateMenu
def activateMenu (self,menuName):

    c = self.c ;  top = c.frame.top
    topx,topy = top.winfo_rootx(),top.winfo_rooty()
    menu = c.frame.menu.getMenu(menuName)

    if menu:
        d = self.computeMenuPositions()
        x = d.get(menuName)
        if x is None:
             x = 0 ; g.trace('oops, no menu offset: %s' % menuName)

        menu.tk_popup(topx+d.get(menuName,0),topy) # Fix by caugm.  Thanks!
    else:
        g.trace('oops, no menu: %s' % menuName)
#@-node:ekr.20060211100905.1:tkMenu.activateMenu
#@+node:ekr.20060210133835.1:tkMenu.computeMenuPositions
def computeMenuPositions (self):

    # A hack.  It would be better to set this when creating the menus.
    menus = ('File','Edit','Outline','Plugins','Cmds','Window','Help')

    # Compute the *approximate* x offsets of each menu.
    d = {}
    n = 0
    for z in menus:
        menu = self.getMenu(z)
        fontName = menu.cget('font')
        font = tkFont.Font(font=fontName)
        # print '%8s' % (z),menu.winfo_reqwidth(),menu.master,menu.winfo_x()
        d [z] = n
        # A total hack: sorta works on windows.
        n += font.measure(z+' '*4)+1

    return d
#@-node:ekr.20060210133835.1:tkMenu.computeMenuPositions
#@-node:ekr.20060211101811:Activate menu commands
#@+node:ekr.20060211144330.1:getMacHelpMenu
def getMacHelpMenu (self):

    try:
        topMenu = self.getMenu('top')
        # Use the name argument to create the special Macintosh Help menu.
        helpMenu = Tk.Menu(topMenu,name='help',tearoff=0)
        self.add_cascade(topMenu,label='Help',menu=helpMenu,underline=0)
        self.createMenuEntries(helpMenu,self.helpMenuTable)
        return helpMenu

    except Exception:
        g.trace('Can not get MacOS Help menu')
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20060211144330.1:getMacHelpMenu
#@+node:ekr.20031218072017.4103:Tkinter menu bindings
# See the Tk docs for what these routines are to do
#@+node:ekr.20031218072017.4104:Methods with Tk spellings
#@+node:ekr.20031218072017.4105:add_cascade
def add_cascade (self,parent,label,menu,underline):

    """Wrapper for the Tkinter add_cascade menu method."""

    return parent.add_cascade(label=label,menu=menu,underline=underline)
#@-node:ekr.20031218072017.4105:add_cascade
#@+node:ekr.20031218072017.4106:add_command
def add_command (self,menu,**keys):

    """Wrapper for the Tkinter add_command menu method."""

    return menu.add_command(**keys)
#@-node:ekr.20031218072017.4106:add_command
#@+node:ekr.20031218072017.4107:add_separator
def add_separator(self,menu):

    """Wrapper for the Tkinter add_separator menu method."""

    menu.add_separator()
#@-node:ekr.20031218072017.4107:add_separator
#@+node:ekr.20031218072017.4108:bind (not called)
def bind (self,bind_shortcut,callback):

    """Wrapper for the Tkinter bind menu method."""

    g.trace(bind_shortcut,g.callers())

    return self.top.bind(bind_shortcut,callback)
#@-node:ekr.20031218072017.4108:bind (not called)
#@+node:ekr.20031218072017.4109:delete
def delete (self,menu,realItemName):

    """Wrapper for the Tkinter delete menu method."""

    return menu.delete(realItemName)
#@-node:ekr.20031218072017.4109:delete
#@+node:ekr.20031218072017.4110:delete_range
def delete_range (self,menu,n1,n2):

    """Wrapper for the Tkinter delete menu method."""

    return menu.delete(n1,n2)
#@-node:ekr.20031218072017.4110:delete_range
#@+node:ekr.20031218072017.4111:destroy
def destroy (self,menu):

    """Wrapper for the Tkinter destroy menu method."""

    return menu.destroy()
#@-node:ekr.20031218072017.4111:destroy
#@+node:ekr.20070124150514:insert
def insert (self,menuName,position,label,command,underline=None):

    menu = self.getMenu(menuName)

    if underline is None:
        menu.insert(position,'command',label=label,command=command)
    else:
        menu.insert(position,'command',label=label,command=command,underline=underline)
#@-node:ekr.20070124150514:insert
#@+node:ekr.20031218072017.4112:insert_cascade
def insert_cascade (self,parent,index,label,menu,underline):

    """Wrapper for the Tkinter insert_cascade menu method."""

    return parent.insert_cascade(
        index=index,label=label,
        menu=menu,underline=underline)
#@-node:ekr.20031218072017.4112:insert_cascade
#@+node:ekr.20031218072017.4113:new_menu
def new_menu(self,parent,tearoff=False):

    """Wrapper for the Tkinter new_menu menu method."""

    if self.font:
        try:
            return Tk.Menu(parent,tearoff=tearoff,font=self.font)
        except Exception:
            g.es_exception()
            return Tk.Menu(parent,tearoff=tearoff)
    else:
        return Tk.Menu(parent,tearoff=tearoff)
#@-node:ekr.20031218072017.4113:new_menu
#@-node:ekr.20031218072017.4104:Methods with Tk spellings
#@+node:ekr.20031218072017.4114:Methods with other spellings (Tkmenu)
#@+node:ekr.20041228063406:clearAccel
def clearAccel(self,menu,name):

    realName = self.getRealMenuName(name)
    realName = realName.replace("&","")

    menu.entryconfig(realName,accelerator='')
#@-node:ekr.20041228063406:clearAccel
#@+node:ekr.20031218072017.4115:createMenuBar
def createMenuBar(self,frame):

    top = frame.top

    # Note: font setting has no effect here.
    topMenu = Tk.Menu(top,postcommand=self.updateAllMenus)

    # Do gui-independent stuff.
    self.setMenu("top",topMenu)
    self.createMenusFromTables()

    top.config(menu=topMenu) # Display the menu.
#@nonl
#@-node:ekr.20031218072017.4115:createMenuBar
#@+node:ekr.20051022042645:createOpenWithMenu
def createOpenWithMenu(self,parent,label,index,amp_index):

    '''Create a submenu.'''

    menu = Tk.Menu(parent,tearoff=0)
    parent.insert_cascade(index,label=label,menu=menu,underline=amp_index)
    return menu
#@-node:ekr.20051022042645:createOpenWithMenu
#@+node:ekr.20031218072017.4119:disableMenu
def disableMenu (self,menu,name):

    try:
        menu.entryconfig(name,state="disabled")
    except: 
        try:
            realName = self.getRealMenuName(name)
            realName = realName.replace("&","")
            menu.entryconfig(realName,state="disabled")
        except:
            print "disableMenu menu,name:",menu,name
            g.es_exception()
            pass
#@-node:ekr.20031218072017.4119:disableMenu
#@+node:ekr.20031218072017.4120:enableMenu
# Fail gracefully if the item name does not exist.

def enableMenu (self,menu,name,val):

    state = g.choose(val,"normal","disabled")
    try:
        menu.entryconfig(name,state=state)
    except:
        try:
            realName = self.getRealMenuName(name)
            realName = realName.replace("&","")
            menu.entryconfig(realName,state=state)
        except:
            print "enableMenu menu,name,val:",menu,name,val
            g.es_exception()
            pass
#@-node:ekr.20031218072017.4120:enableMenu
#@+node:ekr.20060622075612:getMenuLabel
def getMenuLabel (self,menu,name):

    '''Return the index of the menu item whose name (or offset) is given.
    Return None if there is no such menu item.'''

    try:
        index = menu.index(name)
    except:
        index = None

    return index
#@-node:ekr.20060622075612:getMenuLabel
#@+node:ekr.20031218072017.4121:setMenuLabel
def setMenuLabel (self,menu,name,label,underline=-1):

    try:
        if type(name) == type(0):
            # "name" is actually an index into the menu.
            menu.entryconfig(name,label=label,underline=underline)
        else:
            # Bug fix: 2/16/03: use translated name.
            realName = self.getRealMenuName(name)
            realName = realName.replace("&","")
            # Bug fix: 3/25/03" use tranlasted label.
            label = self.getRealMenuName(label)
            label = label.replace("&","")
            menu.entryconfig(realName,label=label,underline=underline)
    except:
        if not g.app.unitTesting:
            print "setMenuLabel menu,name,label:",menu,name,label
            g.es_exception()
#@-node:ekr.20031218072017.4121:setMenuLabel
#@-node:ekr.20031218072017.4114:Methods with other spellings (Tkmenu)
#@-node:ekr.20031218072017.4103:Tkinter menu bindings
#@-node:ekr.20031218072017.4100:@thin leoTkinterMenu.py
#@+node:ekr.20040803072955:@thin leoTkinterTree.py
"""Override outline drawing code to test optimized drawing"""

"""This class implements a tree control similar to Windows explorer.

The code is based on code found in Python's IDLE program."""

@language python
@tabwidth -4
@pagewidth 80

<< about drawing >>
<< imports >>

class leoTkinterTree (leoFrame.leoTree):

    callbacksInjected = False

    """Leo tkinter tree class."""

    @others
#@+node:ekr.20040803072955.1:  << About drawing >>
@

New in Leo 4.4a3: The 'Newer World Order':

- c.redraw_now() redraws the screen immediately by calling c.frame.tree.redraw_now().

- c.beginUpdate() and c.endUpdate() work as always.  They are the preferred way of doing redraws.

- No drawing is done at idle time.

c.redraw_now and c.endUpdate redraw all icons automatically. v.computeIcon
method tells what the icon should be. The v.iconVal tells what the present icon
is. The body key handler simply compares these two values and sets redraw_flag
if they don't match.
#@-node:ekr.20040803072955.1:  << About drawing >>
#@+node:ekr.20040928101836:<< imports >>
import leoGlobals as g

if g.app and g.app.use_psyco:
    # print "enabled psyco classes",__file__
    try: from psyco.classes import *
    except ImportError: pass

Pmw = g.importExtension("Pmw",pluginName='LeoTkinterTree',verbose=True,required=True)

import leoFrame
import Tkinter as Tk
import tkFont
import sys
#@-node:ekr.20040928101836:<< imports >>
#@+node:ekr.20040803072955.2:  Notes
@killcolor
#@+node:ekr.20040803072955.3:Changes made since first update
@

- disabled drawing of user icons.  They weren't being hidden, which messed up scrolling.

- Expanded clickBox so all clicks fall inside it.

- Added binding for plugBox so it doesn't interfere with the clickBox.  Another weirdness.

- Re-enabled code in drawText that sets the headline state.

- eventToPosition now returns p.copy, which means that nobody can change the list.

- Likewise, clear self.iconIds so old icon id's don't confuse findVnodeWithIconId.

- All drawing methods must do p = p.copy() at the beginning if they make any changes to p.
    - This ensures neither they nor their allies can change the caller's position.
    - In fact, though, only drawTree changes position.  It makes a copy before calling drawNode.
    *** Therefore, all positions in the drawing code are immutable!

- Fixed the race conditions that caused drawing sometimes to fail.  The essential idea is that we must not call w.config if we are about to do a redraw.  For full details, see the Notes node in the Race Conditions section.
#@-node:ekr.20040803072955.3:Changes made since first update
#@+node:ekr.20040803072955.4:Changes made since second update
@

- Removed duplicate code in tree.select.  The following code was being called twice (!!):
    self.endEditLabel()
    self.setUnselectedLabelState(old_p)

- Add p.copy() instead of p when inserting nodes into data structures in select.

- Fixed a _major_ bug in Leo's core.  c.setCurrentPosition must COPY the position given to it!  It's _not_ enough to return a copy of position: it may already have changed!!

- Fixed a another (lesser??) bug in Leo's core.  handleUserClick should also make a copy.

- Fixed bug in mod_scripting.py.  The callback was failing if the script was empty.

- Put in the self.recycle ivar AND THE CODE STILL FAILS.
    It seems to me that this shows there is a bug in my code somewhere, but where ???????????????????
#@-node:ekr.20040803072955.4:Changes made since second update
#@+node:ekr.20040803072955.5:Most recent changes
@

- Added generation count.
    - Incremented on each redraw.
    - Potentially a barrior to race conditions, but it never seemed to do anything.
    - This code is a candidate for elimination.

- Used vnodes rather than positions in several places.
    - I actually don't think this was involved in the real problem, and it doesn't hurt.

- Added much better traces: the beginning of the end for the bugs :-)
    - Added self.verbose option.
    - Added align keyword option to g.trace.
    - Separate each set of traces by a blank line.
        - This makes clear the grouping of id's.

- Defensive code: Disable dragging at start of redraw code.
    - This protects against race conditions.

- Fixed blunder 1: Fixed a number of bugs in the dragging code.
    - I had never looked at this code!
    - Eliminating false drags greatly simplifies matters.

- Fixed blunder 2: Added the following to eventToPosition:
        x = canvas.canvasx(x)
        y = canvas.canvasy(y)
    - Apparently this was the cause of false associations between icons and id's.
    - It's amazing that the code didn't fail earlier without these!

- Converted all module-level constants to ivars.

- Lines no longer interfere with eventToPosition.
    - The problem was that find_nearest or find_overlapping don't depend on stacking order!
    - Added p param to horizontal lines, but not vertical lines.
    - EventToPosition adds 1 to the x coordinate of vertical lines, then recomputes the id.

- Compute indentation only in forceDrawNode.  Removed child_indent constant.

- Simplified drawTree to use indentation returned from forceDrawNode.

- setHeadlineText now ensures that state is "normal" before attempting to set the text.
    - This is the robust way.

7/31/04: newText must call setHeadlineText for all nodes allocated, even if p matches.
#@-node:ekr.20040803072955.5:Most recent changes
#@-node:ekr.20040803072955.2:  Notes
#@+node:ekr.20040803072955.15: Birth... (tkTree)
#@+node:ekr.20040803072955.16:__init__ (tkTree)
def __init__(self,c,frame,canvas):

    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Configuration and debugging settings.
    # These must be defined here to eliminate memory leaks.
    self.allow_clone_drags          = c.config.getBool('allow_clone_drags')
    self.center_selected_tree_node  = c.config.getBool('center_selected_tree_node')
    self.enable_drag_messages       = c.config.getBool("enable_drag_messages")
    self.expanded_click_area        = c.config.getBool('expanded_click_area')
    self.gc_before_redraw           = c.config.getBool('gc_before_redraw')

    self.headline_text_editing_foreground_color = c.config.getColor(
        'headline_text_editing_foreground_color')
    self.headline_text_editing_background_color = c.config.getColor(
        'headline_text_editing_background_color')
    self.headline_text_editing_selection_foreground_color = c.config.getColor(
        'headline_text_editing_selection_foreground_color')
    self.headline_text_editing_selection_background_color = c.config.getColor(
        'headline_text_editing_selection_background_color')
    self.headline_text_selected_foreground_color = c.config.getColor(
        "headline_text_selected_foreground_color")
    self.headline_text_selected_background_color = c.config.getColor(
        "headline_text_selected_background_color")
    self.headline_text_editing_selection_foreground_color = c.config.getColor(
        "headline_text_editing_selection_foreground_color")
    self.headline_text_editing_selection_background_color = c.config.getColor(
        "headline_text_editing_selection_background_color")
    self.headline_text_unselected_foreground_color = c.config.getColor(
        'headline_text_unselected_foreground_color')
    self.headline_text_unselected_background_color = c.config.getColor(
        'headline_text_unselected_background_color')

    self.idle_redraw = c.config.getBool('idle_redraw')
    self.initialClickExpandsOrContractsNode = c.config.getBool(
        'initialClickExpandsOrContractsNode')
    self.look_for_control_drag_on_mouse_down = c.config.getBool(
        'look_for_control_drag_on_mouse_down')
    self.select_all_text_when_editing_headlines = c.config.getBool(
        'select_all_text_when_editing_headlines')

    self.stayInTree     = c.config.getBool('stayInTreeAfterSelect')
    self.trace          = c.config.getBool('trace_tree')
    self.trace_alloc    = c.config.getBool('trace_tree_alloc')
    self.trace_chapters = c.config.getBool('trace_chapters')
    self.trace_edit     = c.config.getBool('trace_tree_edit')
    self.trace_gc       = c.config.getBool('trace_tree_gc')
    self.trace_redraw   = c.config.getBool('trace_tree_redraw')
    self.trace_select   = c.config.getBool('trace_select')
    self.trace_stats    = c.config.getBool('show_tree_stats')
    self.use_chapters   = c.config.getBool('use_chapters')

    # Objects associated with this tree.
    self.canvas = canvas

    << define drawing constants >>
    << old ivars >>
    << inject callbacks into the position class >>

    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.

    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount <= 0
    self.verbose = True

    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()

    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = [] # New in 4.4b2: a list of free Tk.Text widgets

    self.freeUserIcons = []
#@+node:ekr.20040803072955.17:<< define drawing constants >>
self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height
#@-node:ekr.20040803072955.17:<< define drawing constants >>
#@+node:ekr.20040803072955.18:<< old ivars >>
# Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if present headline is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = 0.0
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("<B1-ButtonRelease>", self.redraw_now)
#@-node:ekr.20040803072955.18:<< old ivars >>
#@+node:ekr.20040803072955.19:<< inject callbacks into the position class >>
# The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()
#@-node:ekr.20040803072955.19:<< inject callbacks into the position class >>
#@-node:ekr.20040803072955.16:__init__ (tkTree)
#@+node:ekr.20051024102724:tkTtree.setBindings
def setBindings (self,):

    '''Create master bindings for all headlines.'''

    tree = self ; k = self.c.k ; canvas = self.canvas

    # g.trace('self',self,'canvas',canvas)

    << make bindings for a common binding widget >>

    tree.setCanvasBindings(canvas)

    k.completeAllBindingsForWidget(canvas)

    k.completeAllBindingsForWidget(self.bindingWidget)

#@+node:ekr.20060131173440:<< make bindings for a common binding widget >>
self.bindingWidget = w = g.app.gui.plainTextWidget(
    self.canvas,name='bindingWidget')

w.bind('<Key>',k.masterKeyHandler)

table = (
    ('<Button-1>',       k.masterClickHandler,          tree.onHeadlineClick),
    ('<Button-3>',       k.masterClick3Handler,         tree.onHeadlineRightClick),
    ('<Double-Button-1>',k.masterDoubleClickHandler,    tree.onHeadlineClick),
    ('<Double-Button-3>',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
)

for a,handler,func in table:
    def treeBindingCallback(event,handler=handler,func=func):
        # g.trace('func',func)
        return handler(event,func)
    w.bind(a,treeBindingCallback)

self.textBindings = w.bindtags()
#@-node:ekr.20060131173440:<< make bindings for a common binding widget >>
#@-node:ekr.20051024102724:tkTtree.setBindings
#@+node:ekr.20070327103016:tkTree.setCanvasBindings
def setCanvasBindings (self,canvas):

    k = self.c.k

    canvas.bind('<Key>',k.masterKeyHandler)
    canvas.bind('<Button-1>',self.onTreeClick)

    << make bindings for tagged items on the canvas >>
    << create baloon bindings for tagged items on the canvas >>
#@nonl
#@+node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '<Button-1>',self.onClickBoxClick),
    ('iconBox','<Button-1>',self.onIconBoxClick),
    ('iconBox','<Double-1>',self.onIconBoxDoubleClick),
    ('iconBox','<Button-3>',self.onIconBoxRightClick),
    ('iconBox','<Double-3>',self.onIconBoxRightClick),
    ('iconBox','<B1-Motion>',self.onDrag),
    ('iconBox','<Any-ButtonRelease-1>',self.onEndDrag),
)
for tag,event,callback in table:
    canvas.tag_bind(tag,event,callback)
#@-node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
#@+node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
if 0: # I find these very irritating.
    for tag,text in (
        # ('plusBox','plusBox'),
        ('iconBox','Icon Box'),
        ('selectBox','Click to select'),
        ('clickBox','Click to expand or contract'),
        # ('textBox','Headline'),
    ):
        # A fairly long wait is best.
        balloon = Pmw.Balloon(self.canvas,initwait=700)
        balloon.tagbind(self.canvas,tag,balloonHelp=text)
#@-node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
#@-node:ekr.20070327103016:tkTree.setCanvasBindings
#@-node:ekr.20040803072955.15: Birth... (tkTree)
#@+node:ekr.20040803072955.6:Allocation...
#@+node:ekr.20040803072955.7:newBox
def newBox (self,p,x,y,image):

    canvas = self.canvas ; tag = "plusBox"

    if self.freeBoxes:
        theId = self.freeBoxes.pop(0)
        canvas.coords(theId,x,y)
        canvas.itemconfigure(theId,image=image)
    else:
        theId = canvas.create_image(x,y,image=image,tag=tag)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if theId not in self.visibleBoxes: 
        self.visibleBoxes.append(theId)

    if p:
        self.ids[theId] = p

    return theId
#@-node:ekr.20040803072955.7:newBox
#@+node:ekr.20040803072955.8:newClickBox
def newClickBox (self,p,x1,y1,x2,y2):

    canvas = self.canvas ; defaultColor = ""
    tag = g.choose(p.hasChildren(),'clickBox','selectBox')

    if self.freeClickBoxes:
        theId = self.freeClickBoxes.pop(0)
        canvas.coords(theId,x1,y1,x2,y2)
        canvas.itemconfig(theId,tag=tag)
    else:
        theId = self.canvas.create_rectangle(x1,y1,x2,y2,tag=tag)
        canvas.itemconfig(theId,fill=defaultColor,outline=defaultColor)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if theId not in self.visibleClickBoxes:
        self.visibleClickBoxes.append(theId)
    if p:
        self.ids[theId] = p

    return theId
#@-node:ekr.20040803072955.8:newClickBox
#@+node:ekr.20040803072955.9:newIcon
def newIcon (self,p,x,y,image):

    canvas = self.canvas ; tag = "iconBox"

    if self.freeIcons:
        theId = self.freeIcons.pop(0)
        canvas.itemconfigure(theId,image=image)
        canvas.coords(theId,x,y)
    else:
        theId = canvas.create_image(x,y,image=image,anchor="nw",tag=tag)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if theId not in self.visibleIcons:
        self.visibleIcons.append(theId)

    if p:
        data = p,self.generation
        self.iconIds[theId] = data # Remember which vnode belongs to the icon.
        self.ids[theId] = p

    return theId
#@-node:ekr.20040803072955.9:newIcon
#@+node:ekr.20040803072955.10:newLine
def newLine (self,p,x1,y1,x2,y2):

    canvas = self.canvas

    if self.freeLines:
        theId = self.freeLines.pop(0)
        canvas.coords(theId,x1,y1,x2,y2)
    else:
        theId = canvas.create_line(x1,y1,x2,y2,tag="lines",fill="gray50") # stipple="gray25")
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if p:
        self.ids[theId] = p

    if theId not in self.visibleLines:
        self.visibleLines.append(theId)

    return theId
#@-node:ekr.20040803072955.10:newLine
#@+node:ekr.20040803072955.11:newText (tkTree) and helper
def newText (self,p,x,y):

    canvas = self.canvas ; tag = "textBox"
    c = self.c ;  k = c.k
    if self.freeText:
        w,theId = self.freeText.pop()
        canvas.coords(theId,x,y) # Make the window visible again.
            # theId is the id of the *window* not the text.
    else:
        # Tags are not valid in Tk.Text widgets.
        self.textNumber += 1
        w = g.app.gui.plainTextWidget(
            canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
        w.bindtags(self.textBindings) # Set the bindings for this widget.

        if 0: # Crashes on XP.
            << patch by Maciej Kalisiak to handle scroll-wheel events >>

        theId = canvas.create_window(x,y,anchor="nw",window=w,tag=tag)
        w.leo_window_id = theId # Never changes.

        if self.trace_alloc: g.trace('%3d %6s' % (theId,id(w)),align=-20)

    # Common configuration.
    if 0: # Doesn't seem to work.
        balloon = Pmw.Balloon(canvas,initwait=700)
        balloon.tagbind(canvas,theId,balloonHelp='Headline')

    if p:
        self.ids[theId] = p # Add the id of the *window*
        self.setHeadlineText(theId,w,p.headString())
        w.configure(width=self.headWidth(p=p))
        w.leo_position = p # This p never changes.
            # *Required*: onHeadlineClick uses w.leo_position to get p.

        # Keys are p.key().  Entries are (w,theId)
        self.visibleText [p.key()] = w,theId
    else:
        g.trace('**** can not happen.  No p')

    return w
#@+node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
def PropagateButton4(e):
    canvas.event_generate("<Button-4>")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("<Button-5>")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("<MouseWheel>")
    return "break"

instance_tag = w.bindtags()[0]
w.bind_class(instance_tag, "<Button-4>", PropagateButton4)
w.bind_class(instance_tag, "<Button-5>", PropagateButton5)
w.bind_class(instance_tag, "<MouseWheel>",PropagateMouseWheel)
#@-node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
#@+node:ekr.20040803072955.32:tree.setHeadlineText
def setHeadlineText (self,theId,w,s):

    """All changes to text widgets should come here."""

    __pychecker__ = '--no-argsused' # theId not used.

    # if self.trace_alloc: g.trace('%4d %6s %s' % (theId,self.textAddr(w),s),align=-20)

    state = w.cget("state")
    if state != "normal":
        w.configure(state="normal")
    w.delete(0,"end")
    # Important: do not allow newlines in headlines.
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]
    w.insert("end",s)
    # g.trace(repr(s))
    if state != "normal":
        w.configure(state=state)
#@-node:ekr.20040803072955.32:tree.setHeadlineText
#@-node:ekr.20040803072955.11:newText (tkTree) and helper
#@+node:ekr.20040803072955.12:recycleWidgets
def recycleWidgets (self):

    canvas = self.canvas

    for theId in self.visibleBoxes:
        if theId not in self.freeBoxes:
            self.freeBoxes.append(theId)
        canvas.coords(theId,-100,-100)
    self.visibleBoxes = []

    for theId in self.visibleClickBoxes:
        if theId not in self.freeClickBoxes:
            self.freeClickBoxes.append(theId)
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleClickBoxes = []

    for theId in self.visibleIcons:
        if theId not in self.freeIcons:
            self.freeIcons.append(theId)
        canvas.coords(theId,-100,-100)
    self.visibleIcons = []

    for theId in self.visibleLines:
        if theId not in self.freeLines:
            self.freeLines.append(theId)
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleLines = []

    aList = self.visibleText.values()
    for data in aList:
        w,theId = data
        # assert theId == w.leo_window_id
        canvas.coords(theId,-100,-100)
        w.leo_position = None # Allow the position to be freed.
        if data not in self.freeText:
            self.freeText.append(data)
    self.visibleText = {}

    for theId in self.visibleUserIcons:
        # The present code does not recycle user Icons.
        self.canvas.delete(theId)
    self.visibleUserIcons = []
#@-node:ekr.20040803072955.12:recycleWidgets
#@+node:ekr.20040803072955.13:destroyWidgets
def destroyWidgets (self):

    self.ids = {}

    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleUserIcons = []

    self.visibleText = {}

    self.freeText = []
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []

    self.canvas.delete("all")
#@-node:ekr.20040803072955.13:destroyWidgets
#@+node:ekr.20060202125419:showStats
def showStats (self):

    z = []
    for kind,a,b in (
        ('boxes',self.visibleBoxes,self.freeBoxes),
        ('clickBoxes',self.visibleClickBoxes,self.freeClickBoxes),
        ('icons',self.visibleIcons,self.freeIcons),
        ('lines',self.visibleLines,self.freeLines),
        ('tesxt',self.visibleText.values(),self.freeText),
    ):
        z.append('%10s used: %4d free: %4d' % (kind,len(a),len(b)))

    g.es_print('\n' + '\n'.join(z))
#@-node:ekr.20060202125419:showStats
#@-node:ekr.20040803072955.6:Allocation...
#@+node:ekr.20040803072955.26:Config & Measuring...
#@+node:ekr.20040803072955.27:tree.getFont,setFont,setFontFromConfig
def getFont (self):

    return self.font

def setFont (self,font=None, fontName=None):

    # ESSENTIAL: retain a link to font.
    if fontName:
        self.fontName = fontName
        self.font = tkFont.Font(font=fontName)
    else:
        self.fontName = None
        self.font = font

    self.setLineHeight(self.font)

# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):
    c = self.c
    # g.trace()
    font = c.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        c.config.defaultTreeFontSize)

    self.setFont(font)
#@-node:ekr.20040803072955.27:tree.getFont,setFont,setFontFromConfig
#@+node:ekr.20040803072955.28:headWidth & widthInPixels
def headWidth(self,p=None,s=''):

    """Returns the proper width of the entry widget for the headline."""

    if p: s = p.headString()

    return self.font.measure(s)/self.font.measure('0')+1


def widthInPixels(self,s):

    s = g.toEncodedString(s,g.app.tkEncoding)

    return self.font.measure(s)
#@-node:ekr.20040803072955.28:headWidth & widthInPixels
#@+node:ekr.20040803072955.29:setLineHeight
def setLineHeight (self,font):

    try:
        metrics = font.metrics()
        linespace = metrics ["linespace"]
        self.line_height = linespace + 5 # Same as before for the default font on Windows.
        # print metrics
    except:
        self.line_height = self.default_line_height
        g.es("exception setting outline line height")
        g.es_exception()
#@-node:ekr.20040803072955.29:setLineHeight
#@-node:ekr.20040803072955.26:Config & Measuring...
#@+node:ekr.20040803072955.31:Debugging...
#@+node:ekr.20040803072955.33:textAddr
def textAddr(self,w):

    """Return the address part of repr(Tk.Text)."""

    return repr(w)[-9:-1].lower()
#@-node:ekr.20040803072955.33:textAddr
#@+node:ekr.20040803072955.34:traceIds (Not used)
# Verbose tracing is much more useful than this because we can see the recent past.

def traceIds (self,full=False):

    tree = self

    for theDict,tag,flag in ((tree.ids,"ids",True),(tree.iconIds,"icon ids",False)):
        print '=' * 60
        print ; print "%s..." % tag
        keys = theDict.keys()
        keys.sort()
        for key in keys:
            p = tree.ids.get(key)
            if p is None: # For lines.
                print "%3d None" % key
            else:
                print "%3d" % key,p.headString()
        if flag and full:
            print '-' * 40
            values = theDict.values()
            values.sort()
            seenValues = []
            for value in values:
                if value not in seenValues:
                    seenValues.append(value)
                    for item in theDict.items():
                        key,val = item
                        if val and val == value:
                            print "%3d" % key,val.headString()
#@-node:ekr.20040803072955.34:traceIds (Not used)
#@-node:ekr.20040803072955.31:Debugging...
#@+node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20051216155728:tree.begin/endUpdate
def beginUpdate (self):

    self.updateCount += 1
    # g.trace('tree',id(self),self.updateCount,g.callers())

def endUpdate (self,flag,scroll=False):

    self.updateCount -= 1
    # g.trace(self.updateCount,'scroll',scroll,g.callers())

    if self.updateCount <= 0:
        if flag:
            self.redraw_now(scroll=scroll)
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount",g.callers())
#@-node:ekr.20051216155728:tree.begin/endUpdate
#@+node:ekr.20040803072955.58:tree.redraw_now & helper
# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    '''Redraw immediately: used by Find so a redraw doesn't mess up selections in headlines.'''

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return

    c = self.c

    # g.trace(g.callers())

    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary()
        if self.trace_redraw or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            # g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()

    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll)
    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()

redraw = redraw_now # Compatibility
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):

    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        bbox = self.canvas.bbox('all')
        # g.trace('canvas',self.canvas,'bbox',bbox)
        if bbox is None:
            x0,y0,x1,y1 = 0,0,100,100
        else:
            x0, y0, x1, y1 = bbox
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()

    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:tree.redraw_now & helper
#@+node:ekr.20040803072955.61:idle_second_redraw
def idle_second_redraw (self):

    c = self.c

    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)

    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()

    if self.trace:
        g.trace(self.redrawCount)
#@-node:ekr.20040803072955.61:idle_second_redraw
#@+node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.36:drawBox
def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7

    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)

    if theId is None:
        # if self.trace_gc: g.printNewObjects(tag='box 1')
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        # if self.trace_gc: g.printNewObjects(tag='box 2')
        return theId
    else:
        return theId
#@-node:ekr.20040803072955.36:drawBox
#@+node:ekr.20040803072955.37:drawClickBox
def drawClickBox (self,p,y):

    h = self.line_height

    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
#@-node:ekr.20040803072955.37:drawClickBox
#@+node:ekr.20040803072955.39:drawIcon
def drawIcon(self,p,x=None,y=None):

    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    # if self.trace_gc: g.printNewObjects(tag='icon 1')

    c = self.c ; v = p.v
    << compute x,y and iconVal >>
    v.iconVal = val

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)

    return 0,self.icon_width # dummy icon height,width
#@+node:ekr.20040803072955.40:<< compute x,y and iconVal >>
if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.computeIcon()
assert(0 <= val <= 15)
# g.trace(v,val)
#@nonl
#@-node:ekr.20040803072955.40:<< compute x,y and iconVal >>
#@-node:ekr.20040803072955.39:drawIcon
#@+node:ekr.20040803072955.41:drawLine
def drawLine (self,p,x1,y1,x2,y2):

    theId = self.newLine(p,x1,y1,x2,y2)

    return theId
#@-node:ekr.20040803072955.41:drawLine
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):

    c = self.c

    # g.trace(x,y,p,id(self.canvas))

    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0

    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)

    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.

    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2

    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)

    self.drawClickBox(p,y)

    return h,indent
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20040803072955.44:drawText
def drawText(self,p,x,y):

    """draw text for position p at nominal coordinates x,y."""

    assert(p)

    c = self.c
    x += self.text_indent

    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    self.newText(p,x,y+self.lineyoffset)

    self.configureTextState(p)

    return self.line_height
#@-node:ekr.20040803072955.44:drawText
#@+node:ekr.20040803072955.46:drawUserIcons
def drawUserIcons(self,p,where,x,y):

    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""

    h,w = 0,0 ; t = p.v.t

    if not hasattr(t,"unknownAttributes"):
        return h,w

    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w

    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()

    # g.trace(where,h,w)

    return h,w
#@-node:ekr.20040803072955.46:drawUserIcons
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):

    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # if self.trace_gc: g.printNewObjects(tag='userIcon 1')

    # g.trace(where,x,y,theDict)

    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            << draw the icon in string s >>
    elif theType == "file":
        theFile = theDict.get("file")
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>

    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    # if self.trace_gc: g.printNewObjects(tag='userIcon 2')

    return h,w
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.49:<< draw the icon in string s >>
pass
#@-node:ekr.20040803072955.49:<< draw the icon in string s >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None

if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p
    # assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad
#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):

    """Draws the top-level tree, taking into account the hoist state."""

    c = self.c ; canvas = self.canvas
    trace = False or self.trace or self.trace_redraw

    self.redrawing = True

    # Recycle all widgets and clear all widget lists.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.redrawCount += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if trace:
        g.trace('redrawCount',self.redrawCount,'len(c.hoistStack)',len(c.hoistStack)) # g.callers())
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())

    self.prevPositions = g.app.positions
    if self.trace_gc: g.printNewObjects(tag='top 1')

    hoistFlag = c.hoistStack
    if c.hoistStack:
        bunch = c.hoistStack[-1] ; p = bunch.p
        h = p.headString()
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            hoistFlag = False
    else:
        p = c.rootPosition()

    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)

    if self.trace_gc: g.printNewObjects(tag='top 2')
    if self.trace_stats: self.showStats()

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y ; h1 = None
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data

    while p: # Do not use iterator.
        # This is the ONLY copy of p that needs to be made;
        # no other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h # Set h1 *after* calling drawNode.
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
    # Draw the vertical line.
    if h1 is None: h1 = h
    y2 = g.choose(level==0,yfirst+(h1-1)/2,yfirst-h1/2-1)
    self.drawLine(None,x,y2,x,ylast+self.hline_y-h)
    return y
#@-node:ekr.20040803072955.53:drawTree
#@-node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.62:Helpers...
#@+node:ekr.20040803072955.64:getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]

    # g.trace(name)

    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None
#@-node:ekr.20040803072955.64:getIconImage
#@+node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):

    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.

def inExpandedVisibleArea (self,y1):

    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@-node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20040803072955.68:numberOfVisibleNodes
def numberOfVisibleNodes(self):

    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n
#@-node:ekr.20040803072955.68:numberOfVisibleNodes
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""

    __pychecker__ = '--no-argsused' # event not used.
    __pychecker__ = '--no-intdivide' # suppress warning about integer division.

    c = self.c ; frame = c.frame
    if not p or not c.positionExists(p):
        p = c.currentPosition()
    if not p or not c.positionExists(p):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not c.positionExists(p):
        # g.trace('no position')
        return
    try:
        h1 = self.yoffset(p)
        if self.center_selected_tree_node: # New in Leo 4.4.3.
            << compute frac0 >>
            delta = abs(self.prevMoveToFrac-frac0)
            # g.trace(delta)
            if delta > 0.0:
                self.prevMoveToFrac = frac0
                self.canvas.yview("moveto",frac0)
                # g.trace("frac0 %1.2f %3d %3d %3d" % (frac0,h1,htot,wtot))
        else:
            last = c.lastVisible()
            nextToLast = last.visBack()
            h2 = self.yoffset(last)
            << compute approximate line height >>
            << Compute the fractions to scroll down/up >>
            if frac <= lo: # frac is for scrolling down.
                if self.prevMoveToFrac != frac:
                    self.prevMoveToFrac = frac
                    self.canvas.yview("moveto",frac)
                    #g.trace("frac  %1.2f %3d %3d %1.2f %1.2f" % (frac, h1,h2,lo,hi))
            elif frac2 + (hi - lo) >= hi: # frac2 is for scrolling up.
                if self.prevMoveToFrac != frac2:
                    self.prevMoveToFrac = frac2
                    self.canvas.yview("moveto",frac2)
                    #g.trace("frac2 "1.2f %3d %3d %1.2f %1.2f" % (frac2,h1,h2,lo,hi))

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)

        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.

    except:
        g.es_exception()

idle_scrollTo = scrollTo # For compatibility.
#@nonl
#@+node:ekr.20061030091926:<< compute frac0 >>
# frac0 attempt to put the 
scrollRegion = self.canvas.cget('scrollregion')
geom = self.canvas.winfo_geometry()

if scrollRegion and geom:
    scrollRegion = scrollRegion.split(' ')
    # g.trace('scrollRegion',repr(scrollRegion))
    htot = int(scrollRegion[3])
    wh,junk,junk = geom.split('+')
    junk,h = wh.split('x')
    if h: wtot = int(h)
    else: wtot = 500
    # g.trace('geom',geom,'wtot',wtot)
    if htot > 0.1:
        frac0 = float(h1-wtot/2)/float(htot)
        frac0 = max(min(frac0,1.0),0.0)
    else:
        frac0 = 0.0
else:
    frac0 = 0.0 ; htot = wtot = 0
#@-node:ekr.20061030091926:<< compute frac0 >>
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.canvas.leo_treeBar.get() # Get the previous values of the scrollbar.
try: lo, hi = data
except: lo,hi = 0.0,1.0

# h1 and h2 are the y offsets of the present and last nodes.
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.

frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.70:yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not self.c.positionExists(p):
        # g.trace('does not exist',p.headString())
        return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False
#@-node:ekr.20040803072955.70:yoffset
#@-node:ekr.20040803072955.62:Helpers...
#@-node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20040803072955.71:Event handlers (tkTree)
#@+node:ekr.20051105103233:Helpers
#@+node:ekr.20040803072955.72:checkWidgetList
def checkWidgetList (self,tag):

    return True # This will fail when the headline actually changes!

    for w in self.visibleText:

        p = w.leo_position
        if p:
            s = w.getAllText().strip()
            h = p.headString().strip()

            if h != s:
                self.dumpWidgetList(tag)
                return False
        else:
            self.dumpWidgetList(tag)
            return False

    return True
#@-node:ekr.20040803072955.72:checkWidgetList
#@+node:ekr.20040803072955.73:dumpWidgetList
def dumpWidgetList (self,tag):

    print
    print "checkWidgetList: %s" % tag

    for w in self.visibleText:

        p = w.leo_position
        if p:
            s = w.getAllText().strip()
            h = p.headString().strip()

            addr = self.textAddr(w)
            print "p:",addr,h
            if h != s:
                print "w:",'*' * len(addr),s
        else:
            print "w.leo_position == None",w
#@-node:ekr.20040803072955.73:dumpWidgetList
#@+node:ekr.20040803072955.75:tree.edit_widget
def edit_widget (self,p):

    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)
#@nonl
#@-node:ekr.20040803072955.75:tree.edit_widget
#@+node:ekr.20040803072955.74:eventToPosition
def eventToPosition (self,event):

    canvas = self.canvas
    x,y = event.x,event.y
    x = canvas.canvasx(x) 
    y = canvas.canvasy(y)
    if self.trace: g.trace(x,y)
    item = canvas.find_overlapping(x,y,x,y)
    if not item: return None

    # Item may be a tuple, possibly empty.
    try:    theId = item[0]
    except: theId = item
    if not theId: return None

    p = self.ids.get(theId)

    # A kludge: p will be None for vertical lines.
    if not p:
        item = canvas.find_overlapping(x+1,y,x+1,y)
        try:    theId = item[0]
        except: theId = item
        if not theId:
            g.es_print('oops: eventToPosition failed')
            return None
        p = self.ids.get(theId)
        # g.trace("was vertical line",p)

    if self.trace and self.verbose:
        if p:
            w = self.findEditWidget(p)
            g.trace("%3d %3d %3d %d" % (theId,x,y,id(w)),p.headString())
        else:
            g.trace("%3d %3d %3d" % (theId,x,y),None)

    # defensive programming: this copy is not needed.
    if p: return p.copy() # Make _sure_ nobody changes this table!
    else: return None
#@-node:ekr.20040803072955.74:eventToPosition
#@+node:ekr.20040803072955.76:findEditWidget
def findEditWidget (self,p):

    """Return the Tk.Text item corresponding to p."""

    c = self.c

    if p and c:
        aTuple = self.visibleText.get(p.key())
        if aTuple:
            w,theId = aTuple
            # g.trace('%4d' % (theId),self.textAddr(w),p.headString())
            return w
        else:
            # g.trace('oops: not found',p)
            return None

    # g.trace(not found',p.headString())
    return None
#@-node:ekr.20040803072955.76:findEditWidget
#@+node:ekr.20040803072955.109:findVnodeWithIconId
def findPositionWithIconId (self,theId):

    # Due to an old bug, theId may be a tuple.
    try:
        data = self.iconIds.get(theId[0])
    except:
        data = self.iconIds.get(theId)

    if data:
        p,generation = data
        if generation==self.generation:
            if self.trace and self.verbose:
                g.trace(theId,p.headString())
            return p
        else:
            if self.trace and self.verbose:
                g.trace("*** wrong generation: %d ***" % theId)
            return None
    else:
        if self.trace and self.verbose: g.trace(theId,None)
        return None
#@-node:ekr.20040803072955.109:findVnodeWithIconId
#@-node:ekr.20051105103233:Helpers
#@+node:ekr.20040803072955.78:Click Box...
#@+node:ekr.20040803072955.79:onClickBoxClick
def onClickBoxClick (self,event,p=None):

    c = self.c ; p1 = c.currentPosition()

    if not p: p = self.eventToPosition(event)
    if not p: return

    c.setLog()

    c.beginUpdate()
    try:
        if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing()
            if p == p1 or self.initialClickExpandsOrContractsNode:
                if p.isExpanded(): p.contract()
                else:              p.expand()
            self.select(p)
            if c.frame.findPanel:
                c.frame.findPanel.handleUserClick(p)
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
        g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()
#@-node:ekr.20040803072955.79:onClickBoxClick
#@-node:ekr.20040803072955.78:Click Box...
#@+node:ekr.20040803072955.99:Dragging (tkTree)
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):

    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        << set vdrag, childFlag >>
        if self.allow_clone_drags:
            if not self.look_for_control_drag_on_mouse_down:
                self.controlDrag = c.frame.controlKeyIsDown

        if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
            << drag p to vdrag >>
        elif self.trace and self.verbose:
            g.trace("Cancel drag")

        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate()
        c.recolor_now() # Dragging can affect coloring.
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
# g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20041111114944:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):

    """The official helper of the onDrag event handler."""

    c = self.c ; canvas = self.canvas

    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    # g.trace('self.controlDrag',self.controlDrag)
    if self.allow_clone_drags:
        self.controlDrag = c.frame.controlKeyIsDown
        if self.look_for_control_drag_on_mouse_down:
            if self.enable_drag_messages:
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@-node:ekr.20041111114944:startDrag
#@+node:ekr.20040803072955.100:onContinueDrag
def onContinueDrag(self,event):

    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@+node:ekr.20040803072955.101:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.canvas.leo_treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)

    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.canvas.leo_treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@-node:ekr.20040803072955.101:<< scroll the canvas as needed >>
#@-node:ekr.20040803072955.100:onContinueDrag
#@+node:ekr.20040803072955.102:onDrag
def onDrag(self,event):

    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()

    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)

    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@-node:ekr.20040803072955.102:onDrag
#@+node:ekr.20040803072955.103:onEndDrag
def onEndDrag(self,event):

    """Tree end-of-drag handler called from vnode event handler."""

    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()

    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@-node:ekr.20040803072955.103:onEndDrag
#@-node:ekr.20040803072955.99:Dragging (tkTree)
#@+node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.81:onIconBoxClick
def onIconBoxClick (self,event,p=None):

    c = self.c ; tree = self

    if not p: p = self.eventToPosition(event)
    if not p: return

    c.setLog()

    if self.trace and self.verbose: g.trace()

    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel()
        tree.select(p,scroll=False)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)

    return "break" # disable expanded box handling.
#@-node:ekr.20040803072955.81:onIconBoxClick
#@+node:ekr.20040803072955.89:onIconBoxRightClick
def onIconBoxRightClick (self,event,p=None):

    """Handle a right click in any outline widget."""

    c = self.c

    if not p: p = self.eventToPosition(event)
    if not p: return

    c.setLog()

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")

    return 'break'
#@-node:ekr.20040803072955.89:onIconBoxRightClick
#@+node:ekr.20040803072955.82:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event,p=None):

    c = self.c

    if not p: p = self.eventToPosition(event)
    if not p: return

    c.setLog()

    if self.trace and self.verbose: g.trace()

    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")

    return 'break' # 11/19/06
#@-node:ekr.20040803072955.82:onIconBoxDoubleClick
#@-node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
def OnActivateHeadline (self,p,event=None):

    '''Handle common process when any part of a headline is clicked.'''

    # g.trace(p.headString())

    returnVal = 'break' # Default: do nothing more.
    trace = False

    try:
        c = self.c
        c.setLog()
        << activate this window >>
    except:
        g.es_event_exception("activate tree")

    return returnVal
#@+node:ekr.20040803072955.106:<< activate this window >>
if p == c.currentPosition():

    if trace: g.trace('current','active',self.active)
    self.editLabel(p) # sets focus.
    # If we are active, pass the event along so the click gets handled.
    # Otherwise, do *not* pass the event along so the focus stays the same.
    returnVal = g.choose(self.active,'continue','break')
    self.active = True
else:
    if trace: g.trace("not current")
    self.select(p,scroll=False)
    w  = c.frame.body.bodyCtrl
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        spot = p.v.t.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
    else:
        w.setInsertPoint(0)
    # An important detail.
    # The *canvas* (not the headline) gets the focus so that
    # tree bindings take priority over text bindings.
    c.treeWantsFocus()
    self.active = False
    returnVal = 'break'
#@nonl
#@-node:ekr.20040803072955.106:<< activate this window >>
#@-node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
#@+node:ekr.20040803072955.84:Text Box...
#@+node:ekr.20040803072955.85:configureTextState
def configureTextState (self,p):

    c = self.c

    if not p: return

    # g.trace(p.headString(),self.c._currentPosition)

    if c.isCurrentPosition(p):
        if p == self.editPosition():
            self.setEditLabelState(p) # selected, editing.
        else:
            self.setSelectedLabelState(p) # selected, not editing.
    else:
        self.setUnselectedLabelState(p) # unselected
#@-node:ekr.20040803072955.85:configureTextState
#@+node:ekr.20040803072955.86:onCtontrolT
# This works around an apparent Tk bug.

def onControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"
#@-node:ekr.20040803072955.86:onCtontrolT
#@+node:ekr.20040803072955.87:onHeadlineClick
def onHeadlineClick (self,event,p=None):

    # g.trace('p',p)
    c = self.c ; w = event.widget

    if not p:
        try:
            p = w.leo_position
        except AttributeError:
            g.trace('*'*20,'oops')
    if not p: return 'break'

    # g.trace(g.app.gui.widget_name(w)) #p.headString())

    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal
#@-node:ekr.20040803072955.87:onHeadlineClick
#@+node:ekr.20040803072955.83:onHeadlineRightClick
def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget

    try:
        p = w.leo_position
    except AttributeError:
        g.trace('*'*20,'oops')
        return 'break'

    c.setLog()

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")

    # 'continue' *is* correct here.
    # 'break' would make it impossible to unselect the headline text.
    return 'continue'
#@-node:ekr.20040803072955.83:onHeadlineRightClick
#@-node:ekr.20040803072955.84:Text Box...
#@+node:ekr.20040803072955.108:tree.OnDeactivate
def OnDeactivate (self,event=None):

    """Deactivate the tree pane, dimming any headline being edited."""

    __pychecker__ = '--no-argsused' # event not used.

    tree = self ; c = self.c

    # g.trace(g.callers())

    c.beginUpdate()
    try:
        tree.endEditLabel()
        tree.dimEditLabel()
    finally:
        c.endUpdate(False)
#@-node:ekr.20040803072955.108:tree.OnDeactivate
#@+node:ekr.20040803072955.110:tree.OnPopup & allies
def OnPopup (self,p,event):

    """Handle right-clicks in the outline.

    This is *not* an event handler: it is called from other event handlers."""

    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        c.setLog()

        if not g.doHook("create-popup-menu",c=c,p=p,v=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,v=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,v=p,event=event):
            self.showPopupMenu(event)

    return "break"
#@+node:ekr.20040803072955.111:OnPopupFocusLost
@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the <FocusOut> event and explicitly unpost.  In order to process the <FocusOut> event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):

    __pychecker__ = '--no-argsused' # event not used.

    self.popupMenu.unpost()
#@-node:ekr.20040803072955.111:OnPopupFocusLost
#@+node:ekr.20040803072955.112:createPopupMenu
def createPopupMenu (self,event):

    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame

    # If we are going to recreate it, we had better destroy it.
    if self.popupMenu:
        self.popupMenu.destroy()
        self.popupMenu = None

    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)

    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)

    << Create the menu table >>

    # New in 4.4.  There is no need for a dontBind argument because
    # Bindings from tables are ignored.
    frame.menu.createMenuEntries(menu,table)
#@+node:ekr.20040803072955.113:<< Create the menu table >>
table = (
    ("&Read @file Nodes",c.readAtFileNodes),
    ("&Write @file Nodes",c.fileCommands.writeAtFileNodes),
    ("-",None),
    ("&Tangle",c.tangle),
    ("&Untangle",c.untangle),
    ("-",None),
    ("Toggle Angle &Brackets",c.toggleAngleBrackets),
    ("-",None),
    ("Cut Node",c.cutOutline),
    ("Copy Node",c.copyOutline),
    ("&Paste Node",c.pasteOutline),
    ("&Delete Node",c.deleteOutline),
    ("-",None),
    ("&Insert Node",c.insertHeadline),
    ("&Clone Node",c.clone),
    ("Sort C&hildren",c.sortChildren),
    ("&Sort Siblings",c.sortSiblings),
    ("-",None),
    ("Contract Parent",c.contractParent),
)
#@-node:ekr.20040803072955.113:<< Create the menu table >>
#@-node:ekr.20040803072955.112:createPopupMenu
#@+node:ekr.20040803072955.114:enablePopupMenuItems
def enablePopupMenuItems (self,v,event):

    """Enable and disable items in the popup menu."""

    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; menu = self.popupMenu

    << set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)

    enable = self.frame.menu.enableMenu

    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())
#@+node:ekr.20040803072955.115:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree_iter():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True

    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True
#@-node:ekr.20040803072955.115:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
#@-node:ekr.20040803072955.114:enablePopupMenuItems
#@+node:ekr.20040803072955.116:showPopupMenu
def showPopupMenu (self,event):

    """Show a popup menu."""

    c = self.c ; menu = self.popupMenu

    if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
        menu.bind("<FocusOut>",self.OnPopupFocusLost)

    menu.post(event.x_root, event.y_root)

    # Set the focus immediately so we know when we lose it.
    c.widgetWantsFocus(menu)
#@-node:ekr.20040803072955.116:showPopupMenu
#@-node:ekr.20040803072955.110:tree.OnPopup & allies
#@+node:ekr.20051022141020:onTreeClick
def onTreeClick (self,event=None):

    '''Handle an event in the tree canvas, outside of any tree widget.'''

    c = self.c

    # New in Leo 4.4.2: a kludge: disable later event handling after a double-click.
    # This allows focus to stick in newly-opened files opened by double-clicking an @url node.
    if c.doubleClickFlag:
        c.doubleClickFlag = False
    else:
        c.treeWantsFocusNow()

    return 'break'
#@-node:ekr.20051022141020:onTreeClick
#@-node:ekr.20040803072955.71:Event handlers (tkTree)
#@+node:ekr.20040803072955.118:Incremental drawing...
#@+node:ekr.20040803072955.119:allocateNodes
def allocateNodes(self,where,lines):

    """Allocate Tk widgets in nodes that will become visible as the result of an upcoming scroll"""

    assert(where in ("above","below"))

    # print "allocateNodes: %d lines %s visible area" % (lines,where)

    # Expand the visible area: a little extra delta is safer.
    delta = lines * (self.line_height + 4)
    y1,y2 = self.visibleArea

    if where == "below":
        y2 += delta
    else:
        y1 = max(0.0,y1-delta)

    self.expandedVisibleArea=y1,y2
    # print "expandedArea:   %5.1f %5.1f" % (y1,y2)

    # Allocate all nodes in expanded visible area.
    self.updatedNodeCount = 0
    self.updateTree(self.c.rootPosition(),self.root_left,self.root_top,0,0)
    # if self.updatedNodeCount: print "updatedNodeCount:", self.updatedNodeCount
#@-node:ekr.20040803072955.119:allocateNodes
#@+node:ekr.20040803072955.120:allocateNodesBeforeScrolling
def allocateNodesBeforeScrolling (self, args):

    """Calculate the nodes that will become visible as the result of an upcoming scroll.

    args is the tuple passed to the Tk.Canvas.yview method"""

    if not self.allocateOnlyVisibleNodes: return

    # print "allocateNodesBeforeScrolling:",self.redrawCount,args

    assert(self.visibleArea)
    assert(len(args)==2 or len(args)==3)
    kind = args[0] ; n = args[1]
    lines = 2 # Update by 2 lines to account for rounding.
    if len(args) == 2:
        assert(kind=="moveto")
        frac1,frac2 = args
        if float(n) != frac1:
            where = g.choose(n<frac1,"above","below")
            self.allocateNodes(where=where,lines=lines)
    else:
        assert(kind=="scroll")
        linesPerPage = self.canvas.winfo_height()/self.line_height + 2
        n = int(n) ; assert(abs(n)==1)
        where = g.choose(n == 1,"below","above")
        lines = g.choose(args[2] == "pages",linesPerPage,lines)
        self.allocateNodes(where=where,lines=lines)
#@-node:ekr.20040803072955.120:allocateNodesBeforeScrolling
#@+node:ekr.20040803072955.121:updateNode
def updateNode (self,p,x,y):

    """Draw a node that may have become visible as a result of a scrolling operation"""

    c = self.c

    if self.inExpandedVisibleArea(y):
        # This check is a major optimization.
        if not c.edit_widget(p):
            return self.force_draw_node(p,x,y)
        else:
            return self.line_height

    return self.line_height
#@-node:ekr.20040803072955.121:updateNode
#@+node:ekr.20040803072955.122:setVisibleAreaToFullCanvas
def setVisibleAreaToFullCanvas(self):

    if self.visibleArea:
        y1,y2 = self.visibleArea
        y2 = max(y2,y1 + self.canvas.winfo_height())
        self.visibleArea = y1,y2
#@-node:ekr.20040803072955.122:setVisibleAreaToFullCanvas
#@+node:ekr.20040803072955.123:setVisibleArea
def setVisibleArea (self,args):

    r1,r2 = args
    r1,r2 = float(r1),float(r2)
    # print "scroll ratios:",r1,r2

    try:
        s = self.canvas.cget("scrollregion")
        x1,y1,x2,y2 = g.scanf(s,"%d %d %d %d")
        x1,y1,x2,y2 = int(x1),int(y1),int(x2),int(y2)
    except:
        self.visibleArea = None
        return

    scroll_h = y2-y1
    # print "height of scrollregion:", scroll_h

    vy1 = y1 + (scroll_h*r1)
    vy2 = y1 + (scroll_h*r2)
    self.visibleArea = vy1,vy2
    # print "setVisibleArea: %5.1f %5.1f" % (vy1,vy2)
#@-node:ekr.20040803072955.123:setVisibleArea
#@+node:ekr.20040803072955.124:tree.updateTree
def updateTree (self,v,x,y,h,level):

    yfirst = y
    if level==0: yfirst += 10
    while v:
        # g.trace(x,y,v)
        h,indent = self.updateNode(v,x,y)
        y += h
        if v.isExpanded() and v.firstChild():
            y = self.updateTree(v.firstChild(),x+indent,y,h,level+1)
        v = v.next()
    return y
#@-node:ekr.20040803072955.124:tree.updateTree
#@-node:ekr.20040803072955.118:Incremental drawing...
#@+node:ekr.20040803072955.125:Selecting & editing... (tkTree)
#@+node:ekr.20040803072955.142:dimEditLabel, undimEditLabel
# Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)
#@-node:ekr.20040803072955.142:dimEditLabel, undimEditLabel
#@+node:ekr.20040803072955.127:tree.editLabel
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c
    trace = not g.app.unitTesting and (False or self.trace_edit)

    if p and p != self.editPosition():

        if trace:
            g.trace(p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(True)

    self.setEditPosition(p) # That is, self._editPosition = p

    if trace: g.trace(c.edit_widget(p))

    if p and c.edit_widget(p):
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
#@-node:ekr.20040803072955.127:tree.editLabel
#@+node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.135:setEditLabelState
def setEditLabelState (self,p,selectAll=False): # selected, editing

    c = self.c ; w = c.edit_widget(p)

    if p and w:
        # g.trace('*****',g.callers())
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        selectAll = selectAll or self.select_all_text_when_editing_headlines
        if selectAll:
            w.setSelectionRange(0,'end',insert='end')
        else:
            w.setInsertPoint('end') # Clears insert point.
    else:
        g.trace('no edit_widget')

setNormalLabelState = setEditLabelState # For compatibility.
#@-node:ekr.20040803072955.135:setEditLabelState
#@+node:ekr.20040803072955.136:setSelectedLabelState
def setSelectedLabelState (self,p): # selected, disabled

    # g.trace(p.headString(),g.callers())

    c = self.c

    if p and c.edit_widget(p):
        self.setDisabledHeadlineColors(p)
#@-node:ekr.20040803072955.136:setSelectedLabelState
#@+node:ekr.20040803072955.138:setUnselectedLabelState
def setUnselectedLabelState (self,p): # not selected.

    c = self.c

    if p and c.edit_widget(p):
        self.setUnselectedHeadlineColors(p)
#@-node:ekr.20040803072955.138:setUnselectedLabelState
#@+node:ekr.20040803072955.139:setDisabledHeadlineColors
def setDisabledHeadlineColors (self,p):

    c = self.c ; w = c.edit_widget(p)

    if self.trace and self.verbose:
        if not self.redrawing:
            g.trace("%10s %d %s" % ("disabled",id(w),p.headString()))
            # import traceback ; traceback.print_stack(limit=6)

    fg = self.headline_text_selected_foreground_color or 'black'
    bg = self.headline_text_selected_background_color or 'grey80'
    selfg = self.headline_text_editing_selection_foreground_color
    selbg = self.headline_text_editing_selection_background_color

    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()
#@-node:ekr.20040803072955.139:setDisabledHeadlineColors
#@+node:ekr.20040803072955.140:setEditHeadlineColors
def setEditHeadlineColors (self,p):

    c = self.c ; w = c.edit_widget(p)

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())

    fg    = self.headline_text_editing_foreground_color or 'black'
    bg    = self.headline_text_editing_background_color or 'white'
    selfg = self.headline_text_editing_selection_foreground_color or 'white'
    selbg = self.headline_text_editing_selection_background_color or 'black'

    try: # Use system defaults for selection foreground/background
        w.configure(state="normal",highlightthickness=1,
        fg=fg,bg=bg,selectforeground=selfg,selectbackground=selbg)
    except:
        g.es_exception()
#@-node:ekr.20040803072955.140:setEditHeadlineColors
#@+node:ekr.20040803072955.141:setUnselectedHeadlineColors
def setUnselectedHeadlineColors (self,p):

    c = self.c ; w = c.edit_widget(p)

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = self.headline_text_unselected_foreground_color or 'black'
    bg = self.headline_text_unselected_background_color or 'white'

    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()
#@-node:ekr.20040803072955.141:setUnselectedHeadlineColors
#@-node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20060207101443:tree.setHeadline (tkTree)
def setHeadline (self,p,s):

    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''

    w = self.edit_widget(p)
    if w:
        w.configure(state='normal')
        w.delete(0,'end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        w.insert(0,s)
        self.revertHeadline = s
        # g.trace(repr(s),w.getAllText())
    else:
        g.trace('-'*20,'oops')
#@-node:ekr.20060207101443:tree.setHeadline (tkTree)
#@-node:ekr.20040803072955.125:Selecting & editing... (tkTree)
#@-node:ekr.20040803072955:@thin leoTkinterTree.py
#@-node:ekr.20031218072017.3821:Gui Tkinter classes
#@-node:ekr.20031218072017.2406:Code
#@-node:ekr.20070515100356:To do: b2
#@-node:ekr.20060531161030:To do: 4.4.3
#@+node:ekr.20070325052041:To do: 4.4.4 (@auto)
#@+node:ekr.20070512162750:@url http://simpleparse.sourceforge.net/
#@-node:ekr.20070512162750:@url http://simpleparse.sourceforge.net/
#@+node:ekr.20061006165447:Let import commands decide what kind of import to do
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3940843
By: ktenney

>the distiction between importing 'foreign' text files and importing derived
files created by Leo.

Couldn't Leo make this distinction by looking at
the file being imported? If so, I think it should.

This could eliminate a lot of confusion IMO, if
I want to bring a file into a node, just
'import' it, and the right thing happens.

An emergency measure could be available in a 
'File Special' menu.
#@nonl
#@-node:ekr.20061006165447:Let import commands decide what kind of import to do
#@+node:ekr.20070324084040:Prototype of @auto
#@+node:ekr.20070324084040.1:NEWscanPythonText
def NEWscanPythonText (self,s,parent):

    scanner = self.pythonScanner(self,s,parent)

    scanner.parse()
        # Discover the node boundaries.
    scanner.checkWhitespace()
        # Check that whitespace passes TabNanny.
        # Check that whitespace is compatible with @tabwidth.
        # Check for underindented lines.
    scanner.generateNodes()
        # Generate a single node if there are errors,
        # otherwise generate the imported tree.
    scanner.checkImport()
        # Do trial write, verify that it would produce the original file.
        # Insert an @ignore directive in the root if there are errors.
#@nonl
#@-node:ekr.20070324084040.1:NEWscanPythonText
#@+node:ekr.20070324084040.13:class pythonScanner (not ready yet)
class pythonScanner:

    @others

#@+node:ekr.20070324084040.14:ctor (pythonScanner)
def __init__ (self,importer,s,parent):

    baseScannerClass.__init__(self,importer)
        # Init the base class.
        # Copies ivars from importer class to scanner class.

    # Other ivars.
    self.preamble_seen = False
    self.s = s
    self.className = None
    self.methodsSeen = False
    self.root = parent
    self.start = 0
#@-node:ekr.20070324084040.14:ctor (pythonScanner)
#@+node:ekr.20070324084040.15:scanPythonText
# See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    c = self.c
    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << handle possible Python function or class >>
        else: i += 1
        assert(progress < i)
    if not decls_seen: # 2/17/03
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
    << Append a reference to the methods of this file >>
    << Append any unused python text to the parent's body text >>
#@+node:ekr.20070324084040.16:<< Append a reference to the methods of this file >>
if self.treeType == "@root" and self.methodsSeen:
    c.appendStringToBody(parent,
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
#@-node:ekr.20070324084040.16:<< Append a reference to the methods of this file >>
#@+node:ekr.20070324084040.9:<< handle possible Python function or class >> (NOT USED)
if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file":
            c.appendStringToBody(parent,"@others\n")
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)
#@-node:ekr.20070324084040.9:<< handle possible Python function or class >> (NOT USED)
#@+node:ekr.20070324084040.17:<< Append any unused python text to the parent's body text >>
# Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i < len(s):
    c.appendStringToBody(parent,s[start:])
#@-node:ekr.20070324084040.17:<< Append any unused python text to the parent's body text >>
#@-node:ekr.20070324084040.15:scanPythonText
#@+node:ekr.20070324084040.18:doPythonClass & helpers
def doPythonClass (self,i,parent):

    c = self.c ; s = self.s

    if not self.preamble_seen:
        self.doPreamble(i)

    class_indent = self.getLeadingIndent(s,i)
    i,className,headline = self.getClassHeadline(i)
    if self.className:
        oldClassName = self.className
        self.className = className
        i = g.skip_line(s,i) # Skip the class line.
        i,prefix,body = self.createClassNodeText(s,i,start)
        class_vnode = self.createHeadline(parent,prefix + body,headline)
        start,i = self.scanPythonClass(i,class_indent,class_vnode)
        s2 = s[start:i]
        if s2: c.appendStringToBody(class_vnode,s2)
        self.className = oldClassName

    return i
#@nonl
#@+node:ekr.20070324084040.19:getClassHeadline
# Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    class_name = s[j:i]
    headline = "class " + class_name
else:
    headline = ''
    class_name = ''
#@-node:ekr.20070324084040.19:getClassHeadline
#@+node:ekr.20070324084040.20:createParentText
def createParentText (self,class_vnode,class_name):

    '''Insert the proper body text in the class_vnode.'''

    c = self.c

    # This must be done after the declaration reference is generated.
    if self.treeType == "@file":
        c.appendStringToBody(class_vnode,"\t@others\n")
    else:
        ref = g.angleBrackets(' class %s methods ' % (class_name))
        c.appendStringToBody(class_vnode,"\t" + ref + "\n\n")
#@-node:ekr.20070324084040.20:createParentText
#@+node:ekr.20070324084040.21:createClassNodeText
def createClassNodeText (self,s,i,start):

    # Create the section name using the old value of self.methodName.
    if  self.treeType == "@file":
        prefix = ""
    else:
        prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
        self.methodsSeen = True

    # i points just after the class line.

    # Add a docstring to the class node.
    docStringSeen = False
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j != len(s): # No scanning error.
            i = j ; docStringSeen = True

    body = s[start:i]
    body = self.undentBody(body)
    if docStringSeen: body = body + '\n'

    return i,prefix,body
#@-node:ekr.20070324084040.21:createClassNodeText
#@-node:ekr.20070324084040.18:doPythonClass & helpers
#@+node:ekr.20070324084040.22:doPythonDef
def doPythonDef (self,i,parent):

    if not self.preamble_seen:
        self.doPreamble(i)

    i = self.scanPythonDef(i,parent)

    return i
#@nonl
#@-node:ekr.20070324084040.22:doPythonDef
#@+node:ekr.20070324084040.23:doPreamble
def doPreamble (self,i):

    self.preamble_seen = True

    if i > 0:
        # Append the preamble to the root's body text.
        c.appendStringToBody(self.root,s[:i])

    if self.treeType == '@file':
        c.appendStringToBody(self.root,'@others\n')
#@-node:ekr.20070324084040.23:doPreamble
#@+node:ekr.20070324084040.24:scanPythonClass
def scanPythonClassHelper(self,s,i,class_indent,class_name,class_vnode):

    indent =  self.getLeadingIndent(s,i)
    start = i = g.skip_blank_lines(s,i)
    parent_vnode = None
    while i < len(s):
        progress = i
        # New in Leo 4.4.1: ignore comment lines, whatever their indentation.
        if indent <= class_indent:
            j = g.skip_ws(s,i)
            if g.match(s,j,'#'):
                i = g.skip_to_end_of_line(s,j)
            else: break
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            j = g.skip_nl(s,i)
            if not backslashNewline:
                indent = self.getLeadingIndent(s,j)
                if indent > class_indent: i = j
                else: break
            else: i = j
        elif g.match_c_word(s,i,"def"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonDef(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif g.match_c_word(s,i,"class"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonClass(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
        elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
        else: i += 1
        assert(progress < i)
    return start,i
#@-node:ekr.20070324084040.24:scanPythonClass
#@+node:ekr.20070324084040.25:scanPythonDef & helpers
def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    << set headline or return i >>
    i = self.skipPythonDef(s,i,start)
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    << Create def node >>
    self.methodName = savedMethodName
    return i
#@+node:ekr.20070324084040.26:createDefNode
# Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)
#@-node:ekr.20070324084040.26:createDefNode
#@+node:ekr.20070324084040.27:getDefHeadline
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i
#@-node:ekr.20070324084040.27:getDefHeadline
#@-node:ekr.20070324084040.25:scanPythonDef & helpers
#@+node:ekr.20070324084040.28:skipPythonDef
def skipPythonDef (self,s,i,start):

    # g.trace(g.get_line(s,i))

    # Set defIndent to the indentation of the def line.
    defIndent = self.getLeadingIndent(s,start)
    parenCount = 0
    << skip the entire signature >>
    indent = self.getLeadingIndent(s,i)
    while i < len(s): # and indent > defIndent
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            if not backslashNewline:
                # New in Leo 4.4.1: don't set indent for comment lines.
                j = g.skip_ws(s,i)
                if not g.match(s,j,'#'):
                    indent = self.getLeadingIndent(s,i)
                    if indent <= defIndent and parenCount == 0:
                        break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)

    return i
#@+node:ekr.20070324084040.29:<< skip the entire signature >>
# Now that we count parens, we must be careful to skip the entire signature.

j = s.find('(',i)
if j != -1:
    j = g.skip_matching_python_parens(s,j)

if j == -1 or not g.match(s,j+1,':'):
    g.es_print('Warning: improper signature: %s' % g.get_line(s,i))
    return i
else:
    i = g.skip_line(s,j) # Still not quite 100% correct.
#@-node:ekr.20070324084040.29:<< skip the entire signature >>
#@-node:ekr.20070324084040.28:skipPythonDef
#@-node:ekr.20070324084040.13:class pythonScanner (not ready yet)
#@-node:ekr.20070324084040:Prototype of @auto
#@+node:ekr.20051202094427:Resolve cvs conflicts
Investigate meld:  http://meld.sourceforge.net/
#@nonl
#@+node:ekr.20060601073503:Postings
@nocolor
#@nonl
#@+node:ekr.20031218072017.658:Stepen Schaefer 1
@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
#@-node:ekr.20031218072017.658:Stepen Schaefer 1
#@+node:ekr.20050501111900:Stephen Schaefer 2
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3125092
By: thyrsus

About a month ago, I posted a screed on how @thin was inadequate to address
my needs; that what I needed to collaborate on via version control was exactly
the essence of Leo's value: the multiple expressions of structure, which by
their nature must exist outside of @thin.  I said I was going to live the pain
to discover a modus vivendi.

Having done that, let me now say:

AAAAAAAAAAAAGGGGGGGGHHHHHHHHHH!

But the exercise has led me to a vision, which I will implement to the extent
my nonexistent spare time and paltry programming talents permit.

The essence of the pain is "conflicts", which become more  certain to occur
as the leo file encompases ever more related files.  As I work on a change to
the Linux configuration, my colleague works on a change to the Solaris configuration,
and one of us checks in our version of the leo file documenting the site
configuration first, and the other cannot check in his version of that file.
The conflict must be resolved by the human.  Using the "diff" tool on the .leo
XML is not an answer (though thank Heaven and Ed for gnxs).  The resolution
needs two levels of support: outline and node.

With the .leo file declared binary, in the event of a conflict CVS leaves you
with the most recent CVS version and your rejected version, and you're responsible
for performing a reconciliation and then resubmitting that.  Leo will recognize
the problem, and present both versions of the project, side by side, splitting
the outline pane.  The parallel trees will scroll/expand/contract in unison.
Outline branches present in CVS and not yours will display as blank space in
your version; nodes present in your version and not CVS will display as blank
space in the CVS version. The CVS version will be read only, your version editable.
The same node with differences in its text or in its children will be highlighted.
You will be able to drag nodes from the CVS version into your version. If the
text of a selected node has conflicts, the text area will split in two, showing
the CVS version and your version, with differences highlighted, both sides of
the pane scrolling in unison, the CVS side read-only, and you can copy from
that side to your side.  I intend to take as many ideas as I can from tkdiff
(http://sourceforge.net/projects/tkdiff/ - see also
http://freshmeat.net/screenshots/10602/ ).  (I have begun translating tkdiff
from from tcl to python - nearly 9000 lines and I'm still learning both languages,
so draw your own timeline.)  You edit your nodes, you edit your tree, you hit
the "reconcile" button, and your reconciliation of the conflict goes into CVS.
If, meanwhile, another one of your over-achieving colleages has again updated
CVS, the process repeats with the most current CVS version.  Or you can hit
the "abandon" button to give up on your changes.

As the Hebrews say at Passover: "Next year in Jerusalem."
#@nonl
#@-node:ekr.20050501111900:Stephen Schaefer 2
#@+node:ekr.20031218072017.659:Jonathon 1
@nocolor

http://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

In the .leo, if I edit <<bar>>, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@verbatim
#@+leo
#@verbatim
#@+node:0::@file foo.py
#@verbatim
#@+body
#@verbatim
#@+others
#@verbatim
#@+node:1::definition of a
#@verbatim
#@+body
print "a:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"bar"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:1::definition of a
#@verbatim
#@+node:2::definition of b
#@verbatim
#@+body
print "b:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation b"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:2::definition of b
#@verbatim
#@+node:3::definition of c
#@verbatim
#@+body
print "c:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation c"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:3::definition of c
#@verbatim
#@-others
#@verbatim
#@-body
#@verbatim
#@-node:0::@file foo.py
#@verbatim
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
#@-node:ekr.20031218072017.659:Jonathon 1
#@+node:ekr.20031218072017.660:Jonathan 2
@nocolor

By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

<<<<<<< 
blah blah blah? 
======= 
blah blah blah! 
>>>>>>> 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  
#@-node:ekr.20031218072017.660:Jonathan 2
#@+node:ekr.20031218072017.661:Gil 1
http://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
#@-node:ekr.20031218072017.661:Gil 1
#@+node:ekr.20031218072017.662:Gil 2
http://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?
#@nonl
#@-node:ekr.20031218072017.662:Gil 2
#@-node:ekr.20060601073503:Postings
#@-node:ekr.20051202094427:Resolve cvs conflicts
#@+node:ekr.20040919182750.1:Better handling of whitespace (cvs fiendly)
http://sourceforge.net/forum/message.php?msg_id=3578166
#@nonl
#@+node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
#@+node:ekr.20060808103849:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2674828
By: bwmulder

If I understand correctly, there are two different problems:

- Trailing whitespaces
- Left indented comments

1. Before commenting on these, a question:

If I write something like
    a=b
    if a:
        @others

[four spaces indentation]

I sometimes see tab characters before the lines inserted for '@others'.

It seems that Leo remembers 'two levels of indentation', and then
fabricates this indentation using tab characters.

I think it might be more robust if Leo remembered the actual
characters in front of @others and would use them for indentation.

I suspect that many indentation errors I had with Leo could have been
avoided had not Leo had its own ideas on how to do indentation.

Maybe Leo could use the exact sequence of characters in front of
@others for all inserted lines?

2. I do not care much about trailing whitespaces. Most of the time
they are invisible, but sometimes they are very misleading (trailing in python or C).

As far as I am concerned, Leo need never produce trailing whitespaces.

Maybe we need special machinery if sources have trailing whitespaces
and the sources are not under our control. 

Not sure if everybody would be happy if we essentially ban all trailing
whitespaces.

3. Unindented commentlines could be dealt with by using indentation to
indicate structure.

Of course, this might break the correspondance Leo structure / Python
structure, which is very ugly.

4. One possible alternative might be a new directive which indicates outindent:

@outindent <number>.

This would apply to the next comment block.

To me, 4. looks a little bit less ugly than 3.

5. As indicated in a different post, I suspect that Leo has a problem
if almost every node in an outline is changed. Profiling should point
to the culprit.

> 2. Have Leo strip whitespace from otherwise blank lines, and hope
that that solves all problems in Perfect Import. This is solving the
problem in the atFile code. The problem is that if we apply settings
in general we will get massive changes to derived files. In most
programming settings these changes might be welcome, but the problem
is actually making these changes. My first few attempts met with
abject failure.

Are you saying that you could not remove trailing blanks? What kind of
problems did you run into?

Summary:
- Use actual characters in front of @others or <<>> for indentation.
- Don't write trailing whitespaces
- Introduce directive for left-indendet comments.
- Profile to find out what slows Leo down if many nodes change.
#@nonl
#@-node:ekr.20060808103849:Report
#@+node:ekr.20041005105605.210:putIndent
def putIndent(self,n):

    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w > 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
#@-node:ekr.20041005105605.210:putIndent
#@-node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
#@+node:EKR.20040603092958.1:Add new options for handling newlines in body text
@nocolor

- "asis":
- "zero": no trailing newlines.
- "one": exactly one trailing newline.

Special case code is required so empty nodes stay empty with "one" option.
#@nonl
#@-node:EKR.20040603092958.1:Add new options for handling newlines in body text
#@-node:ekr.20040919182750.1:Better handling of whitespace (cvs fiendly)
#@-node:ekr.20070325052041:To do: 4.4.4 (@auto)
#@+node:ekr.20070105135713:To do: 4.5 (new positions)
#@+node:ekr.20061028070132:New positions
# None of this code is part of Leo's core yet: it is all highly experimental.

# Important: the new vnode class implies that the read code must be rewritten to be similar to the opml read code.
#@nonl
#@+node:ekr.20070512131018:Thoughts about positions 1
http://sourceforge.net/forum/message.php?msg_id=4308503

@nocolor

After more thought I am ready to back off my earlier post. Positions are perfectly reasonable things to support. Indeed, they can be, and probably should be, coequal with iterators. 

My 'revulsion' to positions stems from their present implementation--the 'optimization' of positions to avoid adding items to p.stack is certainly the worst optimization presently in Leo. It dates from the days when I was obsessing about reducing the amount of positions created. That was a valid concern then, but Leo now does an excellent job of not generating excess positions. Thus, there is no reason not to have p.stack contain all the parent vnodes at the present spot in a traversal. 

The idea of representing a position by a count in a traversal is cute, but of no practical importance. Indeed, why should Leo be forced to stupidly step through an entire traversal when a list of vnodes in p.stack would get to the proper spot in exponentially shorter time. Moreover, a list of vnodes in p.stack is great information to have, while a count N is almost exactly useless :-) 

Still, it is good to emphasize that *any* position, no matter how it is represented, makes sense *only* for a particular outline, that is, for a particular set of vnodes. In short, positions will stay, but will be reimplemented for the graph world. 
#@nonl
#@-node:ekr.20070512131018:Thoughts about positions 1
#@+node:ekr.20070512130855:Thoughts about positions 2
@nocolor

There will be some significant changes to the position and vnode classes for the graph world (Leo 4.5).  These changes will be common to both the graph and clone worlds:

Only vnode methods will be allowed to alter outline/graph data.  This would have been a good rule to following earlier, but up until now Leo has allowed 'confused' scripts--script that treat positions like vnodes.  This confusion will not be allowed in Leo 4.5.  The need for strict separation between vnodes and positions has become apparent in the recent chapters work.

It would be best to think of a position as a *path* to a particular vnode.  In the present (clone) world, the path is used exclusively by the tree drawing logic.  That logic tests whether the node being drawn matches (has the same position) as c.currentPosition.  In the graph world it probably makes sense to speak only of the current *vnode*, say v, so a position p is *a* current position if p.v == v.

The (renewed) focus on vnodes will be necessary.  For example, there will be no such things as p.back() or v._back in the graph world.  That is, a vnode v will have no *intrinsic* siblings.  Instead, siblings are relative to a parent: the order of vnodes in the parent.children links implicitly define sibling relationships, but a vnode v may have many 'parents', i.e. there may be many nodes that point to v.  We could speak of 'siblings with respect to a particular parent', but I suspect that will not be a particularly useful concept.  Rather, it will probably be more natural simply to define node relationships using iterators.  We shall see...
#@-node:ekr.20070512130855:Thoughts about positions 2
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.use_new_positions = False

    # New positions require the sax-based read code.
    self.use_sax = self.use_new_positions or c.config.getBool('use_sax_based_read')

    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5
    if self.use_sax:
        self.currentVnode = None
        self.rootVnode = None
    else:
        self.fileBuffer = None
        self.fileIndex = 0
        self.currentVnodeStack = [] # A stack of vnodes giving the current position.
        self.topVnodeStack     = [] # A stack of vnodes giving the top position.
        self.topPosition = None
    # For writing
    self.read_only = False
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@nonl
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061029093342.75:linkParentAndChildren (changed)
def linkParentAndChildren (self, parent_v, children):

    # if children: g.trace(parent_v,len(children))

    if self.use_new_positions:
        parent_v.t.links = children
    else:
        firstChild_v = children and children[0] or None
        parent_v.t._firstChild = firstChild_v
        for child in children:
            child._parent = parent_v

    v = parent_v
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
#@nonl
#@-node:ekr.20061029093342.75:linkParentAndChildren (changed)
#@+node:ekr.20061029093342.76:linkSiblings (changed)
def linkSiblings (self, sibs):

    '''Set the v._back and v._next links for all vnodes v in sibs.'''

    if self.use_new_positions:
        pass
    else:
        n = len(sibs)
        for i in xrange(n):
            v = sibs[i]
            v._back = (i-1 >= 0 and sibs[i-1]) or None
            v._next = (i+1 <  n and sibs[i+1]) or None
#@nonl
#@-node:ekr.20061029093342.76:linkSiblings (changed)
#@-node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.5:v.__cmp__ (not used)
if 0: # not used
    def __cmp__(self,other):

        g.trace(self,other)
        return not (self is other) # Must return 0, 1 or -1
#@-node:ekr.20061028211424.5:v.__cmp__ (not used)
#@+node:ekr.20061028211424.6:v.__init__
def __init__ (self,t):

    assert(t)

    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.unknownAttributes or any mutable vnode object changes.

    self.t = t # The tnode.
    self.statusBits = 0 # status bits

    # Structure links.
    #### self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20061028211424.6:v.__init__
#@+node:ekr.20061028211424.7:v.__repr__ & v.__str__
def __repr__ (self):

    if self.t:
        return "<vnode %d:'%s'>" % (id(self),self.cleanHeadString())
    else:
        return "<vnode %d:NULL tnode>" % (id(self))

__str__ = __repr__
#@-node:ekr.20061028211424.7:v.__repr__ & v.__str__
#@+node:ekr.20061028211424.8:v.dump (to be deleted)
def dumpLink (self,link):
    return g.choose(link,link,"<none>")

def dump (self,label=""):

    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)

    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v
#@-node:ekr.20061028211424.8:v.dump (to be deleted)
#@+node:ekr.20061028211424.9:v.__hash__ (only for zodb)
if use_zodb and ZODB:
    def __hash__(self):
        return self.t.__hash__()
#@nonl
#@-node:ekr.20061028211424.9:v.__hash__ (only for zodb)
#@-node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
def findAtFileName (self,names):

    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()

    if not g.match(h,0,'@'):
        return ""

    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
#@-node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
#@+node:ekr.20061028211424.12:anyAtFileNodeName
def anyAtFileNodeName (self):

    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)
#@-node:ekr.20061028211424.12:anyAtFileNodeName
#@+node:ekr.20061028211424.13:at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)

def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)

def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@-node:ekr.20061028211424.13:at...FileNodeName
#@+node:ekr.20061028211424.14:isAtAllNode
def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag
#@-node:ekr.20061028211424.14:isAtAllNode
#@+node:ekr.20061028211424.15:isAnyAtFileNode good
def isAnyAtFileNode (self):

    """Return True if v is any kind of @file or related node."""

    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
#@-node:ekr.20061028211424.15:isAnyAtFileNode good
#@+node:ekr.20061028211424.16:isAt...FileNode (vnode)
def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)

def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@-node:ekr.20061028211424.16:isAt...FileNode (vnode)
#@+node:ekr.20061028211424.17:isAtIgnoreNode
def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag
#@-node:ekr.20061028211424.17:isAtIgnoreNode
#@+node:ekr.20061028211424.18:isAtOthersNode
def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag
#@-node:ekr.20061028211424.18:isAtOthersNode
#@+node:ekr.20061028211424.19:matchHeadline
def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.

    The headline may contain characters following the successfully matched pattern."""

    v = self

    h = g.toUnicode(v.headString(),'utf-8')
    h = h.lower().replace(' ','').replace('\t','')

    pattern = g.toUnicode(pattern,'utf-8')
    pattern = pattern.lower().replace(' ','').replace('\t','')

    return h.startswith(pattern)
#@-node:ekr.20061028211424.19:matchHeadline
#@-node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.22:v.back
# Compatibility routine for scripts

def back (self):

    return self._back
#@-node:ekr.20061028211424.22:v.back
#@+node:ekr.20061028211424.23:v.next
# Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next
#@-node:ekr.20061028211424.23:v.next
#@-node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.25:v.childIndex
def childIndex(self):

    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n
#@-node:ekr.20061028211424.25:v.childIndex
#@+node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
def firstChild (self):

    return self.t._firstChild
#@-node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
#@+node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
def hasChildren (self):

    v = self
    return v.firstChild()

hasFirstChild = hasChildren
#@-node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
#@+node:ekr.20061028211424.28:v.lastChild
def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child
#@-node:ekr.20061028211424.28:v.lastChild
#@+node:ekr.20061028211424.29:v.nthChild
# childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n > 0 and child:
        n -= 1
        child = child.next()
    return child
#@-node:ekr.20061028211424.29:v.nthChild
#@+node:ekr.20061028211424.30:v.numberOfChildren (n)
def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n += 1
        child = child.next()
    return n
#@-node:ekr.20061028211424.30:v.numberOfChildren (n)
#@-node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.32:v.isCloned (4.2)
def isCloned (self):

    return len(self.t.vnodeList) > 1
#@-node:ekr.20061028211424.32:v.isCloned (4.2)
#@+node:ekr.20061028211424.33:isDirty
def isDirty (self):

    return self.t.isDirty()
#@-node:ekr.20061028211424.33:isDirty
#@+node:ekr.20061028211424.34:isExpanded
def isExpanded (self):

    return ( self.statusBits & self.expandedBit ) != 0
#@-node:ekr.20061028211424.34:isExpanded
#@+node:ekr.20061028211424.35:isMarked
def isMarked (self):

    return ( self.statusBits & vnode.markedBit ) != 0
#@-node:ekr.20061028211424.35:isMarked
#@+node:ekr.20061028211424.36:isOrphan
def isOrphan (self):

    return ( self.statusBits & vnode.orphanBit ) != 0
#@-node:ekr.20061028211424.36:isOrphan
#@+node:ekr.20061028211424.37:isSelected
def isSelected (self):

    return ( self.statusBits & vnode.selectedBit ) != 0
#@-node:ekr.20061028211424.37:isSelected
#@+node:ekr.20061028211424.38:isTopBitSet
def isTopBitSet (self):

    return ( self.statusBits & self.topBit ) != 0
#@-node:ekr.20061028211424.38:isTopBitSet
#@+node:ekr.20061028211424.39:isVisited
def isVisited (self):

    return ( self.statusBits & vnode.visitedBit ) != 0
#@-node:ekr.20061028211424.39:isVisited
#@+node:ekr.20061028211424.40:status
def status (self):

    return self.statusBits
#@-node:ekr.20061028211424.40:status
#@-node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.41:v.bodyString
# Compatibility routine for scripts

def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.bodyString):
        s = "v.bodyString: Leo internal error: not unicode:" + repr(self.t.bodyString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
#@-node:ekr.20061028211424.41:v.bodyString
#@+node:ekr.20061028211424.42:v.headString & v.cleanHeadString
def headString (self):

    """Return the headline string."""

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.headString):
        s = "Leo internal error: not unicode:" + repr(self.t.headString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):

    s = self.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
#@-node:ekr.20061028211424.42:v.headString & v.cleanHeadString
#@+node:ekr.20061028211424.43:v.directParents (new method in 4.2)
def directParents (self):

    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.

    This is NOT the same as the list of ancestors of the vnode."""

    v = self

    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []
#@-node:ekr.20061028211424.43:v.directParents (new method in 4.2)
#@-node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
# These remain in 4.2: the file read logic calls these before creating positions.
#@+node:ekr.20061028211424.45:v.detach
def detach (self):

    '''Return a standalone copy of a vnode,
    detached from all other nodes and with a new tnode.'''

    v = self

    # Create a completely separate tnode.
    t2 = tnode(
        bodyString=v.bodyString(),
        headString=v.headString())

    return vnode(t2)
#@nonl
#@-node:ekr.20061028211424.45:v.detach
#@+node:ekr.20061028211424.46:v.insertAfter
def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAfter(self)

    return v
#@-node:ekr.20061028211424.46:v.insertAfter
#@+node:ekr.20061028211424.47:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAsNthChild(self,n)

    return v
#@-node:ekr.20061028211424.47:v.insertAsNthChild
#@+node:ekr.20061028211424.48:v.linkAfter
def linkAfter (self,v):

    """Link self after v."""

    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
#@-node:ekr.20061028211424.48:v.linkAfter
#@+node:ekr.20061028211424.49:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v
#@-node:ekr.20061028211424.49:v.linkAsNthChild
#@+node:ekr.20061028211424.50:v.linkAsRoot
def linkAsRoot (self,oldRoot):

    """Link a vnode as the root node and set the root _position_."""

    v = self

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot

    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v
#@nonl
#@-node:ekr.20061028211424.50:v.linkAsRoot
#@+node:ekr.20061028211424.51:v.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a vnode to the root position.

    Important: oldRoot must the previous root vnode if it exists.'''

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)

    return v
#@nonl
#@-node:ekr.20061028211424.51:v.moveToRoot
#@+node:ekr.20061028211424.52:v.unlink
def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []
#@nonl
#@-node:ekr.20061028211424.52:v.unlink
#@-node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
#@+node:ekr.20061028211424.53:Setters (no change)
#@+node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.55:clearClonedBit
def clearClonedBit (self):

    self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.55:clearClonedBit
#@+node:ekr.20061028211424.56:v.clearDirty (no change needed)
def clearDirty (self):

    v = self
    v.t.clearDirty()
#@nonl
#@-node:ekr.20061028211424.56:v.clearDirty (no change needed)
#@+node:ekr.20061028211424.57:v.clearMarked
def clearMarked (self):

    self.statusBits &= ~ self.markedBit
#@-node:ekr.20061028211424.57:v.clearMarked
#@+node:ekr.20061028211424.58:clearOrphan
def clearOrphan (self):

    self.statusBits &= ~ self.orphanBit
#@-node:ekr.20061028211424.58:clearOrphan
#@+node:ekr.20061028211424.59:clearVisited
def clearVisited (self):

    self.statusBits &= ~ self.visitedBit
#@-node:ekr.20061028211424.59:clearVisited
#@+node:ekr.20061028211424.60:contract & expand & initExpandedBit
def contract(self):

    self.statusBits &= ~ self.expandedBit

    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit

    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit
#@-node:ekr.20061028211424.60:contract & expand & initExpandedBit
#@+node:ekr.20061028211424.61:initStatus
def initStatus (self, status):

    self.statusBits = status
#@-node:ekr.20061028211424.61:initStatus
#@+node:ekr.20061028211424.62:setClonedBit & initClonedBit
def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.62:setClonedBit & initClonedBit
#@+node:ekr.20061028211424.63:v.setMarked & initMarkedBit
def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
#@-node:ekr.20061028211424.63:v.setMarked & initMarkedBit
#@+node:ekr.20061028211424.64:setOrphan
def setOrphan (self):

    self.statusBits |= self.orphanBit
#@-node:ekr.20061028211424.64:setOrphan
#@+node:ekr.20061028211424.65:setSelected (vnode)
# This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit
#@-node:ekr.20061028211424.65:setSelected (vnode)
#@+node:ekr.20061028211424.66:t.setVisited
# Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit
#@-node:ekr.20061028211424.66:t.setVisited
#@-node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.67:v.computeIcon & setIcon
def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val

def setIcon (self):

    pass # Compatibility routine for old scripts
#@-node:ekr.20061028211424.67:v.computeIcon & setIcon
#@+node:ekr.20061028211424.68:v.initHeadString
def initHeadString (self,s,encoding="utf-8"):

    v = self
    s = g.toUnicode(s,encoding,reportErrors=True)
    v.t.headString = s

    # g.trace(g.callers(5))
#@-node:ekr.20061028211424.68:v.initHeadString
#@+node:ekr.20061028211424.69:v.setSelection
def setSelection (self, start, length):

    self.t.setSelection ( start, length )
#@-node:ekr.20061028211424.69:v.setSelection
#@+node:ekr.20061028211424.70:v.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):

    return self.t.setTnodeText(s,encoding)
#@-node:ekr.20061028211424.70:v.setTnodeText
#@-node:ekr.20061028211424.53:Setters (no change)
#@-node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.1:position class
#@+node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.2:p.__cmp__ (changed)
def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self

    # g.trace(p1.headString(),p2 and p2.headString())

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal
    elif p1.v == p2.v and p2._childIndex == p2._childIndex and p1.stack == p2.stack:
        return 0 # equal
    else:
        return 1 # not equal

    # # Check entire stack quickly.
    # # The stack contains vnodes, so this is not a recursive call.
    # if p1.v != p2.v or p1.stack != p2.stack:
        # return 1 # notEqual
    # # This is slow: do this last!
    # if p1.childIndex() != p2.childIndex():
        # # Disambiguate clones having the same parents.
        # return 1 # notEqual
    # return 0 # equal
#@nonl
#@-node:ekr.20061028070057.2:p.__cmp__ (changed)
#@+node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):

        """Convert references to p.t into references to p.v.t.

        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                print "unknown position attribute:",attr
                import traceback ; traceback.print_stack()
            raise AttributeError,attr
#@nonl
#@-node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20061028070057.4:p.__init__
def __init__ (self,v,childIndex=0,stack=None):

    '''Create a new position.'''

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    self._childIndex = childIndex

    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20061028070057.4:p.__init__
#@+node:ekr.20061028070057.5:p.__nonzero__
@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

def __nonzero__ ( self):

    """Return True if a position is valid."""

    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None
#@-node:ekr.20061028070057.5:p.__nonzero__
#@+node:ekr.20061028070057.6:p.__str__ and p.__repr__
def __str__ (self):

    p = self

    if p.v:
        return "<pos %d lvl: %d [%d] %s>" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d        [%d] None>" % (id(p),len(p.stack))

__repr__ = __str__
#@-node:ekr.20061028070057.6:p.__str__ and p.__repr__
#@+node:ekr.20061028070057.7:p.archivedPosition
def archivedPosition (self):

    '''Return a representation of a position suitable for use in .leo files.'''

    p = self
    aList = [p2.v.childIndex() for p2 in p.self_and_parents_iter()]
    aList.reverse()
    return aList
#@nonl
#@-node:ekr.20061028070057.7:p.archivedPosition
#@+node:ekr.20061028070057.8:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):

    """"Return an independent copy of a position."""

    return position(self.v,self.stack)
#@-node:ekr.20061028070057.8:p.copy
#@+node:ekr.20061028070057.9:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):

    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label

def vnodeListIds (self):

    p = self
    return [id(v) for v in p.v.t.vnodeList]
#@-node:ekr.20061028070057.9:p.dump & p.vnodeListIds
#@+node:ekr.20061028070057.10:p.equal & isEqual (changed)
def equal(self,p2):

    """Return True if two postions are equivalent.

    Use this method when the speed comparisons is crucial

    N.B. Unlike __cmp__, p2 must not be None.
    """

    p1 = self

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1._childIndex == p2._childIndex and
        p1.stack == p2.stack
    )

isEqual = equal
#@-node:ekr.20061028070057.10:p.equal & isEqual (changed)
#@+node:ekr.20061028070057.11:p.key
def key (self):

    p = self

    return '%s:%d.%s' % (
        id(p.v),
        p._childIndex,
        ','.join([str(id(v)) for v in p.stack])
    )
#@-node:ekr.20061028070057.11:p.key
#@-node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.12:p.moveToX (many changes)
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
#@+node:ekr.20061028070057.13:p.moveToBack (new)
def moveToBack (self):

    '''Move position p to its previous sibling.'''

    p = self
    if p.stack and p._childIndex > 0:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex -= 1
            p.v = links[p._childIndex]
        else:
            g.trace('Can not happen: no links')
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # p.v = p.v and p.v._back
    # return p
#@nonl
#@-node:ekr.20061028070057.13:p.moveToBack (new)
#@+node:ekr.20061028070057.14:p.moveToFirstChild (new)
def moveToFirstChild (self):

    '''Move a position to it's first child's position.'''

    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = 0
            p.v = links[0]
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # child = p.v.t._firstChild
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.14:p.moveToFirstChild (new)
#@+node:ekr.20061028070057.15:p.moveToLastChild (new)
def moveToLastChild (self):

    '''Move a position to it's last child's position.'''

    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = len(links)-1
            p.v = links[p._childIndex]
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # if p.v.t._firstChild:
            # child = p.v.lastChild()
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.15:p.moveToLastChild (new)
#@+node:ekr.20061028070057.16:p.moveToLastNode (no change)
def moveToLastNode (self):

    """Move a position to last node of its tree.

    N.B. Returns p if p has no children."""

    p = self
    while p.hasChildren():
        p.moveToLastChild()
    return p
#@-node:ekr.20061028070057.16:p.moveToLastNode (no change)
#@+node:ekr.20061028070057.17:p.moveToNext (new)
def moveToNext (self):

    '''Move position p to its next sibling.'''

    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if p._childIndex + 1 < len(links):
            p._childIndex += 1
            p.v = links[p._childIndex]
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # p.v = p.v and p.v._next
    # return p
#@-node:ekr.20061028070057.17:p.moveToNext (new)
#@+node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
def moveToNodeAfterTree (self):

    """Move a position to the node after the position's tree."""

    p = self

    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
#@+node:ekr.20061028070057.19:p.moveToNthChild (new)
def moveToNthChild (self,n):

    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links and n < len(links)
            p.v = links[n]
            p.childIndex = n
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # child = p.v.nthChild(n) # Must call vnode method here!
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.19:p.moveToNthChild (new)
#@+node:ekr.20061028070057.20:p.moveToParent (new)
def moveToParent (self):

    '''Move a position to its parent position.'''

    if p.stack:
        p.v,p._childIndex = p.stack.pop()
    else:
        p.v = None
    return p

    # p = self
    # if not p: return p
    # if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        # p.v = p.v._parent
    # elif p.stack:
        # p.v = p.stack.pop()
    # else:
        # p.v = None
    # return p
#@nonl
#@-node:ekr.20061028070057.20:p.moveToParent (new)
#@+node:ekr.20061028070057.21:p.moveToThreadBack (no change)
def moveToThreadBack (self):

    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.21:p.moveToThreadBack (no change)
#@+node:ekr.20061028070057.22:p.moveToThreadNext (little change)
def moveToThreadNext (self):
    '''Move a position to the next a position in threading order.'''
    p = self
    if p.hasChildren():
        p.moveToFirstChild()
    elif p.hasNext()
        p.moveToNext()
    else:
        p.moveToParent()
        while p:
            if p.hasNext():
                p.moveToNext()
                break #found
            p.moveToParent()
        # not found.
    return p

# def moveToThreadNext (self):
    # """Move a position to the next a position in threading order."""
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # p.moveToFirstChild()
        # elif p.v._next:
            # p.moveToNext()
        # else:
            # p.moveToParent()
            # while p:
                # if p.v._next:
                    # p.moveToNext()
                    # break #found
                # p.moveToParent()
            # # not found. 
    # return p
#@nonl
#@-node:ekr.20061028070057.22:p.moveToThreadNext (little change)
#@+node:ekr.20061028070057.23:p.moveToVisBack (no change)
def moveToVisBack (self):

    """Move a position to the position of the previous visible node."""

    p = self

    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p
#@-node:ekr.20061028070057.23:p.moveToVisBack (no change)
#@+node:ekr.20061028070057.24:p.moveToVisNext (no change)
def moveToVisNext (self):

    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()

    return p
#@-node:ekr.20061028070057.24:p.moveToVisNext (no change)
#@-node:ekr.20061028070057.12:p.moveToX (many changes)
#@+node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.27:p.Comparisons (no change)
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)
#@-node:ekr.20061028070057.27:p.Comparisons (no change)
#@+node:ekr.20061028070057.28:p.Headline & body strings (no change)
def bodyString (self):

    return self.v.bodyString()

def headString (self):

    return self.v.headString()

def cleanHeadString (self):

    return self.v.cleanHeadString()
#@-node:ekr.20061028070057.28:p.Headline & body strings (no change)
#@+node:ekr.20061028070057.29:p.Status bits (no change)
def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
#@-node:ekr.20061028070057.29:p.Status bits (no change)
#@+node:ekr.20061028070057.30:p.directParents (new, faster)
def directParents (self):

    p = self
    return p and p.stack or []

    # return self.v.directParents()
#@-node:ekr.20061028070057.30:p.directParents (new, faster)
#@+node:ekr.20061028070057.31:p.childIndex (new, much faster)
# This is time-critical code!

def childIndex(self):

    return p and p._childIndex or 0

    # p = self ; v = p.v
    # if not v or not v._back:
        # return 0
    # n = 0 ; v = v._back
    # while v:
        # n += 1
        # v = v._back
    # return n
#@nonl
#@-node:ekr.20061028070057.31:p.childIndex (new, much faster)
#@-node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.33:p.hasChildren (new)
def hasChildren(self):

    p = self

    if p.v and p.v.t:
        return len(p.v.t.links) > 0
    else:
        return False

    # return p.v and p.v.t and p.v.t._firstChild
#@-node:ekr.20061028070057.33:p.hasChildren (new)
#@+node:ekr.20061028070057.34:p.numberOfChildren (new)
def numberOfChildren (self):

    if p.v:
        return len(p.v.t.links)
    else:
        return 0

    # return self.v.numberOfChildren()
#@-node:ekr.20061028070057.34:p.numberOfChildren (new)
#@-node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@-node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
#@+node:ekr.20061028070057.36:p.hasX (new)
def hasBack(self):
    return self._childIndex > 0
    # return self.v and self.v._back

hasFirstChild = hasChildren

def hasNext(self):
    p = self
    if p.stack:
        parent_v,junk = self.stack[-1]
        links = parent_v.t.links
        return p._childIndex + 1 < len(parent.v.t.links)
    else:
        return False
    # return self.v and self.v._next

def hasParent(self):
    return len(self.stack) > 1 # The first item of each stack is the dummy parent.
    # return self.v and self.v._parent is not None

def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.

hasVisBack = hasThreadBack
#@-node:ekr.20061028070057.36:p.hasX (new)
#@+node:ekr.20061028070057.37:hasThreadNext (big change)
def hasThreadNext(self):

    p = self ; v = p.v
    if not p.v: return False

    if p.hasChildren() or p.hasNext():
        return True
    else:
        # Simulate this code without copying p.
        # p2 = p.copy()
        # p2.moveToParent()
        # while p2:
            # if p2.hasNext():
                # return True
            # p2.moveToParent()
        # return False
        if not p.stack: return False
        n = len(p.stack)-1
        v,childIndex = p.stack[n]
        n -= 1
        while n >= 0:
            # v2,childIndex2 represent v's parent.
            v2,childIndex2 = parent.stack[n]
            links = v2.t.links
            if childIndex + 1 < len(links):
                return True
            # v.moveToParent
            v,childIndex = v2,childIndex2
            n -= 1
        return False

    # p = self ; v = p.v
    # if not p.v: return False
    # if v.t._firstChild or v._next:
        # return True
    # else:
        # n = len(p.stack)-1
        # v,n = p.vParentWithStack(v,p.stack,n)
        # while v:
            # if v._next:
                # return True
            # v,n = p.vParentWithStack(v,p.stack,n)
        # return False

hasVisNext = hasThreadNext
#@nonl
#@-node:ekr.20061028070057.37:hasThreadNext (big change)
#@+node:ekr.20061028070057.38:p.findRootPosition (unchanged)
def findRootPosition (self):

    p = self.copy()
    while p.hasParent():
        p.moveToParent()
    while p.hasBack():
        p.moveToBack()
    return p
#@nonl
#@-node:ekr.20061028070057.38:p.findRootPosition (unchanged)
#@+node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
def isAncestorOf (self, p2):

    p = self
    if not p.stack:
        return False
    elif p2 is None or not p2.stack:
        return False
    else:
        for v,junk in p2.stack:
            if v == p.v:
                return True
        else:
            return False

    # p = self
    # # Avoid calling p.copy() or copying the stack.
    # v2 = p2.v ; n = len(p2.stack)-1
        # # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # while v2:
        # if v2 == p.v:
            # return True
        # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # return False
#@nonl
#@-node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
#@+node:ekr.20061028070057.40:p.isCloned (unchanged)
def isCloned (self):

    return len(self.v.t.vnodeList) > 1
#@-node:ekr.20061028070057.40:p.isCloned (unchanged)
#@+node:ekr.20061028070057.41:p.isRoot (unchanged)
def isRoot (self):

    p = self

    return not p.hasParent() and not p.hasBack()
#@-node:ekr.20061028070057.41:p.isRoot (unchanged)
#@+node:ekr.20061028070057.42:p.isVisible (new)
def isVisible (self):

    """Return True if all of a position's parents are expanded."""

    p = self
    for v in p.stack:
        if not v.isExpanded():
            return False
    return True

    # p = self
    # v = p.v ; n = len(p.stack)-1
    # v,n = p.vParentWithStack(v,p.stack,n)
    # while v:
        # if not v.isExpanded():
            # return False
        # v,n = p.vParentWithStack(v,p.stack,n)
    # return True
#@nonl
#@-node:ekr.20061028070057.42:p.isVisible (new)
#@+node:ekr.20061028070057.43:p.level & simpleLevel (new)
def level(self):
    return len(self.stack)

simpleLevel = level

# def simpleLevel(self):
    # 
    # return len([p for p in self.parents_iter()])

# def level(self,verbose=False):
    # 
    # p = self ; level = 0
    # if not p: return level
        # 
    # # Avoid calling p.copy() or copying the stack.
    # v = p.v ; n = len(p.stack)-1
    # while 1:
        # assert(p)
        # v,n = p.vParentWithStack(v,p.stack,n)
        # if v:
            # level += 1
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        # else:
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # # if g.app.debug: assert(level==self.simpleLevel())
            # break
    # return level
#@-node:ekr.20061028070057.43:p.level & simpleLevel (new)
#@-node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):

    """A utility that allows the computation of p.v without calling p.copy().

    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n >= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
#@+node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)
#@-node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
#@-node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
#@+node:ekr.20061028070057.47:p.restoreLinksInTree
def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""

    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    for p in root.children_iter():
        p.restoreLinksInTree()
#@-node:ekr.20061028070057.47:p.restoreLinksInTree
#@+node:ekr.20061028070057.48:p.deleteLinksInTree & allies
def deleteLinksInTree (self):

    """Delete and otherwise adjust links when deleting node."""

    root = self

    root.deleteLinksInSubtree()

    # for p in root.children_iter():
        # p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@+node:ekr.20061028070057.49:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20061028070057.49:p.deleteLinksInSubtree
#@+node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
def adjustParentLinksInSubtree (self,parent):

    root = p = self

    assert(parent)

    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]

    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
#@-node:ekr.20061028070057.48:p.deleteLinksInTree & allies
#@-node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@+node:ekr.20061028070057.52:p.linkAfter
def linkAfter (self,after):

    """Link self after position 'after'."""

    p = self
    if not after.stack:
        g.trace('Can not happen: no dummy root.',after)
        return

    p.stack = after.stack[:]
    p._childIndex = after._childIndex + 1 #### New
    parent_v,junk = p.stack[-1] #### New
    links = parent_v.t.links #### New
    links.insert(p._childIndex,p.v) #### New

    #### p.v._parent = after.v._parent

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    #### p.v._back = after.v
    #### p.v._next = after.v._next
    #### after.v._next = p.v
    #### if p.v._next:
        #### p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")
#@-node:ekr.20061028070057.52:p.linkAfter
#@+node:ekr.20061028070057.53:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of parent position 'parent'."""

    # g.trace(self,parent,n,parent.v)

    p = self
    links = parent.v.t.links
    if n <= len(links):
        links.insert(n,p.v)
    else:
        g.trace('Can not happen: n too large.',n,p)
        return

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # # Recreate the stack using the parent.
    # p.stack = parent.stack[:]
    # if parent.isCloned():
        # p.stack.append(parent.v)
    # p.v._parent = parent.v
    # # Add v to it's tnode's vnodeList.
    # if p.v not in p.v.t.vnodeList:
        # p.v.t.vnodeList.append(p.v)
        # p.v.t._p_changed = 1 # Support for tnode class.
    # if n == 0:
        # child1 = parent.v.t._firstChild
        # p.v._back = None
        # p.v._next = child1
        # if child1:
            # child1._back = p.v
        # parent.v.t._firstChild = p.v
    # else:
        # prev = parent.nthChild(n-1) # zero based
        # assert(prev)
        # p.v._back = prev.v
        # p.v._next = prev.v._next
        # prev.v._next = p.v
        # if p.v._next:
            # p.v._next._back = p.v
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.53:p.linkAsNthChild
#@+node:ekr.20061028070057.54:p.linkAsRoot
def linkAsRoot (self,oldRoot):

    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None

    root_v,junk = p.stack[0]
    links = root_v.t.links
    p.stack = [root_v] # Clear the stack, except for the dummy root.
    links = [p.v]
    if oldRoot:
        links.append(oldRoot.v)

    # p.stack = [] # Clear the stack.
    # # Clear all links except the child link.
    # v._parent = None
    # v._back = None
    # v._next = oldRootVnode

    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    # if oldRoot:
        # oldRoot.v._back = v
    # p.dump(label="root")
#@nonl
#@-node:ekr.20061028070057.54:p.linkAsRoot
#@+node:ekr.20061028070057.55:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.

    The p.v.t.links does NOT change."""

    p = self ; v = p.v

    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)

    if p.stack:
        parent,junk = p.stack[-1]
        links = parent.t.links
        if v in links:
            links.remove(v)
        else:
            g.trace("Can not happen: not its father's child.",p)
    else:
        g.trace('Can not happen: missing root.',p)

    # Reset the firstChild link in its direct father.
    # if p.v._parent:
        # if 0: # This can fail.  I have no idea why it was present.
            # assert(p.v and p.v._parent in p.v.directParents())
        # if p.v._parent.t._firstChild == v:
            # #g.trace('resetting _parent.v.t._firstChild to',v._next)
            # p.v._parent.t._firstChild = v._next
    # else:
        # parent = p.parent()
        # if parent:
            # if 0: # This can fail.  I have no idea why it was present.
                # assert(parent.v in p.v.directParents())
            # if parent.v.t._firstChild == v:
                # #g.trace('resetting parent().v.t._firstChild to',v._next)
                # parent.v.t._firstChild = v._next
    # # Do NOT delete the links in any child nodes.
    # # Clear the links in other nodes.
    # if v._back: v._back._next = v._next
    # if v._next: v._next._back = v._back
    # # Unlink _this_ node.
    # v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.55:p.unlink
#@-node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
#@-node:ekr.20061028211424.1:position class
#@-node:ekr.20061028070132:New positions
#@+node:ekr.20070105135851.1:Most important
#@+node:ekr.20061206060454:Improve import code
@nocolor

- Make the later munging unnecessary.
	- Don't generate @file or the full file names.
	- Don't add @ignore
	- Put @language python and @tabwidth -4 only in the root node.
- Put the docstring at the top.
- Make sure only imports go in the << imports >> section.
#@-node:ekr.20061206060454:Improve import code
#@+node:ekr.20061127170002.1:Allow multiple lines on the button bar
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3993176
By: rich_ries

How can the button bar be enlarged to take a second (or third!) row of icons? Or maybe the Scripting buttons can have
their own section, like the NodeBar plugin did/does?

add-new-icon-row command?
#@nonl
#@-node:ekr.20061127170002.1:Allow multiple lines on the button bar
#@-node:ekr.20070105135851.1:Most important
#@+node:ekr.20061028065955.4:New features
#@+node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061014050154.2:Binding to None clears all bindings
#@-node:ekr.20061014050154.2:Binding to None clears all bindings
#@+node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@-node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@+node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:new
def new (self,event=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """

    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"

if ext[0] != ".":
    ext = "."+ext

# print "ext",ext
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None

body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed

if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):

    """Return the path to the temp file corresponding to p and ext."""

    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)

        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)

        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)

        name = g.toUnicode(name,g.app.tkEncoding)

        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))

        path = g.os_path_join(td,name)

        return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    c.beginUpdate()
    try:
        if c.mFileName != "":
            # Calls c.setChanged(False) if no error.
            c.fileCommands.save(c.mFileName)
        else:
            fileName = g.app.gui.runSaveFileDialog(
                initialfile = c.mFileName,
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
            c.bringToFront()

            if fileName:
                # Don't change mFileName until the dialog has suceeded.
                c.mFileName = g.ensure_extension(fileName, ".leo")
                c.frame.title = c.mFileName
                c.frame.setTitle(g.computeWindowTitle(c.mFileName))
                c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
                c.fileCommands.save(c.mFileName)
                c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save As",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # 7/2/02: don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            # Calls c.setChanged(False) if no error.
            c.fileCommands.saveAs(c.mFileName)
            c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
#@-node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        # set local fileName, _not_ c.mFileName
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save To",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            fileName = g.ensure_extension(fileName, ".leo")
            c.fileCommands.saveTo(fileName)
            c.updateRecentFiles(fileName)

    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@-node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@-node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@+node:ekr.20061024093525:Create settings menu
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3977681

How about having a menu Edit -> Settings with the submenu-items 'LeoSettings.leo',
'myLeoSettings.leo', 'this file's settings'?

The menu-items 'Open myLeoSettings.leo' and 'Open LeoSettings.leo' under the
Help-menu seem out-of-place.

#@-node:ekr.20061024093525:Create settings menu
#@+node:ekr.20061116054917.6:Remove blanks in calltips
#@-node:ekr.20061116054917.6:Remove blanks in calltips
#@+node:ekr.20061108100143:Create '*open-&test.leo' command that t.bat or test.leo
# This doesn't seem to work well on XP.
#@nonl
#@+node:ekr.20061209131102.1:openTest
def openTest (self, event=None):

    if 1: # Open in a new process.
        cmd = 'c:\Windows\System32\cmd.exe' # Hangs if used.
        python = sys.executable
        leo = g.os_path_abspath(g.os_path_join(g.app.loadDir,'leo.py'))
        test = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test'))

        os.system('%s %s %s %s' % (cmd, python,leo,test))
        # args = [python, leo, test]

        # if 1: # Use present environment.
            # os.spawnv(os.P_NOWAIT, sys.executable, args)
        # else: # Use a pristine environment.
            # os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
    else:
        c = self
        fileName = g.os_path_join(g.app.loadDir,'..','test','test.leo')

        ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es('not found: %s' % fileName)
#@-node:ekr.20061209131102.1:openTest
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):

    self.helpMenuTable = [
        # &: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&About Leo...',           'about-leo'),
        ('Online &Home Page',       'open-online-home'),
        '*open-online-&tutorial',
        '*open-&users-guide',
        '-',
        ('Open Leo&Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&Settings.leo',   'open-leoSettings-leo'),
        ('Open &myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&ipts.leo',       'open-scripts-leo'),
        # ('Open t&est.leo',          'open-test-leo'),
        '-',
        '*he&lp-for-minibuffer',
        '*help-for-&command',
        '-',
        '*&apropos-autocompletion',
        '*apropos-&bindings',
        '*apropos-&debugging-commands',
        '*apropos-&find-commands',
        '-',
        '*pri&nt-bindings',
        '*print-c&ommands',
    ]
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20061108100143:Create '*open-&test.leo' command that t.bat or test.leo
#@-node:ekr.20061028065955.4:New features
#@-node:ekr.20070105135713:To do: 4.5 (new positions)
#@+node:ekr.20060822174843:Most important projects
# Most of these projects will take a week or more.
#@nonl
#@+node:ekr.20070220082124:Make sure Leo can generate Latex
#@-node:ekr.20070220082124:Make sure Leo can generate Latex
#@+node:ekr.20070226075816.1:Update plugin manager to handle @enabled-plugins nodes
#@-node:ekr.20070226075816.1:Update plugin manager to handle @enabled-plugins nodes
#@+node:ekr.20070307082503:Make Leo an IPython notebook
#@+node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060603085719.1:Use IPython autocompleter?
#@-node:ekr.20060603085719.1:Use IPython autocompleter?
#@+node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@-node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@+node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@-node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@+node:ekr.20060603090445.9:Script button that saves environment between runs
This would allow IPython-like operation.
#@nonl
#@-node:ekr.20060603090445.9:Script button that saves environment between runs
#@-node:ekr.20060603090445.7:Ipython stuff
#@-node:ekr.20070307082503:Make Leo an IPython notebook
#@+node:ekr.20060629154112:Merge Leo & jyLeo
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3799470
By: leouser

I guess its hard to say what pieces must merge and what can stay different.
Id like it if the blasted nodes were the same.  I guess there is progress again
on a jython 2.2 being complete and work starting on 2.3.  So there is hope that
the nodes will be the same code, at least it will be possible.

At the top of my head the big differences outside of the position changes are:
1. Some modifications to the read/write code so that Chapters can work and also
Serialized positions.
2. Commander has some things different, it looks to the Chapters instance to
determine what is the curentPosition, top Position etc... instead of keeping
track of it itself.
3. GUI layers are very different.  Interesting tidbit here: the work I did to
get the JTree to use positions to determine if a node is expanded or not looks
like it has provided the outline for enhancing the JTree for Java itself to
be able to do this.  We will have to see, but maybe in Java 7 you can say: "Positions
lead to user controled tree expansion models".

There is a tremendous amount that is the same. Im sure you could make an interesting
evening out of comparing the codebases to see where things change.


#@+node:ekr.20070307082814:Create g.startupController class
#@-node:ekr.20070307082814:Create g.startupController class
#@-node:ekr.20060629154112:Merge Leo & jyLeo
#@+node:ekr.20060202231708.1:@menu nodes in leoSettings.leo
@nocolor

We could allow users to define Leo menus.
To do this, we must use minibuffer names for all menu entries

@color
#@nonl
#@-node:ekr.20060202231708.1:@menu nodes in leoSettings.leo
#@+node:ekr.20061207073104:Convert bottlenecks to pyrex code
# To do:  actually generate Leo's bottlenecks.
#@nonl
#@+node:ekr.20061207073104.1:gcc build docs
@nocolor

To build your module using GCC is a three step process on Unix. (I have know
idea how many steps it is on Windows™.)

Start by running the Pyrex compiler over your code as follows, where
mymodule.pyx is the name of the Pyrex module you are writing. python2.2 pyrexc
mymodule.pyx Next, compile the resulting C file into a .o file. The call to gcc
looks like this:

gcc -c -fPIC -I/usr/include/python2.2/ mymodule.c
The arguments to gcc are explained below.

-c 
Produces a .o file instead of an executable. 
-fPIC 
Produces position independent code, so we can dynamically link against it later. 
-I/usr/include/python2.2/ 
is the location of the Python 2.2 include file. The location of your Python include file may differ from /usr/include/python2.2/. 
mymodule.c 
is the name of the C file produced by Pyrex. 
Finally, link the .o into a .so: gcc -shared mymodule.o -lxosd -o mymodule.so
-shared 
produces a shared-object file, instead of an executable. 
mymodule.o 
is the name of the module you wish to compile. 
-lxosd 
links against a C-library, with the name of the library given as the argument. 
-o mymodule.so 
causes gcc to put the output into a file called mymodule.so 
The C library that you are wrapping will probably differ from mymodule. 
#@-node:ekr.20061207073104.1:gcc build docs
#@+node:ekr.20061207073104.2:pyrexc command-line options
@nocolor

The pyrexc command supports the following options:

  Short Long              Argument    Description
  -----------------------------------------------------------------------------
  -v    --version                     Display version number of pyrex compiler
  -l    --create-listing              Write error messages to a .lis file
  -I    --include-dir     <directory> Search for include files in named 
                                       directory (may be repeated)
  -o    --output-file     <filename>  Specify name of generated C file (only
                                       one source file allowed if this is used)

Anything else is taken as the name of a Pyrex source file and compiled
to a C source file. Multiple Pyrex source files can be specified
(unless -o is used), in which case each source file is treated as the
source of a distinct extension module and compiled separately to
produce its own C file.
#@-node:ekr.20061207073104.2:pyrexc command-line options
#@+node:ekr.20061207073104.3:@file myModule.pyx
def spam(int i, char *s):
    if 1:
        print i,s
#@nonl
#@-node:ekr.20061207073104.3:@file myModule.pyx
#@+node:ekr.20061207073104.4:Make myModule.c
# Use pyrexc to create myModule.c from myModule.pyx.
import os,sys
python = sys.executable
theFile = r'C:\prog\tigris-cvs\leo\test\myModule.pyx'
pyrexc = r'c:\prog\Pyrex-0.9.4.1\pyrexc.py'
os.system(r'%s %s %s' % (python,pyrexc,theFile))

if 0: # Build myModule library using distutils.
    from distutils.core import setup, Extension

    # Make the extension module ("mymodule") link against xosd
    xosdExtn = Extension("mymodule", ["mymodule.c"], libraries=["xosd"])

    # Compile the extension module
    setup(name="mymodule", ext_modules=[xosdExtn])

@ Save the above code in a file called setup.py and run the following code
to build and install your module.

    python setup.py build
    python setup.py install
#@nonl
#@-node:ekr.20061207073104.4:Make myModule.c
#@+node:ekr.20061207073104.5:Code to be optimized w/ pyrex
#@+node:ekr.20061207073104.6:Nodes...
#@-node:ekr.20061207073104.6:Nodes...
#@+node:ekr.20061207073104.216:Colorizer
#@-node:ekr.20061207073104.216:Colorizer
#@+node:ekr.20061207073104.268:File code
#@-node:ekr.20061207073104.268:File code
#@-node:ekr.20061207073104.5:Code to be optimized w/ pyrex
#@-node:ekr.20061207073104:Convert bottlenecks to pyrex code
#@+node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
@nocolor

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off.

@color
#@nonl
#@-node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
#@-node:ekr.20060530085844:Improve autocompletion
#@-node:ekr.20060822174843:Most important projects
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
