<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="376" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="115" left="279" height="657" width="846"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20060904140404"><vh>Not used</vh>
<v t="ekr.20060904134958.118" a="E"><vh>class modeClass</vh>
<v t="ekr.20060904134958.119"><vh> mode.__init__</vh></v>
<v t="ekr.20060904134958.120"><vh> mode.__str__ &amp; __repr__</vh></v>
<v t="ekr.20060904134958.121"><vh> Output...</vh>
<v t="ekr.20060904134958.122"><vh>fullDelegate</vh></v>
<v t="ekr.20060904134958.123"><vh>escapeString &amp; quoteString</vh></v>
<v t="ekr.20060904134958.124"><vh>put, putTripleString</vh></v>
<v t="ekr.20060904134958.125"><vh>putAttributes</vh></v>
<v t="ekr.20060904134958.126"><vh>putDict &amp; putDictOfLists</vh></v>
<v t="ekr.20060904134958.127"><vh>putImportDict</vh></v>
<v t="ekr.20060904134958.128"><vh>putKeywordsData</vh></v>
<v t="ekr.20060904134958.129"><vh>putList</vh></v>
<v t="ekr.20060904134958.130"><vh>putModeProperties</vh></v>
<v t="ekr.20060904134958.131" a="E"><vh>putRule &amp; rule creators</vh>
<v t="ekr.20060904134958.132"><vh>putBadRule</vh></v>
<v t="ekr.20060904134958.133"><vh>putEolSpan</vh></v>
<v t="ekr.20060904134958.134" a="M"><vh>putEolSpanRegexp</vh></v>
<v t="ekr.20060904134958.135"><vh>putImport</vh></v>
<v t="ekr.20060904134958.136"><vh>putKeywords</vh></v>
<v t="ekr.20060904134958.137"><vh>putMarkFollowing</vh></v>
<v t="ekr.20060904134958.138"><vh>putMarkPrevious</vh></v>
<v t="ekr.20060904134958.139"><vh>putSeq</vh></v>
<v t="ekr.20060904134958.140" a="M"><vh>putSeqRegexp</vh></v>
<v t="ekr.20060904134958.141"><vh>putSpan</vh></v>
<v t="ekr.20060904134958.142" a="M"><vh>putSpanRegexp</vh></v>
<v t="ekr.20060904134958.143"><vh>putTerminate</vh></v>
</v>
<v t="ekr.20060904134958.144"><vh>putRules</vh></v>
<v t="ekr.20060904134958.145"><vh>write</vh></v>
</v>
<v t="ekr.20060904134958.146"><vh> Printing...</vh>
<v t="ekr.20060904134958.147"><vh>printModeAttributes, printRulesetAttributes &amp; printAttributesHelper</vh></v>
<v t="ekr.20060904134958.148"><vh>printProperty</vh></v>
<v t="ekr.20060904134958.149"><vh>printRule</vh></v>
<v t="ekr.20060904134958.150"><vh>printRuleset</vh></v>
<v t="ekr.20060904134958.151"><vh>printSummary</vh></v>
</v>
<v t="ekr.20060904134958.152"><vh>doAttribute</vh></v>
<v t="ekr.20060904134958.153"><vh>doContent</vh></v>
<v t="ekr.20060904134958.154"><vh>endElement</vh></v>
<v t="ekr.20060904134958.155"><vh>error</vh></v>
<v t="ekr.20060904134958.156"><vh>getters</vh></v>
<v t="ekr.20060904134958.157"><vh>inRule</vh></v>
<v t="ekr.20060904134958.158"><vh>startElement</vh></v>
</v>
<v t="ekr.20060904134958.159"><vh>class rulesetClass</vh>
<v t="ekr.20060904134958.160"><vh>ctor &amp; __str__</vh></v>
</v>
<v t="ekr.20060904134958.161"><vh>class ruleClass</vh>
<v t="ekr.20060904134958.162"><vh>ctor &amp; __str__</vh></v>
<v t="ekr.20060904134958.163"><vh>rule.getters</vh></v>
</v>
<v t="ekr.20060904134958.117"><vh>munge</vh></v>
<v t="ekr.20060904134958.115"><vh>convert</vh></v>
<v t="ekr.20060904144645"><vh>from modeClass</vh>
<v t="ekr.20060904141220.3"><vh> Output...</vh>
<v t="ekr.20060904141220.4"><vh>fullDelegate</vh></v>
<v t="ekr.20060904141220.5"><vh>escapeString &amp; quoteString</vh></v>
<v t="ekr.20060904141220.6"><vh>put, putTripleString</vh></v>
<v t="ekr.20060904141220.7"><vh>putAttributes</vh></v>
<v t="ekr.20060904141220.8"><vh>putDict &amp; putDictOfLists</vh></v>
<v t="ekr.20060904141220.9"><vh>putImportDict</vh></v>
<v t="ekr.20060904141220.10"><vh>putKeywordsData</vh></v>
<v t="ekr.20060904141220.11"><vh>putList</vh></v>
<v t="ekr.20060904141220.12"><vh>putModeProperties</vh></v>
<v t="ekr.20060904141220.13" a="E"><vh>putRule &amp; rule creators</vh>
<v t="ekr.20060904141220.14"><vh>putBadRule</vh></v>
<v t="ekr.20060904141220.15"><vh>putEolSpan</vh></v>
<v t="ekr.20060904141220.16" a="M"><vh>putEolSpanRegexp</vh></v>
<v t="ekr.20060904141220.17"><vh>putImport</vh></v>
<v t="ekr.20060904141220.18"><vh>putKeywords</vh></v>
<v t="ekr.20060904141220.19"><vh>putMarkFollowing</vh></v>
<v t="ekr.20060904141220.20"><vh>putMarkPrevious</vh></v>
<v t="ekr.20060904141220.21"><vh>putSeq</vh></v>
<v t="ekr.20060904141220.22" a="M"><vh>putSeqRegexp</vh></v>
<v t="ekr.20060904141220.23"><vh>putSpan</vh></v>
<v t="ekr.20060904141220.24" a="M"><vh>putSpanRegexp</vh></v>
<v t="ekr.20060904141220.25"><vh>putTerminate</vh></v>
</v>
<v t="ekr.20060904141220.26"><vh>putRules</vh></v>
<v t="ekr.20060904141220.27"><vh>write</vh></v>
</v>
<v t="ekr.20060904141220.28" a="E"><vh> Printing...</vh>
<v t="ekr.20060904141220.29"><vh>printModeAttributes, printRulesetAttributes &amp; printAttributesHelper</vh></v>
<v t="ekr.20060904141220.30"><vh>printProperty</vh></v>
<v t="ekr.20060904141220.31"><vh>printRule</vh></v>
<v t="ekr.20060904141220.32"><vh>printRuleset</vh></v>
<v t="ekr.20060904141220.33"><vh>printSummary</vh></v>
</v>
<v t="ekr.20060904141220.39"><vh>inRule</vh></v>
</v>
</v>
<v t="ekr.20060904103412" a="ETV"
expanded="ekr.20060904132527.11,ekr.20060904134958.164,ekr.20060904141220,"><vh>@thin leoOPML.py</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20060904134958.115">def convert (c,inputFileName,outputFileName):
    
    junk, fn = g.os_path_split(inputFileName)
    language, junk = g.os_path_splitext(fn)
    g.trace(language)

    node = parse_opml_file(inputFileName,language)

    if node:
        try:
            f = file(outputFileName,'w')
        except IOError:
            g.trace('can not create %s' % outputFileName)
            return

        try:
            node.write(f,language)
        finally:
            f.close()</t>
<t tx="ekr.20060904134958.117">def munge(s):
    
    '''Munge a mode name so that it is a valid python id.'''
    
    valid = string.ascii_letters + string.digits + '_'
    
    return ''.join([g.choose(ch in valid,ch.lower(),'_') for ch in s])</t>
<t tx="ekr.20060904134958.118">class modeClass:
    
    '''A class representing one jEdit language-description mode.
    
    Use getters to access the attributes, properties and rules of this mode.'''
    
    @others</t>
<t tx="ekr.20060904134958.119">def __init__ (self,contentHandler,fileName):
    
    # g.trace('mode',fileName)

    self.contentHandler = contentHandler
    self.c = contentHandler.c
    self.fileName = g.shortFileName(fileName) # The file from which the mode was imported.
    modeName, junk = g.os_path_splitext(self.fileName)
    self.fileModeName = modeName
    self.modeName = munge(modeName).lower()
    self.outputFile = None # The open output file to which Python statements get written.
    self.tab_width = g.scanDirectives(c).get('tab_width')

    # Mode statistics...
    self.numberOfAttributes = 0
    self.numberOfElements = 0
    self.numberOfErrors = 0
    self.numberOfPropertyAttributes = 0
    self.numberOfRuleAttributes = 0
    
    # List of boolean attributes.
    self.boolAttrs = [
        'at_line_start','at_whitespace_end','at_word_start',
        'exclude_match','highlight_digits','ignore_case',
        'no_escape','no_line_break','no_word_break',]

    # List of elements that start a rule.
    self.ruleElements = [
        'eol_span','eol_span_regexp','import','keywords',
        'mark_following','mark_previous','seq','seq_regexp',
        'span','span_regexp','terminate',]

    if 0: # Not used at present.
        self.seqSpanElements = [
            'eol_span','eol_span_regexp','seq','seq_regexp',
            'span','span_regexp',]

    # Mode semantics.
    self.attributes = {}
    self.handlerCount = 0
    self.importedRules = [] # A bunch describing the imported ruleset.
    self.inProps = False
    self.inRules = False
    self.keywords = None
    self.modeProperties = []
    self.presentProperty = None # A bunch to be assigned to modeProperties or rulesetProperties.
    self.rule = None
    self.rulesets = []
    self.rules = [] # The rules of the present rules element.
    self.rulesetProperties = []
    self.rulesetAttributes = {} # The attributes of the present rules element.</t>
<t tx="ekr.20060904134958.120">def __str__ (self):
    
    return '&lt;modeClass for %s&gt;' % self.fileName
    
__repr__ = __str__</t>
<t tx="ekr.20060904134958.121"># Similar to printing, but generates the output file.</t>
<t tx="ekr.20060904134958.122">def fullDelegate (self,delegate):
    
    if delegate:
        delegate = delegate.lower()
        i = delegate.find('::')
        if i == -1:
            return '%s::%s' % (self.fileModeName.lower(),delegate)
        else:
            return delegate
    else:
        return ''</t>
<t tx="ekr.20060904134958.123">def escapeString (self,s):
    
    '''Return string s enclosed in double quotes.'''
    
    if type(s) == type([]): s = ''.join(s)
    
    # Order is important: escape backspaces first.
    return '"%s"' % s.replace('\\','\\\\').replace('"','\\"').replace('\t','\\t')
    
quoteString = escapeString</t>
<t tx="ekr.20060904134958.124">def put (self,s):
    
    self.outputFile.write(s)
    
def putTripleString(self,s):

    self.put(g.adjustTripleString(s,self.tab_width))</t>
<t tx="ekr.20060904134958.125">def putAttributes (self):
    
    dd = {}
    data = (
        ('default','null'),
        ('digit_re',''),
        ('escape',''),
        ('highlight_digits',True),
        ('ignore_case',True),
        ('no_word_sep',None), # could be false or ''.
    )

    for ruleset in self.rulesets:
        d = {}
        prefix = '%s_%s' % (self.modeName,ruleset.name)
        self.put('# Attributes dict for %s ruleset.\n' % (prefix))
        for key,default in data:
            val = ruleset.attributes.get(key,default)
            if default == True: val = g.choose(val,'true','false')
            elif default == None:
                if val and val.lower() == 'false': val = ''
                else: val = g.choose(val,val,'')
            # if val: g.trace(key,repr(val))
            d [key] = val
            

        self.putDict('%s_attributes_dict' % (prefix),d)
        dd [ prefix ] = '%s_attributes_dict' % (prefix)
        
    self.put('# Dictionary of attributes dictionaries for %s mode.\n' % (self.modeName))
    self.putDict('attributesDictDict',dd,escape=False)</t>
<t tx="ekr.20060904134958.126">def putDict (self,name,theDict,escape=True):

    esc = self.escapeString
    esc2 = g.choose(escape,self.escapeString,lambda a: a)
    keys = theDict.keys() ; keys.sort()
    s = ''.join(['\t%s: %s,\n' % (esc(key),esc2(theDict.get(key))) for key in keys])
    if s: s = '\n' + s
    self.put('%s = {%s}\n\n' % (name,s))
    
def putDictOfLists (self,name,theDict,strings=False):

    esc = self.escapeString
    keys = theDict.keys() ; keys.sort()
    theList = []
    for key in keys:
        if strings:
            # Not completely general, but it works for the import dict, and that's good enough.
            s = ''.join(['"%s",' % (item) for item in theDict.get(key)])
        else:
             s = ''.join(['%s,' % (item) for item in theDict.get(key)])
        theList.append('\t%s: [%s],\n' % (esc(key),s))
    s = ''.join(theList)
    if s: s = '\n' + s
    self.put('%s = {%s}\n\n' % (name,s))</t>
<t tx="ekr.20060904134958.127">def putImportDict (self):

    d = {}
    for ruleset in self.rulesets:
        prefix = '%s_%s' % (self.modeName,ruleset.name)
        for rule in ruleset.rules:
            if rule.name == 'import':
                delegate = rule.getStrAttrib('delegate').lower()
                if delegate:
                    i = delegate.find('::')
                    delegate_name = g.choose(i==-1,
                        '%s::%s' % (prefix,delegate), # Can indeed happen.
                        '%s' % (delegate))
                    theList = d.get(prefix,[])
                    if delegate_name not in theList:
                        theList.append(delegate_name)
                        d [prefix] = theList

    self.put('# Import dict for %s mode.\n' % (self.modeName))
    self.putDictOfLists('importDict',d,strings=True)</t>
<t tx="ekr.20060904134958.128">def putKeywordsData (self):
    
    dd = {}

    for ruleset in self.rulesets:
       
        prefix = '%s_%s' % (self.modeName,ruleset.name)
        
        ignore_case = ruleset.attributes.get('ignore_case',False)
        # g.trace(ignore_case)
    
        self.put('# Keywords dict for %s ruleset.\n' % (prefix))

        for rule in ruleset.rules:
            if rule.name == 'keywords':
                d = rule.keywordsDict
                for key in d.keys():
                    if not key.strip():
                        del d [key]
                    elif key.find(' ') != -1 or key.find('\t') != -1:
                        del d [key]
                        g.es_print('Warning: ignoring keyword containing whitespace: %s' % (
                            repr(key)))
                    elif ignore_case: # New in 4.4.1 final.
                        # Downcase all keys.
                        val = d.get(key)
                        key2 = key.lower()
                        if key2 != key:
                            del d[key]
                        d[key2] = val
                break
        else: d = {}

        self.putDict('%s_keywords_dict' % (prefix),d)
        dd [ prefix ] = '%s_keywords_dict' % (prefix)
        
    self.put('# Dictionary of keywords dictionaries for %s mode.\n' % (self.modeName))
    self.putDict('keywordsDictDict',dd,escape=False)</t>
<t tx="ekr.20060904134958.129">def putList (self,name,theList,escape=True,lineCount=0):
    
    def comma(i):
        return ',' # return g.choose(i==len(theList)-1,'',',')
    def nl(i):
        return g.choose(lineCount == 0 or ((i%lineCount)==lineCount-1),'\n',' ')
    def tab(i,n):
        # return g.choose(i == 0 or nl(i-1) != ' ','\t','')
        return g.choose(i &gt; 0 and nl(i-1) != ' ','\t','')
    esc = g.choose(escape,self.escapeString,lambda a:a)

    result = []
    n = len(theList)
    for i in xrange(n):
        result.append('%s%s%s%s' % (tab(i,n),esc(theList[i]),comma(i),nl(i)))

    vals = ''.join(result)
    # if n &gt; 1: vals = '\n' + vals
    self.put('%s = [%s]\n\n' % (name,vals))
</t>
<t tx="ekr.20060904134958.130">def putModeProperties (self,language):
    
    d = {}
    
    self.put('# Properties for %s mode.\n' % (language))

    for prop in self.modeProperties:
        d2 = prop.attributes
        name = d2.get('name')
        d [name] = d2.get('value')

    self.putDict('properties', d)</t>
<t tx="ekr.20060904134958.131">def putRule (self, rule):
    
    '''Call the rule creator for the given rule.'''

    d = {
        'eol_span':         self.putEolSpan,
        'eol_span_regexp':  self.putEolSpanRegexp,
        'import':           self.putImport,
        'keywords':         self.putKeywords,
        'mark_following':   self.putMarkFollowing,
        'mark_previous':    self.putMarkPrevious,
        'seq':              self.putSeq,
        'seq_regexp':       self.putSeqRegexp,
        'span':             self.putSpan,
        'span_regexp':      self.putSpanRegexp,
        'terminate':        self.putTerminate,
    }
    
    # Call the rule creator.
    f = d.get(rule.name,self.putBadRule)
    val = f (rule)
    self.handlerCount += 1
        
    return val</t>
<t tx="ekr.20060904134958.132">def putBadRule (self,rule):
    
    self.put('\n\n# *****no output creator for %s*****' % rule.name)</t>
<t tx="ekr.20060904134958.133">def putEolSpan (self,rule):

    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_eol_span(s, i, kind=%s, seq=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s,
        delegate=%s, exclude_match=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
        rule.getBoolAttrib('exclude_match'),
    )

    self.putTripleString(s)
    return seq[0]</t>
<t tx="ekr.20060904134958.134">def putEolSpanRegexp (self,rule):
    
    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_eol_span_regexp(s, i, kind=%s, regexp=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s,
        delegate=%s, exclude_match=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        # quote(rule.getStrAttrib('hash_char')),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
        rule.getBoolAttrib('exclude_match'),
    )

    self.putTripleString(s)
    return seq[0]</t>
<t tx="ekr.20060904134958.135"># Do nothing here: putImportDict creates x.importDict.

def putImport (self,rule):
    
    # Decrement the count to indicate that this method did not generate a rule.
    self.handlerCount -= 1
    return ''</t>
<t tx="ekr.20060904134958.136">def putKeywords (self,rule):

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_keywords(s, i)''' % (
    self.fileModeName,
    self.handlerCount)

    self.putTripleString(s)
    return 'keywords'</t>
<t tx="ekr.20060904134958.137">def putMarkFollowing (self,rule):
    
    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_mark_following(s, i, kind=%s, pattern=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s, exclude_match=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        rule.getBoolAttrib('exclude_match'),
    )

    self.putTripleString(s)
    return seq[0]</t>
<t tx="ekr.20060904134958.138">def putMarkPrevious (self,rule):
    
    quote = self.quoteString
    seq = rule.getSeq(rule.name)
    
    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_mark_previous(s, i, kind=%s, pattern=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s, exclude_match=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        rule.getBoolAttrib('exclude_match'),
    )

    self.putTripleString(s)
    return seq[0]</t>
<t tx="ekr.20060904134958.139">def putSeq (self,rule):

    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_seq(s, i, kind=%s, seq=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s, delegate=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
    )

    self.putTripleString(s)
    return seq[0]</t>
<t tx="ekr.20060904134958.140">def putSeqRegexp (self,rule):
    
    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_seq_regexp(s, i, kind=%s, regexp=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s, delegate=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        # quote(rule.getStrAttrib('hash_char')),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
    )

    self.putTripleString(s)
    return seq[0]</t>
<t tx="ekr.20060904134958.141">def putSpan (self,rule):
    
    quote = self.quoteString
    begin,end = rule.getSpan()

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_span(s, i, kind=%s, begin=%s, end=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s,
        delegate=%s,exclude_match=%s,
        no_escape=%s, no_line_break=%s, no_word_break=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(begin),quote(end),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
        rule.getBoolAttrib('exclude_match'),
        rule.getBoolAttrib('no_escape'),
        rule.getBoolAttrib('no_line_break'),
        rule.getBoolAttrib('no_word_break'),
    )
    
    self.putTripleString(s)
    return begin[0]</t>
<t tx="ekr.20060904134958.142">def putSpanRegexp (self,rule):
    
    quote = self.quoteString
    begin,end = rule.getSpan()

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind=%s, begin=%s, end=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s,
        delegate=%s,exclude_match=%s,
        no_escape=%s, no_line_break=%s, no_word_break=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(begin),quote(end),
        # quote(rule.getStrAttrib('hash_char')),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
        rule.getBoolAttrib('exclude_match'),
        rule.getBoolAttrib('no_escape'),
        rule.getBoolAttrib('no_line_break'),
        rule.getBoolAttrib('no_word_break'),
    )
    
    self.putTripleString(s)
    return begin[0]</t>
<t tx="ekr.20060904134958.143">def putTerminate (self,rule):
    
    quote = self.quoteString
    
    n = rule.getIntAttrib('at_char')
    if n == None: return

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_terminate(s, i, kind=%s, at_char=%d)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        n)

    self.putTripleString(s)</t>
<t tx="ekr.20060904134958.144">def putRules (self):
    
    '''Create all rule matchers, a rules dict for each ruleset and x.rulesDictDict.'''

    d = {} ; d2Count = 0
    for ruleset in self.rulesets:
        d2 = {}
        start_count = self.handlerCount
        # prefix = '%s::%s' % (self.modeName,ruleset.name)
        prefix2 = '%s_%s_rules' % (self.modeName,ruleset.name)
        prefix3 = '%s_%s'% (self.modeName,ruleset.name)
        self.put('# Rules for %s ruleset.\n' % (prefix3))
        for rule in ruleset.rules:
            ch = self.putRule(rule)
            self.put('\n')
            if ch == 'keywords':
                for ch in self.keywordChars:
                    theList = d2.get(ch,[])
                    theList.append('%s_rule%d' % (self.fileModeName,self.handlerCount-1))
                    d2 [ch] = theList
            elif ch:
                theList = d2.get(ch,[])
                theList.append('%s_rule%d' % (self.fileModeName,self.handlerCount-1))
                d2 [ch] = theList
        # Create the rules dict for the ruleset.
        self.put('\n# Rules dict for %s ruleset.\n' % (prefix3))
        d2Count += 1 ; name = 'rulesDict%d' % d2Count
        self.putDictOfLists(name,d2)
        d [prefix3] = name
    # Create rulesDictDict.
    self.put('# x.rulesDictDict for %s mode.\n' % (self.modeName))
    self.putDict('rulesDictDict',d,escape=False)</t>
<t tx="ekr.20060904134958.145">def write (self,theFile,language):
    
    # Compute all the letters that can occur in a keyword.
    self.keywordChars = [ch for ch in string.letters + string.digits + '@']
    for ruleset in self.rulesets:
        for rule in ruleset.rules:
            d = rule.keywordsDict
            for key in d.keys():
                for ch in key:
                    if ch not in self.keywordChars and ch not in (' ','\t','\n'):
                        self.keywordChars.append(ch)
    self.keywordChars = ''.join(self.keywordChars)
    # g.trace('keywordChars',repr(self.keywordChars))
    
    self.outputFile = theFile
    self.put('# Leo colorizer control file for %s mode.\n' % language)
    self.put('# This file is in the public domain.\n\n')
    self.putModeProperties(language)
    self.putAttributes()
    self.putKeywordsData()
    self.putRules()
    self.putImportDict()</t>
<t tx="ekr.20060904134958.146"></t>
<t tx="ekr.20060904134958.147">def printModeAttributes (self):
    
    self.printAttributesHelper('mode attributes',self.attributes)
    
def printRulesetAttributes (self,ruleset,tag=None):

    if not tag: tag = 'main ruleset'
    
    self.printAttributesHelper(tag,ruleset.attributes)
    
def printAttributesHelper (self,kind,attrs):
    
    print '%-15s' % (kind),'attrs:',attrs</t>
<t tx="ekr.20060904134958.148">def printProperty (self,theProperty):
    
    # A property is a bunch.
    d = theProperty.attributes
    if d:
        self.printAttributesHelper('property',d)</t>
<t tx="ekr.20060904134958.149">def printRule (self,rule):
    
    # A rule is a g.Bunch.
    if rule.name == 'keywords':
        print '%-15s' % ('rule:keywords'),
        d = rule.keywordsDict
        d2 = {}
        for key in d:
            val = d.get(key)
            d2 [val] = d2.get(val,0) + 1
        keys = d2.keys() ; keys.sort()
        for key in keys:
            print '%s: %d' % (key,d2.get(key)),
        print
    else:
        d = rule.attributes
        d2 = rule.contents
        if d or d2:
            print '%-15s' % ('rule:'+rule.name),
            if d:  print 'attrs:',d,
            if d2: print 'contents:',d2,
            print
           </t>
<t tx="ekr.20060904134958.150">def printRuleset (self,ruleset,tag):
    
    self.printRulesetAttributes(ruleset,tag)

    for rule in self.rulesets[0].rules:
        self.printRule(rule)</t>
<t tx="ekr.20060904134958.151">def printSummary (self,printStats=True):

    if printStats:
        print '-' * 10, 'mode statistics'
        print 'elements',self.numberOfElements
        print 'errors',self.numberOfErrors
        print 'mode attributes',self.numberOfAttributes
        print 'property attributes',self.numberOfPropertyAttributes
        print 'rule attributes',self.numberOfRuleAttributes

    self.printModeAttributes()
    
    for bunch in self.modeProperties:
        self.printProperty(bunch)

    self.printRuleset(self.rulesets[0],tag='main ruleset')</t>
<t tx="ekr.20060904134958.152">def doAttribute (self,name,val):
    
    name = str(name.lower())
    
    if name in self.boolAttrs:
        val = g.choose(val.lower()=='true',True,False)
    else:
        val = str(val) # Do NOT lower this value!

    if self.rule:
        d = self.rule.attributes
        d [name] = val
        self.numberOfRuleAttributes += 1
    elif self.presentProperty:
        d = self.presentProperty.get('attributes')
        d [name] = val
        self.numberOfPropertyAttributes += 1
    elif self.inRules:
        self.rulesetAttributes[name] = val
        self.numberOfAttributes += 1
    else:
        self.attributes[name] = val
        self.numberOfAttributes += 1</t>
<t tx="ekr.20060904134958.153">def doContent (self,elementName,content):
    
    if not content:
        return
    
    name = str(elementName.lower())
    
    if self.inRule('keywords'):
        # g.trace('in keywords',name,content)
        d = self.rule.keywordsDict
        d [ content ] = name

    elif self.rule:
        d = self.rule.contents
        s = d.get(name,'')
        d [name] = s + content
        self.contents = d</t>
<t tx="ekr.20060904134958.154">def endElement (self,elementName):

    name = elementName.lower()
    
    if name == 'props':
        self.inProps = True
    if name == 'rules':
        self.inRules = False
        ruleset = rulesetClass(self.rulesetAttributes,self.keywords,self.rulesetProperties,self.rules)
        self.rulesets.append(ruleset)
        #g.trace('rules...\n',g.listToString(self.rules))
        #g.trace('ruleset attributes...\n',g.dictToString(self.rulesetAttributes))
    if name == 'property':
        bunch = self.presentProperty
        if bunch:
            if self.inRules:
                self.rulesetProperties.append(bunch)
            else:
                self.modeProperties.append(bunch)
        else:
            self.error('end %s not matched by start %s' % (name,name))
        self.presentProperty = None
    if name in self.ruleElements:
        if self.inRule(name):
            self.rules.append(self.rule)
            self.rule = None
        else:
            self.error('end %s not matched by start %s' % (name,name))</t>
<t tx="ekr.20060904134958.155">def error (self,message):
    
    self.numberOfErrors += 1

    self.contentHandler.error(message)</t>
<t tx="ekr.20060904134958.156">def getAttributes (self):
    return self.attributes
    
def getAttributesForRuleset (self,ruleset):
    bunch = ruleset
    return bunch.attributes
    
def getFileName (self):
    return self.fileName
    
def getKeywords (self,n,ruleset):
    bunch = ruleset
    keywords = bunch.keywords
    if keywords:
        return keywords.get('keyword%d'%(n),[])
    return []

def getLanguage (self):
    path,name = g.os_path_split(self.fileName)
    language,ext = g.os_path_splitext(name)
    return language

def getPropertiesForMode (self):
    return self.props
    
def getPropertiesForRuleset (self,name=''):
    bunch = self.getRuleset(name)
    if bunch:
        return bunch.properties
    else:
        return []
    
def getRuleset(self,name=''):
    if not name:
        return self.rulesets[0] # Return the main ruleset.
    for ruleset in self.rulesets:
        if ruleset.name.lower()==name.lower():
            return ruleset
    else: return None

def getRulesets(self):
    return self.rulesets
    
def getRulesForRuleset (self,name=''):
    bunch = self.getRuleset(name)
    if bunch:
        return bunch.rules
    else:
        return []</t>
<t tx="ekr.20060904134958.157">def inRule (self,elementName):

    return self.rule and self.rule.name == elementName</t>
<t tx="ekr.20060904134958.158">def startElement (self,elementName):

    name = elementName.lower()
    
    if name == 'props':
        self.inProps = True
    if name == 'rules':
        self.inRules = True
        self.attributes=[]
        self.keywords=[]
        self.rulesetProperties=[]
        self.rules=[]
    if name == 'property':
        if self.inProps:
            self.presentProperty = g.bunch(name=name,attributes={})
        else:
            self.error('property not in props element')
    if name in self.ruleElements:
        if self.inRules:
            self.rule = ruleClass(name=name)
            if name == 'keywords':
                self.keywords = self.rule
        else:
            self.error('%s not in rules element' % name)</t>
<t tx="ekr.20060904134958.159">class rulesetClass:
    
    @others</t>
<t tx="ekr.20060904134958.160">def __init__ (self,attributes,keywords,properties,rules):
        
    self.name=munge(attributes.get('set','main'))
    self.attributes=attributes.copy() # A dict.
    self.properties=properties[:] # A list.
    self.keywords=keywords # A bunch.
    self.rules=rules[:] # A list.
    
    # g.trace('ruleset',self.name or 'main')
        
    self.defaultColor = self.attributes.get('default')
    
def __str__ (self):
    
    return '&lt;ruleset %s&gt;' % self.name

__repr__ = __str__</t>
<t tx="ekr.20060904134958.161">class ruleClass:
    
    '''A class to represent one xml rule.'''
    
    @others</t>
<t tx="ekr.20060904134958.162">def __init__ (self,name):
    
    self.attributes = {}
    self.contents = {}
    self.keywordsDict = {}
    self.name = name

def __str__ (self):
    
    return '&lt;rule %s\nattr: %s\ncontents: %s&gt;' % (
        self.name,g.dictToString(self.attributes),g.dictToString(self.contents))
    
__repr__ = __str__</t>
<t tx="ekr.20060904134958.163">def getBoolAttrib(self,name):
    d = self.attributes
    val = d.get(name)
    return g.choose(val,'True','False')
    
def getIntAttrib(self,name):
    d = self.attributes
    val = d.get(name)
    if val is not None:
        try:
            val = int(val)
        except ValueError:
            g.trace('bad int argument: %s = %s' % (name,val))
            val = None
    return val

def getSpan (self):
    d = self.contents
    begin = d.get('begin','')
    end   = d.get('end','')
    return begin,end
    
def getStrAttrib(self,name):
    d = self.attributes
    val = d.get(name,'')
    return str(val)

def getSeq(self,kind):
    # g.trace(repr(self.contents))
    d = self.contents
    return d.get(kind,'')</t>
<t tx="ekr.20060904140404"></t>
<t tx="ekr.20060904141220.3"># Similar to printing, but generates the output file.</t>
<t tx="ekr.20060904141220.4">def fullDelegate (self,delegate):
    
    if delegate:
        delegate = delegate.lower()
        i = delegate.find('::')
        if i == -1:
            return '%s::%s' % (self.fileModeName.lower(),delegate)
        else:
            return delegate
    else:
        return ''</t>
<t tx="ekr.20060904141220.5">def escapeString (self,s):
    
    '''Return string s enclosed in double quotes.'''
    
    if type(s) == type([]): s = ''.join(s)
    
    # Order is important: escape backspaces first.
    return '"%s"' % s.replace('\\','\\\\').replace('"','\\"').replace('\t','\\t')
    
quoteString = escapeString</t>
<t tx="ekr.20060904141220.6">def put (self,s):
    
    self.outputFile.write(s)
    
def putTripleString(self,s):

    self.put(g.adjustTripleString(s,self.tab_width))</t>
<t tx="ekr.20060904141220.7">def putAttributes (self):
    
    dd = {}
    data = (
        ('default','null'),
        ('digit_re',''),
        ('escape',''),
        ('highlight_digits',True),
        ('ignore_case',True),
        ('no_word_sep',None), # could be false or ''.
    )

    for ruleset in self.rulesets:
        d = {}
        prefix = '%s_%s' % (self.modeName,ruleset.name)
        self.put('# Attributes dict for %s ruleset.\n' % (prefix))
        for key,default in data:
            val = ruleset.attributes.get(key,default)
            if default == True: val = g.choose(val,'true','false')
            elif default == None:
                if val and val.lower() == 'false': val = ''
                else: val = g.choose(val,val,'')
            # if val: g.trace(key,repr(val))
            d [key] = val
            

        self.putDict('%s_attributes_dict' % (prefix),d)
        dd [ prefix ] = '%s_attributes_dict' % (prefix)
        
    self.put('# Dictionary of attributes dictionaries for %s mode.\n' % (self.modeName))
    self.putDict('attributesDictDict',dd,escape=False)</t>
<t tx="ekr.20060904141220.8">def putDict (self,name,theDict,escape=True):

    esc = self.escapeString
    esc2 = g.choose(escape,self.escapeString,lambda a: a)
    keys = theDict.keys() ; keys.sort()
    s = ''.join(['\t%s: %s,\n' % (esc(key),esc2(theDict.get(key))) for key in keys])
    if s: s = '\n' + s
    self.put('%s = {%s}\n\n' % (name,s))
    
def putDictOfLists (self,name,theDict,strings=False):

    esc = self.escapeString
    keys = theDict.keys() ; keys.sort()
    theList = []
    for key in keys:
        if strings:
            # Not completely general, but it works for the import dict, and that's good enough.
            s = ''.join(['"%s",' % (item) for item in theDict.get(key)])
        else:
             s = ''.join(['%s,' % (item) for item in theDict.get(key)])
        theList.append('\t%s: [%s],\n' % (esc(key),s))
    s = ''.join(theList)
    if s: s = '\n' + s
    self.put('%s = {%s}\n\n' % (name,s))</t>
<t tx="ekr.20060904141220.9">def putImportDict (self):

    d = {}
    for ruleset in self.rulesets:
        prefix = '%s_%s' % (self.modeName,ruleset.name)
        for rule in ruleset.rules:
            if rule.name == 'import':
                delegate = rule.getStrAttrib('delegate').lower()
                if delegate:
                    i = delegate.find('::')
                    delegate_name = g.choose(i==-1,
                        '%s::%s' % (prefix,delegate), # Can indeed happen.
                        '%s' % (delegate))
                    theList = d.get(prefix,[])
                    if delegate_name not in theList:
                        theList.append(delegate_name)
                        d [prefix] = theList

    self.put('# Import dict for %s mode.\n' % (self.modeName))
    self.putDictOfLists('importDict',d,strings=True)</t>
<t tx="ekr.20060904141220.10">def putKeywordsData (self):
    
    dd = {}

    for ruleset in self.rulesets:
       
        prefix = '%s_%s' % (self.modeName,ruleset.name)
        
        ignore_case = ruleset.attributes.get('ignore_case',False)
        # g.trace(ignore_case)
    
        self.put('# Keywords dict for %s ruleset.\n' % (prefix))

        for rule in ruleset.rules:
            if rule.name == 'keywords':
                d = rule.keywordsDict
                for key in d.keys():
                    if not key.strip():
                        del d [key]
                    elif key.find(' ') != -1 or key.find('\t') != -1:
                        del d [key]
                        g.es_print('Warning: ignoring keyword containing whitespace: %s' % (
                            repr(key)))
                    elif ignore_case: # New in 4.4.1 final.
                        # Downcase all keys.
                        val = d.get(key)
                        key2 = key.lower()
                        if key2 != key:
                            del d[key]
                        d[key2] = val
                break
        else: d = {}

        self.putDict('%s_keywords_dict' % (prefix),d)
        dd [ prefix ] = '%s_keywords_dict' % (prefix)
        
    self.put('# Dictionary of keywords dictionaries for %s mode.\n' % (self.modeName))
    self.putDict('keywordsDictDict',dd,escape=False)</t>
<t tx="ekr.20060904141220.11">def putList (self,name,theList,escape=True,lineCount=0):
    
    def comma(i):
        return ',' # return g.choose(i==len(theList)-1,'',',')
    def nl(i):
        return g.choose(lineCount == 0 or ((i%lineCount)==lineCount-1),'\n',' ')
    def tab(i,n):
        # return g.choose(i == 0 or nl(i-1) != ' ','\t','')
        return g.choose(i &gt; 0 and nl(i-1) != ' ','\t','')
    esc = g.choose(escape,self.escapeString,lambda a:a)

    result = []
    n = len(theList)
    for i in xrange(n):
        result.append('%s%s%s%s' % (tab(i,n),esc(theList[i]),comma(i),nl(i)))

    vals = ''.join(result)
    # if n &gt; 1: vals = '\n' + vals
    self.put('%s = [%s]\n\n' % (name,vals))
</t>
<t tx="ekr.20060904141220.12">def putModeProperties (self,language):
    
    d = {}
    
    self.put('# Properties for %s mode.\n' % (language))

    for prop in self.modeProperties:
        d2 = prop.attributes
        name = d2.get('name')
        d [name] = d2.get('value')

    self.putDict('properties', d)</t>
<t tx="ekr.20060904141220.13">def putRule (self, rule):
    
    '''Call the rule creator for the given rule.'''

    d = {
        'eol_span':         self.putEolSpan,
        'eol_span_regexp':  self.putEolSpanRegexp,
        'import':           self.putImport,
        'keywords':         self.putKeywords,
        'mark_following':   self.putMarkFollowing,
        'mark_previous':    self.putMarkPrevious,
        'seq':              self.putSeq,
        'seq_regexp':       self.putSeqRegexp,
        'span':             self.putSpan,
        'span_regexp':      self.putSpanRegexp,
        'terminate':        self.putTerminate,
    }
    
    # Call the rule creator.
    f = d.get(rule.name,self.putBadRule)
    val = f (rule)
    self.handlerCount += 1
        
    return val</t>
<t tx="ekr.20060904141220.14">def putBadRule (self,rule):
    
    self.put('\n\n# *****no output creator for %s*****' % rule.name)</t>
<t tx="ekr.20060904141220.15">def putEolSpan (self,rule):

    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_eol_span(s, i, kind=%s, seq=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s,
        delegate=%s, exclude_match=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
        rule.getBoolAttrib('exclude_match'),
    )

    self.putTripleString(s)
    return seq[0]</t>
<t tx="ekr.20060904141220.16">def putEolSpanRegexp (self,rule):
    
    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_eol_span_regexp(s, i, kind=%s, regexp=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s,
        delegate=%s, exclude_match=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        # quote(rule.getStrAttrib('hash_char')),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
        rule.getBoolAttrib('exclude_match'),
    )

    self.putTripleString(s)
    return seq[0]</t>
<t tx="ekr.20060904141220.17"># Do nothing here: putImportDict creates x.importDict.

def putImport (self,rule):
    
    # Decrement the count to indicate that this method did not generate a rule.
    self.handlerCount -= 1
    return ''</t>
<t tx="ekr.20060904141220.18">def putKeywords (self,rule):

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_keywords(s, i)''' % (
    self.fileModeName,
    self.handlerCount)

    self.putTripleString(s)
    return 'keywords'</t>
<t tx="ekr.20060904141220.19">def putMarkFollowing (self,rule):
    
    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_mark_following(s, i, kind=%s, pattern=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s, exclude_match=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        rule.getBoolAttrib('exclude_match'),
    )

    self.putTripleString(s)
    return seq[0]</t>
<t tx="ekr.20060904141220.20">def putMarkPrevious (self,rule):
    
    quote = self.quoteString
    seq = rule.getSeq(rule.name)
    
    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_mark_previous(s, i, kind=%s, pattern=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s, exclude_match=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        rule.getBoolAttrib('exclude_match'),
    )

    self.putTripleString(s)
    return seq[0]</t>
<t tx="ekr.20060904141220.21">def putSeq (self,rule):

    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_seq(s, i, kind=%s, seq=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s, delegate=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
    )

    self.putTripleString(s)
    return seq[0]</t>
<t tx="ekr.20060904141220.22">def putSeqRegexp (self,rule):
    
    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_seq_regexp(s, i, kind=%s, regexp=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s, delegate=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        # quote(rule.getStrAttrib('hash_char')),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
    )

    self.putTripleString(s)
    return seq[0]</t>
<t tx="ekr.20060904141220.23">def putSpan (self,rule):
    
    quote = self.quoteString
    begin,end = rule.getSpan()

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_span(s, i, kind=%s, begin=%s, end=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s,
        delegate=%s,exclude_match=%s,
        no_escape=%s, no_line_break=%s, no_word_break=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(begin),quote(end),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
        rule.getBoolAttrib('exclude_match'),
        rule.getBoolAttrib('no_escape'),
        rule.getBoolAttrib('no_line_break'),
        rule.getBoolAttrib('no_word_break'),
    )
    
    self.putTripleString(s)
    return begin[0]</t>
<t tx="ekr.20060904141220.24">def putSpanRegexp (self,rule):
    
    quote = self.quoteString
    begin,end = rule.getSpan()

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind=%s, begin=%s, end=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s,
        delegate=%s,exclude_match=%s,
        no_escape=%s, no_line_break=%s, no_word_break=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(begin),quote(end),
        # quote(rule.getStrAttrib('hash_char')),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
        rule.getBoolAttrib('exclude_match'),
        rule.getBoolAttrib('no_escape'),
        rule.getBoolAttrib('no_line_break'),
        rule.getBoolAttrib('no_word_break'),
    )
    
    self.putTripleString(s)
    return begin[0]</t>
<t tx="ekr.20060904141220.25">def putTerminate (self,rule):
    
    quote = self.quoteString
    
    n = rule.getIntAttrib('at_char')
    if n == None: return

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_terminate(s, i, kind=%s, at_char=%d)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        n)

    self.putTripleString(s)</t>
<t tx="ekr.20060904141220.26">def putRules (self):
    
    '''Create all rule matchers, a rules dict for each ruleset and x.rulesDictDict.'''

    d = {} ; d2Count = 0
    for ruleset in self.rulesets:
        d2 = {}
        start_count = self.handlerCount
        # prefix = '%s::%s' % (self.modeName,ruleset.name)
        prefix2 = '%s_%s_rules' % (self.modeName,ruleset.name)
        prefix3 = '%s_%s'% (self.modeName,ruleset.name)
        self.put('# Rules for %s ruleset.\n' % (prefix3))
        for rule in ruleset.rules:
            ch = self.putRule(rule)
            self.put('\n')
            if ch == 'keywords':
                for ch in self.keywordChars:
                    theList = d2.get(ch,[])
                    theList.append('%s_rule%d' % (self.fileModeName,self.handlerCount-1))
                    d2 [ch] = theList
            elif ch:
                theList = d2.get(ch,[])
                theList.append('%s_rule%d' % (self.fileModeName,self.handlerCount-1))
                d2 [ch] = theList
        # Create the rules dict for the ruleset.
        self.put('\n# Rules dict for %s ruleset.\n' % (prefix3))
        d2Count += 1 ; name = 'rulesDict%d' % d2Count
        self.putDictOfLists(name,d2)
        d [prefix3] = name
    # Create rulesDictDict.
    self.put('# x.rulesDictDict for %s mode.\n' % (self.modeName))
    self.putDict('rulesDictDict',d,escape=False)</t>
<t tx="ekr.20060904141220.27">def write (self,theFile,language):
    
    # Compute all the letters that can occur in a keyword.
    self.keywordChars = [ch for ch in string.letters + string.digits + '@']
    for ruleset in self.rulesets:
        for rule in ruleset.rules:
            d = rule.keywordsDict
            for key in d.keys():
                for ch in key:
                    if ch not in self.keywordChars and ch not in (' ','\t','\n'):
                        self.keywordChars.append(ch)
    self.keywordChars = ''.join(self.keywordChars)
    # g.trace('keywordChars',repr(self.keywordChars))
    
    self.outputFile = theFile
    self.put('# Leo colorizer control file for %s mode.\n' % language)
    self.put('# This file is in the public domain.\n\n')
    self.putModeProperties(language)
    self.putAttributes()
    self.putKeywordsData()
    self.putRules()
    self.putImportDict()</t>
<t tx="ekr.20060904141220.28"></t>
<t tx="ekr.20060904141220.29">def printModeAttributes (self):
    
    self.printAttributesHelper('mode attributes',self.attributes)
    
def printRulesetAttributes (self,ruleset,tag=None):

    if not tag: tag = 'main ruleset'
    
    self.printAttributesHelper(tag,ruleset.attributes)
    
def printAttributesHelper (self,kind,attrs):
    
    print '%-15s' % (kind),'attrs:',attrs</t>
<t tx="ekr.20060904141220.30">def printProperty (self,theProperty):
    
    # A property is a bunch.
    d = theProperty.attributes
    if d:
        self.printAttributesHelper('property',d)</t>
<t tx="ekr.20060904141220.31">def printRule (self,rule):
    
    # A rule is a g.Bunch.
    if rule.name == 'keywords':
        print '%-15s' % ('rule:keywords'),
        d = rule.keywordsDict
        d2 = {}
        for key in d:
            val = d.get(key)
            d2 [val] = d2.get(val,0) + 1
        keys = d2.keys() ; keys.sort()
        for key in keys:
            print '%s: %d' % (key,d2.get(key)),
        print
    else:
        d = rule.attributes
        d2 = rule.contents
        if d or d2:
            print '%-15s' % ('rule:'+rule.name),
            if d:  print 'attrs:',d,
            if d2: print 'contents:',d2,
            print
           </t>
<t tx="ekr.20060904141220.32">def printRuleset (self,ruleset,tag):
    
    self.printRulesetAttributes(ruleset,tag)

    for rule in self.rulesets[0].rules:
        self.printRule(rule)</t>
<t tx="ekr.20060904141220.33">def printSummary (self,printStats=True):

    if printStats:
        print '-' * 10, 'mode statistics'
        print 'elements',self.numberOfElements
        print 'errors',self.numberOfErrors
        print 'mode attributes',self.numberOfAttributes
        print 'property attributes',self.numberOfPropertyAttributes
        print 'rule attributes',self.numberOfRuleAttributes

    self.printModeAttributes()
    
    for bunch in self.modeProperties:
        self.printProperty(bunch)

    self.printRuleset(self.rulesets[0],tag='main ruleset')</t>
<t tx="ekr.20060904141220.39">def inRule (self,elementName):

    return self.rule and self.rule.name == elementName</t>
<t tx="ekr.20060904144645"></t>
</tnodes>
</leo_file>
