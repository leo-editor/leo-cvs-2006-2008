<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="271" clone_windows="0"/>
<globals body_outline_ratio="0.502115655853">
	<global_window_position top="123" left="326" height="709" width="910"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20060904171303"><vh>@url http://www.zope.org/Documentation/Books/ZDG/current/Persistence.stx</vh></v>
<v t="ekr.20060904174727"><vh>Exception in unit tests</vh></v>
<v t="ekr.20060904175413"><vh>No longer used</vh>
<v t="ekr.20050826073640"><vh>buildTnodeClass</vh>
<v t="ekr.20050826073640.1" a="E"><vh>class tnode</vh>
<v t="ekr.20050826073640.2"><vh>&lt;&lt; tnode constants &gt;&gt;</vh></v>
<v t="ekr.20050826073640.3"><vh>t.__init__</vh></v>
<v t="ekr.20050826073640.4"><vh>t.__repr__ &amp; t.__str__</vh></v>
<v t="ekr.20050826081159"><vh>t.__hash__ &amp; __cmp__ (for zodb)</vh></v>
<v t="ekr.20050826073640.5"><vh>Getters</vh>
<v t="ekr.20050826073640.6"><vh>getBody</vh></v>
<v t="ekr.20050826073640.7"><vh>hasBody</vh></v>
<v t="ekr.20050826073640.8"><vh>Status bits</vh>
<v t="ekr.20050826073640.9"><vh>isDirty</vh></v>
<v t="ekr.20050826073640.10"><vh>isRichTextBit</vh></v>
<v t="ekr.20050826073640.11"><vh>isVisited</vh></v>
<v t="ekr.20050826073640.12"><vh>isWriteBit</vh></v>
</v>
</v>
<v t="ekr.20050826073640.13"><vh>Setters</vh>
<v t="ekr.20050826073640.14"><vh>Setting body text</vh>
<v t="ekr.20050826073640.15"><vh>setTnodeText</vh></v>
<v t="ekr.20050826073640.16"><vh>setSelection</vh></v>
</v>
<v t="ekr.20050826073640.17"><vh>Status bits</vh>
<v t="ekr.20050826073640.18"><vh>clearDirty</vh></v>
<v t="ekr.20050826073640.19"><vh>clearRichTextBit</vh></v>
<v t="ekr.20050826073640.20"><vh>clearVisited</vh></v>
<v t="ekr.20050826073640.21"><vh>clearWriteBit</vh></v>
<v t="ekr.20050826073640.22"><vh>setDirty</vh></v>
<v t="ekr.20050826073640.23"><vh>setRichTextBit</vh></v>
<v t="ekr.20050826073640.24"><vh>setVisited</vh></v>
<v t="ekr.20050826073640.25"><vh>setWriteBit</vh></v>
</v>
<v t="ekr.20050826073640.26"><vh>setCloneIndex (used in 3.x)</vh></v>
<v t="ekr.20050826073640.27"><vh>setFileIndex</vh></v>
<v t="ekr.20050826073640.28"><vh>setHeadString (new in 4.3)</vh></v>
</v>
</v>
</v>
<v t="ekr.20050826134701"><vh>buildVnodeClass</vh>
<v t="ekr.20050826134701.1"><vh>class vnode</vh>
<v t="ekr.20050826134701.2"><vh>&lt;&lt; vnode constants &gt;&gt;</vh></v>
<v t="ekr.20050826134701.3"><vh>Birth &amp; death</vh>
<v t="ekr.20050826134701.4"><vh>v.__cmp__ (not used)</vh></v>
<v t="ekr.20050826134701.5"><vh>v.__init__</vh>
<v t="ekr.20050826134701.6"><vh>&lt;&lt; initialize vnode data members &gt;&gt;</vh></v>
</v>
<v t="ekr.20050826134701.7"><vh>v.__repr__ &amp; v.__str__</vh></v>
<v t="ekr.20050826135159"><vh>t.__hash__ &amp; __cmp__ (for zodb)</vh></v>
<v t="ekr.20050826134701.8"><vh>v.dump</vh></v>
</v>
<v t="ekr.20050826134701.9"><vh>v.Comparisons</vh>
<v t="ekr.20050826134701.10"><vh>findAtFileName (new in 4.2 b3)</vh></v>
<v t="ekr.20050826134701.11"><vh>anyAtFileNodeName</vh></v>
<v t="ekr.20050826134701.12"><vh>at...FileNodeName</vh></v>
<v t="ekr.20050826134701.13"><vh>isAtAllNode</vh></v>
<v t="ekr.20050826134701.14"><vh>isAnyAtFileNode good</vh></v>
<v t="ekr.20050826134701.15"><vh>isAt...FileNode</vh></v>
<v t="ekr.20050826134701.16"><vh>isAtIgnoreNode</vh></v>
<v t="ekr.20050826134701.17"><vh>isAtOthersNode</vh></v>
<v t="ekr.20050826134701.18"><vh>matchHeadline</vh></v>
</v>
<v t="ekr.20050826134701.19"><vh>Getters (vnode)</vh>
<v t="ekr.20050826134701.20"><vh>Tree Traversal getters</vh>
<v t="ekr.20050826134701.21"><vh>v.back</vh></v>
<v t="ekr.20050826134701.22"><vh>v.next</vh></v>
</v>
<v t="ekr.20050826134701.23"><vh>Children</vh>
<v t="ekr.20050826134701.24"><vh>v.childIndex</vh></v>
<v t="ekr.20050826134701.25"><vh>v.firstChild (changed for 4.2)</vh></v>
<v t="ekr.20050826134701.26"><vh>v.hasChildren &amp; hasFirstChild</vh></v>
<v t="ekr.20050826134701.27"><vh>v.lastChild</vh></v>
<v t="ekr.20050826134701.28"><vh>v.nthChild</vh></v>
<v t="ekr.20050826134701.29"><vh>v.numberOfChildren (n)</vh></v>
</v>
<v t="ekr.20050826134701.30"><vh>Status Bits</vh>
<v t="ekr.20050826134701.31"><vh>v.isCloned (4.2)</vh></v>
<v t="ekr.20050826134701.32"><vh>isDirty</vh></v>
<v t="ekr.20050826134701.33"><vh>isExpanded</vh></v>
<v t="ekr.20050826134701.34"><vh>isMarked</vh></v>
<v t="ekr.20050826134701.35"><vh>isOrphan</vh></v>
<v t="ekr.20050826134701.36"><vh>isSelected</vh></v>
<v t="ekr.20050826134701.37"><vh>isTopBitSet</vh></v>
<v t="ekr.20050826134701.38"><vh>isVisited</vh></v>
<v t="ekr.20050826134701.39"><vh>status</vh></v>
</v>
<v t="ekr.20050826134701.40"><vh>v.bodyString</vh></v>
<v t="ekr.20050826134701.41"><vh>v.currentVnode (and c.currentPosition 4.2)</vh></v>
<v t="ekr.20050826134701.42"><vh>v.findRoot (4.2)</vh></v>
<v t="ekr.20050826134701.43"><vh>v.headString &amp; v.cleanHeadString</vh></v>
<v t="ekr.20050826134701.44"><vh>v.directParents (new method in 4.2)</vh></v>
</v>
<v t="ekr.20050826134701.45"><vh>v.Link/Unlink/Insert methods (used by file read logic)</vh>
<v t="ekr.20050826134701.46"><vh>v.insertAfter</vh></v>
<v t="ekr.20050826134701.47"><vh>v.insertAsNthChild</vh></v>
<v t="ekr.20050826134701.48"><vh>v.linkAfter</vh></v>
<v t="ekr.20050826134701.49"><vh>v.linkAsNthChild</vh></v>
<v t="ekr.20050826134701.50"><vh>v.linkAsRoot</vh></v>
<v t="ekr.20050826134701.51"><vh>v.moveToRoot</vh></v>
<v t="ekr.20050826134701.52"><vh>v.unlink</vh></v>
</v>
<v t="ekr.20050826134701.53"><vh>Setters</vh>
<v t="ekr.20050826134701.54"><vh> v.Status bits</vh>
<v t="ekr.20050826134701.55"><vh>clearClonedBit</vh></v>
<v t="ekr.20050826134701.56"><vh>clearDirty &amp; clearDirtyJoined (redundant code)</vh></v>
<v t="ekr.20050826134701.57"><vh>v.clearMarked</vh></v>
<v t="ekr.20050826134701.58"><vh>clearOrphan</vh></v>
<v t="ekr.20050826134701.59"><vh>clearVisited</vh></v>
<v t="ekr.20050826134701.60"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="ekr.20050826134701.61"><vh>initStatus</vh></v>
<v t="ekr.20050826134701.62"><vh>setClonedBit &amp; initClonedBit</vh></v>
<v t="ekr.20050826134701.63"><vh>v.setMarked &amp; initMarkedBit</vh></v>
<v t="ekr.20050826134701.64"><vh>setOrphan</vh></v>
<v t="ekr.20050826134701.65"><vh>setSelected (vnode)</vh></v>
<v t="ekr.20050826134701.66"><vh>t.setVisited</vh></v>
</v>
<v t="ekr.20050826134701.67"><vh>v.computeIcon &amp; setIcon</vh></v>
<v t="ekr.20050826134701.68"><vh>v.initHeadString</vh></v>
<v t="ekr.20050826134701.69"><vh>v.setSelection</vh></v>
<v t="ekr.20050826134701.70"><vh>v.setTnodeText</vh></v>
<v t="ekr.20050826134701.71"><vh>v.trimTrailingLines</vh></v>
</v>
<v t="ekr.20050826134701.72"><vh>v.Iterators</vh>
<v t="ekr.20050826134701.73"><vh>self_subtree_iter</vh></v>
<v t="ekr.20050826134701.74"><vh>unique_subtree_iter</vh></v>
</v>
</v>
</v>
<v t="ekr.20050826134701.75"><vh>buildPositionClass</vh>
<v t="ekr.20050826134701.76"><vh>class position</vh>
<v t="ekr.20050826134701.77"><vh>&lt;&lt; about the position class &gt;&gt;</vh></v>
<v t="ekr.20050826134701.78"><vh>&lt;&lt; positions may become invalid when outlines change &gt;&gt;</vh></v>
<v t="ekr.20050826134701.79"><vh> ctor &amp; other special methods...</vh>
<v t="ekr.20050826134701.80"><vh>p.__cmp__</vh></v>
<v t="ekr.20050826134701.81"><vh>p.__getattr__  ON:  must be ON if use_plugins</vh></v>
<v t="ekr.20050826134701.82"><vh>p.__init__</vh></v>
<v t="ekr.20050826134701.83"><vh>p.__nonzero__</vh></v>
<v t="ekr.20050826134701.84"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20050826134701.85"><vh>p.copy</vh></v>
<v t="ekr.20050826134701.86"><vh>p.dump &amp; p.vnodeListIds</vh></v>
<v t="ekr.20050826134701.87"><vh>p.equal &amp; isEqual</vh></v>
</v>
<v t="ekr.20050826134701.88"><vh>Getters</vh>
<v t="ekr.20050826134701.89"><vh> vnode proxies</vh>
<v t="ekr.20050826134701.90"><vh>p.Comparisons</vh></v>
<v t="ekr.20050826134701.91"><vh>p.Extra Attributes</vh></v>
<v t="ekr.20050826134701.92"><vh>p.Headline &amp; body strings</vh></v>
<v t="ekr.20050826134701.93"><vh>p.Status bits</vh></v>
<v t="ekr.20050826134701.94"><vh>p.edit_text</vh></v>
<v t="ekr.20050826134701.95"><vh>p.directParents</vh></v>
<v t="ekr.20050826134701.96"><vh>p.childIndex</vh></v>
</v>
<v t="ekr.20050826134701.97"><vh>children</vh>
<v t="ekr.20050826134701.98"><vh>p.hasChildren</vh></v>
<v t="ekr.20050826134701.99"><vh>p.numberOfChildren</vh></v>
</v>
<v t="ekr.20050826134701.100"><vh>p.exists</vh></v>
<v t="ekr.20050826134701.101"><vh>p.findRoot</vh></v>
<v t="ekr.20050826134701.102"><vh>p.getX &amp; vnode compatibility traversal routines</vh></v>
<v t="ekr.20050826134701.103"><vh>p.hasX</vh>
<v t="ekr.20050826134701.104"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20050826134701.105"><vh>p.isAncestorOf</vh></v>
<v t="ekr.20050826134701.106"><vh>p.isCurrentPosition &amp; isRootPosition</vh>
<v t="ekr.20050826134701.107"><vh>isCurrentPosition</vh></v>
<v t="ekr.20050826134701.108"><vh>isRootPosition</vh></v>
</v>
<v t="ekr.20050826134701.109"><vh>p.isCloned</vh></v>
<v t="ekr.20050826134701.110"><vh>p.isRoot</vh></v>
<v t="ekr.20050826134701.111"><vh>p.isVisible</vh></v>
<v t="ekr.20050826134701.112"><vh>p.lastVisible &amp; oldLastVisible</vh></v>
<v t="ekr.20050826134701.113"><vh>p.level &amp; simpleLevel</vh></v>
</v>
<v t="ekr.20050826134701.114"><vh>Setters</vh>
<v t="ekr.20050826134701.115"><vh>vnode proxies</vh>
<v t="ekr.20050826134701.116"><vh> Status bits (position)</vh></v>
<v t="ekr.20050826134701.117"><vh>p.computeIcon &amp; p.setIcon</vh></v>
<v t="ekr.20050826134701.118"><vh>p.setSelection</vh></v>
<v t="ekr.20050826134701.119"><vh>p.trimTrailingLines</vh></v>
<v t="ekr.20050826134701.120"><vh>p.setTnodeText</vh></v>
</v>
<v t="ekr.20050826134701.121"><vh>Head &amp; body text (position)</vh>
<v t="ekr.20050826134701.122"><vh>p.appendStringToBody</vh></v>
<v t="ekr.20050826134701.123"><vh>p.setBodyStringOrPane &amp; p.setBodyTextOrPane</vh></v>
<v t="ekr.20050826134701.124"><vh>p.setHeadString &amp; p.initHeadString</vh></v>
<v t="ekr.20050826134701.125"><vh>p.setHeadStringOrHeadline</vh></v>
<v t="ekr.20050826134701.126"><vh>p.scriptSetBodyString</vh></v>
</v>
<v t="ekr.20050826134701.127"><vh>Visited bits</vh>
<v t="ekr.20050826134701.128"><vh>p.clearAllVisited</vh></v>
<v t="ekr.20050826134701.129"><vh>p.clearVisitedInTree</vh></v>
<v t="ekr.20050826134701.130"><vh>p.clearAllVisitedInTree (4.2)</vh></v>
</v>
<v t="ekr.20050826134701.131"><vh>p.Dirty bits</vh>
<v t="ekr.20050826134701.132"><vh>p.clearDirty</vh></v>
<v t="ekr.20050826134701.133"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20050826134701.134"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20050826134701.135"><vh>p.setDirty</vh></v>
<v t="ekr.20050826134701.136"><vh>p.inAtIgnoreRange</vh></v>
</v>
</v>
<v t="ekr.20050826134701.137"><vh>File Conversion</vh>
<v t="ekr.20050826134701.138"><vh>convertTreeToString</vh></v>
<v t="ekr.20050826134701.139"><vh>moreHead</vh></v>
<v t="ekr.20050826134701.140"><vh>moreBody</vh></v>
</v>
<v t="ekr.20050826134701.141"><vh>p.Iterators</vh>
<v t="ekr.20050826134701.142"><vh>p.tnodes_iter &amp; unique_tnodes_iter</vh></v>
<v t="ekr.20050826134701.143"><vh>p.vnodes_iter &amp; unique_vnodes_iter</vh></v>
<v t="ekr.20050826134701.144"><vh>p.allNodes_iter</vh>
<v t="ekr.20050826134701.145"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20050826134701.146"><vh>next</vh></v>
</v>
<v t="ekr.20050826134701.147"><vh>p.subtree_iter</vh>
<v t="ekr.20050826134701.148"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20050826134701.149"><vh>next</vh></v>
</v>
<v t="ekr.20050826134701.150"><vh>p.children_iter</vh>
<v t="ekr.20050826134701.151"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20050826134701.152"><vh>next</vh></v>
</v>
<v t="ekr.20050826134701.153"><vh>p.parents_iter</vh>
<v t="ekr.20050826134701.154"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20050826134701.155"><vh>next</vh></v>
</v>
<v t="ekr.20050826134701.156"><vh>p.siblings_iter</vh>
<v t="ekr.20050826134701.157"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20050826134701.158"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20050826134701.159"><vh>p.Moving, Inserting, Deleting, Cloning, Sorting (position)</vh>
<v t="ekr.20050826134701.160"><vh>p.doDelete</vh></v>
<v t="ekr.20050826134701.161"><vh>p.insertAfter</vh></v>
<v t="ekr.20050826134701.162"><vh>p.insertAsLastChild</vh></v>
<v t="ekr.20050826134701.163"><vh>p.insertAsNthChild</vh></v>
<v t="ekr.20050826134701.164"><vh>p.moveToRoot</vh></v>
<v t="ekr.20050826134701.165"><vh>p.clone</vh></v>
<v t="ekr.20050826134701.166"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
<v t="ekr.20050826134701.167"><vh>p.moveAfter</vh></v>
<v t="ekr.20050826134701.168"><vh>p.moveToLastChildOf</vh></v>
<v t="ekr.20050826134701.169"><vh>p.moveToNthChildOf</vh></v>
<v t="ekr.20050826134701.170"><vh>p.validateOutlineWithParent</vh>
<v t="ekr.20050826134701.171"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20050826134701.172"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="ekr.20050826134701.173"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
<v t="ekr.20050826134701.174"><vh>p.invalidOutline</vh></v>
</v>
<v t="ekr.20050826134701.175"><vh>p.moveToX</vh>
<v t="ekr.20050826134701.176"><vh>p.moveToBack</vh></v>
<v t="ekr.20050826134701.177"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20050826134701.178"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20050826134701.179"><vh>p.moveToLastNode (Big improvement for 4.2)</vh></v>
<v t="ekr.20050826134701.180"><vh>p.moveToNext</vh></v>
<v t="ekr.20050826134701.181"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20050826134701.182"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20050826134701.183"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20050826134701.184"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20050826134701.185"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20050826134701.186"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20050826134701.187"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20050826134701.188"><vh>p.utils...</vh>
<v t="ekr.20050826134701.189"><vh>p.vParentWithStack</vh>
<v t="ekr.20050826134701.190"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
<v t="ekr.20050826134701.191"><vh>p.restoreLinksInTree</vh></v>
<v t="ekr.20050826134701.192"><vh>p.deleteLinksInTree &amp; allies</vh>
<v t="ekr.20050826134701.193"><vh>p.deleteLinksInSubtree</vh></v>
<v t="ekr.20050826134701.194"><vh>p.adjustParentLinksInSubtree</vh></v>
</v>
</v>
<v t="ekr.20050826134701.195"><vh>p.Link/Unlink methods</vh>
<v t="ekr.20050826134701.196"><vh>p.linkAfter</vh></v>
<v t="ekr.20050826134701.197"><vh>p.linkAsNthChild</vh></v>
<v t="ekr.20050826134701.198"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20050826134701.199"><vh>p.unlink</vh></v>
</v>
</v>
</v>
<v t="ekr.20050825171046.13"><vh>Originals</vh>
<v t="ekr.20050825171046.14"><vh>fileCommands.write_Leo_file</vh>
<v t="ekr.20050825171046.15"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20050825171046.16"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20050825171046.17"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20050825171046.18"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20050825171046.19"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="ekr.20050825171046.20"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20050825171046.21"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
</v>
<v t="ekr.20050825171046.22"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20050825162326"><vh>patchLeoCore</vh>
<v t="ekr.20050826142105"><vh>openWithFileName_callback</vh></v>
<v t="ekr.20050826142105.1"><vh>write_Leo_file_callback</vh></v>
</v>
<v t="ekr.20050825165338"><vh>Overrides of core methods</vh>
<v t="ekr.20050825165912"><vh>zodb_openWithFileName (from leoGlobals)</vh></v>
<v t="ekr.20050825171046"><vh>zodb_write_Leo_file (from fileCommands)</vh>
<v t="ekr.20050825171046.1"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20050825171046.2"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20050825171046.3"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20050825171046.4"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20050825171046.5"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="ekr.20050825171046.6"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20050825171046.7"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050825155228.1"><vh>class zodbControllerClass</vh>
<v t="ekr.20060904201421" a="E"><vh>Not used from zodbControllerClass</vh>
<v t="ekr.20050825155308"><vh> ctor (zodbControllerClass)</vh></v>
<v t="ekr.20060904200020"><vh>ok</vh></v>
<v t="ekr.20050825162137.1"><vh>getRoot</vh></v>
<v t="ekr.20050825162137"><vh>isOpen</vh></v>
<v t="ekr.20050825162137.2"><vh>close</vh></v>
<v t="ekr.20050825160255.2"><vh>open</vh></v>
</v>
</v>
</v>
<v t="ekr.20050825154553" a="E"
expanded="ekr.20060904192907.1,"><vh>@thin zodb.py</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20050825155228.1">class zodbControllerClass:
    
    '''A singleton controller class for the zodb database attached to zodb_filename.'''
    
    @others</t>
<t tx="ekr.20050825155308">def __init__ (self,zodb_filename):

    self.connection = None
    self.storage = None
    self.zodb_filename = zodb_filename</t>
<t tx="ekr.20050825160255.2">def open(self):
    
    if not self.storage:
        g.trace('no storage')
        return None
    
    if not self.connection:
        try:
            self.connection = ZODB.DB(self.storage)
        except Exception:
            g.es('Can not create zodb connection')
            g.es_exception()
            self.connection = None

    return self.connection</t>
<t tx="ekr.20050825162137">def isOpen (self):
    
    return self.storage is not None and self.connection is not None</t>
<t tx="ekr.20050825162137.1">def getRoot (self):
    
    if not self.connection:
        return None
        
    print g.listToString(dir(self.connection))

    root = self.connection.root()
    if 0:
        t = get_transaction()
        t.begin()
        # root.clear()
        root ['count'] = root.get('count',0) + 1
        t.commit()
    g.trace(root)
    return root</t>
<t tx="ekr.20050825162137.2">def close (self):
    
    if self.storage and self.connection:
        self.connection.close()
        self.connection = None</t>
<t tx="ekr.20050825162326">def patchLeoCore (zodbController):
    
    @others # define the callbacks
    
    if 1:
        g.openWithFileName = openWithFileName_callback
    
    if 0:
        leoFileCommands.write_Leo_file = write_Leo_file_callback</t>
<t tx="ekr.20050825165338"></t>
<t tx="ekr.20050825165912">def zodb_openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True,forceDiskRead=False,zodbController=None):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""
    
    g.trace('forceDiskRead',forceDiskRead,zodbController)

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = g.app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            g.app.setLog(frame.log)
            # g.trace('Already open',fileName)
            return True, frame
            
    if not forceDiskRead:
        z = zodbController
        connection = z.open()
        try:
            root = connection.root()
            files = root.get('files',{})
            f = files.get(fileName)
            if f:
                g.trace('found in zodb',fileName)
            connection.close()
        finally:
            z.close()
    try:
        # g.trace('Not open',fileName)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = g.app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            g.app.setLog(frame.log)
            g.app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            g.app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20050825171046">def zodb_write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c
    self.assignFileIndices()
    if not outlineOnlyFlag:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        theActualFile = None
        &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        self.outputFile = cStringIO.StringIO() # or g.fileLikeObject()
        theActualFile = open(fileName, 'wb')
        &lt;&lt; put the .leo file &gt;&gt;
        theActualFile.write(self.outputFile.getvalue())
        theActualFile.close()
        self.outputFile = None
        &lt;&lt; delete backup file &gt;&gt;
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        &lt;&lt; delete fileName &gt;&gt;
        &lt;&lt; rename backupName to fileName &gt;&gt;
        return False</t>
<t tx="ekr.20050825171046.1">try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False</t>
<t tx="ekr.20050825171046.2"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.</t>
<t tx="ekr.20050825171046.3"># rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None</t>
<t tx="ekr.20050825171046.4">self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()</t>
<t tx="ekr.20050825171046.5">if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')</t>
<t tx="ekr.20050825171046.6">if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
</t>
<t tx="ekr.20050825171046.7">if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)</t>
<t tx="ekr.20050825171046.13">if 0:
    
    @others</t>
<t tx="ekr.20050825171046.14">def write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c
    self.assignFileIndices()
    if not outlineOnlyFlag:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        theActualFile = None
        &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        self.outputFile = cStringIO.StringIO() # or g.fileLikeObject()
        theActualFile = open(fileName, 'wb')
        &lt;&lt; put the .leo file &gt;&gt;
        theActualFile.write(self.outputFile.getvalue())
        theActualFile.close()
        self.outputFile = None
        &lt;&lt; delete backup file &gt;&gt;
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        &lt;&lt; delete fileName &gt;&gt;
        &lt;&lt; rename backupName to fileName &gt;&gt;
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.</t>
<t tx="ekr.20050825171046.15">try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False</t>
<t tx="ekr.20050825171046.16"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.</t>
<t tx="ekr.20050825171046.17"># rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None</t>
<t tx="ekr.20050825171046.18">self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()</t>
<t tx="ekr.20050825171046.19">if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')</t>
<t tx="ekr.20050825171046.20">if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
</t>
<t tx="ekr.20050825171046.21">if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)</t>
<t tx="ekr.20050825171046.22">def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.trace('Already open',fileName)
            return True, frame
    try:
        # g.trace('Not open',fileName)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20050826073640">def buildTnodeClass (controller=None):
    
    class tnode (ZODB.Persistence.Persistent):
        '''A class that implements tnodes.'''
        &lt;&lt; tnode constants &gt;&gt;
        @others

    return tnode</t>
<t tx="ekr.20050826073640.1"></t>
<t tx="ekr.20050826073640.2">dirtyBit    =		0x01
richTextBit =	0x02 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit  =	0x04
writeBit    = 0x08 # Set: write the tnode.</t>
<t tx="ekr.20050826073640.3"># All params have defaults, so t = tnode() is valid.

def __init__ (self,bodyString=None,headString=None):

    self.cloneIndex = 0 # For Pre-3.12 files.  Zero for @file nodes
    self.fileIndex = None # The immutable file index for this tnode.
    self.insertSpot = None # Location of previous insert point.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    self.selectionLength = 0 # The length of the selected body text.
    self.selectionStart = 0 # The start of the selected body text.
    self.statusBits = 0 # status bits

    # Convert everything to unicode...
    self.headString = g.toUnicode(headString,g.app.tkEncoding)
    self.bodyString = g.toUnicode(bodyString,g.app.tkEncoding)
    
    self.vnodeList = [] # List of all vnodes pointing to this tnode.
    self._firstChild = None</t>
<t tx="ekr.20050826073640.4">def __repr__ (self):
    
    return "&lt;tnode %d&gt;" % (id(self))
        
__str__ = __repr__</t>
<t tx="ekr.20050826073640.5"></t>
<t tx="ekr.20050826073640.6">def getBody (self):

    return self.bodyString</t>
<t tx="ekr.20050826073640.7">def hasBody (self):

    return self.bodyString and len(self.bodyString) &gt; 0</t>
<t tx="ekr.20050826073640.8"></t>
<t tx="ekr.20050826073640.9">def isDirty (self):

    return (self.statusBits &amp; self.dirtyBit) != 0</t>
<t tx="ekr.20050826073640.10">def isRichTextBit (self):

    return (self.statusBits &amp; self.richTextBit) != 0</t>
<t tx="ekr.20050826073640.11">def isVisited (self):

    return (self.statusBits &amp; self.visitedBit) != 0</t>
<t tx="ekr.20050826073640.12">def isWriteBit (self):

    return (self.statusBits &amp; self.writeBit) != 0</t>
<t tx="ekr.20050826073640.13"></t>
<t tx="ekr.20050826073640.14"></t>
<t tx="ekr.20050826073640.15"># This sets the text in the tnode from the given string.

def setTnodeText (self,s,encoding="utf-8"):
    
    """Set the body text of a tnode to the given string."""
    
    s = g.toUnicode(s,encoding,reportErrors=True)
    
    if 0: # DANGEROUS:  This automatically converts everything when reading files.
    
        ## Self c does not exist yet.
        option = c.config.trailing_body_newlines
        
        if option == "one":
            s = s.rstrip() + '\n'
        elif option == "zero":
            s = s.rstrip()
    
    self.bodyString = s</t>
<t tx="ekr.20050826073640.16">def setSelection (self,start,length):

    self.selectionStart = start
    self.selectionLength = length</t>
<t tx="ekr.20050826073640.17"></t>
<t tx="ekr.20050826073640.18">def clearDirty (self):

    self.statusBits &amp;= ~ self.dirtyBit</t>
<t tx="ekr.20050826073640.19">def clearRichTextBit (self):

    self.statusBits &amp;= ~ self.richTextBit</t>
<t tx="ekr.20050826073640.20">def clearVisited (self):

    self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="ekr.20050826073640.21">def clearWriteBit (self):

    self.statusBits &amp;= ~ self.writeBit</t>
<t tx="ekr.20050826073640.22">def setDirty (self):

    self.statusBits |= self.dirtyBit</t>
<t tx="ekr.20050826073640.23">def setRichTextBit (self):

    self.statusBits |= self.richTextBit</t>
<t tx="ekr.20050826073640.24">def setVisited (self):

    self.statusBits |= self.visitedBit</t>
<t tx="ekr.20050826073640.25">def setWriteBit (self):

    self.statusBits |= self.writeBit</t>
<t tx="ekr.20050826073640.26">def setCloneIndex (self, index):

    self.cloneIndex = index</t>
<t tx="ekr.20050826073640.27">def setFileIndex (self, index):

    self.fileIndex = index</t>
<t tx="ekr.20050826073640.28">def setHeadString (self,s,encoding="utf-8"):
    
    t = self

    s = g.toUnicode(s,encoding,reportErrors=True)
    t.headString = s</t>
<t tx="ekr.20050826081159">def __hash__ (self):
    
    return id(self)
    
def __cmp__(self,other):
    
    # Must return 0, 1 or -1
    
    if self is other:
        return 0
    elif id(self) &gt; id(other):
        return 1
    else:
        return -1</t>
<t tx="ekr.20050826134701">def buildVnodeClass (controller=None):
    
    class vnode (ZODB.Persistence.Persistent):
        '''A class that implements vnodes.'''
        &lt;&lt; vnode constants &gt;&gt;
        @others

    return vnode</t>
<t tx="ekr.20050826134701.1"></t>
<t tx="ekr.20050826134701.2"># Define the meaning of status bits in new vnodes.

# Archived...
clonedBit	  = 0x01 # True: vnode has clone mark.

# not used	 = 0x02
expandedBit = 0x04 # True: vnode is expanded.
markedBit	  = 0x08 # True: vnode is marked
orphanBit	  = 0x10 # True: vnode saved in .leo file, not derived file.
selectedBit = 0x20 # True: vnode is current vnode.
topBit		    = 0x40 # True: vnode was top vnode when saved.

# Not archived...
dirtyBit    =	0x060
richTextBit =	0x080 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit	 = 0x100
</t>
<t tx="ekr.20050826134701.3"></t>
<t tx="ekr.20050826134701.4">if 0: # not used
    def __cmp__(self,other):
        
        g.trace(self,other)
        return not (self is other) # Must return 0, 1 or -1</t>
<t tx="ekr.20050826134701.5">def __init__ (self,c,t):

    assert(t)
    &lt;&lt; initialize vnode data members &gt;&gt;</t>
<t tx="ekr.20050826134701.6">self.c = c # The commander for this vnode.
self.t = t # The tnode.
self.statusBits = 0 # status bits

# Structure links.
self._parent = self._next = self._back = None</t>
<t tx="ekr.20050826134701.7">def __repr__ (self):
    
    if self.t:
        return "&lt;vnode %d:'%s'&gt;" % (id(self),self.cleanHeadString())
    else:
        return "&lt;vnode %d:NULL tnode&gt;" % (id(self))
        
__str__ = __repr__</t>
<t tx="ekr.20050826134701.8">def dumpLink (self,link):
    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):
    
    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)
    
    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v</t>
<t tx="ekr.20050826134701.9"></t>
<t tx="ekr.20050826134701.10">def findAtFileName (self,names):
    
    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()
    
    if not g.match(h,0,'@'):
        return ""
    
    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""</t>
<t tx="ekr.20050826134701.11">def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)</t>
<t tx="ekr.20050826134701.12"># These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)
    
def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)
    
def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)
    
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName</t>
<t tx="ekr.20050826134701.13">def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag</t>
<t tx="ekr.20050826134701.14">def isAnyAtFileNode (self):
    
    """Return True if v is any kind of @file or related node."""
    
    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()</t>
<t tx="ekr.20050826134701.15">def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)
    
def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)
    
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode</t>
<t tx="ekr.20050826134701.16">def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag</t>
<t tx="ekr.20050826134701.17">def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag</t>
<t tx="ekr.20050826134701.18">def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""

    h = string.lower(self.headString())
    h = string.replace(h,' ','')
    h = string.replace(h,'\t','')

    s = string.lower(pattern)
    s = string.replace(s,' ','')
    s = string.replace(s,'\t','')

    # ignore characters in the headline following the match
    return s == h[0:len(s)]</t>
<t tx="ekr.20050826134701.19"></t>
<t tx="ekr.20050826134701.20"></t>
<t tx="ekr.20050826134701.21"># Compatibility routine for scripts

def back (self):

    return self._back</t>
<t tx="ekr.20050826134701.22"># Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next</t>
<t tx="ekr.20050826134701.23"></t>
<t tx="ekr.20050826134701.24">def childIndex(self):
    
    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n</t>
<t tx="ekr.20050826134701.25">def firstChild (self):
    
    return self.t._firstChild</t>
<t tx="ekr.20050826134701.26">def hasChildren (self):
    
    v = self
    return v.firstChild()

hasFirstChild = hasChildren</t>
<t tx="ekr.20050826134701.27">def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child</t>
<t tx="ekr.20050826134701.28"># childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n &gt; 0 and child:
        n -= 1
        child = child.next()
    return child</t>
<t tx="ekr.20050826134701.29">def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n += 1
        child = child.next()
    return n</t>
<t tx="ekr.20050826134701.30"></t>
<t tx="ekr.20050826134701.31">def isCloned (self):
    
    return len(self.t.vnodeList) &gt; 1</t>
<t tx="ekr.20050826134701.32">def isDirty (self):

    return self.t.isDirty()</t>
<t tx="ekr.20050826134701.33">def isExpanded (self):

    return ( self.statusBits &amp; self.expandedBit ) != 0</t>
<t tx="ekr.20050826134701.34">def isMarked (self):

    return ( self.statusBits &amp; vnode.markedBit ) != 0</t>
<t tx="ekr.20050826134701.35">def isOrphan (self):

    return ( self.statusBits &amp; vnode.orphanBit ) != 0</t>
<t tx="ekr.20050826134701.36">def isSelected (self):

    return ( self.statusBits &amp; vnode.selectedBit ) != 0</t>
<t tx="ekr.20050826134701.37">def isTopBitSet (self):

    return ( self.statusBits &amp; self.topBit ) != 0</t>
<t tx="ekr.20050826134701.38">def isVisited (self):

    return ( self.statusBits &amp; vnode.visitedBit ) != 0</t>
<t tx="ekr.20050826134701.39">def status (self):

    return self.statusBits</t>
<t tx="ekr.20050826134701.40"># Compatibility routine for scripts

def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.bodyString):
        s = "Leo internal error: not unicode:" + repr(self.t.bodyString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
</t>
<t tx="ekr.20050826134701.41">def currentPosition (self):
    return self.c.currentPosition()
        
def currentVnode (self):
    return self.c.currentVnode()</t>
<t tx="ekr.20050826134701.42">def findRoot (self):
    
    return self.c.rootPosition()</t>
<t tx="ekr.20050826134701.43">def headString (self):
    
    """Return the headline string."""
    
    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.headString):
        s = "Leo internal error: not unicode:" + repr(self.t.headString)
        g.es_print(s,color="red")
        
    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):
    
    s = self.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'</t>
<t tx="ekr.20050826134701.44">def directParents (self):
    
    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.
    
    This is NOT the same as the list of ancestors of the vnode."""
    
    v = self
    
    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []</t>
<t tx="ekr.20050826134701.45"># These remain in 4.2: the file read logic calls these before creating positions.</t>
<t tx="ekr.20050826134701.46">def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(self.c,t)
    v.linkAfter(self)

    return v</t>
<t tx="ekr.20050826134701.47">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(self.c,t)
    v.linkAsNthChild(self,n)

    return v</t>
<t tx="ekr.20050826134701.48">def linkAfter (self,v):

    """Link self after v."""
    
    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
</t>
<t tx="ekr.20050826134701.49">def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v</t>
<t tx="ekr.20050826134701.50">def linkAsRoot (self,oldRoot):
    
    """Link a vnode as the root node and set the root _position_."""

    v = self ; c = v.c

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = True # zodb support.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v

    newRoot = position(c,v,[])
    c.setRootPosition(newRoot)</t>
<t tx="ekr.20050826134701.51">def moveToRoot (self,oldRoot=None):

    """Moves the receiver to the root position"""

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)
    
    return v</t>
<t tx="ekr.20050826134701.52">def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self ; c = v.c

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)
    
    # Special case the root.
    if v == c.rootPosition().v: # 3/11/04
        assert(v._next)
        newRoot = position(c,v._next,[])
        c.setRootPosition(newRoot)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []</t>
<t tx="ekr.20050826134701.53"></t>
<t tx="ekr.20050826134701.54"></t>
<t tx="ekr.20050826134701.55">def clearClonedBit (self):

    self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="ekr.20050826134701.56">def clearDirty (self):

    v = self
    v.t.clearDirty()

def clearDirtyJoined (self):

    g.trace()
    v = self ; c = v.c
    c.beginUpdate()
    v.t.clearDirty()
    c.endUpdate() # recomputes all icons</t>
<t tx="ekr.20050826134701.57">def clearMarked (self):

    self.statusBits &amp;= ~ self.markedBit
</t>
<t tx="ekr.20050826134701.58">def clearOrphan (self):

    self.statusBits &amp;= ~ self.orphanBit</t>
<t tx="ekr.20050826134701.59">def clearVisited (self):

    self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="ekr.20050826134701.60">def contract(self):

    self.statusBits &amp;= ~ self.expandedBit
    
    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit
    
    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit</t>
<t tx="ekr.20050826134701.61">def initStatus (self, status):

    self.statusBits = status</t>
<t tx="ekr.20050826134701.62">def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="ekr.20050826134701.63">def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
</t>
<t tx="ekr.20050826134701.64">def setOrphan (self):

    self.statusBits |= self.orphanBit</t>
<t tx="ekr.20050826134701.65"># This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit</t>
<t tx="ekr.20050826134701.66"># Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit</t>
<t tx="ekr.20050826134701.67">def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val
    
def setIcon (self):

    pass # Compatibility routine for old scripts</t>
<t tx="ekr.20050826134701.68">def initHeadString (self,s,encoding="utf-8"):
    
    v = self

    s = g.toUnicode(s,encoding,reportErrors=True)
    v.t.headString = s</t>
<t tx="ekr.20050826134701.69">def setSelection (self, start, length):

    self.t.setSelection ( start, length )</t>
<t tx="ekr.20050826134701.70">def setTnodeText (self,s,encoding="utf-8"):
    
    return self.t.setTnodeText(s,encoding)</t>
<t tx="ekr.20050826134701.71">def trimTrailingLines (self):

    """Trims trailing blank lines from a node.
    
    It is surprising difficult to do this during Untangle."""

    v = self
    body = v.bodyString()
    # g.trace(body)
    lines = string.split(body,'\n')
    i = len(lines) - 1 ; changed = False
    while i &gt;= 0:
        line = lines[i]
        j = g.skip_ws(line,0)
        if j + 1 == len(line):
            del lines[i]
            i -= 1 ; changed = True
        else: break
    if changed:
        body = string.join(body,'') + '\n' # Add back one last newline.
        # g.trace(body)
        v.setBodyStringOrPane(body)
        # Don't set the dirty bit: it would just be annoying.
</t>
<t tx="ekr.20050826134701.72"></t>
<t tx="ekr.20050826134701.73">def subtree_iter(self):

    """Return all nodes of self's tree in outline order."""
    
    v = self

    if v:
        yield v
        child = v.t._firstChild
        while child:
            for v1 in child.subtree_iter():
                yield v1
            child = child.next()
            
self_and_subtree_iter = subtree_iter</t>
<t tx="ekr.20050826134701.74">def unique_subtree_iter(self,marks=None):

    """Return all vnodes in self's tree, discarding duplicates """
    
    v = self

    if marks == None: marks = {}

    if v and v not in marks:
        marks[v] = v
        yield v
        if v.t._firstChild:
            for v1 in v.t._firstChild.unique_subtree_iter(marks):
                yield v1
        v = v._next
        while v:
            for v in v.unique_subtree_iter(marks):
                yield v
            v = v._next
            
self_and_unique_subtree_iter = unique_subtree_iter</t>
<t tx="ekr.20050826134701.75">def buildPositionClass (controller=None):
    
    class position (ZODB.Persistence.Persistent):
    
        """A class representing a position in a traversal of a tree containing shared tnodes."""
    
        &lt;&lt; about the position class &gt;&gt;
        &lt;&lt; positions may become invalid when outlines change &gt;&gt;
        
        @others

    return position</t>
<t tx="ekr.20050826134701.76"></t>
<t tx="ekr.20050826134701.77">@killcolor

@ This class provides tree traversal methods that operate on positions, not vnodes.  Positions encapsulate the notion of present position within a traversal.

Positions consist of a vnode and a stack of parent nodes used to determine the next parent when a vnode has mutliple parents.

Calling, e.g., p.moveToThreadNext() results in p being an invalid position.  That is, p represents the position following the last node of the outline.  The test "if p" is the _only_ correct way to test whether a position p is valid.  In particular, tests like "if p is None" or "if p is not None" will not work properly.

The only changes to vnodes and tnodes needed to implement shared tnodes are:

- The firstChild field becomes part of tnodes.
- t.vnodes contains a list of all vnodes sharing the tnode.

The advantages of using shared tnodes:

- Leo no longer needs to create or destroy "dependent" trees when changing descendents of cloned trees.
- There is no need for join links and no such things as joined nodes.

These advantages are extremely important: Leo is now scalable to very large outlines.

An important complication is the need to avoid creating temporary positions while traversing trees:
- Several routines use p.vParentWithStack to avoid having to call tempPosition.moveToParent().
  These include p.level, p.isVisible and p.hasThreadNext.
- p.moveToLastNode and p.moveToThreadBack use new algorithms that don't use temporary data.
- Several lookahead routines compute whether a position exists without computing the actual position.</t>
<t tx="ekr.20050826134701.78">@killcolor

@ If a vnode has only one parent, v._parent is that parent. Otherwise,
v.t.vnodeList is the list of vnodes v2 such that v2._firstChild == v. Alas, this
means that positions can become invalid when vnodeList's change!

There is no use trying to solve the problem in p.moveToParent or
p.vParentWithStack: the invalidated positions simply don't have the stack
entries needed to compute parent fields properly. In short, changing t.vnodeList
may invalidate existing positions!</t>
<t tx="ekr.20050826134701.79"></t>
<t tx="ekr.20050826134701.80">def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal

    # Check entire stack quickly.
    # The stack contains vnodes, so this is not a recursive call.
    if p1.v != p2.v or p1.stack != p2.stack:
        return 1 # notEqual

    # This is slow: do this last!
    if p1.childIndex() != p2.childIndex():
        # Disambiguate clones having the same parents.
        return 1 # notEqual

    return 0 # equal</t>
<t tx="ekr.20050826134701.81">if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                print "unknown position attribute:",attr
                import traceback ; traceback.print_stack()
            raise AttributeError,attr</t>
<t tx="ekr.20050826134701.82">def __init__ (self,c,v,stack,trace=True):

    """Create a new position."""
    
    self.c = c
    self.v = v
    assert(v is None or v.t)
    self.stack = stack[:] # Creating a copy here is safest and best.

    g.app.positions += 1
    
    if g.app.tracePositions and trace:
        g.trace("%-25s %-25s %s" % (
            g.callerName(4),g.callerName(3),g.callerName(2)),align=10)
    
    # Note: __getattr__ implements p.t.
</t>
<t tx="ekr.20050826134701.83">@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

def __nonzero__ ( self):
    
    """Return True if a position is valid."""
    
    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None</t>
<t tx="ekr.20050826134701.84">def __str__ (self):
    
    p = self
    
    if p.v:
        return "&lt;pos %d lvl: %d [%d] %s&gt;" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "&lt;pos %d        [%d] None&gt;" % (id(p),len(p.stack))
        
__repr__ = __str__</t>
<t tx="ekr.20050826134701.85"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    if g.app.tracePositions:
        g.trace("%-25s %-25s %s" % (
            g.callerName(4),g.callerName(3),g.callerName(2)),align=10)

    return position(self.c,self.v,self.stack,trace=False)</t>
<t tx="ekr.20050826134701.86">def dumpLink (self,link):

    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):
    
    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label
        
def vnodeListIds (self):
    
    p = self
    return [id(v) for v in p.v.t.vnodeList]</t>
<t tx="ekr.20050826134701.87">def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None.
    """

    p1 = self
    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1.stack == p2.stack and
        p1.childIndex() == p2.childIndex())
        
isEqual = equal
</t>
<t tx="ekr.20050826134701.88"></t>
<t tx="ekr.20050826134701.89"></t>
<t tx="ekr.20050826134701.90">def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)</t>
<t tx="ekr.20050826134701.91">def extraAttributes (self):
    
    return self.v.extraAttributes()

def setExtraAttributes (self,data):

    return self.v.setExtraAttributes(data)</t>
<t tx="ekr.20050826134701.92">def bodyString (self):
    
    return self.v.bodyString()

def headString (self):
    
    return self.v.headString()
    
def cleanHeadString (self):
    
    return self.v.cleanHeadString()
</t>
<t tx="ekr.20050826134701.93">def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()</t>
<t tx="ekr.20050826134701.94">def edit_widget (self):
    
    # New in 4.3 beta 3: let the tree classes do all the work.
    
    p = self ; c = p.c
    
    return c.frame.tree.edit_widget(p)</t>
<t tx="ekr.20050826134701.95">def directParents (self):
    
    return self.v.directParents()
</t>
<t tx="ekr.20050826134701.96">def childIndex(self):
    
    p = self ; v = p.v
    
    # This is time-critical code!
    
    # 3/25/04: Much faster code:
    if not v or not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back

    return n</t>
<t tx="ekr.20050826134701.97"></t>
<t tx="ekr.20050826134701.98">def hasChildren(self):
    
    p = self
    # g.trace(p,p.v)
    return p.v and p.v.t and p.v.t._firstChild</t>
<t tx="ekr.20050826134701.99">def numberOfChildren (self):
    
    return self.v.numberOfChildren()
</t>
<t tx="ekr.20050826134701.100">def exists(self,c):
    
    """Return True if a position exists in c's tree"""
    
    p = self.copy()

    # This code must be fast.
    root = c.rootPosition()

    while p:
        # g.trace(p,'parent',p.parent(),'back',p.back())
        if p == root:
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    return False</t>
<t tx="ekr.20050826134701.101">def findRoot (self):
    
    return self.c.frame.rootPosition()</t>
<t tx="ekr.20050826134701.102"># These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext</t>
<t tx="ekr.20050826134701.103">def hasBack(self):
    return self.v and self.v._back

hasFirstChild = hasChildren
    
def hasNext(self):
    return self.v and self.v._next
    
def hasParent(self):
    return self.v and self.v._parent is not None
    
def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
    
hasVisBack = hasThreadBack</t>
<t tx="ekr.20050826134701.104">def hasThreadNext(self):

    p = self ; v = p.v
    if not p.v: return False

    if v.t._firstChild or v._next:
        return True
    else:
        n = len(p.stack)-1
        v,n = p.vParentWithStack(v,p.stack,n)
        while v:
            if v._next:
                return True
            v,n = p.vParentWithStack(v,p.stack,n)
        return False

hasVisNext = hasThreadNext</t>
<t tx="ekr.20050826134701.105">def isAncestorOf (self, p2):
    
    p = self
    
    if 0: # Avoid the copies made in the iterator.
        for p3 in p2.parents_iter():
            if p3 == p:
                return True

    # Avoid calling p.copy() or copying the stack.
    v2 = p2.v ; n = len(p2.stack)-1
        # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
    while v2:
        if v2 == p.v:
            return True
        v2,n = p2.vParentWithStack(v2,p2.stack,n)

    return False</t>
<t tx="ekr.20050826134701.106"></t>
<t tx="ekr.20050826134701.107">def isCurrentPosition (self):
    
    p = self ; c = p.c
    
    return c.isCurrentPosition(p)
    
</t>
<t tx="ekr.20050826134701.108">def isRootPosition (self):
    
    p = self ; c = p.c
    
    return c.isRootPosition(p)</t>
<t tx="ekr.20050826134701.109">def isCloned (self):
    
    return len(self.v.t.vnodeList) &gt; 1</t>
<t tx="ekr.20050826134701.110">def isRoot (self):
    
    p = self

    return not p.hasParent() and not p.hasBack()</t>
<t tx="ekr.20050826134701.111">def isVisible (self):
    
    """Return True if all of a position's parents are expanded."""

    # v.isVisible no longer exists.
    p = self

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1

    v,n = p.vParentWithStack(v,p.stack,n)
    while v:
        if not v.isExpanded():
            return False
        v,n = p.vParentWithStack(v,p.stack,n)

    return True</t>
<t tx="ekr.20050826134701.112">def oldLastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    assert(p.isVisible())
    last = p.copy()
    while 1:
        if g.app.debug: g.trace(last)
        p.moveToVisNext()
        if not p: break
        last = p.copy()
    return last
        
def lastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    # Move to the last top-level node.
    while p.hasNext():
        if g.app.debug: g.trace(p)
        p.moveToNext()
    assert(p.isVisible())
    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        if g.app.debug: g.trace(p)
        p.moveToLastChild()
    if 0: # This assert is invalid.
        assert(p.isVisible())
    if g.app.debug: g.trace(p)
    return p</t>
<t tx="ekr.20050826134701.113">def simpleLevel(self):
    
    return len([p for p in self.parents_iter()])

def level(self,verbose=False):
    
    p = self ; level = 0
    if not p: return level
        
    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1
    while 1:
        assert(p)
        v,n = p.vParentWithStack(v,p.stack,n)
        if v:
            level += 1
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        else:
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # if g.app.debug: assert(level==self.simpleLevel())
            break
    return level</t>
<t tx="ekr.20050826134701.114"></t>
<t tx="ekr.20050826134701.115"></t>
<t tx="ekr.20050826134701.116"># Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked  (self):
    self.v.clearMarked()
    g.doHook("clear-mark",c=self.c,p=self,v=self)

def clearOrphan  (self): return self.v.clearOrphan()
def clearVisited (self): return self.v.clearVisited()

def contract (self): return self.v.contract()
def expand   (self): return self.v.expand()

def initExpandedBit    (self): return self.v.initExpandedBit()
def initMarkedBit      (self): return self.v.initMarkedBit()
def initStatus (self, status): return self.v.initStatus(status)
    
def setMarked (self):
    self.v.setMarked()
    g.doHook("set-mark",c=self.c,p=self,v=self)

def setOrphan   (self): return self.v.setOrphan()
def setSelected (self): return self.v.setSelected()
def setVisited  (self): return self.v.setVisited()</t>
<t tx="ekr.20050826134701.117">def computeIcon (self):
    
    return self.v.computeIcon()
    
def setIcon (self):

    pass # Compatibility routine for old scripts</t>
<t tx="ekr.20050826134701.118">def setSelection (self,start,length):

    return self.v.setSelection(start,length)</t>
<t tx="ekr.20050826134701.119">def trimTrailingLines (self):

    return self.v.trimTrailingLines()</t>
<t tx="ekr.20050826134701.120">def setTnodeText (self,s,encoding="utf-8"):
    
    return self.v.setTnodeText(s,encoding)</t>
<t tx="ekr.20050826134701.121"></t>
<t tx="ekr.20050826134701.122">def appendStringToBody (self,s,encoding="utf-8"):
    
    p = self
    if not s: return
    
    body = p.bodyString()
    assert(g.isUnicode(body))
    s = g.toUnicode(s,encoding)

    p.setBodyStringOrPane(body + s,encoding)</t>
<t tx="ekr.20050826134701.123">def setBodyStringOrPane (self,s,encoding="utf-8"):

    p = self ; v = p.v ; c = p.c
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts</t>
<t tx="ekr.20050826134701.124">def setHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
    p.setDirty()
    
def initHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
</t>
<t tx="ekr.20050826134701.125">def setHeadStringOrHeadline (self,s,encoding="utf-8"):

    p = self ; t = p.edit_widget()
    
    p.initHeadString(s,encoding)

    if t:
        state = t.cget("state")
        # g.trace(state,s)
        t.configure(state="normal")
        t.delete("1.0","end")
        t.insert("end",s)
        t.configure(state=state)

    p.setDirty()</t>
<t tx="ekr.20050826134701.126">def scriptSetBodyString (self,s,encoding="utf-8"):
    
    """Update the body string for the receiver.
    
    Should be called only from scripts: does NOT update body text."""

    self.v.t.bodyString = g.toUnicode(s,encoding)</t>
<t tx="ekr.20050826134701.127"></t>
<t tx="ekr.20050826134701.128"># Compatibility routine for scripts.

def clearAllVisited (self):
    
    for p in self.allNodes_iter():
        p.clearVisited()</t>
<t tx="ekr.20050826134701.129"># Compatibility routine for scripts.

def clearVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.clearVisited()
</t>
<t tx="ekr.20050826134701.130">def clearAllVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.v.clearVisited()
        p.v.t.clearVisited()
        p.v.t.clearWriteBit()</t>
<t tx="ekr.20050826134701.131"></t>
<t tx="ekr.20050826134701.132">def clearDirty (self):

    p = self
    p.v.clearDirty()</t>
<t tx="ekr.20050826134701.133">def findAllPotentiallyDirtyNodes(self):
    
    p = self 
    
    # Start with all nodes in the vnodeList.
    nodes = []
    newNodes = p.v.t.vnodeList[:]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.t.vnodeList:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
                for v3 in v2.directParents():
                    if v3 not in nodes and v3 not in addedNodes:
                        addedNodes.append(v3)
        newNodes = addedNodes[:]

    # g.trace(len(nodes))
    return nodes</t>
<t tx="ekr.20050826134701.134">def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self ; c = p.c
    dirtyVnodeList = []
    
    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
                
    dirtyVnodeList = [v for v in nodes
        if not v.t.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) &gt; 0

    c.beginUpdate()
    for v in dirtyVnodeList:
        v.t.setDirty() # Do not call v.setDirty here!
    c.endUpdate(changed)

    return dirtyVnodeList</t>
<t tx="ekr.20050826134701.135"># Ensures that all ancestor and descentent @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self,setDescendentsDirty=True):

    p = self ; c = p.c ; dirtyVnodeList = []
    # g.trace(g.app.count) ; g.app.count += 1

    c.beginUpdate()
    if 1: # update...
        if not p.v.t.isDirty():
            p.v.t.setDirty()
            dirtyVnodeList.append(p.v)
        # N.B. This must be called even if p.v is already dirty.
        # Typing can change the @ignore state!
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
        dirtyVnodeList.extend(dirtyVnodeList2)
        changed = len(dirtyVnodeList) &gt; 0
    c.endUpdate(changed)

    return dirtyVnodeList</t>
<t tx="ekr.20050826134701.136">def inAtIgnoreRange (self):
    
    """Returns True if position p or one of p's parents is an @ignore node."""
    
    p = self
    
    for p in p.self_and_parents_iter():
        if p.isAtIgnoreNode():
            return True

    return False</t>
<t tx="ekr.20050826134701.137">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20050826134701.138">def convertTreeToString (self):
    
    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()
    
    array = []
    for p in p.self_and_subtree_iter():
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)
</t>
<t tx="ekr.20050826134701.139">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""
    
    # useVerticalBar is unused, but it would be useful in over-ridden methods.
    __pychecker__ = '--no-argsused'

    p = self
    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20050826134701.140">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; array = []
    lines = string.split(p.bodyString(),'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s) and s[i] in ('+','-','\\'):
            s = s[:i] + '\\' + s[i:]
        array.append(s)
    return '\n'.join(array)</t>
<t tx="ekr.20050826134701.141">@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others</t>
<t tx="ekr.20050826134701.142">def tnodes_iter(self):
    
    """Return all tnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v.t
        
def unique_tnodes_iter(self):
    
    """Return all unique tnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v.t not in marks:
            marks[p.v.t] = p.v.t
            yield p.v.t</t>
<t tx="ekr.20050826134701.143">def vnodes_iter(self):
    
    """Return all vnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_vnodes_iter(self):
    
    """Return all unique vnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="ekr.20050826134701.144">class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    return self.allNodes_iter_class(self,copy)</t>
<t tx="ekr.20050826134701.145">def __init__(self,p,copy):

    self.first = p.c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20050826134701.146">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20050826134701.147">class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=False)
    
def self_and_subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=True)</t>
<t tx="ekr.20050826134701.148">def __init__(self,p,copy,includeSelf):
    
    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20050826134701.149">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration</t>
<t tx="ekr.20050826134701.150">class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):
    
    return self.children_iter_class(self,copy)</t>
<t tx="ekr.20050826134701.151">def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self
</t>
<t tx="ekr.20050826134701.152">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20050826134701.153">class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=False)
    
def self_and_parents_iter(self,copy=False):
    
    return self.parents_iter_class(self,copy,includeSelf=True)</t>
<t tx="ekr.20050826134701.154">def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self</t>
<t tx="ekr.20050826134701.155">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
</t>
<t tx="ekr.20050826134701.156">class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):
    
    return self.siblings_iter_class(self,copy,following)
    
self_and_siblings_iter = siblings_iter
    
def following_siblings_iter (self,copy=False):
    
    return self.siblings_iter_class(self,copy,following=True)</t>
<t tx="ekr.20050826134701.157">def __init__(self,p,copy,following):
    
    # We always include p, even if following is True.
    
    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self

</t>
<t tx="ekr.20050826134701.158">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20050826134701.159"></t>
<t tx="ekr.20050826134701.160">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newPosition):

    """Deletes position p from the outline.  May be undone.

    Returns newPosition."""

    p = self ; c = p.c

    assert(newPosition != p)
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
    c.selectVnode(newPosition)
    
    return newPosition

</t>
<t tx="ekr.20050826134701.161">def insertAfter (self,t=None):

    """Inserts a new position after self.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAfter(p)

    return p2</t>
<t tx="ekr.20050826134701.162">def insertAsLastChild (self,t=None):

    """Inserts a new vnode as the last child of self.
    
    Returns the newly created position."""
    
    p = self
    n = p.numberOfChildren()

    if not t:
        t = tnode(headString="NewHeadline")
    
    return p.insertAsNthChild(n,t)</t>
<t tx="ekr.20050826134701.163">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")
    
    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAsNthChild(p,n)

    return p2</t>
<t tx="ekr.20050826134701.164">def moveToRoot (self,oldRoot=None):

    """Moves a position to the root position."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)
    
    return p</t>
<t tx="ekr.20050826134701.165">def clone (self,back):
    
    """Create a clone of back.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    
    # g.trace(p,back)

    p2 = back.copy()
    p2.v = vnode(c,back.v.t)
    p2.linkAfter(back)

    return p2</t>
<t tx="ekr.20050826134701.166"># This is used by unit tests.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2
    
def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v.t.headString = p.headString()
    p2.v.t.bodyString = p.bodyString()
    for child in p.children_iter(copy=True):
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)</t>
<t tx="ekr.20050826134701.167">def moveAfter (self,a):

    """Move a position after position a."""
    
    p = self ; c = p.c # Do NOT copy the position!
    p.unlink()
    p.linkAfter(a)
    
    # Moving a node after another node can create a new root node.
    if not a.hasParent() and not a.hasBack():
        c.setRootPosition(a)

    return p</t>
<t tx="ekr.20050826134701.168">def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!

    p.unlink()
    n = parent.numberOfChildren()
    p.linkAsNthChild(parent,n)

    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        p.c.setRootPosition(parent)
        
    return p
</t>
<t tx="ekr.20050826134701.169">def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self ; c = p.c # Do NOT copy the position!
    
    # g.trace(p,parent,n)

    p.unlink()
    p.linkAsNthChild(parent,n)
    
    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        c.setRootPosition(parent)

    return p
</t>
<t tx="ekr.20050826134701.170"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):
    
    p = self
    result = True # optimists get only unpleasant surprises.
    parent = p.getParent()
    childIndex = p.childIndex()
    
    # g.trace(p,parent,pv)
    &lt;&lt; validate parent ivar &gt;&gt;
    &lt;&lt; validate childIndex ivar &gt;&gt;
    &lt;&lt; validate x ivar &gt;&gt;

    # Recursively validate all the children.
    for child in p.children_iter():
        r = child.validateOutlineWithParent(p)
        if not r: result = False

    return result</t>
<t tx="ekr.20050826134701.171">if parent != pv:
    p.invalidOutline( "Invalid parent link: " + repr(parent))</t>
<t tx="ekr.20050826134701.172">if pv:
    if childIndex &lt; 0:
        p.invalidOutline ( "missing childIndex" + childIndex )
    elif childIndex &gt;= pv.numberOfChildren():
        p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
    p.invalidOutline ( "negative childIndex" + childIndex )</t>
<t tx="ekr.20050826134701.173">if not p.v.t and pv:
    self.invalidOutline ( "Empty t" )</t>
<t tx="ekr.20050826134701.174">def invalidOutline (self, message):
    
    p = self

    if p.hasParent():
        node = p.parent()
    else:
        node = p

    g.alert("invalid outline: %s\n%s" % (message,node))</t>
<t tx="ekr.20050826134701.175">@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()</t>
<t tx="ekr.20050826134701.176">def moveToBack (self):
    
    """Move self to its previous sibling."""
    
    p = self

    p.v = p.v and p.v._back
    
    return p</t>
<t tx="ekr.20050826134701.177">def moveToFirstChild (self):

    """Move a position to it's first child's position."""
    
    p = self

    if p:
        child = p.v.t._firstChild
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
        
    return p

</t>
<t tx="ekr.20050826134701.178">def moveToLastChild (self):
    
    """Move a position to it's last child's position."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            child = p.v.lastChild()
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p
</t>
<t tx="ekr.20050826134701.179">def moveToLastNode (self):
    
    """Move a position to last node of its tree.
    
    N.B. Returns p if p has no children."""
    
    p = self
    
    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()

    return p</t>
<t tx="ekr.20050826134701.180">def moveToNext (self):
    
    """Move a position to its next sibling."""
    
    p = self
    
    p.v = p.v and p.v._next
    
    return p</t>
<t tx="ekr.20050826134701.181">def moveToNodeAfterTree (self):
    
    """Move a position to the node after the position's tree."""
    
    p = self
    
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
</t>
<t tx="ekr.20050826134701.182">def moveToNthChild (self,n):
    
    p = self
    
    if p:
        child = p.v.nthChild(n) # Must call vnode method here!
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p</t>
<t tx="ekr.20050826134701.183">def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    if not p: return p

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
    else:
        p.v = None
    return p</t>
<t tx="ekr.20050826134701.184">def moveToThreadBack (self):
    
    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p</t>
<t tx="ekr.20050826134701.185">def moveToThreadNext (self):
    
    """Move a position to the next a position in threading order."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            p.moveToFirstChild()
        elif p.v._next:
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.v._next:
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.
                
    return p</t>
<t tx="ekr.20050826134701.186">def moveToVisBack (self):
    
    """Move a position to the position of the previous visible node."""

    p = self
    
    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p</t>
<t tx="ekr.20050826134701.187">def moveToVisNext (self):
    
    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()
            
    return p</t>
<t tx="ekr.20050826134701.188"></t>
<t tx="ekr.20050826134701.189"># A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

&lt;&lt; about the vParentWithStack utility method &gt;&gt;

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n &gt;= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n</t>
<t tx="ekr.20050826134701.190">@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)

</t>
<t tx="ekr.20050826134701.191">def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""
    
    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = True # zodb support.
        
    for p in root.children_iter():
        p.restoreLinksInTree()</t>
<t tx="ekr.20050826134701.192">def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()
    
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)</t>
<t tx="ekr.20050826134701.193">def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = True # zodb support.
        assert(p.v not in p.v.t.vnodeList)
        # g.trace("deleted",p.v,p.vnodeListIds())
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()</t>
<t tx="ekr.20050826134701.194">def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)</t>
<t tx="ekr.20050826134701.195"># These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.</t>
<t tx="ekr.20050826134701.196">def linkAfter (self,after):

    """Link self after v."""
    
    p = self
    # g.trace(p,after)
    
    p.stack = after.stack[:] # 3/12/04
    p.v._parent = after.v._parent
    
    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = True # zodb support.
    
    p.v._back = after.v
    p.v._next = after.v._next
    
    after.v._next = p.v
    
    if p.v._next:
        p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")</t>
<t tx="ekr.20050826134701.197">def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of vnode pv"""
    
    # g.trace(self,parent,n)
    p = self

    # Recreate the stack using the parent.
    p.stack = parent.stack[:] 
    if parent.isCloned():
        p.stack.append(parent.v)

    p.v._parent = parent.v

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = True # zodb support.

    if n == 0:
        child1 = parent.v.t._firstChild
        p.v._back = None
        p.v._next = child1
        if child1:
            child1._back = p.v
        parent.v.t._firstChild = p.v
    else:
        prev = parent.nthChild(n-1) # zero based
        assert(prev)
        p.v._back = prev.v
        p.v._next = prev.v._next
        prev.v._next = p.v
        if p.v._next:
            p.v._next._back = p.v
            
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")</t>
<t tx="ekr.20050826134701.198">def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""
    
    # g.trace(self,oldRoot)

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    p.stack = [] # Clear the stack.
    
    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRootVnode # Bug fix: 3/12/04
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = True # zodb support.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        oldRoot.v._back = v # Bug fix: 3/12/04

    p.c.setRootPosition(p)
    
    if 0:
        p.dump(label="root")
</t>
<t tx="ekr.20050826134701.199">def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""
    
    # Warning: p.parent() is NOT necessarily the same as p.v._parent!

    p = self ; v = p.v
    
    # g.trace('p.v._parent',p.v._parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Special case the root.
    if p == p.c.rootPosition():
        assert(p.v._next)
        p.c.setRootPosition(p.next())
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = True # zodb support.
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if p.v._parent:
        assert(p.v and p.v._parent in p.v.directParents())
        if p.v._parent.t._firstChild == v:
            #g.trace('resetting _parent.v.t._firstChild to',v._next)
            p.v._parent.t._firstChild = v._next
    else:
        parent = p.parent()
        if parent:
            assert(parent.v in p.v.directParents())
            if parent.v.t._firstChild == v:
                #g.trace('resetting parent().v.t._firstChild to',v._next)
                parent.v.t._firstChild = v._next

    # Do NOT delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")</t>
<t tx="ekr.20050826135159">def __hash__ (self):
    
    return id(self)
    
def __cmp__(self,other):
    
    # Must return 0, 1 or -1
    
    if self is other:
        return 0
    elif id(self) &gt; id(other):
        return 1
    else:
        return -1</t>
<t tx="ekr.20050826142105">def openWithFileName_callback (
    fileName,old_c,
    enableLog=True,
    readAtFileNodesFlag=True,
    forceDiskRead=True,
    zodbController=zodbController
):
    return  zodb_openWithFileName(
        fileName,old_c,
        enableLog=enableLog,
        readAtFileNodesFlag=readAtFileNodesFlag,
        forceDiskRead=forceDiskRead,
        zodbController=zodbController)
</t>
<t tx="ekr.20050826142105.1">def write_Leo_file_callback (self,fileName,outlineOnlyFlag,zodbController=zodbController):

    return zodb_write_Leo_file(self,
        fileName,outlineOnlyFlag,zodbController=zodbController)</t>
<t tx="ekr.20060904171303"></t>
<t tx="ekr.20060904174727">findTestsInModule: Exception in inspect.getmembers(theClass,inspect.ismethod) for leoNodes
findTestsInModule: Exception in inspect.getmembers(theClass,inspect.ismethod) for leoNodes
findTestsInModule: Exception in inspect.getmembers(theClass,inspect.ismethod) for leoNodes
</t>
<t tx="ekr.20060904175413"></t>
<t tx="ekr.20060904200020">def ok (self):
    
    return self.storage is not None</t>
<t tx="ekr.20060904201421"></t>
</tnodes>
</leo_file>
