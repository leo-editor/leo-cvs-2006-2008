<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.541463414634">
	<global_window_position top="49" left="292" height="820" width="800"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20071201085451"><vh>startup</vh>
<v t="ekr.20071129105118"><vh>@chapters</vh></v>
<v t="ekr.20071129121221"><vh>@settings</vh>
<v t="ekr.20071129121210"><vh>@bool at_auto_warns_about_leading_whitespace = False</vh></v>
</v>
<v t="ekr.20071201082618"><vh>create-at-auto-nodes</vh></v>
</v>
<v t="ekr.20071201085901" a="TV"><vh>Read me</vh></v>
<v t="ekr.20071129105323"><vh>@path c:\Python25\Lib\site-packages\IPython</vh>
<v t="ekr.20071129110733"><vh>top level</vh>
<v t="ekr.20071129105210.71"><vh>@@auto background_jobs.py</vh>
<v t="ekr.20071201085751"><vh>background_jobs declarations</vh></v>
<v t="ekr.20071201085751.1"><vh>class BackgroundJobManager</vh>
<v t="ekr.20071201085751.2"><vh>__init__</vh></v>
<v t="ekr.20071201085751.3"><vh>new</vh></v>
<v t="ekr.20071201085751.4"><vh>__getitem__</vh></v>
<v t="ekr.20071201085751.5"><vh>__call__</vh></v>
<v t="ekr.20071201085751.6"><vh>_update_status</vh></v>
<v t="ekr.20071201085751.7"><vh>_group_report</vh></v>
<v t="ekr.20071201085751.8"><vh>_group_flush</vh></v>
<v t="ekr.20071201085751.9"><vh>_status_new</vh></v>
<v t="ekr.20071201085751.10"><vh>status</vh></v>
<v t="ekr.20071201085751.11"><vh>remove</vh></v>
<v t="ekr.20071201085751.12"><vh>flush_finished</vh></v>
<v t="ekr.20071201085751.13"><vh>result</vh></v>
<v t="ekr.20071201085751.14"><vh>traceback</vh></v>
</v>
<v t="ekr.20071201085751.15"><vh>class BackgroundJobBase</vh>
<v t="ekr.20071201085751.16"><vh>__init__</vh></v>
<v t="ekr.20071201085751.17"><vh>_init</vh></v>
<v t="ekr.20071201085751.18"><vh>__str__</vh></v>
<v t="ekr.20071201085751.19"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.20"><vh>traceback</vh></v>
<v t="ekr.20071201085751.21"><vh>run</vh></v>
</v>
<v t="ekr.20071201085751.22"><vh>class BackgroundJobExpr</vh>
<v t="ekr.20071201085751.23"><vh>__init__</vh></v>
<v t="ekr.20071201085751.24"><vh>call</vh></v>
</v>
<v t="ekr.20071201085751.25"><vh>class BackgroundJobFunc</vh>
<v t="ekr.20071201085751.26"><vh>__init__</vh></v>
<v t="ekr.20071201085751.27"><vh>call</vh></v>
</v>
</v>
<v t="ekr.20071129105210.72"><vh>@@auto ColorANSI.py</vh>
<v t="ekr.20071201085751.28"><vh>ColorANSI declarations</vh></v>
<v t="ekr.20071201085751.29"><vh>make_color_table</vh></v>
<v t="ekr.20071201085751.30"><vh>class TermColors</vh></v>
<v t="ekr.20071201085751.31"><vh>class InputTermColors</vh></v>
<v t="ekr.20071201085751.32"><vh>class ColorScheme</vh>
<v t="ekr.20071201085751.33"><vh>__init__</vh></v>
<v t="ekr.20071201085751.34"><vh>copy</vh></v>
</v>
<v t="ekr.20071201085751.35"><vh>class ColorSchemeTable</vh>
<v t="ekr.20071201085751.36"><vh>__init__</vh></v>
<v t="ekr.20071201085751.37"><vh>copy</vh></v>
<v t="ekr.20071201085751.38"><vh>add_scheme</vh></v>
<v t="ekr.20071201085751.39"><vh>set_active_scheme</vh></v>
</v>
</v>
<v t="ekr.20071129105210.73"><vh>@@auto completer.py</vh>
<v t="ekr.20071201085751.40"><vh>completer declarations</vh></v>
<v t="ekr.20071201085751.41"><vh>get_class_members</vh></v>
<v t="ekr.20071201085751.42"><vh>class Completer</vh>
<v t="ekr.20071201085751.43"><vh>__init__</vh></v>
<v t="ekr.20071201085751.44"><vh>complete</vh></v>
<v t="ekr.20071201085751.45"><vh>global_matches</vh></v>
<v t="ekr.20071201085751.46"><vh>attr_matches</vh></v>
</v>
<v t="ekr.20071201085751.47"><vh>class IPCompleter</vh>
<v t="ekr.20071201085751.48"><vh>__init__</vh></v>
<v t="ekr.20071201085751.49"><vh>all_completions</vh></v>
<v t="ekr.20071201085751.50"><vh>_clean_glob</vh></v>
<v t="ekr.20071201085751.51"><vh>_clean_glob_win32</vh></v>
<v t="ekr.20071201085751.52"><vh>file_matches</vh></v>
<v t="ekr.20071201085751.53"><vh>alias_matches</vh></v>
<v t="ekr.20071201085751.54"><vh>python_matches</vh></v>
<v t="ekr.20071201085751.55"><vh>_default_arguments</vh></v>
<v t="ekr.20071201085751.56"><vh>python_func_kw_matches</vh></v>
<v t="ekr.20071201085751.57"><vh>dispatch_custom_completer</vh></v>
<v t="ekr.20071201085751.58"><vh>complete</vh></v>
</v>
</v>
<v t="ekr.20071129105210.74"><vh>@@auto ConfigLoader.py</vh>
<v t="ekr.20071201085751.59"><vh>ConfigLoader declarations</vh></v>
<v t="ekr.20071201085751.60"><vh>class ConfigLoaderError</vh>
<v t="ekr.20071201085751.61"><vh>__init__</vh></v>
</v>
<v t="ekr.20071201085751.62"><vh>class ConfigLoader</vh>
<v t="ekr.20071201085751.63"><vh>__init__</vh></v>
<v t="ekr.20071201085751.64"><vh>reset</vh></v>
<v t="ekr.20071201085751.65"><vh>load</vh></v>
</v>
</v>
<v t="ekr.20071129105210.75" a="M"><vh>@@auto CrashHandler.py (bad import)</vh>
<v t="ekr.20071129105657.66"><vh>CrashHandler declarations</vh></v>
<v t="ekr.20071129105657.67"><vh>class CrashHandler</vh>
<v t="ekr.20071129105657.68"><vh>__init__</vh></v>
<v t="ekr.20071129105657.69"><vh>__call__</vh></v>
<v t="ekr.20071129105657.70"><vh>make_report</vh></v>
</v>
<v t="ekr.20071129105657.71"><vh>class IPythonCrashHandler</vh>
<v t="ekr.20071129105657.72"><vh>__init__</vh></v>
<v t="ekr.20071129105657.73"><vh>make_report</vh></v>
</v>
</v>
<v t="ekr.20071129105210.76"><vh>@@auto Debugger.py</vh>
<v t="ekr.20071201085751.66"><vh>Debugger declarations</vh></v>
<v t="ekr.20071201085751.67"><vh>decorate_fn_with_doc</vh></v>
<v t="ekr.20071201085751.68"><vh>_file_lines</vh></v>
<v t="ekr.20071201085751.69"><vh>class Pdb</vh>
<v t="ekr.20071201085751.70"><vh>set_colors</vh></v>
<v t="ekr.20071201085751.71"><vh>interaction</vh></v>
<v t="ekr.20071201085751.72"><vh>new_do_up</vh></v>
<v t="ekr.20071201085751.73"><vh>new_do_down</vh></v>
<v t="ekr.20071201085751.74"><vh>new_do_frame</vh></v>
<v t="ekr.20071201085751.75"><vh>new_do_quit</vh></v>
<v t="ekr.20071201085751.76"><vh>new_do_restart</vh></v>
<v t="ekr.20071201085751.77"><vh>postloop</vh></v>
<v t="ekr.20071201085751.78"><vh>print_stack_trace</vh></v>
<v t="ekr.20071201085751.79"><vh>print_stack_entry</vh></v>
<v t="ekr.20071201085751.80"><vh>format_stack_entry</vh></v>
<v t="ekr.20071201085751.81"><vh>__format_line</vh></v>
<v t="ekr.20071201085751.82"><vh>list_command_pydb</vh></v>
<v t="ekr.20071201085751.83"><vh>print_list_lines</vh></v>
<v t="ekr.20071201085751.84"><vh>do_list</vh></v>
<v t="ekr.20071201085751.85"><vh>do_pdef</vh></v>
<v t="ekr.20071201085751.86"><vh>do_pdoc</vh></v>
<v t="ekr.20071201085751.87"><vh>do_pinfo</vh></v>
</v>
</v>
<v t="ekr.20071129105210.77"><vh>@@auto deep_reload.py</vh>
<v t="ekr.20071201085751.88"><vh>deep_reload declarations</vh></v>
<v t="ekr.20071201085751.89"><vh>deep_import_hook</vh></v>
<v t="ekr.20071201085751.90"><vh>determine_parent</vh></v>
<v t="ekr.20071201085751.91"><vh>find_head_package</vh></v>
<v t="ekr.20071201085751.92"><vh>load_tail</vh></v>
<v t="ekr.20071201085751.93"><vh>ensure_fromlist</vh></v>
<v t="ekr.20071201085751.94"><vh>import_module</vh></v>
<v t="ekr.20071201085751.95"><vh>deep_reload_hook</vh></v>
<v t="ekr.20071201085751.96"><vh>reload</vh></v>
</v>
<v t="ekr.20071129105210.78"><vh>@@auto demo.py</vh>
<v t="ekr.20071201085751.97"><vh>demo declarations</vh></v>
<v t="ekr.20071201085751.98"><vh>class DemoError</vh></v>
<v t="ekr.20071201085751.99"><vh>re_mark</vh></v>
<v t="ekr.20071201085751.100"><vh>class Demo</vh>
<v t="ekr.20071201085751.101"><vh>__init__</vh></v>
<v t="ekr.20071201085751.102"><vh>reload</vh></v>
<v t="ekr.20071201085751.103"><vh>reset</vh></v>
<v t="ekr.20071201085751.104"><vh>_validate_index</vh></v>
<v t="ekr.20071201085751.105"><vh>_get_index</vh></v>
<v t="ekr.20071201085751.106"><vh>seek</vh></v>
<v t="ekr.20071201085751.107"><vh>back</vh></v>
<v t="ekr.20071201085751.108"><vh>jump</vh></v>
<v t="ekr.20071201085751.109"><vh>again</vh></v>
<v t="ekr.20071201085751.110"><vh>edit</vh></v>
<v t="ekr.20071201085751.111"><vh>show</vh></v>
<v t="ekr.20071201085751.112"><vh>show_all</vh></v>
<v t="ekr.20071201085751.113"><vh>runlines</vh></v>
<v t="ekr.20071201085751.114"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.115"><vh>class IPythonDemo</vh>
<v t="ekr.20071201085751.116"><vh>runlines</vh></v>
</v>
<v t="ekr.20071201085751.117"><vh>class LineDemo</vh>
<v t="ekr.20071201085751.118"><vh>reload</vh></v>
</v>
<v t="ekr.20071201085751.119"><vh>class IPythonLineDemo</vh></v>
</v>
<v t="ekr.20071129111837"><vh>@@auto DPyGetOpt.py</vh>
<v t="ekr.20071201085751.120"><vh>DPyGetOpt declarations</vh></v>
<v t="ekr.20071201085751.121"><vh>class DPyGetOpt</vh>
<v t="ekr.20071201085751.122"><vh>__init__</vh></v>
<v t="ekr.20071201085751.123"><vh>setPosixCompliance</vh></v>
<v t="ekr.20071201085751.124"><vh>isPosixCompliant</vh></v>
<v t="ekr.20071201085751.125"><vh>setIgnoreCase</vh></v>
<v t="ekr.20071201085751.126"><vh>ignoreCase</vh></v>
<v t="ekr.20071201085751.127"><vh>setAllowAbbreviations</vh></v>
<v t="ekr.20071201085751.128"><vh>willAllowAbbreviations</vh></v>
<v t="ekr.20071201085751.129"><vh>addTerminator</vh></v>
<v t="ekr.20071201085751.130"><vh>_addOption</vh></v>
<v t="ekr.20071201085751.131"><vh>addOptionConfigurationTuple</vh></v>
<v t="ekr.20071201085751.132"><vh>addOptionConfigurationTuples</vh></v>
<v t="ekr.20071201085751.133"><vh>parseConfiguration</vh></v>
<v t="ekr.20071201085751.134"><vh>_getArgTuple</vh></v>
<v t="ekr.20071201085751.135"><vh>_isTerminator</vh></v>
<v t="ekr.20071201085751.136"><vh>processArguments</vh></v>
<v t="ekr.20071201085751.137"><vh>valueForOption</vh></v>
</v>
<v t="ekr.20071201085751.138"><vh>_test</vh></v>
</v>
<v t="ekr.20071129105210.80"><vh>@@auto excolors.py</vh>
<v t="ekr.20071201085751.139"><vh>excolors declarations</vh></v>
</v>
<v t="ekr.20071129105210.81"><vh>@@auto FakeModule.py</vh>
<v t="ekr.20071201085751.140"><vh>FakeModule declarations</vh></v>
<v t="ekr.20071201085751.141"><vh>class FakeModule</vh>
<v t="ekr.20071201085751.142"><vh>__init__</vh></v>
<v t="ekr.20071201085751.143"><vh>__getattr__</vh></v>
<v t="ekr.20071201085751.144"><vh>__str__</vh></v>
<v t="ekr.20071201085751.145"><vh>__repr__</vh></v>
</v>
</v>
<v t="ekr.20071129105210.82"><vh>@@auto genutils.py</vh>
<v t="ekr.20071201085751.146"><vh>genutils declarations</vh></v>
<v t="ekr.20071201085751.147"><vh>class Error</vh></v>
<v t="ekr.20071201085751.148"><vh>class IOStream</vh>
<v t="ekr.20071201085751.149"><vh>__init__</vh></v>
<v t="ekr.20071201085751.150"><vh>write</vh></v>
</v>
<v t="ekr.20071201085751.151"><vh>class IOTerm</vh>
<v t="ekr.20071201085751.152"><vh>__init__</vh></v>
</v>
<v t="ekr.20071201085751.153"><vh>warn</vh></v>
<v t="ekr.20071201085751.154"><vh>info</vh></v>
<v t="ekr.20071201085751.155"><vh>error</vh></v>
<v t="ekr.20071201085751.156"><vh>fatal</vh></v>
<v t="ekr.20071201085751.157"><vh>debugx</vh></v>
<v t="ekr.20071201085751.158"><vh>timings_out</vh></v>
<v t="ekr.20071201085751.159"><vh>timings</vh></v>
<v t="ekr.20071201085751.160"><vh>timing</vh></v>
<v t="ekr.20071201085751.161"><vh>arg_split</vh></v>
<v t="ekr.20071201085751.162"><vh>system</vh></v>
<v t="ekr.20071201085751.163"><vh>shell</vh></v>
<v t="ekr.20071201085751.164"><vh>getoutput</vh></v>
<v t="ekr.20071201085751.165"><vh>getoutputerror</vh></v>
<v t="ekr.20071201085751.166"><vh>class SystemExec</vh>
<v t="ekr.20071201085751.167"><vh>__init__</vh></v>
<v t="ekr.20071201085751.168"><vh>system</vh></v>
<v t="ekr.20071201085751.169"><vh>shell</vh></v>
<v t="ekr.20071201085751.170"><vh>getoutput</vh></v>
<v t="ekr.20071201085751.171"><vh>getoutputerror</vh></v>
</v>
<v t="ekr.20071201085751.172"><vh>mutex_opts</vh></v>
<v t="ekr.20071201085751.173"><vh>get_py_filename</vh></v>
<v t="ekr.20071201085751.174"><vh>filefind</vh></v>
<v t="ekr.20071201085751.175"><vh>file_read</vh></v>
<v t="ekr.20071201085751.176"><vh>file_readlines</vh></v>
<v t="ekr.20071201085751.177"><vh>target_outdated</vh></v>
<v t="ekr.20071201085751.178"><vh>target_update</vh></v>
<v t="ekr.20071201085751.179"><vh>unquote_ends</vh></v>
<v t="ekr.20071201085751.180"><vh>process_cmdline</vh></v>
<v t="ekr.20071201085751.181"><vh>optstr2types</vh></v>
<v t="ekr.20071201085751.182"><vh>read_dict</vh></v>
<v t="ekr.20071201085751.183"><vh>flag_calls</vh></v>
<v t="ekr.20071201085751.184"><vh>class HomeDirError</vh></v>
<v t="ekr.20071201085751.185"><vh>get_home_dir</vh></v>
<v t="ekr.20071201085751.186"><vh>class LSString</vh>
<v t="ekr.20071201085751.187"><vh>get_list</vh></v>
<v t="ekr.20071201085751.188"><vh>get_spstr</vh></v>
<v t="ekr.20071201085751.189"><vh>get_nlstr</vh></v>
<v t="ekr.20071201085751.190"><vh>get_paths</vh></v>
</v>
<v t="ekr.20071201085751.191"><vh>class SList</vh>
<v t="ekr.20071201085751.192"><vh>get_list</vh></v>
<v t="ekr.20071201085751.193"><vh>get_spstr</vh></v>
<v t="ekr.20071201085751.194"><vh>get_nlstr</vh></v>
<v t="ekr.20071201085751.195"><vh>get_paths</vh></v>
</v>
<v t="ekr.20071201085751.196"><vh>esc_quotes</vh></v>
<v t="ekr.20071201085751.197"><vh>make_quoted_expr</vh></v>
<v t="ekr.20071201085751.198"><vh>raw_input_multi</vh></v>
<v t="ekr.20071201085751.199"><vh>raw_input_ext</vh></v>
<v t="ekr.20071201085751.200"><vh>ask_yes_no</vh></v>
<v t="ekr.20071201085751.201"><vh>marquee</vh></v>
<v t="ekr.20071201085751.202"><vh>class EvalDict</vh>
<v t="ekr.20071201085751.203"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20071201085751.204"><vh>qw</vh></v>
<v t="ekr.20071201085751.205"><vh>qwflat</vh></v>
<v t="ekr.20071201085751.206"><vh>qw_lol</vh></v>
<v t="ekr.20071201085751.207"><vh>list_strings</vh></v>
<v t="ekr.20071201085751.208"><vh>grep</vh></v>
<v t="ekr.20071201085751.209"><vh>dgrep</vh></v>
<v t="ekr.20071201085751.210"><vh>idgrep</vh></v>
<v t="ekr.20071201085751.211"><vh>igrep</vh></v>
<v t="ekr.20071201085751.212"><vh>indent</vh></v>
<v t="ekr.20071201085751.213"><vh>native_line_ends</vh></v>
<v t="ekr.20071201085751.214"><vh>get_pager_cmd</vh></v>
<v t="ekr.20071201085751.215"><vh>get_pager_start</vh></v>
<v t="ekr.20071201085751.216"><vh>page_dumb</vh></v>
<v t="ekr.20071201085751.217"><vh>page</vh></v>
<v t="ekr.20071201085751.218"><vh>page_file</vh></v>
<v t="ekr.20071201085751.219"><vh>snip_print</vh></v>
<v t="ekr.20071201085751.220"><vh>belong</vh></v>
<v t="ekr.20071201085751.221"><vh>uniq_stable</vh></v>
<v t="ekr.20071201085751.222"><vh>class NLprinter</vh>
<v t="ekr.20071201085751.223"><vh>__init__</vh></v>
<v t="ekr.20071201085751.224"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.225"><vh>all_belong</vh></v>
<v t="ekr.20071201085751.226"><vh>sort_compare</vh></v>
<v t="ekr.20071201085751.227"><vh>mkdict</vh></v>
<v t="ekr.20071201085751.228"><vh>list2dict</vh></v>
<v t="ekr.20071201085751.229"><vh>list2dict2</vh></v>
<v t="ekr.20071201085751.230"><vh>flatten</vh></v>
<v t="ekr.20071201085751.231"><vh>get_slice</vh></v>
<v t="ekr.20071201085751.232"><vh>chop</vh></v>
<v t="ekr.20071201085751.233"><vh>with_obj</vh></v>
<v t="ekr.20071201085751.234"><vh>setattr_list</vh></v>
<v t="ekr.20071201085751.235"><vh>getattr_list</vh></v>
<v t="ekr.20071201085751.236"><vh>map_method</vh></v>
<v t="ekr.20071201085751.237"><vh>import_fail_info</vh></v>
<v t="ekr.20071201085751.238"><vh>class NotGiven</vh></v>
<v t="ekr.20071201085751.239"><vh>popkey</vh></v>
<v t="ekr.20071201085751.240"><vh>wrap_deprecated</vh></v>
</v>
<v t="ekr.20071129105210.83"><vh>@@auto Gnuplot2.py</vh>
<v t="ekr.20071201085751.241"><vh>Gnuplot2 declarations</vh></v>
<v t="ekr.20071201085751.242"><vh>eps_fix_bbox</vh></v>
<v t="ekr.20071201085751.243"><vh>is_list1d</vh></v>
<v t="ekr.20071201085751.244"><vh>zip_items</vh></v>
<v t="ekr.20071201085751.245"><vh>class String</vh>
<v t="ekr.20071201085751.246"><vh>__init__</vh></v>
</v>
<v t="ekr.20071201085751.247"><vh>class Gnuplot</vh>
<v t="ekr.20071201085751.248"><vh>xrange</vh></v>
<v t="ekr.20071201085751.249"><vh>yrange</vh></v>
<v t="ekr.20071201085751.250"><vh>zrange</vh></v>
<v t="ekr.20071201085751.251"><vh>x2range</vh></v>
<v t="ekr.20071201085751.252"><vh>y2range</vh></v>
<v t="ekr.20071201085751.253"><vh>z2range</vh></v>
<v t="ekr.20071201085751.254"><vh>rrange</vh></v>
<v t="ekr.20071201085751.255"><vh>trange</vh></v>
<v t="ekr.20071201085751.256"><vh>urange</vh></v>
<v t="ekr.20071201085751.257"><vh>vrange</vh></v>
<v t="ekr.20071201085751.258"><vh>set_ps</vh></v>
<v t="ekr.20071201085751.259"><vh>__plot_ps</vh></v>
<v t="ekr.20071201085751.260"><vh>plot</vh></v>
<v t="ekr.20071201085751.261"><vh>plot2</vh></v>
<v t="ekr.20071201085751.262"><vh>splot</vh></v>
<v t="ekr.20071201085751.263"><vh>replot</vh></v>
<v t="ekr.20071201085751.264"><vh>hardcopy</vh></v>
</v>
</v>
<v t="ekr.20071129105210.84"><vh>@@auto GnuplotInteractive.py</vh>
<v t="ekr.20071201085751.265"><vh>GnuplotInteractive declarations</vh></v>
<v t="ekr.20071201085751.266"><vh>gphelp</vh></v>
<v t="ekr.20071201085751.267"><vh>magic_gpc</vh></v>
<v t="ekr.20071201085751.268"><vh>magic_gp_set_default</vh></v>
</v>
<v t="ekr.20071129105210.85"><vh>@@auto GnuplotRuntime.py</vh>
<v t="ekr.20071201085751.269"><vh>GnuplotRuntime declarations</vh></v>
<v t="ekr.20071201085751.270"><vh>class NotGiven</vh></v>
<v t="ekr.20071201085751.271"><vh>gp_new</vh></v>
</v>
<v t="ekr.20071129122202.272"><vh>@@auto hooks.py</vh>
<v t="ekr.20071201085751.272"><vh>hooks declarations</vh></v>
<v t="ekr.20071201085751.273"><vh>editor</vh></v>
<v t="ekr.20071201085751.274"><vh>fix_error_editor</vh></v>
<v t="ekr.20071201085751.275"><vh>class CommandChainDispatcher</vh>
<v t="ekr.20071201085751.276"><vh>__init__</vh></v>
<v t="ekr.20071201085751.277"><vh>__call__</vh></v>
<v t="ekr.20071201085751.278"><vh>__str__</vh></v>
<v t="ekr.20071201085751.279"><vh>add</vh></v>
<v t="ekr.20071201085751.280"><vh>__iter__</vh></v>
</v>
<v t="ekr.20071201085751.281"><vh>result_display</vh></v>
<v t="ekr.20071201085751.282"><vh>input_prefilter</vh></v>
<v t="ekr.20071201085751.283"><vh>shutdown_hook</vh></v>
<v t="ekr.20071201085751.284"><vh>late_startup_hook</vh></v>
<v t="ekr.20071201085751.285"><vh>generate_prompt</vh></v>
<v t="ekr.20071201085751.286"><vh>generate_output_prompt</vh></v>
</v>
<v t="ekr.20071129105210.87"><vh>@@auto ipapi.py</vh>
<v t="ekr.20071201085751.287"><vh>ipapi declarations</vh></v>
<v t="ekr.20071201085751.288"><vh>class TryNext</vh>
<v t="ekr.20071201085751.289"><vh>__init__</vh></v>
</v>
<v t="ekr.20071201085751.290"><vh>class IPythonNotRunning</vh>
<v t="ekr.20071201085751.291"><vh>__str__</vh></v>
<v t="ekr.20071201085751.292"><vh>__getattr__</vh></v>
<v t="ekr.20071201085751.293"><vh>dummy</vh></v>
</v>
<v t="ekr.20071201085751.294"><vh>get</vh></v>
<v t="ekr.20071201085751.295"><vh>class IPApi</vh>
<v t="ekr.20071201085751.296"><vh>__init__</vh></v>
<v t="ekr.20071201085751.297"><vh>get_db</vh></v>
<v t="ekr.20071201085751.298"><vh>get_options</vh></v>
<v t="ekr.20071201085751.299"><vh>expose_magic</vh></v>
<v t="ekr.20071201085751.300"><vh>ex</vh></v>
<v t="ekr.20071201085751.301"><vh>ev</vh></v>
<v t="ekr.20071201085751.302"><vh>runlines</vh></v>
<v t="ekr.20071201085751.303"><vh>to_user_ns</vh></v>
</v>
<v t="ekr.20071201085751.304"><vh>launch_new_instance</vh></v>
<v t="ekr.20071201085751.305"><vh>make_user_ns</vh></v>
<v t="ekr.20071201085751.306"><vh>make_user_global_ns</vh></v>
<v t="ekr.20071201085751.307"><vh>make_session</vh></v>
</v>
<v t="ekr.20071129105210.88"><vh>@@auto iplib.py</vh>
<v t="ekr.20071201085751.308"><vh>iplib declarations</vh></v>
<v t="ekr.20071201085751.309"><vh>num_ini_spaces</vh></v>
<v t="ekr.20071201085751.310"><vh>softspace</vh></v>
<v t="ekr.20071201085751.311"><vh>class SpaceInInput</vh></v>
<v t="ekr.20071201085751.312"><vh>class Bunch</vh></v>
<v t="ekr.20071201085751.313"><vh>class Undefined</vh></v>
<v t="ekr.20071201085751.314"><vh>class Quitter</vh>
<v t="ekr.20071201085751.315"><vh>__init__</vh></v>
<v t="ekr.20071201085751.316"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.317"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.318"><vh>class InputList</vh>
<v t="ekr.20071201085751.319"><vh>__getslice__</vh></v>
</v>
<v t="ekr.20071201085751.320"><vh>class SyntaxTB</vh>
<v t="ekr.20071201085751.321"><vh>__init__</vh></v>
<v t="ekr.20071201085751.322"><vh>__call__</vh></v>
<v t="ekr.20071201085751.323"><vh>clear_err_state</vh></v>
</v>
<v t="ekr.20071201085751.324"><vh>class InteractiveShell</vh>
<v t="ekr.20071201085751.325"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20071129105210.89"><vh>@@auto ipmaker.py</vh>
<v t="ekr.20071201085751.326"><vh>ipmaker declarations</vh></v>
<v t="ekr.20071201085751.327"><vh>make_IPython</vh></v>
</v>
<v t="ekr.20071129105210.90"><vh>@@auto ipstruct.py</vh>
<v t="ekr.20071201085751.328"><vh>ipstruct declarations</vh></v>
<v t="ekr.20071201085751.329"><vh>class Struct</vh>
<v t="ekr.20071201085751.330"><vh>__init__</vh></v>
<v t="ekr.20071201085751.331"><vh>__setitem__</vh></v>
<v t="ekr.20071201085751.332"><vh>__setattr__</vh></v>
<v t="ekr.20071201085751.333"><vh>__str__</vh></v>
<v t="ekr.20071201085751.334"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.335"><vh>__getitem__</vh></v>
<v t="ekr.20071201085751.336"><vh>__contains__</vh></v>
<v t="ekr.20071201085751.337"><vh>__iadd__</vh></v>
<v t="ekr.20071201085751.338"><vh>__add__</vh></v>
<v t="ekr.20071201085751.339"><vh>__sub__</vh></v>
<v t="ekr.20071201085751.340"><vh>__isub__</vh></v>
<v t="ekr.20071201085751.341"><vh>__make_dict</vh></v>
<v t="ekr.20071201085751.342"><vh>__dict_invert</vh></v>
<v t="ekr.20071201085751.343"><vh>clear</vh></v>
<v t="ekr.20071201085751.344"><vh>copy</vh></v>
<v t="ekr.20071201085751.345"><vh>dict</vh></v>
<v t="ekr.20071201085751.346"><vh>dictcopy</vh></v>
<v t="ekr.20071201085751.347"><vh>popitem</vh></v>
<v t="ekr.20071201085751.348"><vh>update</vh></v>
<v t="ekr.20071201085751.349"><vh>merge</vh></v>
<v t="ekr.20071201085751.350"><vh>has_key</vh></v>
<v t="ekr.20071201085751.351"><vh>hasattr</vh></v>
<v t="ekr.20071201085751.352"><vh>items</vh></v>
<v t="ekr.20071201085751.353"><vh>keys</vh></v>
<v t="ekr.20071201085751.354"><vh>values</vh></v>
<v t="ekr.20071201085751.355"><vh>get</vh></v>
<v t="ekr.20071201085751.356"><vh>setdefault</vh></v>
<v t="ekr.20071201085751.357"><vh>allow_new_attr</vh></v>
</v>
</v>
<v t="ekr.20071129105210.91" a="M"><vh>@@@auto irunner.py (bad import)</vh>
<v t="ekr.20071129105657.366"><vh>irunner declarations</vh></v>
<v t="ekr.20071129105657.367"><vh>class InteractiveRunner</vh>
<v t="ekr.20071129105657.368"><vh>__init__</vh></v>
<v t="ekr.20071129105657.369"><vh>run_file</vh></v>
<v t="ekr.20071129105657.370"><vh>run_source</vh></v>
<v t="ekr.20071129105657.371"><vh>main</vh></v>
</v>
<v t="ekr.20071129105657.372"><vh>class IPythonRunner</vh>
<v t="ekr.20071129105657.373"><vh>__init__</vh></v>
</v>
<v t="ekr.20071129105657.374"><vh>class PythonRunner</vh>
<v t="ekr.20071129105657.375"><vh>__init__</vh></v>
</v>
<v t="ekr.20071129105657.376"><vh>class SAGERunner</vh>
<v t="ekr.20071129105657.377"><vh>__init__</vh></v>
</v>
<v t="ekr.20071129105657.378"><vh>main</vh></v>
</v>
<v t="ekr.20071129105210.92"><vh>@@auto Itpl.py</vh>
<v t="ekr.20071201085751.358"><vh>Itpl declarations</vh></v>
<v t="ekr.20071201085751.359"><vh>class ItplError</vh>
<v t="ekr.20071201085751.360"><vh>__init__</vh></v>
<v t="ekr.20071201085751.361"><vh>__str__</vh></v>
</v>
<v t="ekr.20071201085751.362"><vh>matchorfail</vh></v>
<v t="ekr.20071201085751.363"><vh>class Itpl</vh>
<v t="ekr.20071201085751.364"><vh>__init__</vh></v>
<v t="ekr.20071201085751.365"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.366"><vh>_str</vh></v>
<v t="ekr.20071201085751.367"><vh>__str__</vh></v>
</v>
<v t="ekr.20071201085751.368"><vh>class ItplNS</vh>
<v t="ekr.20071201085751.369"><vh>__init__</vh></v>
<v t="ekr.20071201085751.370"><vh>__str__</vh></v>
<v t="ekr.20071201085751.371"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.372"><vh>itpl</vh></v>
<v t="ekr.20071201085751.373"><vh>printpl</vh></v>
<v t="ekr.20071201085751.374"><vh>itplns</vh></v>
<v t="ekr.20071201085751.375"><vh>printplns</vh></v>
<v t="ekr.20071201085751.376"><vh>class ItplFile</vh>
<v t="ekr.20071201085751.377"><vh>__init__</vh></v>
<v t="ekr.20071201085751.378"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.379"><vh>__getattr__</vh></v>
<v t="ekr.20071201085751.380"><vh>write</vh></v>
</v>
<v t="ekr.20071201085751.381"><vh>filter</vh></v>
<v t="ekr.20071201085751.382"><vh>unfilter</vh></v>
</v>
<v t="ekr.20071129105210.93" a="M"><vh>@@auto Logger.py (bad import)</vh>
<v t="ekr.20071129105657.404"><vh>Logger declarations</vh></v>
<v t="ekr.20071129105657.405"><vh>class Logger</vh>
<v t="ekr.20071129105657.406"><vh>__init__</vh></v>
<v t="ekr.20071129105657.407"><vh>_set_mode</vh></v>
<v t="ekr.20071129105657.408"><vh>_get_mode</vh></v>
<v t="ekr.20071129105657.409"><vh>logstart</vh></v>
<v t="ekr.20071129105657.410"><vh>switch_log</vh></v>
<v t="ekr.20071129105657.411"><vh>logstate</vh></v>
<v t="ekr.20071129105657.412"><vh>log</vh></v>
<v t="ekr.20071129105657.413"><vh>log_write</vh></v>
<v t="ekr.20071129105657.414"><vh>close_log</vh></v>
</v>
</v>
<v t="ekr.20071129124043"><vh>@@auto macro.py</vh>
<v t="ekr.20071201085751.383"><vh>macro declarations</vh></v>
<v t="ekr.20071201085751.384"><vh>class Macro</vh>
<v t="ekr.20071201085751.385"><vh>__init__</vh></v>
<v t="ekr.20071201085751.386"><vh>__str__</vh></v>
<v t="ekr.20071201085751.387"><vh>__repr__</vh></v>
</v>
</v>
<v t="ekr.20071129105210.95" a="M"><vh>@@auto Magic.py (bad import)</vh>
<v t="ekr.20071129105657.420"><vh>Magic declarations</vh></v>
<v t="ekr.20071129105657.421"><vh>on_off</vh></v>
<v t="ekr.20071129105657.422"><vh>class Bunch</vh></v>
<v t="ekr.20071129105657.423"><vh>class Magic</vh>
<v t="ekr.20071129105657.424"><vh>__init__</vh></v>
<v t="ekr.20071129105657.425"><vh>profile_missing_notice</vh></v>
<v t="ekr.20071129105657.426"><vh>default_option</vh></v>
<v t="ekr.20071129105657.427"><vh>lsmagic</vh></v>
<v t="ekr.20071129105657.428"><vh>extract_input_slices</vh></v>
<v t="ekr.20071129105657.429"><vh>_ofind</vh></v>
<v t="ekr.20071129105657.430"><vh>arg_err</vh></v>
<v t="ekr.20071129105657.431"><vh>format_latex</vh></v>
<v t="ekr.20071129105657.432"><vh>format_screen</vh></v>
<v t="ekr.20071129105657.433"><vh>parse_options</vh></v>
<v t="ekr.20071129105657.434"><vh>magic_lsmagic</vh></v>
<v t="ekr.20071129105657.435"><vh>magic_magic</vh></v>
<v t="ekr.20071129105657.436"><vh>magic_automagic</vh></v>
<v t="ekr.20071129105657.437"><vh>magic_autocall</vh></v>
<v t="ekr.20071129105657.438"><vh>magic_autoindent</vh></v>
<v t="ekr.20071129105657.439"><vh>magic_system_verbose</vh></v>
<v t="ekr.20071129105657.440"><vh>magic_history</vh></v>
<v t="ekr.20071129105657.441"><vh>magic_hist</vh></v>
<v t="ekr.20071129105657.442"><vh>magic_p</vh></v>
<v t="ekr.20071129105657.443"><vh>magic_r</vh></v>
<v t="ekr.20071129105657.444"><vh>magic_page</vh></v>
<v t="ekr.20071129105657.445"><vh>magic_profile</vh></v>
<v t="ekr.20071129105657.446"><vh>_inspect</vh></v>
<v t="ekr.20071129105657.447"><vh>magic_pdef</vh></v>
<v t="ekr.20071129105657.448"><vh>magic_pdoc</vh></v>
<v t="ekr.20071129105657.449"><vh>magic_psource</vh></v>
<v t="ekr.20071129105657.450"><vh>magic_pfile</vh></v>
<v t="ekr.20071129105657.451"><vh>magic_pinfo</vh></v>
<v t="ekr.20071129105657.452"><vh>magic_psearch</vh></v>
<v t="ekr.20071129105657.453"><vh>magic_who_ls</vh></v>
<v t="ekr.20071129105657.454"><vh>magic_who</vh></v>
<v t="ekr.20071129105657.455"><vh>magic_whos</vh></v>
<v t="ekr.20071129105657.456"><vh>magic_reset</vh></v>
<v t="ekr.20071129105657.457"><vh>magic_logstart</vh></v>
<v t="ekr.20071129105657.458"><vh>magic_logoff</vh></v>
<v t="ekr.20071129105657.459"><vh>magic_logon</vh></v>
<v t="ekr.20071129105657.460"><vh>magic_logstate</vh></v>
<v t="ekr.20071129105657.461"><vh>magic_pdb</vh></v>
<v t="ekr.20071129105657.462"><vh>magic_debug</vh></v>
<v t="ekr.20071129105657.463"><vh>magic_prun</vh></v>
<v t="ekr.20071129105657.464"><vh>magic_run</vh></v>
<v t="ekr.20071129105657.465"><vh>magic_runlog</vh></v>
<v t="ekr.20071129105657.466"><vh>magic_timeit</vh></v>
<v t="ekr.20071129105657.467"><vh>magic_time</vh></v>
<v t="ekr.20071129105657.468"><vh>magic_macro</vh></v>
<v t="ekr.20071129105657.469"><vh>magic_save</vh></v>
<v t="ekr.20071129105657.470"><vh>_edit_macro</vh></v>
<v t="ekr.20071129105657.471"><vh>magic_ed</vh></v>
<v t="ekr.20071129105657.472"><vh>magic_edit</vh></v>
<v t="ekr.20071129105657.473"><vh>magic_xmode</vh></v>
<v t="ekr.20071129105657.474"><vh>magic_colors</vh></v>
<v t="ekr.20071129105657.475"><vh>magic_color_info</vh></v>
<v t="ekr.20071129105657.476"><vh>magic_Pprint</vh></v>
<v t="ekr.20071129105657.477"><vh>magic_exit</vh></v>
<v t="ekr.20071129105657.478"><vh>magic_quit</vh></v>
<v t="ekr.20071129105657.479"><vh>magic_Exit</vh></v>
<v t="ekr.20071129105657.480"><vh>magic_Quit</vh></v>
<v t="ekr.20071129105657.481"><vh>magic_alias</vh></v>
<v t="ekr.20071129105657.482"><vh>magic_unalias</vh></v>
<v t="ekr.20071129105657.483"><vh>magic_rehash</vh></v>
<v t="ekr.20071129105657.484"><vh>magic_rehashx</vh></v>
<v t="ekr.20071129105657.485"><vh>magic_pwd</vh></v>
<v t="ekr.20071129105657.486"><vh>magic_cd</vh></v>
<v t="ekr.20071129105657.487"><vh>magic_dhist</vh></v>
<v t="ekr.20071129105657.488"><vh>magic_env</vh></v>
<v t="ekr.20071129105657.489"><vh>magic_pushd</vh></v>
<v t="ekr.20071129105657.490"><vh>magic_popd</vh></v>
<v t="ekr.20071129105657.491"><vh>magic_dirs</vh></v>
<v t="ekr.20071129105657.492"><vh>magic_sc</vh></v>
<v t="ekr.20071129105657.493"><vh>magic_sx</vh></v>
<v t="ekr.20071129105657.494"><vh>magic_bg</vh></v>
<v t="ekr.20071129105657.495"><vh>magic_bookmark</vh></v>
<v t="ekr.20071129105657.496"><vh>magic_pycat</vh></v>
<v t="ekr.20071129105657.497"><vh>magic_cpaste</vh></v>
<v t="ekr.20071129105657.498"><vh>magic_quickref</vh></v>
<v t="ekr.20071129105657.499"><vh>magic_upgrade</vh></v>
</v>
</v>
<v t="ekr.20071129105210.96"><vh>@@auto numutils.py</vh>
<v t="ekr.20071201085751.388"><vh>numutils declarations</vh></v>
<v t="ekr.20071201085751.389"><vh>exp_safe</vh></v>
<v t="ekr.20071201085751.390"><vh>amap</vh></v>
<v t="ekr.20071201085751.391"><vh>amin</vh></v>
<v t="ekr.20071201085751.392"><vh>amax</vh></v>
<v t="ekr.20071201085751.393"><vh>zeros_like</vh></v>
<v t="ekr.20071201085751.394"><vh>empty_like</vh></v>
<v t="ekr.20071201085751.395"><vh>sum_flat</vh></v>
<v t="ekr.20071201085751.396"><vh>mean_flat</vh></v>
<v t="ekr.20071201085751.397"><vh>rms_flat</vh></v>
<v t="ekr.20071201085751.398"><vh>l1norm</vh></v>
<v t="ekr.20071201085751.399"><vh>l2norm</vh></v>
<v t="ekr.20071201085751.400"><vh>norm</vh></v>
<v t="ekr.20071201085751.401"><vh>frange</vh></v>
<v t="ekr.20071201085751.402"><vh>diagonal_matrix</vh></v>
<v t="ekr.20071201085751.403"><vh>identity</vh></v>
<v t="ekr.20071201085751.404"><vh>base_repr</vh></v>
<v t="ekr.20071201085751.405"><vh>binary_repr</vh></v>
<v t="ekr.20071201085751.406"><vh>log2</vh></v>
<v t="ekr.20071201085751.407"><vh>ispower2</vh></v>
<v t="ekr.20071201085751.408"><vh>fromfunction_kw</vh></v>
</v>
<v t="ekr.20071129105210.97"><vh>@@auto OInspect.py</vh>
<v t="ekr.20071201085751.409"><vh>OInspect declarations</vh></v>
<v t="ekr.20071201085751.410"><vh>getdoc</vh></v>
<v t="ekr.20071201085751.411"><vh>getsource</vh></v>
<v t="ekr.20071201085751.412"><vh>class myStringIO</vh>
<v t="ekr.20071201085751.413"><vh>writeln</vh></v>
</v>
<v t="ekr.20071201085751.414"><vh>class Inspector</vh>
<v t="ekr.20071201085751.415"><vh>__init__</vh></v>
<v t="ekr.20071201085751.416"><vh>__getargspec</vh></v>
<v t="ekr.20071201085751.417"><vh>__getdef</vh></v>
<v t="ekr.20071201085751.418"><vh>__head</vh></v>
<v t="ekr.20071201085751.419"><vh>set_active_scheme</vh></v>
<v t="ekr.20071201085751.420"><vh>noinfo</vh></v>
<v t="ekr.20071201085751.421"><vh>pdef</vh></v>
<v t="ekr.20071201085751.422"><vh>pdoc</vh></v>
<v t="ekr.20071201085751.423"><vh>psource</vh></v>
<v t="ekr.20071201085751.424"><vh>pfile</vh></v>
<v t="ekr.20071201085751.425"><vh>pinfo</vh></v>
<v t="ekr.20071201085751.426"><vh>psearch</vh></v>
</v>
</v>
<v t="ekr.20071129105210.98"><vh>@@auto OutputTrap.py</vh>
<v t="ekr.20071201085751.427"><vh>OutputTrap declarations</vh></v>
<v t="ekr.20071201085751.428"><vh>class OutputTrapError</vh>
<v t="ekr.20071201085751.429"><vh>__init__</vh></v>
</v>
<v t="ekr.20071201085751.430"><vh>class OutputTrap</vh>
<v t="ekr.20071201085751.431"><vh>__init__</vh></v>
<v t="ekr.20071201085751.432"><vh>trap_out</vh></v>
<v t="ekr.20071201085751.433"><vh>release_out</vh></v>
<v t="ekr.20071201085751.434"><vh>summary_out</vh></v>
<v t="ekr.20071201085751.435"><vh>flush_out</vh></v>
<v t="ekr.20071201085751.436"><vh>trap_err</vh></v>
<v t="ekr.20071201085751.437"><vh>release_err</vh></v>
<v t="ekr.20071201085751.438"><vh>summary_err</vh></v>
<v t="ekr.20071201085751.439"><vh>flush_err</vh></v>
<v t="ekr.20071201085751.440"><vh>trap_all</vh></v>
<v t="ekr.20071201085751.441"><vh>release_all</vh></v>
<v t="ekr.20071201085751.442"><vh>summary_all</vh></v>
<v t="ekr.20071201085751.443"><vh>flush_all</vh></v>
</v>
<v t="ekr.20071201085751.444"><vh>_test_all</vh></v>
</v>
<v t="ekr.20071129105210.99"><vh>@@auto platutils.py</vh>
<v t="ekr.20071201085751.445"><vh>platutils declarations</vh></v>
</v>
<v t="ekr.20071129105210.100"><vh>@@auto platutils_dummy.py</vh>
<v t="ekr.20071201085751.446"><vh>platutils_dummy declarations</vh></v>
<v t="ekr.20071201085751.447"><vh>_dummy</vh></v>
</v>
<v t="ekr.20071129105210.101"><vh>@@auto platutils_posix.py</vh>
<v t="ekr.20071201085751.448"><vh>platutils_posix declarations</vh></v>
<v t="ekr.20071201085751.449"><vh>_dummy_op</vh></v>
<v t="ekr.20071201085751.450"><vh>_set_term_title_xterm</vh></v>
</v>
<v t="ekr.20071129105210.102"><vh>@@auto platutils_win32.py</vh>
<v t="ekr.20071201085751.451"><vh>platutils_win32 declarations</vh></v>
<v t="ekr.20071201085751.452"><vh>set_term_title</vh></v>
</v>
<v t="ekr.20071129105210.103"><vh>@@auto Prompts.py</vh>
<v t="ekr.20071201085751.453"><vh>Prompts declarations</vh></v>
<v t="ekr.20071201085751.454"><vh>multiple_replace</vh></v>
<v t="ekr.20071201085751.455"><vh>str_safe</vh></v>
<v t="ekr.20071201085751.456"><vh>class BasePrompt</vh>
<v t="ekr.20071201085751.457"><vh>__init__</vh></v>
<v t="ekr.20071201085751.458"><vh>set_p_str</vh></v>
<v t="ekr.20071201085751.459"><vh>write</vh></v>
<v t="ekr.20071201085751.460"><vh>__str__</vh></v>
<v t="ekr.20071201085751.461"><vh>cwd_filt</vh></v>
<v t="ekr.20071201085751.462"><vh>cwd_filt2</vh></v>
</v>
<v t="ekr.20071201085751.463"><vh>class Prompt1</vh>
<v t="ekr.20071201085751.464"><vh>__init__</vh></v>
<v t="ekr.20071201085751.465"><vh>set_colors</vh></v>
<v t="ekr.20071201085751.466"><vh>__str__</vh></v>
<v t="ekr.20071201085751.467"><vh>auto_rewrite</vh></v>
</v>
<v t="ekr.20071201085751.468"><vh>class PromptOut</vh>
<v t="ekr.20071201085751.469"><vh>__init__</vh></v>
<v t="ekr.20071201085751.470"><vh>set_colors</vh></v>
</v>
<v t="ekr.20071201085751.471"><vh>class Prompt2</vh>
<v t="ekr.20071201085751.472"><vh>__init__</vh></v>
<v t="ekr.20071201085751.473"><vh>set_p_str</vh></v>
<v t="ekr.20071201085751.474"><vh>set_colors</vh></v>
</v>
<v t="ekr.20071201085751.475"><vh>class CachedOutput</vh>
<v t="ekr.20071201085751.476"><vh>__init__</vh></v>
<v t="ekr.20071201085751.477"><vh>_set_prompt_str</vh></v>
<v t="ekr.20071201085751.478"><vh>set_colors</vh></v>
<v t="ekr.20071201085751.479"><vh>__call__</vh></v>
<v t="ekr.20071201085751.480"><vh>_display</vh></v>
<v t="ekr.20071201085751.481"><vh>update</vh></v>
<v t="ekr.20071201085751.482"><vh>flush</vh></v>
</v>
</v>
<v t="ekr.20071129105210.104"><vh>@@auto PyColorize.py</vh>
<v t="ekr.20071201085751.483"><vh>PyColorize declarations</vh></v>
<v t="ekr.20071201085751.484"><vh>class Parser</vh>
<v t="ekr.20071201085751.485"><vh>__init__</vh></v>
<v t="ekr.20071201085751.486"><vh>format</vh></v>
<v t="ekr.20071201085751.487"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.488"><vh>main</vh></v>
</v>
<v t="ekr.20071129105210.105"><vh>@@auto Release.py</vh>
<v t="ekr.20071201085751.489"><vh>Release declarations</vh></v>
</v>
<v t="ekr.20071129105210.106"><vh>@@auto rlineimpl.py</vh>
<v t="ekr.20071201085751.490"><vh>rlineimpl declarations</vh></v>
</v>
<v t="ekr.20071129105210.107" a="M"><vh>@@auto Shell.py (bad import)</vh>
<v t="ekr.20071129105657.603"><vh>Shell declarations</vh></v>
<v t="ekr.20071129105657.604"><vh>class IPShell</vh>
<v t="ekr.20071129105657.605"><vh>__init__</vh></v>
<v t="ekr.20071129105657.606"><vh>mainloop</vh></v>
</v>
<v t="ekr.20071129105657.607"><vh>class IPShellEmbed</vh>
<v t="ekr.20071129105657.608"><vh>__init__</vh></v>
<v t="ekr.20071129105657.609"><vh>restore_system_completer</vh></v>
<v t="ekr.20071129105657.610"><vh>__call__</vh></v>
<v t="ekr.20071129105657.611"><vh>set_dummy_mode</vh></v>
<v t="ekr.20071129105657.612"><vh>get_dummy_mode</vh></v>
<v t="ekr.20071129105657.613"><vh>set_banner</vh></v>
<v t="ekr.20071129105657.614"><vh>set_exit_msg</vh></v>
</v>
<v t="ekr.20071129105657.615"><vh>sigint_handler</vh></v>
<v t="ekr.20071129105657.616"><vh>class MTInteractiveShell</vh>
<v t="ekr.20071129105657.617"><vh>__init__</vh></v>
<v t="ekr.20071129105657.618"><vh>runsource</vh></v>
<v t="ekr.20071129105657.619"><vh>runcode</vh></v>
<v t="ekr.20071129105657.620"><vh>kill</vh></v>
</v>
<v t="ekr.20071129105657.621"><vh>class MatplotlibShellBase</vh>
<v t="ekr.20071129105657.622"><vh>_matplotlib_config</vh></v>
<v t="ekr.20071129105657.623"><vh>mplot_exec</vh></v>
<v t="ekr.20071129105657.624"><vh>magic_run</vh></v>
</v>
<v t="ekr.20071129105657.625"><vh>class MatplotlibShell</vh>
<v t="ekr.20071129105657.626"><vh>__init__</vh></v>
</v>
<v t="ekr.20071129105657.627"><vh>class MatplotlibMTShell</vh>
<v t="ekr.20071129105657.628"><vh>__init__</vh></v>
</v>
<v t="ekr.20071129105657.629"><vh>get_tk</vh></v>
<v t="ekr.20071129105657.630"><vh>hijack_tk</vh></v>
<v t="ekr.20071129105657.631"><vh>update_tk</vh></v>
<v t="ekr.20071129105657.632"><vh>hijack_wx</vh></v>
<v t="ekr.20071129105657.633"><vh>hijack_gtk</vh></v>
<v t="ekr.20071129105657.634"><vh>class IPShellGTK</vh>
<v t="ekr.20071129105657.635"><vh>__init__</vh></v>
<v t="ekr.20071129105657.636"><vh>run</vh></v>
<v t="ekr.20071129105657.637"><vh>mainloop</vh></v>
<v t="ekr.20071129105657.638"><vh>on_timer</vh></v>
</v>
<v t="ekr.20071129105657.639"><vh>class IPShellWX</vh>
<v t="ekr.20071129105657.640"><vh>__init__</vh></v>
<v t="ekr.20071129105657.641"><vh>wxexit</vh></v>
<v t="ekr.20071129105657.642"><vh>run</vh></v>
<v t="ekr.20071129105657.643"><vh>mainloop</vh></v>
</v>
<v t="ekr.20071129105657.644"><vh>class IPShellQt</vh>
<v t="ekr.20071129105657.645"><vh>__init__</vh></v>
<v t="ekr.20071129105657.646"><vh>run</vh></v>
<v t="ekr.20071129105657.647"><vh>mainloop</vh></v>
<v t="ekr.20071129105657.648"><vh>on_timer</vh></v>
</v>
<v t="ekr.20071129105657.649"><vh>class IPShellQt4</vh>
<v t="ekr.20071129105657.650"><vh>__init__</vh></v>
<v t="ekr.20071129105657.651"><vh>run</vh></v>
<v t="ekr.20071129105657.652"><vh>mainloop</vh></v>
<v t="ekr.20071129105657.653"><vh>on_timer</vh></v>
</v>
<v t="ekr.20071129105657.654"><vh>class IPShellMatplotlib</vh>
<v t="ekr.20071129105657.655"><vh>__init__</vh></v>
</v>
<v t="ekr.20071129105657.656"><vh>class IPShellMatplotlibGTK</vh>
<v t="ekr.20071129105657.657"><vh>__init__</vh></v>
</v>
<v t="ekr.20071129105657.658"><vh>class IPShellMatplotlibWX</vh>
<v t="ekr.20071129105657.659"><vh>__init__</vh></v>
</v>
<v t="ekr.20071129105657.660"><vh>class IPShellMatplotlibQt</vh>
<v t="ekr.20071129105657.661"><vh>__init__</vh></v>
</v>
<v t="ekr.20071129105657.662"><vh>class IPShellMatplotlibQt4</vh>
<v t="ekr.20071129105657.663"><vh>__init__</vh></v>
</v>
<v t="ekr.20071129105657.664"><vh>_matplotlib_shell_class</vh></v>
<v t="ekr.20071129105657.665"><vh>start</vh></v>
</v>
<v t="ekr.20071129105210.108"><vh>@@auto strdispatch.py</vh>
<v t="ekr.20071201085751.491"><vh>strdispatch declarations</vh></v>
<v t="ekr.20071201085751.492"><vh>class StrDispatch</vh>
<v t="ekr.20071201085751.493"><vh>__init__</vh></v>
<v t="ekr.20071201085751.494"><vh>add_s</vh></v>
<v t="ekr.20071201085751.495"><vh>add_re</vh></v>
<v t="ekr.20071201085751.496"><vh>dispatch</vh></v>
<v t="ekr.20071201085751.497"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.498"><vh>s_matches</vh></v>
<v t="ekr.20071201085751.499"><vh>flat_matches</vh></v>
</v>
<v t="ekr.20071201085751.500"><vh>test</vh></v>
</v>
<v t="ekr.20071129105210.109"><vh>@@auto ultraTB.py</vh>
<v t="ekr.20071201085751.501"><vh>ultraTB declarations</vh></v>
<v t="ekr.20071201085751.502"><vh>inspect_error</vh></v>
<v t="ekr.20071201085751.503"><vh>_fixed_getinnerframes</vh></v>
<v t="ekr.20071201085751.504"><vh>_formatTracebackLines</vh></v>
<v t="ekr.20071201085751.505"><vh>class TBTools</vh>
<v t="ekr.20071201085751.506"><vh>__init__</vh></v>
<v t="ekr.20071201085751.507"><vh>set_colors</vh></v>
<v t="ekr.20071201085751.508"><vh>color_toggle</vh></v>
</v>
<v t="ekr.20071201085751.509"><vh>class ListTB</vh>
<v t="ekr.20071201085751.510"><vh>__init__</vh></v>
<v t="ekr.20071201085751.511"><vh>__call__</vh></v>
<v t="ekr.20071201085751.512"><vh>text</vh></v>
<v t="ekr.20071201085751.513"><vh>_format_list</vh></v>
<v t="ekr.20071201085751.514"><vh>_format_exception_only</vh></v>
<v t="ekr.20071201085751.515"><vh>_some_str</vh></v>
</v>
<v t="ekr.20071201085751.516"><vh>class VerboseTB</vh>
<v t="ekr.20071201085751.517"><vh>__init__</vh></v>
<v t="ekr.20071201085751.518"><vh>text</vh></v>
<v t="ekr.20071201085751.519"><vh>debugger</vh></v>
<v t="ekr.20071201085751.520"><vh>handler</vh></v>
<v t="ekr.20071201085751.521"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.522"><vh>class FormattedTB</vh>
<v t="ekr.20071201085751.523"><vh>__init__</vh></v>
<v t="ekr.20071201085751.524"><vh>_extract_tb</vh></v>
<v t="ekr.20071201085751.525"><vh>text</vh></v>
<v t="ekr.20071201085751.526"><vh>set_mode</vh></v>
<v t="ekr.20071201085751.527"><vh>plain</vh></v>
<v t="ekr.20071201085751.528"><vh>context</vh></v>
<v t="ekr.20071201085751.529"><vh>verbose</vh></v>
</v>
<v t="ekr.20071201085751.530"><vh>class AutoFormattedTB</vh>
<v t="ekr.20071201085751.531"><vh>__call__</vh></v>
<v t="ekr.20071201085751.532"><vh>text</vh></v>
</v>
<v t="ekr.20071201085751.533"><vh>class ColorTB</vh>
<v t="ekr.20071201085751.534"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20071129105210.110"><vh>@@auto upgrade_dir.py</vh>
<v t="ekr.20071201085751.535"><vh>upgrade_dir declarations</vh></v>
<v t="ekr.20071201085751.536"><vh>showdiff</vh></v>
<v t="ekr.20071201085751.537"><vh>upgrade_dir</vh></v>
</v>
<v t="ekr.20071129105210.111"><vh>@@auto usage.py</vh>
<v t="ekr.20071201085751.538"><vh>usage declarations</vh></v>
</v>
<v t="ekr.20071129105210.112"><vh>@@auto wildcard.py</vh>
<v t="ekr.20071201085751.539"><vh>wildcard declarations</vh></v>
<v t="ekr.20071201085751.540"><vh>create_typestr2type_dicts</vh></v>
<v t="ekr.20071201085751.541"><vh>is_type</vh></v>
<v t="ekr.20071201085751.542"><vh>show_hidden</vh></v>
<v t="ekr.20071201085751.543"><vh>class NameSpace</vh>
<v t="ekr.20071201085751.544"><vh>__init__</vh></v>
<v t="ekr.20071201085751.545"><vh>get_ns</vh></v>
<v t="ekr.20071201085751.546"><vh>get_ns_names</vh></v>
<v t="ekr.20071201085751.547"><vh>filter</vh></v>
</v>
<v t="ekr.20071201085751.548"><vh>list_namespace</vh></v>
</v>
<v t="ekr.20071129105210.113"><vh>@@auto winconsole.py</vh>
<v t="ekr.20071201085751.549"><vh>winconsole declarations</vh></v>
<v t="ekr.20071201085751.550"><vh>get_console_size</vh></v>
</v>
<v t="ekr.20071129105210.114"><vh>@@auto __init__.py</vh>
<v t="ekr.20071201085751.551"><vh>__init__ declarations</vh></v>
</v>
</v>
<v t="ekr.20071129110733.514"><vh>Extensions</vh>
<v t="ekr.20071129105210.115"><vh>@@auto Extensions\astyle.py</vh>
<v t="ekr.20071201085751.552"><vh>astyle declarations</vh></v>
<v t="ekr.20071201085751.553"><vh>class Style</vh>
<v t="ekr.20071201085751.554"><vh>__init__</vh></v>
<v t="ekr.20071201085751.555"><vh>__call__</vh></v>
<v t="ekr.20071201085751.556"><vh>__eq__</vh></v>
<v t="ekr.20071201085751.557"><vh>__neq__</vh></v>
<v t="ekr.20071201085751.558"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.559"><vh>fromstr</vh></v>
<v t="ekr.20071201085751.560"><vh>fromenv</vh></v>
</v>
<v t="ekr.20071201085751.561"><vh>switchstyle</vh></v>
<v t="ekr.20071201085751.562"><vh>class Text</vh>
<v t="ekr.20071201085751.563"><vh>__init__</vh></v>
<v t="ekr.20071201085751.564"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.565"><vh>append</vh></v>
<v t="ekr.20071201085751.566"><vh>insert</vh></v>
<v t="ekr.20071201085751.567"><vh>__add__</vh></v>
<v t="ekr.20071201085751.568"><vh>__iadd__</vh></v>
<v t="ekr.20071201085751.569"><vh>format</vh></v>
<v t="ekr.20071201085751.570"><vh>string</vh></v>
<v t="ekr.20071201085751.571"><vh>__str__</vh></v>
<v t="ekr.20071201085751.572"><vh>write</vh></v>
</v>
<v t="ekr.20071201085751.573"><vh>streamstyle</vh></v>
<v t="ekr.20071201085751.574"><vh>write</vh></v>
<v t="ekr.20071201085751.575"><vh>writeln</vh></v>
<v t="ekr.20071201085751.576"><vh>class Stream</vh>
<v t="ekr.20071201085751.577"><vh>__init__</vh></v>
<v t="ekr.20071201085751.578"><vh>write</vh></v>
<v t="ekr.20071201085751.579"><vh>writeln</vh></v>
<v t="ekr.20071201085751.580"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20071201085751.581"><vh>class stdout</vh>
<v t="ekr.20071201085751.582"><vh>write</vh></v>
<v t="ekr.20071201085751.583"><vh>writeln</vh></v>
<v t="ekr.20071201085751.584"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20071201085751.585"><vh>class stderr</vh>
<v t="ekr.20071201085751.586"><vh>write</vh></v>
<v t="ekr.20071201085751.587"><vh>writeln</vh></v>
<v t="ekr.20071201085751.588"><vh>__getattr__</vh></v>
</v>
</v>
<v t="ekr.20071129105210.116"><vh>@@auto Extensions\clearcmd.py</vh>
<v t="ekr.20071201085751.589"><vh>clearcmd declarations</vh></v>
<v t="ekr.20071201085751.590"><vh>clear_f</vh></v>
</v>
<v t="ekr.20071129105210.117"><vh>@@auto Extensions\ext_rehashdir.py</vh>
<v t="ekr.20071201085751.591"><vh>ext_rehashdir declarations</vh></v>
<v t="ekr.20071201085751.592"><vh>rehashdir_f</vh></v>
</v>
<v t="ekr.20071129105210.118"><vh>@@auto Extensions\ext_rescapture.py</vh>
<v t="ekr.20071201085751.593"><vh>ext_rescapture declarations</vh></v>
<v t="ekr.20071201085751.594"><vh>hnd_magic</vh></v>
<v t="ekr.20071201085751.595"><vh>hnd_syscmd</vh></v>
<v t="ekr.20071201085751.596"><vh>install_re_handler</vh></v>
<v t="ekr.20071201085751.597"><vh>init_handlers</vh></v>
<v t="ekr.20071201085751.598"><vh>regex_prefilter_f</vh></v>
</v>
<v t="ekr.20071129105210.119"><vh>@@auto Extensions\ibrowse.py</vh>
<v t="ekr.20071201085751.599"><vh>ibrowse declarations</vh></v>
<v t="ekr.20071201085751.600"><vh>class UnassignedKeyError</vh></v>
<v t="ekr.20071201085751.601"><vh>class UnknownCommandError</vh></v>
<v t="ekr.20071201085751.602"><vh>class CommandError</vh></v>
<v t="ekr.20071201085751.603"><vh>class Keymap</vh>
<v t="ekr.20071201085751.604"><vh>__init__</vh></v>
<v t="ekr.20071201085751.605"><vh>__setitem__</vh></v>
<v t="ekr.20071201085751.606"><vh>__getitem__</vh></v>
<v t="ekr.20071201085751.607"><vh>__detitem__</vh></v>
<v t="ekr.20071201085751.608"><vh>register</vh></v>
<v t="ekr.20071201085751.609"><vh>get</vh></v>
<v t="ekr.20071201085751.610"><vh>findkey</vh></v>
</v>
<v t="ekr.20071201085751.611"><vh>class _BrowserCachedItem</vh>
<v t="ekr.20071201085751.612"><vh>__init__</vh></v>
</v>
<v t="ekr.20071201085751.613"><vh>class _BrowserHelp</vh>
<v t="ekr.20071201085751.614"><vh>__init__</vh></v>
<v t="ekr.20071201085751.615"><vh>__xrepr__</vh></v>
<v t="ekr.20071201085751.616"><vh>__iter__</vh></v>
</v>
<v t="ekr.20071201085751.617"><vh>class _BrowserLevel</vh>
<v t="ekr.20071201085751.618"><vh>__init__</vh></v>
<v t="ekr.20071201085751.619"><vh>fetch</vh></v>
<v t="ekr.20071201085751.620"><vh>calcdisplayattrs</vh></v>
<v t="ekr.20071201085751.621"><vh>getrow</vh></v>
<v t="ekr.20071201085751.622"><vh>calcwidths</vh></v>
<v t="ekr.20071201085751.623"><vh>calcdisplayattr</vh></v>
<v t="ekr.20071201085751.624"><vh>moveto</vh></v>
<v t="ekr.20071201085751.625"><vh>sort</vh></v>
<v t="ekr.20071201085751.626"><vh>refresh</vh></v>
<v t="ekr.20071201085751.627"><vh>refreshfind</vh></v>
</v>
<v t="ekr.20071201085751.628"><vh>class _CommandInput</vh>
<v t="ekr.20071201085751.629"><vh>__init__</vh></v>
<v t="ekr.20071201085751.630"><vh>start</vh></v>
<v t="ekr.20071201085751.631"><vh>handlekey</vh></v>
<v t="ekr.20071201085751.632"><vh>handlechar</vh></v>
<v t="ekr.20071201085751.633"><vh>dohistory</vh></v>
<v t="ekr.20071201085751.634"><vh>cmd_backspace</vh></v>
<v t="ekr.20071201085751.635"><vh>cmd_delete</vh></v>
<v t="ekr.20071201085751.636"><vh>cmd_delend</vh></v>
<v t="ekr.20071201085751.637"><vh>cmd_left</vh></v>
<v t="ekr.20071201085751.638"><vh>cmd_right</vh></v>
<v t="ekr.20071201085751.639"><vh>cmd_home</vh></v>
<v t="ekr.20071201085751.640"><vh>cmd_end</vh></v>
<v t="ekr.20071201085751.641"><vh>cmd_up</vh></v>
<v t="ekr.20071201085751.642"><vh>cmd_down</vh></v>
<v t="ekr.20071201085751.643"><vh>cmd_incsearchup</vh></v>
<v t="ekr.20071201085751.644"><vh>cmd_incsearchdown</vh></v>
<v t="ekr.20071201085751.645"><vh>cmd_exit</vh></v>
<v t="ekr.20071201085751.646"><vh>cmd_execute</vh></v>
</v>
<v t="ekr.20071201085751.647"><vh>class _CommandGoto</vh>
<v t="ekr.20071201085751.648"><vh>__init__</vh></v>
<v t="ekr.20071201085751.649"><vh>handlechar</vh></v>
<v t="ekr.20071201085751.650"><vh>cmd_execute</vh></v>
</v>
<v t="ekr.20071201085751.651"><vh>class _CommandFind</vh>
<v t="ekr.20071201085751.652"><vh>__init__</vh></v>
<v t="ekr.20071201085751.653"><vh>cmd_execute</vh></v>
</v>
<v t="ekr.20071201085751.654"><vh>class _CommandFindBackwards</vh>
<v t="ekr.20071201085751.655"><vh>__init__</vh></v>
<v t="ekr.20071201085751.656"><vh>cmd_execute</vh></v>
</v>
<v t="ekr.20071201085751.657"><vh>class ibrowse</vh>
<v t="ekr.20071201085751.658"><vh>__init__</vh></v>
<v t="ekr.20071201085751.659"><vh>nextstepx</vh></v>
<v t="ekr.20071201085751.660"><vh>nextstepy</vh></v>
<v t="ekr.20071201085751.661"><vh>getstyle</vh></v>
<v t="ekr.20071201085751.662"><vh>addstr</vh></v>
<v t="ekr.20071201085751.663"><vh>addchr</vh></v>
<v t="ekr.20071201085751.664"><vh>_calcheaderlines</vh></v>
<v t="ekr.20071201085751.665"><vh>getstylehere</vh></v>
<v t="ekr.20071201085751.666"><vh>report</vh></v>
<v t="ekr.20071201085751.667"><vh>enter</vh></v>
<v t="ekr.20071201085751.668"><vh>startkeyboardinput</vh></v>
<v t="ekr.20071201085751.669"><vh>keylabel</vh></v>
<v t="ekr.20071201085751.670"><vh>beep</vh></v>
<v t="ekr.20071201085751.671"><vh>cmd_up</vh></v>
<v t="ekr.20071201085751.672"><vh>cmd_down</vh></v>
<v t="ekr.20071201085751.673"><vh>cmd_pageup</vh></v>
<v t="ekr.20071201085751.674"><vh>cmd_pagedown</vh></v>
<v t="ekr.20071201085751.675"><vh>cmd_left</vh></v>
<v t="ekr.20071201085751.676"><vh>cmd_right</vh></v>
<v t="ekr.20071201085751.677"><vh>cmd_home</vh></v>
<v t="ekr.20071201085751.678"><vh>cmd_end</vh></v>
<v t="ekr.20071201085751.679"><vh>cmd_prevattr</vh></v>
<v t="ekr.20071201085751.680"><vh>cmd_nextattr</vh></v>
<v t="ekr.20071201085751.681"><vh>cmd_pick</vh></v>
<v t="ekr.20071201085751.682"><vh>cmd_pickattr</vh></v>
<v t="ekr.20071201085751.683"><vh>cmd_pickallattrs</vh></v>
<v t="ekr.20071201085751.684"><vh>cmd_pickmarked</vh></v>
<v t="ekr.20071201085751.685"><vh>cmd_pickmarkedattr</vh></v>
<v t="ekr.20071201085751.686"><vh>cmd_markrange</vh></v>
<v t="ekr.20071201085751.687"><vh>cmd_enter</vh></v>
<v t="ekr.20071201085751.688"><vh>cmd_leave</vh></v>
<v t="ekr.20071201085751.689"><vh>cmd_enterattr</vh></v>
<v t="ekr.20071201085751.690"><vh>cmd_detail</vh></v>
<v t="ekr.20071201085751.691"><vh>cmd_detailattr</vh></v>
<v t="ekr.20071201085751.692"><vh>cmd_tooglemark</vh></v>
<v t="ekr.20071201085751.693"><vh>cmd_sortattrasc</vh></v>
<v t="ekr.20071201085751.694"><vh>cmd_sortattrdesc</vh></v>
<v t="ekr.20071201085751.695"><vh>cmd_hideattr</vh></v>
<v t="ekr.20071201085751.696"><vh>cmd_unhideattrs</vh></v>
<v t="ekr.20071201085751.697"><vh>cmd_goto</vh></v>
<v t="ekr.20071201085751.698"><vh>cmd_find</vh></v>
<v t="ekr.20071201085751.699"><vh>cmd_findbackwards</vh></v>
<v t="ekr.20071201085751.700"><vh>cmd_refresh</vh></v>
<v t="ekr.20071201085751.701"><vh>cmd_refreshfind</vh></v>
<v t="ekr.20071201085751.702"><vh>cmd_help</vh></v>
<v t="ekr.20071201085751.703"><vh>cmd_quit</vh></v>
<v t="ekr.20071201085751.704"><vh>sigwinchhandler</vh></v>
<v t="ekr.20071201085751.705"><vh>_dodisplay</vh></v>
<v t="ekr.20071201085751.706"><vh>display</vh></v>
</v>
</v>
<v t="ekr.20071129105210.120"><vh>@@auto Extensions\InterpreterExec.py</vh>
<v t="ekr.20071201085751.707"><vh>InterpreterExec declarations</vh></v>
<v t="ekr.20071201085751.708"><vh>prefilter_shell</vh></v>
<v t="ekr.20071201085751.709"><vh>pysh</vh></v>
</v>
<v t="ekr.20071129105210.121"><vh>@@auto Extensions\InterpreterPasteInput.py</vh>
<v t="ekr.20071201085751.710"><vh>InterpreterPasteInput declarations</vh></v>
<v t="ekr.20071201085751.711"><vh>prefilter_paste</vh></v>
</v>
<v t="ekr.20071129105210.122"><vh>@@auto Extensions\ipipe.py</vh>
<v t="ekr.20071201085751.712"><vh>ipipe declarations</vh></v>
<v t="ekr.20071201085751.713"><vh>class AttrNamespace</vh>
<v t="ekr.20071201085751.714"><vh>__init__</vh></v>
<v t="ekr.20071201085751.715"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20071201085751.716"><vh>item</vh></v>
<v t="ekr.20071201085751.717"><vh>getglobals</vh></v>
<v t="ekr.20071201085751.718"><vh>class Descriptor</vh>
<v t="ekr.20071201085751.719"><vh>__hash__</vh></v>
<v t="ekr.20071201085751.720"><vh>__eq__</vh></v>
<v t="ekr.20071201085751.721"><vh>__ne__</vh></v>
<v t="ekr.20071201085751.722"><vh>key</vh></v>
<v t="ekr.20071201085751.723"><vh>name</vh></v>
<v t="ekr.20071201085751.724"><vh>attrtype</vh></v>
<v t="ekr.20071201085751.725"><vh>valuetype</vh></v>
<v t="ekr.20071201085751.726"><vh>value</vh></v>
<v t="ekr.20071201085751.727"><vh>doc</vh></v>
<v t="ekr.20071201085751.728"><vh>shortdoc</vh></v>
<v t="ekr.20071201085751.729"><vh>iter</vh></v>
</v>
<v t="ekr.20071201085751.730"><vh>class SelfDescriptor</vh>
<v t="ekr.20071201085751.731"><vh>key</vh></v>
<v t="ekr.20071201085751.732"><vh>attrtype</vh></v>
<v t="ekr.20071201085751.733"><vh>valuetype</vh></v>
<v t="ekr.20071201085751.734"><vh>value</vh></v>
<v t="ekr.20071201085751.735"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.736"><vh>class AttributeDescriptor</vh>
<v t="ekr.20071201085751.737"><vh>__init__</vh></v>
<v t="ekr.20071201085751.738"><vh>key</vh></v>
<v t="ekr.20071201085751.739"><vh>doc</vh></v>
<v t="ekr.20071201085751.740"><vh>attrtype</vh></v>
<v t="ekr.20071201085751.741"><vh>valuetype</vh></v>
<v t="ekr.20071201085751.742"><vh>value</vh></v>
<v t="ekr.20071201085751.743"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.744"><vh>class IndexDescriptor</vh>
<v t="ekr.20071201085751.745"><vh>__init__</vh></v>
<v t="ekr.20071201085751.746"><vh>key</vh></v>
<v t="ekr.20071201085751.747"><vh>attrtype</vh></v>
<v t="ekr.20071201085751.748"><vh>valuetype</vh></v>
<v t="ekr.20071201085751.749"><vh>value</vh></v>
<v t="ekr.20071201085751.750"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.751"><vh>class MethodDescriptor</vh>
<v t="ekr.20071201085751.752"><vh>__init__</vh></v>
<v t="ekr.20071201085751.753"><vh>key</vh></v>
<v t="ekr.20071201085751.754"><vh>doc</vh></v>
<v t="ekr.20071201085751.755"><vh>attrtype</vh></v>
<v t="ekr.20071201085751.756"><vh>valuetype</vh></v>
<v t="ekr.20071201085751.757"><vh>value</vh></v>
<v t="ekr.20071201085751.758"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.759"><vh>class IterAttributeDescriptor</vh>
<v t="ekr.20071201085751.760"><vh>__init__</vh></v>
<v t="ekr.20071201085751.761"><vh>key</vh></v>
<v t="ekr.20071201085751.762"><vh>doc</vh></v>
<v t="ekr.20071201085751.763"><vh>attrtype</vh></v>
<v t="ekr.20071201085751.764"><vh>valuetype</vh></v>
<v t="ekr.20071201085751.765"><vh>value</vh></v>
<v t="ekr.20071201085751.766"><vh>iter</vh></v>
<v t="ekr.20071201085751.767"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.768"><vh>class IterMethodDescriptor</vh>
<v t="ekr.20071201085751.769"><vh>__init__</vh></v>
<v t="ekr.20071201085751.770"><vh>key</vh></v>
<v t="ekr.20071201085751.771"><vh>doc</vh></v>
<v t="ekr.20071201085751.772"><vh>attrtype</vh></v>
<v t="ekr.20071201085751.773"><vh>valuetype</vh></v>
<v t="ekr.20071201085751.774"><vh>value</vh></v>
<v t="ekr.20071201085751.775"><vh>iter</vh></v>
<v t="ekr.20071201085751.776"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.777"><vh>class FunctionDescriptor</vh>
<v t="ekr.20071201085751.778"><vh>__init__</vh></v>
<v t="ekr.20071201085751.779"><vh>key</vh></v>
<v t="ekr.20071201085751.780"><vh>name</vh></v>
<v t="ekr.20071201085751.781"><vh>doc</vh></v>
<v t="ekr.20071201085751.782"><vh>attrtype</vh></v>
<v t="ekr.20071201085751.783"><vh>valuetype</vh></v>
<v t="ekr.20071201085751.784"><vh>value</vh></v>
<v t="ekr.20071201085751.785"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.786"><vh>class Table</vh>
<v t="ekr.20071201085751.787"><vh>class __metaclass__</vh>
<v t="ekr.20071201085751.788"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.789"><vh>__or__</vh></v>
<v t="ekr.20071201085751.790"><vh>__add__</vh></v>
<v t="ekr.20071201085751.791"><vh>__radd__</vh></v>
<v t="ekr.20071201085751.792"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20071201085751.793"><vh>__getitem__</vh></v>
<v t="ekr.20071201085751.794"><vh>__contains__</vh></v>
<v t="ekr.20071201085751.795"><vh>__or__</vh></v>
<v t="ekr.20071201085751.796"><vh>__add__</vh></v>
<v t="ekr.20071201085751.797"><vh>__radd__</vh></v>
</v>
<v t="ekr.20071201085751.798"><vh>class Pipe</vh>
<v t="ekr.20071201085751.799"><vh>class __metaclass__</vh>
<v t="ekr.20071201085751.800"><vh>__ror__</vh></v>
</v>
<v t="ekr.20071201085751.801"><vh>__ror__</vh></v>
</v>
<v t="ekr.20071201085751.802"><vh>xrepr</vh></v>
<v t="ekr.20071201085751.803"><vh>xrepr_none</vh></v>
<v t="ekr.20071201085751.804"><vh>xrepr_bool</vh></v>
<v t="ekr.20071201085751.805"><vh>xrepr_str</vh></v>
<v t="ekr.20071201085751.806"><vh>xrepr_unicode</vh></v>
<v t="ekr.20071201085751.807"><vh>xrepr_number</vh></v>
<v t="ekr.20071201085751.808"><vh>xrepr_complex</vh></v>
<v t="ekr.20071201085751.809"><vh>xrepr_datetime</vh></v>
<v t="ekr.20071201085751.810"><vh>xrepr_date</vh></v>
<v t="ekr.20071201085751.811"><vh>xrepr_time</vh></v>
<v t="ekr.20071201085751.812"><vh>xrepr_timedelta</vh></v>
<v t="ekr.20071201085751.813"><vh>xrepr_type</vh></v>
<v t="ekr.20071201085751.814"><vh>xrepr_exception</vh></v>
<v t="ekr.20071201085751.815"><vh>xrepr_listtuple</vh></v>
<v t="ekr.20071201085751.816"><vh>xrepr_dict</vh></v>
<v t="ekr.20071201085751.817"><vh>upgradexattr</vh></v>
<v t="ekr.20071201085751.818"><vh>xattrs</vh></v>
<v t="ekr.20071201085751.819"><vh>xattrs_complex</vh></v>
<v t="ekr.20071201085751.820"><vh>_isdict</vh></v>
<v t="ekr.20071201085751.821"><vh>_isstr</vh></v>
<v t="ekr.20071201085751.822"><vh>xiter</vh></v>
<v t="ekr.20071201085751.823"><vh>class ichain</vh>
<v t="ekr.20071201085751.824"><vh>__init__</vh></v>
<v t="ekr.20071201085751.825"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.826"><vh>__xrepr__</vh></v>
<v t="ekr.20071201085751.827"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.828"><vh>class ifile</vh>
<v t="ekr.20071201085751.829"><vh>getmode</vh></v>
<v t="ekr.20071201085751.830"><vh>gettype</vh></v>
<v t="ekr.20071201085751.831"><vh>getmodestr</vh></v>
<v t="ekr.20071201085751.832"><vh>getblocks</vh></v>
<v t="ekr.20071201085751.833"><vh>getblksize</vh></v>
<v t="ekr.20071201085751.834"><vh>getdev</vh></v>
<v t="ekr.20071201085751.835"><vh>getnlink</vh></v>
<v t="ekr.20071201085751.836"><vh>getuid</vh></v>
<v t="ekr.20071201085751.837"><vh>getgid</vh></v>
<v t="ekr.20071201085751.838"><vh>getowner</vh></v>
<v t="ekr.20071201085751.839"><vh>getgroup</vh></v>
<v t="ekr.20071201085751.840"><vh>getadate</vh></v>
<v t="ekr.20071201085751.841"><vh>getcdate</vh></v>
<v t="ekr.20071201085751.842"><vh>getmdate</vh></v>
<v t="ekr.20071201085751.843"><vh>mimetype</vh></v>
<v t="ekr.20071201085751.844"><vh>encoding</vh></v>
<v t="ekr.20071201085751.845"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.846"><vh>__xattrs__</vh></v>
</v>
<v t="ekr.20071201085751.847"><vh>xiter_ifile</vh></v>
<v t="ekr.20071201085751.848"><vh>xrepr_ifile</vh></v>
<v t="ekr.20071201085751.849"><vh>class ils</vh>
<v t="ekr.20071201085751.850"><vh>__init__</vh></v>
<v t="ekr.20071201085751.851"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.852"><vh>__xrepr__</vh></v>
<v t="ekr.20071201085751.853"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.854"><vh>class iglob</vh>
<v t="ekr.20071201085751.855"><vh>__init__</vh></v>
<v t="ekr.20071201085751.856"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.857"><vh>__xrepr__</vh></v>
<v t="ekr.20071201085751.858"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.859"><vh>class iwalk</vh>
<v t="ekr.20071201085751.860"><vh>__init__</vh></v>
<v t="ekr.20071201085751.861"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.862"><vh>__xrepr__</vh></v>
<v t="ekr.20071201085751.863"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.864"><vh>class ipwdentry</vh>
<v t="ekr.20071201085751.865"><vh>__init__</vh></v>
<v t="ekr.20071201085751.866"><vh>__eq__</vh></v>
<v t="ekr.20071201085751.867"><vh>__ne__</vh></v>
<v t="ekr.20071201085751.868"><vh>_getentry</vh></v>
<v t="ekr.20071201085751.869"><vh>getname</vh></v>
<v t="ekr.20071201085751.870"><vh>getpasswd</vh></v>
<v t="ekr.20071201085751.871"><vh>getuid</vh></v>
<v t="ekr.20071201085751.872"><vh>getgid</vh></v>
<v t="ekr.20071201085751.873"><vh>getgroup</vh></v>
<v t="ekr.20071201085751.874"><vh>getgecos</vh></v>
<v t="ekr.20071201085751.875"><vh>getdir</vh></v>
<v t="ekr.20071201085751.876"><vh>getshell</vh></v>
<v t="ekr.20071201085751.877"><vh>__xattrs__</vh></v>
<v t="ekr.20071201085751.878"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.879"><vh>class ipwd</vh>
<v t="ekr.20071201085751.880"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.881"><vh>__xrepr__</vh></v>
</v>
<v t="ekr.20071201085751.882"><vh>class igrpentry</vh>
<v t="ekr.20071201085751.883"><vh>__init__</vh></v>
<v t="ekr.20071201085751.884"><vh>__eq__</vh></v>
<v t="ekr.20071201085751.885"><vh>__ne__</vh></v>
<v t="ekr.20071201085751.886"><vh>_getentry</vh></v>
<v t="ekr.20071201085751.887"><vh>getname</vh></v>
<v t="ekr.20071201085751.888"><vh>getpasswd</vh></v>
<v t="ekr.20071201085751.889"><vh>getgid</vh></v>
<v t="ekr.20071201085751.890"><vh>getmem</vh></v>
<v t="ekr.20071201085751.891"><vh>__xattrs__</vh></v>
<v t="ekr.20071201085751.892"><vh>__xrepr__</vh></v>
<v t="ekr.20071201085751.893"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.894"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.895"><vh>class igrp</vh>
<v t="ekr.20071201085751.896"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.897"><vh>__xrepr__</vh></v>
</v>
<v t="ekr.20071201085751.898"><vh>class Fields</vh>
<v t="ekr.20071201085751.899"><vh>__init__</vh></v>
<v t="ekr.20071201085751.900"><vh>__xattrs__</vh></v>
<v t="ekr.20071201085751.901"><vh>__xrepr__</vh></v>
</v>
<v t="ekr.20071201085751.902"><vh>class FieldTable</vh>
<v t="ekr.20071201085751.903"><vh>__init__</vh></v>
<v t="ekr.20071201085751.904"><vh>add</vh></v>
<v t="ekr.20071201085751.905"><vh>__xrepr__</vh></v>
<v t="ekr.20071201085751.906"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.907"><vh>class List</vh>
<v t="ekr.20071201085751.908"><vh>__xattrs__</vh></v>
<v t="ekr.20071201085751.909"><vh>__xrepr__</vh></v>
</v>
<v t="ekr.20071201085751.910"><vh>class ienv</vh>
<v t="ekr.20071201085751.911"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.912"><vh>__xrepr__</vh></v>
</v>
<v t="ekr.20071201085751.913"><vh>class icsv</vh>
<v t="ekr.20071201085751.914"><vh>__init__</vh></v>
<v t="ekr.20071201085751.915"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.916"><vh>__xrepr__</vh></v>
<v t="ekr.20071201085751.917"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.918"><vh>class ix</vh>
<v t="ekr.20071201085751.919"><vh>__init__</vh></v>
<v t="ekr.20071201085751.920"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.921"><vh>__del__</vh></v>
<v t="ekr.20071201085751.922"><vh>__xrepr__</vh></v>
<v t="ekr.20071201085751.923"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.924"><vh>class ifilter</vh>
<v t="ekr.20071201085751.925"><vh>__init__</vh></v>
<v t="ekr.20071201085751.926"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.927"><vh>__xrepr__</vh></v>
<v t="ekr.20071201085751.928"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.929"><vh>class ieval</vh>
<v t="ekr.20071201085751.930"><vh>__init__</vh></v>
<v t="ekr.20071201085751.931"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.932"><vh>__xrepr__</vh></v>
<v t="ekr.20071201085751.933"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.934"><vh>class ienum</vh>
<v t="ekr.20071201085751.935"><vh>__iter__</vh></v>
</v>
<v t="ekr.20071201085751.936"><vh>class isort</vh>
<v t="ekr.20071201085751.937"><vh>__init__</vh></v>
<v t="ekr.20071201085751.938"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.939"><vh>__xrepr__</vh></v>
<v t="ekr.20071201085751.940"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.941"><vh>_format</vh></v>
<v t="ekr.20071201085751.942"><vh>class Display</vh>
<v t="ekr.20071201085751.943"><vh>class __metaclass__</vh>
<v t="ekr.20071201085751.944"><vh>__ror__</vh></v>
</v>
<v t="ekr.20071201085751.945"><vh>__ror__</vh></v>
<v t="ekr.20071201085751.946"><vh>display</vh></v>
</v>
<v t="ekr.20071201085751.947"><vh>class iless</vh>
<v t="ekr.20071201085751.948"><vh>display</vh></v>
</v>
<v t="ekr.20071201085751.949"><vh>xformat</vh></v>
<v t="ekr.20071201085751.950"><vh>class idump</vh>
<v t="ekr.20071201085751.951"><vh>__init__</vh></v>
<v t="ekr.20071201085751.952"><vh>display</vh></v>
</v>
<v t="ekr.20071201085751.953"><vh>class AttributeDetail</vh>
<v t="ekr.20071201085751.954"><vh>__init__</vh></v>
<v t="ekr.20071201085751.955"><vh>__iter__</vh></v>
<v t="ekr.20071201085751.956"><vh>name</vh></v>
<v t="ekr.20071201085751.957"><vh>attrtype</vh></v>
<v t="ekr.20071201085751.958"><vh>valuetype</vh></v>
<v t="ekr.20071201085751.959"><vh>doc</vh></v>
<v t="ekr.20071201085751.960"><vh>shortdoc</vh></v>
<v t="ekr.20071201085751.961"><vh>value</vh></v>
<v t="ekr.20071201085751.962"><vh>__xattrs__</vh></v>
<v t="ekr.20071201085751.963"><vh>__xrepr__</vh></v>
</v>
</v>
<v t="ekr.20071129105210.123"><vh>@@auto Extensions\ipy_defaults.py</vh>
<v t="ekr.20071201085751.964"><vh>ipy_defaults declarations</vh></v>
</v>
<v t="ekr.20071129105210.124"><vh>@@auto Extensions\ipy_pydb.py</vh>
<v t="ekr.20071201085751.965"><vh>ipy_pydb declarations</vh></v>
<v t="ekr.20071201085751.966"><vh>call_pydb</vh></v>
</v>
<v t="ekr.20071129105210.125"><vh>@@auto Extensions\ipy_signals.py</vh>
<v t="ekr.20071201085751.967"><vh>ipy_signals declarations</vh></v>
<v t="ekr.20071201085751.968"><vh>new_ipsystem_posix</vh></v>
<v t="ekr.20071201085751.969"><vh>new_ipsystem_win32</vh></v>
<v t="ekr.20071201085751.970"><vh>init</vh></v>
</v>
<v t="ekr.20071129105210.126" a="M"><vh>@@auto Extensions\ipy_stock_completers.py (bad import)</vh>
<v t="ekr.20071129110439.932"><vh>ipy_stock_completers declarations</vh></v>
<v t="ekr.20071129110439.933"><vh>vcs_completer</vh></v>
<v t="ekr.20071129110439.934"><vh>apt_completers</vh></v>
<v t="ekr.20071129110439.935"><vh>module_completer</vh></v>
<v t="ekr.20071129110439.936"><vh>svn_completer</vh></v>
<v t="ekr.20071129110439.937"><vh>hg_completer</vh></v>
<v t="ekr.20071129110439.938"><vh>bzr_completer</vh></v>
<v t="ekr.20071129110439.939"><vh>runlistpy</vh></v>
<v t="ekr.20071129110439.940"><vh>cd_completer</vh></v>
</v>
<v t="ekr.20071129105210.127"><vh>@@auto Extensions\ipy_system_conf.py</vh>
<v t="ekr.20071201085751.971"><vh>ipy_system_conf declarations</vh></v>
</v>
<v t="ekr.20071129105210.128"><vh>@@auto Extensions\jobctrl.py</vh>
<v t="ekr.20071201085751.972"><vh>jobctrl declarations</vh></v>
<v t="ekr.20071201085751.973"><vh>class IpyPopen</vh>
<v t="ekr.20071201085751.974"><vh>go</vh></v>
<v t="ekr.20071201085751.975"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.976"><vh>kill</vh></v>
</v>
<v t="ekr.20071201085751.977"><vh>startjob</vh></v>
<v t="ekr.20071201085751.978"><vh>jobctrl_prefilter_f</vh></v>
<v t="ekr.20071201085751.979"><vh>install</vh></v>
</v>
<v t="ekr.20071129105210.129"><vh>@@auto Extensions\ledit.py</vh>
<v t="ekr.20071201085751.980"><vh>ledit declarations</vh></v>
<v t="ekr.20071201085751.981"><vh>line_edit_f</vh></v>
<v t="ekr.20071201085751.982"><vh>line_edit_complete_f</vh></v>
</v>
<v t="ekr.20071129105210.130"><vh>@@auto Extensions\numeric_formats.py</vh>
<v t="ekr.20071201085751.983"><vh>numeric_formats declarations</vh></v>
<v t="ekr.20071201085751.984"><vh>num_display</vh></v>
<v t="ekr.20071201085751.985"><vh>magic_format</vh></v>
</v>
<v t="ekr.20071129105210.131"><vh>@@auto Extensions\path.py</vh>
<v t="ekr.20071201085751.986"><vh>path declarations</vh></v>
<v t="ekr.20071201085751.987"><vh>class TreeWalkWarning</vh></v>
<v t="ekr.20071201085751.988"><vh>class path</vh>
<v t="ekr.20071201085751.989"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.990"><vh>__add__</vh></v>
<v t="ekr.20071201085751.991"><vh>__radd__</vh></v>
<v t="ekr.20071201085751.992"><vh>__div__</vh></v>
<v t="ekr.20071201085751.993"><vh>getcwd</vh></v>
<v t="ekr.20071201085751.994"><vh>abspath</vh></v>
<v t="ekr.20071201085751.995"><vh>normcase</vh></v>
<v t="ekr.20071201085751.996"><vh>normpath</vh></v>
<v t="ekr.20071201085751.997"><vh>realpath</vh></v>
<v t="ekr.20071201085751.998"><vh>expanduser</vh></v>
<v t="ekr.20071201085751.999"><vh>expandvars</vh></v>
<v t="ekr.20071201085751.1000"><vh>dirname</vh></v>
<v t="ekr.20071201085751.1001"><vh>expand</vh></v>
<v t="ekr.20071201085751.1002"><vh>_get_namebase</vh></v>
<v t="ekr.20071201085751.1003"><vh>_get_ext</vh></v>
<v t="ekr.20071201085751.1004"><vh>_get_drive</vh></v>
<v t="ekr.20071201085751.1005"><vh>splitpath</vh></v>
<v t="ekr.20071201085751.1006"><vh>splitdrive</vh></v>
<v t="ekr.20071201085751.1007"><vh>splitext</vh></v>
<v t="ekr.20071201085751.1008"><vh>stripext</vh></v>
<v t="ekr.20071201085751.1009"><vh>joinpath</vh></v>
<v t="ekr.20071201085751.1010"><vh>splitall</vh></v>
<v t="ekr.20071201085751.1011"><vh>relpath</vh></v>
<v t="ekr.20071201085751.1012"><vh>relpathto</vh></v>
<v t="ekr.20071201085751.1013"><vh>listdir</vh></v>
<v t="ekr.20071201085751.1014"><vh>dirs</vh></v>
<v t="ekr.20071201085751.1015"><vh>files</vh></v>
<v t="ekr.20071201085751.1016"><vh>walk</vh></v>
<v t="ekr.20071201085751.1017"><vh>walkdirs</vh></v>
<v t="ekr.20071201085751.1018"><vh>walkfiles</vh></v>
<v t="ekr.20071201085751.1019"><vh>fnmatch</vh></v>
<v t="ekr.20071201085751.1020"><vh>glob</vh></v>
<v t="ekr.20071201085751.1021"><vh>open</vh></v>
<v t="ekr.20071201085751.1022"><vh>bytes</vh></v>
<v t="ekr.20071201085751.1023"><vh>write_bytes</vh></v>
<v t="ekr.20071201085751.1024"><vh>text</vh></v>
<v t="ekr.20071201085751.1025"><vh>write_text</vh></v>
<v t="ekr.20071201085751.1026"><vh>lines</vh></v>
<v t="ekr.20071201085751.1027"><vh>write_lines</vh></v>
<v t="ekr.20071201085751.1028"><vh>read_md5</vh></v>
<v t="ekr.20071201085751.1029"><vh>stat</vh></v>
<v t="ekr.20071201085751.1030"><vh>lstat</vh></v>
<v t="ekr.20071201085751.1031"><vh>get_owner</vh></v>
<v t="ekr.20071201085751.1032"><vh>utime</vh></v>
<v t="ekr.20071201085751.1033"><vh>chmod</vh></v>
<v t="ekr.20071201085751.1034"><vh>rename</vh></v>
<v t="ekr.20071201085751.1035"><vh>renames</vh></v>
<v t="ekr.20071201085751.1036"><vh>mkdir</vh></v>
<v t="ekr.20071201085751.1037"><vh>makedirs</vh></v>
<v t="ekr.20071201085751.1038"><vh>rmdir</vh></v>
<v t="ekr.20071201085751.1039"><vh>removedirs</vh></v>
<v t="ekr.20071201085751.1040"><vh>touch</vh></v>
<v t="ekr.20071201085751.1041"><vh>remove</vh></v>
<v t="ekr.20071201085751.1042"><vh>unlink</vh></v>
</v>
</v>
<v t="ekr.20071129105210.132"><vh>@@auto Extensions\PhysicalQInput.py</vh>
<v t="ekr.20071201085751.1043"><vh>PhysicalQInput declarations</vh></v>
<v t="ekr.20071201085751.1044"><vh>prefilter_PQ</vh></v>
</v>
<v t="ekr.20071129105210.133"><vh>@@auto Extensions\PhysicalQInteractive.py</vh>
<v t="ekr.20071201085751.1045"><vh>PhysicalQInteractive declarations</vh></v>
<v t="ekr.20071201085751.1046"><vh>class PhysicalQuantityFunction</vh>
<v t="ekr.20071201085751.1047"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1048"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1049"><vh>class PhysicalQuantityInteractive</vh>
<v t="ekr.20071201085751.1050"><vh>__str__</vh></v>
<v t="ekr.20071201085751.1051"><vh>__repr__</vh></v>
</v>
</v>
<v t="ekr.20071129105210.134"><vh>@@auto Extensions\pickleshare.py</vh>
<v t="ekr.20071201085751.1052"><vh>pickleshare declarations</vh></v>
<v t="ekr.20071201085751.1053"><vh>class PickleShareDB</vh>
<v t="ekr.20071201085751.1054"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1055"><vh>__getitem__</vh></v>
<v t="ekr.20071201085751.1056"><vh>__setitem__</vh></v>
<v t="ekr.20071201085751.1057"><vh>__delitem__</vh></v>
<v t="ekr.20071201085751.1058"><vh>_normalized</vh></v>
<v t="ekr.20071201085751.1059"><vh>keys</vh></v>
<v t="ekr.20071201085751.1060"><vh>uncache</vh></v>
<v t="ekr.20071201085751.1061"><vh>waitget</vh></v>
<v t="ekr.20071201085751.1062"><vh>getlink</vh></v>
<v t="ekr.20071201085751.1063"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.1064"><vh>class PickleShareLink</vh>
<v t="ekr.20071201085751.1065"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1066"><vh>__getattr__</vh></v>
<v t="ekr.20071201085751.1067"><vh>__setattr__</vh></v>
<v t="ekr.20071201085751.1068"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201085751.1069"><vh>test</vh></v>
<v t="ekr.20071201085751.1070"><vh>stress</vh></v>
<v t="ekr.20071201085751.1071"><vh>main</vh></v>
</v>
<v t="ekr.20071129105210.135"><vh>@@auto Extensions\pspersistence.py</vh>
<v t="ekr.20071201085751.1072"><vh>pspersistence declarations</vh></v>
<v t="ekr.20071201085751.1073"><vh>restore_aliases</vh></v>
<v t="ekr.20071201085751.1074"><vh>refresh_variables</vh></v>
<v t="ekr.20071201085751.1075"><vh>restore_data</vh></v>
<v t="ekr.20071201085751.1076"><vh>magic_store</vh></v>
</v>
<v t="ekr.20071129105210.136"><vh>@@auto Extensions\win32clip.py</vh>
<v t="ekr.20071201085751.1077"><vh>win32clip declarations</vh></v>
<v t="ekr.20071201085751.1078"><vh>clip_f</vh></v>
</v>
<v t="ekr.20071129105210.137"><vh>@@auto Extensions\__init__.py</vh>
<v t="ekr.20071201085751.1079"><vh>__init__ declarations</vh></v>
</v>
</v>
<v t="ekr.20071129110733.1043"><vh>UserConfig</vh>
<v t="ekr.20071129105210.138"><vh>@@auto UserConfig\ipy_profile_sh.py</vh>
<v t="ekr.20071201085751.1080"><vh>ipy_profile_sh declarations</vh></v>
<v t="ekr.20071201085751.1081"><vh>main</vh></v>
<v t="ekr.20071201085751.1082"><vh>extend_shell_behavior</vh></v>
</v>
<v t="ekr.20071129105210.139"><vh>@@auto UserConfig\ipy_user_conf.py</vh>
<v t="ekr.20071201085751.1083"><vh>ipy_user_conf declarations</vh></v>
<v t="ekr.20071201085751.1084"><vh>main</vh></v>
</v>
</v>
</v>
<v t="ekr.20071201083431"><vh>@path c:\Python25\Lib\site-packages\pyreadline</vh>
<v t="ekr.20071201083431.1"><vh>top level</vh>
<v t="ekr.20071201083431.2"><vh>@@auto clipboard.py</vh>
<v t="ekr.20071201085751.1085"><vh>clipboard declarations</vh></v>
<v t="ekr.20071201085751.1086"><vh>enum</vh></v>
<v t="ekr.20071201085751.1087"><vh>getformatname</vh></v>
<v t="ekr.20071201085751.1088"><vh>GetClipboardText</vh></v>
<v t="ekr.20071201085751.1089"><vh>make_tab</vh></v>
<v t="ekr.20071201085751.1090"><vh>send_data</vh></v>
<v t="ekr.20071201085751.1091"><vh>SetClipboardText</vh></v>
<v t="ekr.20071201085751.1092"><vh>set_clipboard_text</vh></v>
<v t="ekr.20071201085751.1093"><vh>make_list_of_list</vh></v>
<v t="ekr.20071201085751.1094"><vh>get_clipboard_text_and_convert</vh></v>
</v>
<v t="ekr.20071201083431.3"><vh>@@auto console.py (import error)</vh>
<v t="ekr.20071201084507.10"><vh>console declarations</vh></v>
<v t="ekr.20071201084507.11"><vh>class COORD</vh></v>
<v t="ekr.20071201084507.12"><vh>class SMALL_RECT</vh></v>
<v t="ekr.20071201084507.13"><vh>class CONSOLE_SCREEN_BUFFER_INFO</vh></v>
<v t="ekr.20071201084507.14"><vh>class CHAR_UNION</vh></v>
<v t="ekr.20071201084507.15"><vh>class CHAR_INFO</vh></v>
<v t="ekr.20071201084507.16"><vh>class KEY_EVENT_RECORD</vh></v>
<v t="ekr.20071201084507.17"><vh>class MOUSE_EVENT_RECORD</vh></v>
<v t="ekr.20071201084507.18"><vh>class WINDOW_BUFFER_SIZE_RECORD</vh></v>
<v t="ekr.20071201084507.19"><vh>class MENU_EVENT_RECORD</vh></v>
<v t="ekr.20071201084507.20"><vh>class FOCUS_EVENT_RECORD</vh></v>
<v t="ekr.20071201084507.21"><vh>class INPUT_UNION</vh></v>
<v t="ekr.20071201084507.22"><vh>class INPUT_RECORD</vh></v>
<v t="ekr.20071201084507.23"><vh>class CONSOLE_CURSOR_INFO</vh></v>
<v t="ekr.20071201084507.24"><vh>class Console</vh>
<v t="ekr.20071201084507.25"><vh>__init__</vh></v>
<v t="ekr.20071201084507.26"><vh>__del__</vh></v>
<v t="ekr.20071201084507.27"><vh>fixcoord</vh></v>
<v t="ekr.20071201084507.28"><vh>pos</vh></v>
<v t="ekr.20071201084507.29"><vh>home</vh></v>
<v t="ekr.20071201084507.30"><vh>write_scrolling</vh></v>
<v t="ekr.20071201084507.31"><vh>write_color</vh></v>
<v t="ekr.20071201084507.32"><vh>write_plain</vh></v>
<v t="ekr.20071201084507.33"><vh>write</vh></v>
<v t="ekr.20071201084507.34"><vh>isatty</vh></v>
<v t="ekr.20071201084507.35"><vh>flush</vh></v>
<v t="ekr.20071201084507.36"><vh>page</vh></v>
<v t="ekr.20071201084507.37"><vh>text</vh></v>
<v t="ekr.20071201084507.38"><vh>rectangle</vh></v>
<v t="ekr.20071201084507.39"><vh>scroll</vh></v>
<v t="ekr.20071201084507.40"><vh>scroll_window</vh></v>
<v t="ekr.20071201084507.41"><vh>get</vh></v>
<v t="ekr.20071201084507.42"><vh>getkeypress</vh></v>
<v t="ekr.20071201084507.43"><vh>getchar</vh></v>
<v t="ekr.20071201084507.44"><vh>peek</vh></v>
<v t="ekr.20071201084507.45"><vh>title</vh></v>
<v t="ekr.20071201084507.46"><vh>size</vh></v>
<v t="ekr.20071201084507.47"><vh>cursor</vh></v>
<v t="ekr.20071201084507.48"><vh>bell</vh></v>
<v t="ekr.20071201084507.49"><vh>next_serial</vh></v>
</v>
<v t="ekr.20071201084507.50"><vh>class event</vh>
<v t="ekr.20071201084507.51"><vh>__init__</vh></v>
<v t="ekr.20071201084507.52"><vh>__repr__</vh></v>
</v>
<v t="ekr.20071201084507.53"><vh>getconsole</vh></v>
<v t="ekr.20071201084507.54"><vh>hook_wrapper_23</vh></v>
<v t="ekr.20071201084507.55"><vh>hook_wrapper</vh></v>
<v t="ekr.20071201084507.56"><vh>install_readline</vh></v>
</v>
<v t="ekr.20071201083431.4"><vh>@@auto error.py</vh>
<v t="ekr.20071201085751.1095"><vh>class ReadlineError</vh></v>
<v t="ekr.20071201085751.1096"><vh>class GetSetError</vh></v>
</v>
<v t="ekr.20071201083431.5"><vh>@@auto get_doc.py (import warning)</vh>
<v t="ekr.20071201085451.1098"><vh>get_doc declarations</vh></v>
<v t="ekr.20071201085451.1099"><vh>get_doc</vh></v>
<v t="ekr.20071201085451.1100"><vh>get_rest</vh></v>
</v>
<v t="ekr.20071201083431.6"><vh>@@auto init_rl.py</vh>
<v t="ekr.20071201085751.1097"><vh>init_rl declarations</vh></v>
<v t="ekr.20071201085751.1098"><vh>GetOutputFile</vh></v>
</v>
<v t="ekr.20071201083431.7"><vh>@@auto keysyms.py</vh>
<v t="ekr.20071201085751.1099"><vh>keysyms declarations</vh></v>
<v t="ekr.20071201085751.1100"><vh>make_keysym</vh></v>
<v t="ekr.20071201085751.1101"><vh>key_text_to_keyinfo</vh></v>
<v t="ekr.20071201085751.1102"><vh>char_to_keyinfo</vh></v>
<v t="ekr.20071201085751.1103"><vh>keyname_to_keyinfo</vh></v>
<v t="ekr.20071201085751.1104"><vh>keyseq_to_keyinfo</vh></v>
<v t="ekr.20071201085751.1105"><vh>make_keyinfo</vh></v>
</v>
<v t="ekr.20071201083431.8"><vh>@@auto logger.py</vh>
<v t="ekr.20071201085751.1106"><vh>logger declarations</vh></v>
<v t="ekr.20071201085751.1107"><vh>start_log</vh></v>
<v t="ekr.20071201085751.1108"><vh>log</vh></v>
<v t="ekr.20071201085751.1109"><vh>log_sock</vh></v>
</v>
<v t="ekr.20071201083431.9"><vh>@@auto logserver.py</vh>
<v t="ekr.20071201085751.1110"><vh>logserver declarations</vh></v>
<v t="ekr.20071201085751.1111"><vh>check_key</vh></v>
</v>
<v t="ekr.20071201083431.10"><vh>@@auto release.py</vh>
<v t="ekr.20071201085751.1112"><vh>release declarations</vh></v>
</v>
<v t="ekr.20071201083431.11"><vh>@@auto rlmain.py</vh>
<v t="ekr.20071201085751.1113"><vh>rlmain declarations</vh></v>
<v t="ekr.20071201085751.1114"><vh>quote_char</vh></v>
<v t="ekr.20071201085751.1115"><vh>inword</vh></v>
<v t="ekr.20071201085751.1116"><vh>class Readline</vh>
<v t="ekr.20071201085751.1117"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1118"><vh>_g</vh></v>
<v t="ekr.20071201085751.1119"><vh>parse_and_bind</vh></v>
<v t="ekr.20071201085751.1120"><vh>get_line_buffer</vh></v>
<v t="ekr.20071201085751.1121"><vh>insert_text</vh></v>
<v t="ekr.20071201085751.1122"><vh>read_init_file</vh></v>
<v t="ekr.20071201085751.1123"><vh>add_history</vh></v>
<v t="ekr.20071201085751.1124"><vh>get_history_length</vh></v>
<v t="ekr.20071201085751.1125"><vh>set_history_length</vh></v>
<v t="ekr.20071201085751.1126"><vh>clear_history</vh></v>
<v t="ekr.20071201085751.1127"><vh>read_history_file</vh></v>
<v t="ekr.20071201085751.1128"><vh>write_history_file</vh></v>
<v t="ekr.20071201085751.1129"><vh>set_completer</vh></v>
<v t="ekr.20071201085751.1130"><vh>get_completer</vh></v>
<v t="ekr.20071201085751.1131"><vh>get_begidx</vh></v>
<v t="ekr.20071201085751.1132"><vh>get_endidx</vh></v>
<v t="ekr.20071201085751.1133"><vh>set_completer_delims</vh></v>
<v t="ekr.20071201085751.1134"><vh>get_completer_delims</vh></v>
<v t="ekr.20071201085751.1135"><vh>set_startup_hook</vh></v>
<v t="ekr.20071201085751.1136"><vh>set_pre_input_hook</vh></v>
<v t="ekr.20071201085751.1137"><vh>rl_settings_to_string</vh></v>
<v t="ekr.20071201085751.1138"><vh>_bell</vh></v>
<v t="ekr.20071201085751.1139"><vh>_clear_after</vh></v>
<v t="ekr.20071201085751.1140"><vh>_set_cursor</vh></v>
<v t="ekr.20071201085751.1141"><vh>_print_prompt</vh></v>
<v t="ekr.20071201085751.1142"><vh>_update_prompt_pos</vh></v>
<v t="ekr.20071201085751.1143"><vh>_update_line</vh></v>
<v t="ekr.20071201085751.1144"><vh>readline</vh></v>
<v t="ekr.20071201085751.1145"><vh>read_inputrc</vh></v>
</v>
<v t="ekr.20071201085751.1146"><vh>CTRL</vh></v>
<v t="ekr.20071201085751.1147"><vh>GetOutputFile</vh></v>
</v>
<v t="ekr.20071201083431.12"><vh>@@auto winconstants.py</vh>
<v t="ekr.20071201085751.1148"><vh>winconstants declarations</vh></v>
</v>
<v t="ekr.20071201083431.13"><vh>@@auto __init__.py</vh>
<v t="ekr.20071201085751.1149"><vh>__init__ declarations</vh></v>
</v>
</v>
<v t="ekr.20071201083431.14"><vh>clipboard</vh>
<v t="ekr.20071201083431.15"><vh>@@auto clipboard\ironpython_clipboard.py</vh>
<v t="ekr.20071201085751.1150"><vh>ironpython_clipboard declarations</vh></v>
<v t="ekr.20071201085751.1151"><vh>GetClipboardText</vh></v>
<v t="ekr.20071201085751.1152"><vh>SetClipboardText</vh></v>
</v>
<v t="ekr.20071201083431.16"><vh>@@auto clipboard\win32_clipboard.py</vh>
<v t="ekr.20071201085751.1153"><vh>win32_clipboard declarations</vh></v>
<v t="ekr.20071201085751.1154"><vh>enum</vh></v>
<v t="ekr.20071201085751.1155"><vh>getformatname</vh></v>
<v t="ekr.20071201085751.1156"><vh>GetClipboardText</vh></v>
<v t="ekr.20071201085751.1157"><vh>SetClipboardText</vh></v>
</v>
<v t="ekr.20071201083431.17"><vh>@@auto clipboard\__init__.py</vh>
<v t="ekr.20071201085751.1158"><vh>__init__ declarations</vh></v>
<v t="ekr.20071201085751.1159"><vh>send_data</vh></v>
<v t="ekr.20071201085751.1160"><vh>set_clipboard_text</vh></v>
<v t="ekr.20071201085751.1161"><vh>make_tab</vh></v>
<v t="ekr.20071201085751.1162"><vh>make_list_of_list</vh></v>
<v t="ekr.20071201085751.1163"><vh>get_clipboard_text_and_convert</vh></v>
</v>
</v>
<v t="ekr.20071201083431.18"><vh>@@auto configuration\startup.py</vh>
<v t="ekr.20071201085751.1164"><vh>startup declarations</vh></v>
</v>
<v t="ekr.20071201083431.19"><vh>console</vh>
<v t="ekr.20071201083431.20"><vh>@@auto console\ansi.py (import error)</vh>
<v t="ekr.20071201084507.130"><vh>ansi declarations</vh></v>
<v t="ekr.20071201084507.131"><vh>class AnsiState</vh>
<v t="ekr.20071201084507.132"><vh>__init__</vh></v>
<v t="ekr.20071201084507.133"><vh>get_winattr</vh></v>
<v t="ekr.20071201084507.134"><vh>set_winattr</vh></v>
<v t="ekr.20071201084507.135"><vh>__repr__</vh></v>
<v t="ekr.20071201084507.136"><vh>copy</vh></v>
</v>
<v t="ekr.20071201084507.137"><vh>class AnsiWriter</vh>
<v t="ekr.20071201084507.138"><vh>__init__</vh></v>
<v t="ekr.20071201084507.139"><vh>write_color</vh></v>
<v t="ekr.20071201084507.140"><vh>parse_color</vh></v>
</v>
<v t="ekr.20071201084507.141"><vh>write_color</vh></v>
<v t="ekr.20071201084507.142"><vh>write_color_old</vh></v>
</v>
<v t="ekr.20071201083431.21"><vh>@@auto console\console.py (import error)</vh>
<v t="ekr.20071201084507.143"><vh>console declarations</vh></v>
<v t="ekr.20071201084507.144"><vh>class COORD</vh></v>
<v t="ekr.20071201084507.145"><vh>class SMALL_RECT</vh></v>
<v t="ekr.20071201084507.146"><vh>class CONSOLE_SCREEN_BUFFER_INFO</vh></v>
<v t="ekr.20071201084507.147"><vh>class CHAR_UNION</vh></v>
<v t="ekr.20071201084507.148"><vh>class CHAR_INFO</vh></v>
<v t="ekr.20071201084507.149"><vh>class KEY_EVENT_RECORD</vh></v>
<v t="ekr.20071201084507.150"><vh>class MOUSE_EVENT_RECORD</vh></v>
<v t="ekr.20071201084507.151"><vh>class WINDOW_BUFFER_SIZE_RECORD</vh></v>
<v t="ekr.20071201084507.152"><vh>class MENU_EVENT_RECORD</vh></v>
<v t="ekr.20071201084507.153"><vh>class FOCUS_EVENT_RECORD</vh></v>
<v t="ekr.20071201084507.154"><vh>class INPUT_UNION</vh></v>
<v t="ekr.20071201084507.155"><vh>class INPUT_RECORD</vh></v>
<v t="ekr.20071201084507.156"><vh>class CONSOLE_CURSOR_INFO</vh></v>
<v t="ekr.20071201084507.157"><vh>ensure_text</vh></v>
<v t="ekr.20071201084507.158"><vh>class Console</vh>
<v t="ekr.20071201084507.159"><vh>__init__</vh></v>
<v t="ekr.20071201084507.160"><vh>__del__</vh></v>
<v t="ekr.20071201084507.161"><vh>_get_top_bot</vh></v>
<v t="ekr.20071201084507.162"><vh>fixcoord</vh></v>
<v t="ekr.20071201084507.163"><vh>pos</vh></v>
<v t="ekr.20071201084507.164"><vh>home</vh></v>
<v t="ekr.20071201084507.165"><vh>write_scrolling</vh></v>
<v t="ekr.20071201084507.166"><vh>write_color</vh></v>
<v t="ekr.20071201084507.167"><vh>write_color</vh></v>
<v t="ekr.20071201084507.168"><vh>write_plain</vh></v>
<v t="ekr.20071201084507.169"><vh>write</vh></v>
<v t="ekr.20071201084507.170"><vh>isatty</vh></v>
<v t="ekr.20071201084507.171"><vh>flush</vh></v>
<v t="ekr.20071201084507.172"><vh>page</vh></v>
<v t="ekr.20071201084507.173"><vh>text</vh></v>
<v t="ekr.20071201084507.174"><vh>clear_to_end_of_window</vh></v>
<v t="ekr.20071201084507.175"><vh>rectangle</vh></v>
<v t="ekr.20071201084507.176"><vh>scroll</vh></v>
<v t="ekr.20071201084507.177"><vh>scroll_window</vh></v>
<v t="ekr.20071201084507.178"><vh>get</vh></v>
<v t="ekr.20071201084507.179"><vh>getkeypress</vh></v>
<v t="ekr.20071201084507.180"><vh>getchar</vh></v>
<v t="ekr.20071201084507.181"><vh>peek</vh></v>
<v t="ekr.20071201084507.182"><vh>title</vh></v>
<v t="ekr.20071201084507.183"><vh>size</vh></v>
<v t="ekr.20071201084507.184"><vh>cursor</vh></v>
<v t="ekr.20071201084507.185"><vh>bell</vh></v>
<v t="ekr.20071201084507.186"><vh>next_serial</vh></v>
</v>
<v t="ekr.20071201084507.187"><vh>class event</vh>
<v t="ekr.20071201084507.188"><vh>__init__</vh></v>
</v>
<v t="ekr.20071201084507.189"><vh>getconsole</vh></v>
<v t="ekr.20071201084507.190"><vh>hook_wrapper_23</vh></v>
<v t="ekr.20071201084507.191"><vh>hook_wrapper</vh></v>
<v t="ekr.20071201084507.192"><vh>install_readline</vh></v>
</v>
<v t="ekr.20071201083431.22"><vh>@@auto console\consolebase.py</vh>
<v t="ekr.20071201085751.1165"><vh>class baseconsole</vh>
<v t="ekr.20071201085751.1166"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1167"><vh>bell</vh></v>
<v t="ekr.20071201085751.1168"><vh>pos</vh></v>
<v t="ekr.20071201085751.1169"><vh>size</vh></v>
<v t="ekr.20071201085751.1170"><vh>rectangle</vh></v>
<v t="ekr.20071201085751.1171"><vh>write_scrolling</vh></v>
<v t="ekr.20071201085751.1172"><vh>getkeypress</vh></v>
<v t="ekr.20071201085751.1173"><vh>write</vh></v>
<v t="ekr.20071201085751.1174"><vh>page</vh></v>
<v t="ekr.20071201085751.1175"><vh>isatty</vh></v>
<v t="ekr.20071201085751.1176"><vh>flush</vh></v>
</v>
</v>
<v t="ekr.20071201083431.23"><vh>@@auto console\console_attributes.py</vh>
<v t="ekr.20071201085751.1177"><vh>console_attributes declarations</vh></v>
</v>
<v t="ekr.20071201083431.24"><vh>@@auto console\event.py</vh>
<v t="ekr.20071201085751.1178"><vh>class Event</vh>
<v t="ekr.20071201085751.1179"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1180"><vh>__repr__</vh></v>
</v>
</v>
<v t="ekr.20071201083431.25"><vh>@@auto console\ironpython_console.py</vh>
<v t="ekr.20071201084507.209"><vh>ironpython_console declarations</vh></v>
<v t="ekr.20071201084507.210"><vh>class Console</vh>
<v t="ekr.20071201084507.211"><vh>__init__</vh></v>
<v t="ekr.20071201084507.212"><vh>_get</vh></v>
<v t="ekr.20071201084507.213"><vh>_set</vh></v>
<v t="ekr.20071201084507.214"><vh>__del__</vh></v>
<v t="ekr.20071201084507.215"><vh>pos</vh></v>
<v t="ekr.20071201084507.216"><vh>home</vh></v>
<v t="ekr.20071201084507.217"><vh>write_scrolling</vh></v>
<v t="ekr.20071201084507.218"><vh>write_color</vh></v>
<v t="ekr.20071201084507.219"><vh>write_plain</vh></v>
<v t="ekr.20071201084507.220"><vh>write</vh></v>
<v t="ekr.20071201084507.221"><vh>isatty</vh></v>
<v t="ekr.20071201084507.222"><vh>flush</vh></v>
<v t="ekr.20071201084507.223"><vh>page</vh></v>
<v t="ekr.20071201084507.224"><vh>text</vh></v>
<v t="ekr.20071201084507.225"><vh>clear_to_end_of_window</vh></v>
<v t="ekr.20071201084507.226"><vh>rectangle</vh></v>
<v t="ekr.20071201084507.227"><vh>scroll</vh></v>
<v t="ekr.20071201084507.228"><vh>scroll_window</vh></v>
<v t="ekr.20071201084507.229"><vh>getkeypress</vh></v>
<v t="ekr.20071201084507.230"><vh>title</vh></v>
<v t="ekr.20071201084507.231"><vh>size</vh></v>
<v t="ekr.20071201084507.232"><vh>cursor</vh></v>
<v t="ekr.20071201084507.233"><vh>bell</vh></v>
<v t="ekr.20071201084507.234"><vh>next_serial</vh></v>
</v>
<v t="ekr.20071201084507.235"><vh>class event</vh>
<v t="ekr.20071201084507.236"><vh>__init__</vh></v>
</v>
<v t="ekr.20071201084507.237"><vh>make_event_from_keydescr</vh></v>
<v t="ekr.20071201084507.238"><vh>install_readline</vh></v>
</v>
<v t="ekr.20071201083431.26"><vh>@@auto console\__init__.py</vh>
<v t="ekr.20071201085751.1181"><vh>__init__ declarations</vh></v>
</v>
<v t="ekr.20071201083431.27"><vh>@@auto keysyms\common.py</vh>
<v t="ekr.20071201085751.1182"><vh>common declarations</vh></v>
<v t="ekr.20071201085751.1183"><vh>class KeyPress</vh>
<v t="ekr.20071201085751.1184"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1185"><vh>create</vh></v>
<v t="ekr.20071201085751.1186"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.1187"><vh>tuple</vh></v>
</v>
<v t="ekr.20071201085751.1188"><vh>make_KeyPress_from_keydescr</vh></v>
</v>
<v t="ekr.20071201083431.28"><vh>@@auto keysyms\ironpython_keysyms.py</vh>
<v t="ekr.20071201085751.1189"><vh>ironpython_keysyms declarations</vh></v>
<v t="ekr.20071201085751.1190"><vh>make_keysym</vh></v>
<v t="ekr.20071201085751.1191"><vh>key_text_to_keyinfo</vh></v>
<v t="ekr.20071201085751.1192"><vh>char_to_keyinfo</vh></v>
<v t="ekr.20071201085751.1193"><vh>keyname_to_keyinfo</vh></v>
<v t="ekr.20071201085751.1194"><vh>keyseq_to_keyinfo</vh></v>
<v t="ekr.20071201085751.1195"><vh>make_keyinfo</vh></v>
<v t="ekr.20071201085751.1196"><vh>make_KeyPress</vh></v>
</v>
<v t="ekr.20071201083431.29"><vh>@@auto keysyms\keysyms.py</vh>
<v t="ekr.20071201085751.1197"><vh>keysyms declarations</vh></v>
<v t="ekr.20071201085751.1198"><vh>char_to_keyinfo</vh></v>
<v t="ekr.20071201085751.1199"><vh>make_KeyPress</vh></v>
</v>
<v t="ekr.20071201083431.30"><vh>@@auto keysyms\winconstants.py</vh>
<v t="ekr.20071201085751.1200"><vh>winconstants declarations</vh></v>
</v>
<v t="ekr.20071201083431.31"><vh>@@auto keysyms\__init__.py</vh>
<v t="ekr.20071201085751.1201"><vh>__init__ declarations</vh></v>
</v>
</v>
<v t="ekr.20071201083431.32"><vh>lineeditor</vh>
<v t="ekr.20071201083431.33"><vh>@@auto lineeditor\history.py</vh>
<v t="ekr.20071201085751.1202"><vh>history declarations</vh></v>
<v t="ekr.20071201085751.1203"><vh>class EscapeHistory</vh></v>
<v t="ekr.20071201085751.1204"><vh>class LineHistory</vh>
<v t="ekr.20071201085751.1205"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1206"><vh>get_history_length</vh></v>
<v t="ekr.20071201085751.1207"><vh>set_history_length</vh></v>
<v t="ekr.20071201085751.1208"><vh>get_history_cursor</vh></v>
<v t="ekr.20071201085751.1209"><vh>set_history_cursor</vh></v>
<v t="ekr.20071201085751.1210"><vh>clear_history</vh></v>
<v t="ekr.20071201085751.1211"><vh>read_history_file</vh></v>
<v t="ekr.20071201085751.1212"><vh>write_history_file</vh></v>
<v t="ekr.20071201085751.1213"><vh>add_history</vh></v>
<v t="ekr.20071201085751.1214"><vh>previous_history</vh></v>
<v t="ekr.20071201085751.1215"><vh>next_history</vh></v>
<v t="ekr.20071201085751.1216"><vh>beginning_of_history</vh></v>
<v t="ekr.20071201085751.1217"><vh>end_of_history</vh></v>
<v t="ekr.20071201085751.1218"><vh>reverse_search_history</vh></v>
<v t="ekr.20071201085751.1219"><vh>forward_search_history</vh></v>
<v t="ekr.20071201085751.1220"><vh>_non_i_search</vh></v>
<v t="ekr.20071201085751.1221"><vh>non_incremental_reverse_search_history</vh></v>
<v t="ekr.20071201085751.1222"><vh>non_incremental_forward_search_history</vh></v>
<v t="ekr.20071201085751.1223"><vh>_search</vh></v>
<v t="ekr.20071201085751.1224"><vh>history_search_forward</vh></v>
<v t="ekr.20071201085751.1225"><vh>history_search_backward</vh></v>
</v>
</v>
<v t="ekr.20071201083431.34" a="M"><vh>@@auto lineeditor\lineobj.py</vh>
<v t="ekr.20071201085751.1226"><vh>lineobj declarations</vh></v>
<v t="ekr.20071201085751.1227"><vh>class NotAWordError</vh></v>
<v t="ekr.20071201085751.1228"><vh>quote_char</vh></v>
<v t="ekr.20071201085751.1229"><vh>class LinePositioner</vh>
<v t="ekr.20071201085751.1230"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1231"><vh>class NextChar</vh>
<v t="ekr.20071201085751.1232"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1233"><vh>class PrevChar</vh>
<v t="ekr.20071201085751.1234"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1235"><vh>class NextWordStart</vh>
<v t="ekr.20071201085751.1236"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1237"><vh>class NextWordEnd</vh>
<v t="ekr.20071201085751.1238"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1239"><vh>class PrevWordStart</vh>
<v t="ekr.20071201085751.1240"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1241"><vh>class WordStart</vh>
<v t="ekr.20071201085751.1242"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1243"><vh>class WordEnd</vh>
<v t="ekr.20071201085751.1244"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1245"><vh>class PrevWordEnd</vh>
<v t="ekr.20071201085751.1246"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1247"><vh>class PrevSpace</vh>
<v t="ekr.20071201085751.1248"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1249"><vh>class StartOfLine</vh>
<v t="ekr.20071201085751.1250"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1251"><vh>class EndOfLine</vh>
<v t="ekr.20071201085751.1252"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1253"><vh>class Point</vh>
<v t="ekr.20071201085751.1254"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1255"><vh>class Mark</vh>
<v t="ekr.20071201085751.1256"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1257"><vh>class LineSlice</vh>
<v t="ekr.20071201085751.1258"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1259"><vh>class CurrentWord</vh>
<v t="ekr.20071201085751.1260"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1261"><vh>class NextWord</vh>
<v t="ekr.20071201085751.1262"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1263"><vh>class PrevWord</vh>
<v t="ekr.20071201085751.1264"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1265"><vh>class PointSlice</vh>
<v t="ekr.20071201085751.1266"><vh>__call__</vh></v>
</v>
<v t="ekr.20071201085751.1267"><vh>class TextLine</vh>
<v t="ekr.20071201085751.1268"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1269"><vh>push_undo</vh></v>
<v t="ekr.20071201085751.1270"><vh>pop_undo</vh></v>
<v t="ekr.20071201085751.1271"><vh>set_top_undo</vh></v>
<v t="ekr.20071201085751.1272"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.1273"><vh>copy</vh></v>
<v t="ekr.20071201085751.1274"><vh>set_point</vh></v>
<v t="ekr.20071201085751.1275"><vh>get_point</vh></v>
<v t="ekr.20071201085751.1276"><vh>visible_line_width</vh></v>
<v t="ekr.20071201085751.1277"><vh>quoted_text</vh></v>
<v t="ekr.20071201085751.1278"><vh>get_line_text</vh></v>
<v t="ekr.20071201085751.1279"><vh>set_line</vh></v>
<v t="ekr.20071201085751.1280"><vh>reset_line</vh></v>
<v t="ekr.20071201085751.1281"><vh>end_of_line</vh></v>
<v t="ekr.20071201085751.1282"><vh>_insert_text</vh></v>
<v t="ekr.20071201085751.1283"><vh>__getitem__</vh></v>
<v t="ekr.20071201085751.1284"><vh>__delitem__</vh></v>
<v t="ekr.20071201085751.1285"><vh>__setitem__</vh></v>
<v t="ekr.20071201085751.1286"><vh>__len__</vh></v>
<v t="ekr.20071201085751.1287"><vh>upper</vh></v>
<v t="ekr.20071201085751.1288"><vh>lower</vh></v>
<v t="ekr.20071201085751.1289"><vh>capitalize</vh></v>
<v t="ekr.20071201085751.1290"><vh>startswith</vh></v>
<v t="ekr.20071201085751.1291"><vh>endswith</vh></v>
<v t="ekr.20071201085751.1292"><vh>__contains__</vh></v>
</v>
<v t="ekr.20071201085751.1293"><vh>class ReadLineTextBuffer</vh>
<v t="ekr.20071201085751.1294"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1295"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.1296"><vh>insert_text</vh></v>
<v t="ekr.20071201085751.1297"><vh>to_clipboard</vh></v>
<v t="ekr.20071201085751.1298"><vh>beginning_of_line</vh></v>
<v t="ekr.20071201085751.1299"><vh>end_of_line</vh></v>
<v t="ekr.20071201085751.1300"><vh>forward_char</vh></v>
<v t="ekr.20071201085751.1301"><vh>backward_char</vh></v>
<v t="ekr.20071201085751.1302"><vh>forward_word</vh></v>
<v t="ekr.20071201085751.1303"><vh>backward_word</vh></v>
<v t="ekr.20071201085751.1304"><vh>forward_word_end</vh></v>
<v t="ekr.20071201085751.1305"><vh>backward_word_end</vh></v>
<v t="ekr.20071201085751.1306"><vh>beginning_of_line_extend_selection</vh></v>
<v t="ekr.20071201085751.1307"><vh>end_of_line_extend_selection</vh></v>
<v t="ekr.20071201085751.1308"><vh>forward_char_extend_selection</vh></v>
<v t="ekr.20071201085751.1309"><vh>backward_char_extend_selection</vh></v>
<v t="ekr.20071201085751.1310"><vh>forward_word_extend_selection</vh></v>
<v t="ekr.20071201085751.1311"><vh>backward_word_extend_selection</vh></v>
<v t="ekr.20071201085751.1312"><vh>forward_word_end_extend_selection</vh></v>
<v t="ekr.20071201085751.1313"><vh>backward_word_end_extend_selection</vh></v>
<v t="ekr.20071201085751.1314"><vh>delete_selection</vh></v>
<v t="ekr.20071201085751.1315"><vh>delete_char</vh></v>
<v t="ekr.20071201085751.1316"><vh>backward_delete_char</vh></v>
<v t="ekr.20071201085751.1317"><vh>forward_delete_word</vh></v>
<v t="ekr.20071201085751.1318"><vh>backward_delete_word</vh></v>
<v t="ekr.20071201085751.1319"><vh>delete_current_word</vh></v>
<v t="ekr.20071201085751.1320"><vh>delete_horizontal_space</vh></v>
<v t="ekr.20071201085751.1321"><vh>upcase_word</vh></v>
<v t="ekr.20071201085751.1322"><vh>downcase_word</vh></v>
<v t="ekr.20071201085751.1323"><vh>capitalize_word</vh></v>
<v t="ekr.20071201085751.1324"><vh>transpose_chars</vh></v>
<v t="ekr.20071201085751.1325"><vh>transpose_words</vh></v>
<v t="ekr.20071201085751.1326"><vh>kill_line</vh></v>
<v t="ekr.20071201085751.1327"><vh>kill_whole_line</vh></v>
<v t="ekr.20071201085751.1328"><vh>backward_kill_line</vh></v>
<v t="ekr.20071201085751.1329"><vh>unix_line_discard</vh></v>
<v t="ekr.20071201085751.1330"><vh>kill_word</vh></v>
<v t="ekr.20071201085751.1331"><vh>backward_kill_word</vh></v>
<v t="ekr.20071201085751.1332"><vh>forward_kill_word</vh></v>
<v t="ekr.20071201085751.1333"><vh>unix_word_rubout</vh></v>
<v t="ekr.20071201085751.1334"><vh>kill_region</vh></v>
<v t="ekr.20071201085751.1335"><vh>copy_region_as_kill</vh></v>
<v t="ekr.20071201085751.1336"><vh>copy_backward_word</vh></v>
<v t="ekr.20071201085751.1337"><vh>copy_forward_word</vh></v>
<v t="ekr.20071201085751.1338"><vh>yank</vh></v>
<v t="ekr.20071201085751.1339"><vh>yank_pop</vh></v>
<v t="ekr.20071201085751.1340"><vh>set_mark</vh></v>
<v t="ekr.20071201085751.1341"><vh>exchange_point_and_mark</vh></v>
<v t="ekr.20071201085751.1342"><vh>copy_region_to_clipboard</vh></v>
<v t="ekr.20071201085751.1343"><vh>copy_selection_to_clipboard</vh></v>
<v t="ekr.20071201085751.1344"><vh>cut_selection_to_clipboard</vh></v>
<v t="ekr.20071201085751.1345"><vh>add_to_kill_ring</vh></v>
<v t="ekr.20071201085751.1346"><vh>paste_from_kill_ring</vh></v>
</v>
<v t="ekr.20071201085751.1347"><vh>show_pos</vh></v>
<v t="ekr.20071201085751.1348"><vh>test_positioner</vh></v>
</v>
<v t="ekr.20071201083431.35"><vh>@@auto lineeditor\wordmatcher.py</vh>
<v t="ekr.20071201085751.1349"><vh>wordmatcher declarations</vh></v>
<v t="ekr.20071201085751.1350"><vh>str_find_all</vh></v>
<v t="ekr.20071201085751.1351"><vh>markwords</vh></v>
<v t="ekr.20071201085751.1352"><vh>split_words</vh></v>
<v t="ekr.20071201085751.1353"><vh>mark_start_segment</vh></v>
<v t="ekr.20071201085751.1354"><vh>mark_end_segment</vh></v>
<v t="ekr.20071201085751.1355"><vh>mark_start_segment_index</vh></v>
<v t="ekr.20071201085751.1356"><vh>mark_end_segment_index</vh></v>
<v t="ekr.20071201085751.1357"><vh>is_word_token</vh></v>
<v t="ekr.20071201085751.1358"><vh>is_non_word_token</vh></v>
<v t="ekr.20071201085751.1359"><vh>next_start_segment</vh></v>
<v t="ekr.20071201085751.1360"><vh>next_end_segment</vh></v>
<v t="ekr.20071201085751.1361"><vh>prev_start_segment</vh></v>
<v t="ekr.20071201085751.1362"><vh>prev_end_segment</vh></v>
</v>
<v t="ekr.20071201083431.36"><vh>@@auto lineeditor\__init__.py</vh></v>
</v>
<v t="ekr.20071201083431.37"><vh>modes</vh>
<v t="ekr.20071201083431.38"><vh>@@auto modes\basemode.py</vh>
<v t="ekr.20071201085751.1363"><vh>basemode declarations</vh></v>
<v t="ekr.20071201085751.1364"><vh>class BaseMode</vh>
<v t="ekr.20071201085751.1365"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1366"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.1367"><vh>_gs</vh></v>
<v t="ekr.20071201085751.1368"><vh>_g</vh></v>
<v t="ekr.20071201085751.1369"><vh>_argreset</vh></v>
<v t="ekr.20071201085751.1370"><vh>_readline_from_keyboard</vh></v>
<v t="ekr.20071201085751.1371"><vh>readline</vh></v>
<v t="ekr.20071201085751.1372"><vh>_bind_key</vh></v>
<v t="ekr.20071201085751.1373"><vh>_bind_exit_key</vh></v>
<v t="ekr.20071201085751.1374"><vh>init_editing_mode</vh></v>
<v t="ekr.20071201085751.1375"><vh>_get_completions</vh></v>
<v t="ekr.20071201085751.1376"><vh>_display_completions</vh></v>
<v t="ekr.20071201085751.1377"><vh>complete</vh></v>
<v t="ekr.20071201085751.1378"><vh>possible_completions</vh></v>
<v t="ekr.20071201085751.1379"><vh>insert_completions</vh></v>
<v t="ekr.20071201085751.1380"><vh>menu_complete</vh></v>
<v t="ekr.20071201085751.1381"><vh>beginning_of_line</vh></v>
<v t="ekr.20071201085751.1382"><vh>end_of_line</vh></v>
<v t="ekr.20071201085751.1383"><vh>forward_char</vh></v>
<v t="ekr.20071201085751.1384"><vh>backward_char</vh></v>
<v t="ekr.20071201085751.1385"><vh>forward_word</vh></v>
<v t="ekr.20071201085751.1386"><vh>backward_word</vh></v>
<v t="ekr.20071201085751.1387"><vh>forward_word_end</vh></v>
<v t="ekr.20071201085751.1388"><vh>backward_word_end</vh></v>
<v t="ekr.20071201085751.1389"><vh>beginning_of_line_extend_selection</vh></v>
<v t="ekr.20071201085751.1390"><vh>end_of_line_extend_selection</vh></v>
<v t="ekr.20071201085751.1391"><vh>forward_char_extend_selection</vh></v>
<v t="ekr.20071201085751.1392"><vh>backward_char_extend_selection</vh></v>
<v t="ekr.20071201085751.1393"><vh>forward_word_extend_selection</vh></v>
<v t="ekr.20071201085751.1394"><vh>backward_word_extend_selection</vh></v>
<v t="ekr.20071201085751.1395"><vh>forward_word_end_extend_selection</vh></v>
<v t="ekr.20071201085751.1396"><vh>backward_word_end_extend_selection</vh></v>
<v t="ekr.20071201085751.1397"><vh>upcase_word</vh></v>
<v t="ekr.20071201085751.1398"><vh>downcase_word</vh></v>
<v t="ekr.20071201085751.1399"><vh>capitalize_word</vh></v>
<v t="ekr.20071201085751.1400"><vh>clear_screen</vh></v>
<v t="ekr.20071201085751.1401"><vh>redraw_current_line</vh></v>
<v t="ekr.20071201085751.1402"><vh>accept_line</vh></v>
<v t="ekr.20071201085751.1403"><vh>delete_char</vh></v>
<v t="ekr.20071201085751.1404"><vh>backward_delete_char</vh></v>
<v t="ekr.20071201085751.1405"><vh>backward_delete_word</vh></v>
<v t="ekr.20071201085751.1406"><vh>forward_delete_word</vh></v>
<v t="ekr.20071201085751.1407"><vh>delete_horizontal_space</vh></v>
<v t="ekr.20071201085751.1408"><vh>self_insert</vh></v>
<v t="ekr.20071201085751.1409"><vh>paste</vh></v>
<v t="ekr.20071201085751.1410"><vh>paste_mulitline_code</vh></v>
<v t="ekr.20071201085751.1411"><vh>ipython_paste</vh></v>
<v t="ekr.20071201085751.1412"><vh>copy_region_to_clipboard</vh></v>
<v t="ekr.20071201085751.1413"><vh>copy_selection_to_clipboard</vh></v>
<v t="ekr.20071201085751.1414"><vh>cut_selection_to_clipboard</vh></v>
<v t="ekr.20071201085751.1415"><vh>dump_functions</vh></v>
</v>
<v t="ekr.20071201085751.1416"><vh>commonprefix</vh></v>
</v>
<v t="ekr.20071201083431.39"><vh>@@auto modes\emacs.py</vh>
<v t="ekr.20071201085751.1417"><vh>emacs declarations</vh></v>
<v t="ekr.20071201085751.1418"><vh>format</vh></v>
<v t="ekr.20071201085751.1419"><vh>class EmacsMode</vh>
<v t="ekr.20071201085751.1420"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1421"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.1422"><vh>add_key_logger</vh></v>
<v t="ekr.20071201085751.1423"><vh>_readline_from_keyboard</vh></v>
<v t="ekr.20071201085751.1424"><vh>readline</vh></v>
<v t="ekr.20071201085751.1425"><vh>previous_history</vh></v>
<v t="ekr.20071201085751.1426"><vh>next_history</vh></v>
<v t="ekr.20071201085751.1427"><vh>beginning_of_history</vh></v>
<v t="ekr.20071201085751.1428"><vh>end_of_history</vh></v>
<v t="ekr.20071201085751.1429"><vh>_i_search</vh></v>
<v t="ekr.20071201085751.1430"><vh>reverse_search_history</vh></v>
<v t="ekr.20071201085751.1431"><vh>forward_search_history</vh></v>
<v t="ekr.20071201085751.1432"><vh>non_incremental_reverse_search_history</vh></v>
<v t="ekr.20071201085751.1433"><vh>non_incremental_forward_search_history</vh></v>
<v t="ekr.20071201085751.1434"><vh>history_search_forward</vh></v>
<v t="ekr.20071201085751.1435"><vh>history_search_backward</vh></v>
<v t="ekr.20071201085751.1436"><vh>yank_nth_arg</vh></v>
<v t="ekr.20071201085751.1437"><vh>yank_last_arg</vh></v>
<v t="ekr.20071201085751.1438"><vh>forward_backward_delete_char</vh></v>
<v t="ekr.20071201085751.1439"><vh>quoted_insert</vh></v>
<v t="ekr.20071201085751.1440"><vh>tab_insert</vh></v>
<v t="ekr.20071201085751.1441"><vh>transpose_chars</vh></v>
<v t="ekr.20071201085751.1442"><vh>transpose_words</vh></v>
<v t="ekr.20071201085751.1443"><vh>overwrite_mode</vh></v>
<v t="ekr.20071201085751.1444"><vh>kill_line</vh></v>
<v t="ekr.20071201085751.1445"><vh>backward_kill_line</vh></v>
<v t="ekr.20071201085751.1446"><vh>unix_line_discard</vh></v>
<v t="ekr.20071201085751.1447"><vh>kill_whole_line</vh></v>
<v t="ekr.20071201085751.1448"><vh>kill_word</vh></v>
<v t="ekr.20071201085751.1449"><vh>backward_kill_word</vh></v>
<v t="ekr.20071201085751.1450"><vh>unix_word_rubout</vh></v>
<v t="ekr.20071201085751.1451"><vh>kill_region</vh></v>
<v t="ekr.20071201085751.1452"><vh>copy_region_as_kill</vh></v>
<v t="ekr.20071201085751.1453"><vh>copy_backward_word</vh></v>
<v t="ekr.20071201085751.1454"><vh>copy_forward_word</vh></v>
<v t="ekr.20071201085751.1455"><vh>yank</vh></v>
<v t="ekr.20071201085751.1456"><vh>yank_pop</vh></v>
<v t="ekr.20071201085751.1457"><vh>digit_argument</vh></v>
<v t="ekr.20071201085751.1458"><vh>universal_argument</vh></v>
<v t="ekr.20071201085751.1459"><vh>delete_char_or_list</vh></v>
<v t="ekr.20071201085751.1460"><vh>start_kbd_macro</vh></v>
<v t="ekr.20071201085751.1461"><vh>end_kbd_macro</vh></v>
<v t="ekr.20071201085751.1462"><vh>call_last_kbd_macro</vh></v>
<v t="ekr.20071201085751.1463"><vh>re_read_init_file</vh></v>
<v t="ekr.20071201085751.1464"><vh>abort</vh></v>
<v t="ekr.20071201085751.1465"><vh>do_uppercase_version</vh></v>
<v t="ekr.20071201085751.1466"><vh>prefix_meta</vh></v>
<v t="ekr.20071201085751.1467"><vh>undo</vh></v>
<v t="ekr.20071201085751.1468"><vh>revert_line</vh></v>
<v t="ekr.20071201085751.1469"><vh>tilde_expand</vh></v>
<v t="ekr.20071201085751.1470"><vh>set_mark</vh></v>
<v t="ekr.20071201085751.1471"><vh>exchange_point_and_mark</vh></v>
<v t="ekr.20071201085751.1472"><vh>character_search</vh></v>
<v t="ekr.20071201085751.1473"><vh>character_search_backward</vh></v>
<v t="ekr.20071201085751.1474"><vh>insert_comment</vh></v>
<v t="ekr.20071201085751.1475"><vh>dump_variables</vh></v>
<v t="ekr.20071201085751.1476"><vh>dump_macros</vh></v>
<v t="ekr.20071201085751.1477"><vh>init_editing_mode</vh></v>
</v>
<v t="ekr.20071201085751.1478"><vh>commonprefix</vh></v>
</v>
<v t="ekr.20071201083431.40"><vh>@@auto modes\notemacs.py</vh>
<v t="ekr.20071201085751.1479"><vh>notemacs declarations</vh></v>
<v t="ekr.20071201085751.1480"><vh>class NotEmacsMode</vh>
<v t="ekr.20071201085751.1481"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1482"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.1483"><vh>_readline_from_keyboard</vh></v>
<v t="ekr.20071201085751.1484"><vh>readline</vh></v>
<v t="ekr.20071201085751.1485"><vh>beginning_of_line</vh></v>
<v t="ekr.20071201085751.1486"><vh>end_of_line</vh></v>
<v t="ekr.20071201085751.1487"><vh>forward_char</vh></v>
<v t="ekr.20071201085751.1488"><vh>backward_char</vh></v>
<v t="ekr.20071201085751.1489"><vh>forward_word</vh></v>
<v t="ekr.20071201085751.1490"><vh>backward_word</vh></v>
<v t="ekr.20071201085751.1491"><vh>clear_screen</vh></v>
<v t="ekr.20071201085751.1492"><vh>redraw_current_line</vh></v>
<v t="ekr.20071201085751.1493"><vh>accept_line</vh></v>
<v t="ekr.20071201085751.1494"><vh>previous_history</vh></v>
<v t="ekr.20071201085751.1495"><vh>next_history</vh></v>
<v t="ekr.20071201085751.1496"><vh>beginning_of_history</vh></v>
<v t="ekr.20071201085751.1497"><vh>end_of_history</vh></v>
<v t="ekr.20071201085751.1498"><vh>_i_search</vh></v>
<v t="ekr.20071201085751.1499"><vh>reverse_search_history</vh></v>
<v t="ekr.20071201085751.1500"><vh>forward_search_history</vh></v>
<v t="ekr.20071201085751.1501"><vh>non_incremental_reverse_search_history</vh></v>
<v t="ekr.20071201085751.1502"><vh>non_incremental_forward_search_history</vh></v>
<v t="ekr.20071201085751.1503"><vh>history_search_forward</vh></v>
<v t="ekr.20071201085751.1504"><vh>history_search_backward</vh></v>
<v t="ekr.20071201085751.1505"><vh>yank_nth_arg</vh></v>
<v t="ekr.20071201085751.1506"><vh>yank_last_arg</vh></v>
<v t="ekr.20071201085751.1507"><vh>delete_char</vh></v>
<v t="ekr.20071201085751.1508"><vh>backward_delete_char</vh></v>
<v t="ekr.20071201085751.1509"><vh>forward_backward_delete_char</vh></v>
<v t="ekr.20071201085751.1510"><vh>quoted_insert</vh></v>
<v t="ekr.20071201085751.1511"><vh>tab_insert</vh></v>
<v t="ekr.20071201085751.1512"><vh>self_insert</vh></v>
<v t="ekr.20071201085751.1513"><vh>transpose_chars</vh></v>
<v t="ekr.20071201085751.1514"><vh>transpose_words</vh></v>
<v t="ekr.20071201085751.1515"><vh>upcase_word</vh></v>
<v t="ekr.20071201085751.1516"><vh>downcase_word</vh></v>
<v t="ekr.20071201085751.1517"><vh>capitalize_word</vh></v>
<v t="ekr.20071201085751.1518"><vh>overwrite_mode</vh></v>
<v t="ekr.20071201085751.1519"><vh>kill_line</vh></v>
<v t="ekr.20071201085751.1520"><vh>backward_kill_line</vh></v>
<v t="ekr.20071201085751.1521"><vh>unix_line_discard</vh></v>
<v t="ekr.20071201085751.1522"><vh>kill_whole_line</vh></v>
<v t="ekr.20071201085751.1523"><vh>kill_word</vh></v>
<v t="ekr.20071201085751.1524"><vh>backward_kill_word</vh></v>
<v t="ekr.20071201085751.1525"><vh>unix_word_rubout</vh></v>
<v t="ekr.20071201085751.1526"><vh>delete_horizontal_space</vh></v>
<v t="ekr.20071201085751.1527"><vh>kill_region</vh></v>
<v t="ekr.20071201085751.1528"><vh>copy_region_as_kill</vh></v>
<v t="ekr.20071201085751.1529"><vh>copy_region_to_clipboard</vh></v>
<v t="ekr.20071201085751.1530"><vh>copy_backward_word</vh></v>
<v t="ekr.20071201085751.1531"><vh>copy_forward_word</vh></v>
<v t="ekr.20071201085751.1532"><vh>paste</vh></v>
<v t="ekr.20071201085751.1533"><vh>paste_mulitline_code</vh></v>
<v t="ekr.20071201085751.1534"><vh>ipython_paste</vh></v>
<v t="ekr.20071201085751.1535"><vh>yank</vh></v>
<v t="ekr.20071201085751.1536"><vh>yank_pop</vh></v>
<v t="ekr.20071201085751.1537"><vh>digit_argument</vh></v>
<v t="ekr.20071201085751.1538"><vh>universal_argument</vh></v>
<v t="ekr.20071201085751.1539"><vh>delete_char_or_list</vh></v>
<v t="ekr.20071201085751.1540"><vh>start_kbd_macro</vh></v>
<v t="ekr.20071201085751.1541"><vh>end_kbd_macro</vh></v>
<v t="ekr.20071201085751.1542"><vh>call_last_kbd_macro</vh></v>
<v t="ekr.20071201085751.1543"><vh>re_read_init_file</vh></v>
<v t="ekr.20071201085751.1544"><vh>abort</vh></v>
<v t="ekr.20071201085751.1545"><vh>do_uppercase_version</vh></v>
<v t="ekr.20071201085751.1546"><vh>prefix_meta</vh></v>
<v t="ekr.20071201085751.1547"><vh>undo</vh></v>
<v t="ekr.20071201085751.1548"><vh>revert_line</vh></v>
<v t="ekr.20071201085751.1549"><vh>tilde_expand</vh></v>
<v t="ekr.20071201085751.1550"><vh>set_mark</vh></v>
<v t="ekr.20071201085751.1551"><vh>exchange_point_and_mark</vh></v>
<v t="ekr.20071201085751.1552"><vh>character_search</vh></v>
<v t="ekr.20071201085751.1553"><vh>character_search_backward</vh></v>
<v t="ekr.20071201085751.1554"><vh>insert_comment</vh></v>
<v t="ekr.20071201085751.1555"><vh>dump_functions</vh></v>
<v t="ekr.20071201085751.1556"><vh>dump_variables</vh></v>
<v t="ekr.20071201085751.1557"><vh>dump_macros</vh></v>
<v t="ekr.20071201085751.1558"><vh>init_editing_mode</vh></v>
</v>
<v t="ekr.20071201085751.1559"><vh>commonprefix</vh></v>
</v>
<v t="ekr.20071201083431.41"><vh>@@auto modes\vi.py</vh>
<v t="ekr.20071201085751.1560"><vh>vi declarations</vh></v>
<v t="ekr.20071201085751.1561"><vh>class ViMode</vh>
<v t="ekr.20071201085751.1562"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1563"><vh>__repr__</vh></v>
<v t="ekr.20071201085751.1564"><vh>_readline_from_keyboard</vh></v>
<v t="ekr.20071201085751.1565"><vh>readline</vh></v>
<v t="ekr.20071201085751.1566"><vh>init_editing_mode</vh></v>
<v t="ekr.20071201085751.1567"><vh>vi_key</vh></v>
<v t="ekr.20071201085751.1568"><vh>vi_error</vh></v>
<v t="ekr.20071201085751.1569"><vh>vi_get_is_insert_mode</vh></v>
<v t="ekr.20071201085751.1570"><vh>vi_escape</vh></v>
<v t="ekr.20071201085751.1571"><vh>vi_backspace</vh></v>
<v t="ekr.20071201085751.1572"><vh>_vi_do_backspace</vh></v>
<v t="ekr.20071201085751.1573"><vh>vi_accept_line</vh></v>
<v t="ekr.20071201085751.1574"><vh>vi_eof</vh></v>
<v t="ekr.20071201085751.1575"><vh>vi_set_insert_mode</vh></v>
<v t="ekr.20071201085751.1576"><vh>vi_undo_restart</vh></v>
<v t="ekr.20071201085751.1577"><vh>vi_save_line</vh></v>
<v t="ekr.20071201085751.1578"><vh>vi_undo_prepare</vh></v>
<v t="ekr.20071201085751.1579"><vh>vi_undo</vh></v>
<v t="ekr.20071201085751.1580"><vh>vi_undo_all</vh></v>
<v t="ekr.20071201085751.1581"><vh>vi_undo_assign</vh></v>
<v t="ekr.20071201085751.1582"><vh>vi_redo</vh></v>
<v t="ekr.20071201085751.1583"><vh>vi_search</vh></v>
<v t="ekr.20071201085751.1584"><vh>vi_search_first</vh></v>
<v t="ekr.20071201085751.1585"><vh>vi_search_again_backward</vh></v>
<v t="ekr.20071201085751.1586"><vh>vi_search_again_forward</vh></v>
<v t="ekr.20071201085751.1587"><vh>vi_up</vh></v>
<v t="ekr.20071201085751.1588"><vh>vi_down</vh></v>
<v t="ekr.20071201085751.1589"><vh>vi_arrow_up</vh></v>
<v t="ekr.20071201085751.1590"><vh>vi_arrow_down</vh></v>
<v t="ekr.20071201085751.1591"><vh>vi_complete</vh></v>
</v>
<v t="ekr.20071201085751.1592"><vh>class ViCommand</vh>
<v t="ekr.20071201085751.1593"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1594"><vh>add_char</vh></v>
<v t="ekr.20071201085751.1595"><vh>set_text</vh></v>
<v t="ekr.20071201085751.1596"><vh>set_buffer</vh></v>
<v t="ekr.20071201085751.1597"><vh>replace_one</vh></v>
<v t="ekr.20071201085751.1598"><vh>char_isprint</vh></v>
<v t="ekr.20071201085751.1599"><vh>key_dollar</vh></v>
<v t="ekr.20071201085751.1600"><vh>key_hat</vh></v>
<v t="ekr.20071201085751.1601"><vh>key_0</vh></v>
<v t="ekr.20071201085751.1602"><vh>key_digit</vh></v>
<v t="ekr.20071201085751.1603"><vh>key_w</vh></v>
<v t="ekr.20071201085751.1604"><vh>key_W</vh></v>
<v t="ekr.20071201085751.1605"><vh>key_e</vh></v>
<v t="ekr.20071201085751.1606"><vh>key_E</vh></v>
<v t="ekr.20071201085751.1607"><vh>key_b</vh></v>
<v t="ekr.20071201085751.1608"><vh>key_B</vh></v>
<v t="ekr.20071201085751.1609"><vh>key_f</vh></v>
<v t="ekr.20071201085751.1610"><vh>key_F</vh></v>
<v t="ekr.20071201085751.1611"><vh>key_t</vh></v>
<v t="ekr.20071201085751.1612"><vh>key_T</vh></v>
<v t="ekr.20071201085751.1613"><vh>key_j</vh></v>
<v t="ekr.20071201085751.1614"><vh>key_k</vh></v>
<v t="ekr.20071201085751.1615"><vh>key_semicolon</vh></v>
<v t="ekr.20071201085751.1616"><vh>key_comma</vh></v>
<v t="ekr.20071201085751.1617"><vh>key_percent</vh></v>
<v t="ekr.20071201085751.1618"><vh>key_dot</vh></v>
<v t="ekr.20071201085751.1619"><vh>key_slash</vh></v>
<v t="ekr.20071201085751.1620"><vh>key_star</vh></v>
<v t="ekr.20071201085751.1621"><vh>key_bar</vh></v>
<v t="ekr.20071201085751.1622"><vh>key_tilde</vh></v>
<v t="ekr.20071201085751.1623"><vh>key_h</vh></v>
<v t="ekr.20071201085751.1624"><vh>key_backspace</vh></v>
<v t="ekr.20071201085751.1625"><vh>key_l</vh></v>
<v t="ekr.20071201085751.1626"><vh>key_i</vh></v>
<v t="ekr.20071201085751.1627"><vh>key_I</vh></v>
<v t="ekr.20071201085751.1628"><vh>key_a</vh></v>
<v t="ekr.20071201085751.1629"><vh>key_A</vh></v>
<v t="ekr.20071201085751.1630"><vh>key_d</vh></v>
<v t="ekr.20071201085751.1631"><vh>key_D</vh></v>
<v t="ekr.20071201085751.1632"><vh>key_x</vh></v>
<v t="ekr.20071201085751.1633"><vh>key_X</vh></v>
<v t="ekr.20071201085751.1634"><vh>key_s</vh></v>
<v t="ekr.20071201085751.1635"><vh>key_S</vh></v>
<v t="ekr.20071201085751.1636"><vh>key_c</vh></v>
<v t="ekr.20071201085751.1637"><vh>key_C</vh></v>
<v t="ekr.20071201085751.1638"><vh>key_r</vh></v>
<v t="ekr.20071201085751.1639"><vh>key_R</vh></v>
<v t="ekr.20071201085751.1640"><vh>key_y</vh></v>
<v t="ekr.20071201085751.1641"><vh>key_Y</vh></v>
<v t="ekr.20071201085751.1642"><vh>key_p</vh></v>
<v t="ekr.20071201085751.1643"><vh>key_P</vh></v>
<v t="ekr.20071201085751.1644"><vh>key_u</vh></v>
<v t="ekr.20071201085751.1645"><vh>key_U</vh></v>
<v t="ekr.20071201085751.1646"><vh>key_v</vh></v>
<v t="ekr.20071201085751.1647"><vh>error</vh></v>
<v t="ekr.20071201085751.1648"><vh>state_is_end</vh></v>
<v t="ekr.20071201085751.1649"><vh>state_is_search</vh></v>
<v t="ekr.20071201085751.1650"><vh>state_is_replace_one</vh></v>
<v t="ekr.20071201085751.1651"><vh>do_search</vh></v>
<v t="ekr.20071201085751.1652"><vh>key_n</vh></v>
<v t="ekr.20071201085751.1653"><vh>key_N</vh></v>
<v t="ekr.20071201085751.1654"><vh>motion_beginning_of_line</vh></v>
<v t="ekr.20071201085751.1655"><vh>motion_end_in_line</vh></v>
<v t="ekr.20071201085751.1656"><vh>motion_word_short</vh></v>
<v t="ekr.20071201085751.1657"><vh>motion_word_long</vh></v>
<v t="ekr.20071201085751.1658"><vh>motion_end_short</vh></v>
<v t="ekr.20071201085751.1659"><vh>motion_end_long</vh></v>
<v t="ekr.20071201085751.1660"><vh>motion_back_short</vh></v>
<v t="ekr.20071201085751.1661"><vh>motion_back_long</vh></v>
<v t="ekr.20071201085751.1662"><vh>motion_find_char_forward</vh></v>
<v t="ekr.20071201085751.1663"><vh>motion_find_char_backward</vh></v>
<v t="ekr.20071201085751.1664"><vh>motion_to_char_forward</vh></v>
<v t="ekr.20071201085751.1665"><vh>motion_to_char_backward</vh></v>
<v t="ekr.20071201085751.1666"><vh>motion_left</vh></v>
<v t="ekr.20071201085751.1667"><vh>motion_right</vh></v>
<v t="ekr.20071201085751.1668"><vh>motion_matching</vh></v>
<v t="ekr.20071201085751.1669"><vh>motion_column</vh></v>
<v t="ekr.20071201085751.1670"><vh>has_multiplier</vh></v>
<v t="ekr.20071201085751.1671"><vh>get_multiplier</vh></v>
<v t="ekr.20071201085751.1672"><vh>set_override_multiplier</vh></v>
<v t="ekr.20071201085751.1673"><vh>apply</vh></v>
<v t="ekr.20071201085751.1674"><vh>movement</vh></v>
<v t="ekr.20071201085751.1675"><vh>yank</vh></v>
<v t="ekr.20071201085751.1676"><vh>delete</vh></v>
<v t="ekr.20071201085751.1677"><vh>delete_end_of_line</vh></v>
<v t="ekr.20071201085751.1678"><vh>delete_char</vh></v>
<v t="ekr.20071201085751.1679"><vh>delete_prev_char</vh></v>
<v t="ekr.20071201085751.1680"><vh>change</vh></v>
<v t="ekr.20071201085751.1681"><vh>escape</vh></v>
<v t="ekr.20071201085751.1682"><vh>set_motion_argument</vh></v>
<v t="ekr.20071201085751.1683"><vh>end</vh></v>
</v>
<v t="ekr.20071201085751.1684"><vh>class ViExternalEditor</vh>
<v t="ekr.20071201085751.1685"><vh>__init__</vh></v>
<v t="ekr.20071201085751.1686"><vh>get_tempfile</vh></v>
<v t="ekr.20071201085751.1687"><vh>file_open</vh></v>
<v t="ekr.20071201085751.1688"><vh>file_remove</vh></v>
<v t="ekr.20071201085751.1689"><vh>get_editor</vh></v>
<v t="ekr.20071201085751.1690"><vh>run_editor</vh></v>
<v t="ekr.20071201085751.1691"><vh>run_command</vh></v>
</v>
<v t="ekr.20071201085751.1692"><vh>class ViEvent</vh>
<v t="ekr.20071201085751.1693"><vh>__init__</vh></v>
</v>
<v t="ekr.20071201085751.1694"><vh>vi_is_word</vh></v>
<v t="ekr.20071201085751.1695"><vh>vi_is_space</vh></v>
<v t="ekr.20071201085751.1696"><vh>vi_is_word_or_space</vh></v>
<v t="ekr.20071201085751.1697"><vh>vi_pos_word_short</vh></v>
<v t="ekr.20071201085751.1698"><vh>vi_pos_word_long</vh></v>
<v t="ekr.20071201085751.1699"><vh>vi_pos_end_short</vh></v>
<v t="ekr.20071201085751.1700"><vh>vi_pos_end_long</vh></v>
<v t="ekr.20071201085751.1701"><vh>class vi_list</vh>
<v t="ekr.20071201085751.1702"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20071201085751.1703"><vh>vi_pos_back_short</vh></v>
<v t="ekr.20071201085751.1704"><vh>vi_pos_back_long</vh></v>
<v t="ekr.20071201085751.1705"><vh>vi_pos_find_char_forward</vh></v>
<v t="ekr.20071201085751.1706"><vh>vi_pos_find_char_backward</vh></v>
<v t="ekr.20071201085751.1707"><vh>vi_pos_to_char_forward</vh></v>
<v t="ekr.20071201085751.1708"><vh>vi_pos_to_char_backward</vh></v>
<v t="ekr.20071201085751.1709"><vh>vi_pos_matching</vh></v>
</v>
<v t="ekr.20071201083431.42"><vh>@@auto modes\__init__.py</vh>
<v t="ekr.20071201085751.1710"><vh>__init__ declarations</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20071129105118"></t>
<t tx="ekr.20071129105210.71">@language python
@tabwidth -4
@others
if __name__=='__main__':

    import time

    def sleepfunc(interval=2,*a,**kw):
        args = dict(interval=interval,
                    args=a,
                    kwargs=kw)
        time.sleep(interval)
        return args

    def diefunc(interval=2,*a,**kw):
        time.sleep(interval)
        die

    def printfunc(interval=1,reps=5):
        for n in range(reps):
            time.sleep(interval)
            print 'In the background...'

    jobs = BackgroundJobManager()
    # first job will have # 0
    jobs.new(sleepfunc,4)
    jobs.new(sleepfunc,kw={'reps':2})
    # This makes a job which will die
    jobs.new(diefunc,1)
    jobs.new('printfunc(1,3)')

    # after a while, you can get the traceback of a dead job.  Run the line
    # below again interactively until it prints a traceback (check the status
    # of the job):
    print jobs[1].status
    jobs[1].traceback()
    
    # Run this line again until the printed result changes
    print "The result of job #0 is:",jobs[0].result
</t>
<t tx="ekr.20071129105210.72">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.73">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.74">@language python
@tabwidth -4
@others
# end ConfigLoader
</t>
<t tx="ekr.20071129105210.75">@language python
@tabwidth -4
@others
@ignore

@
*** first mismatch at line 94
original line:  Oops, $self.app_name crashed. We do our best to make it stable, but...
generated line:     Oops, $self.app_name crashed. We do our best to make it stable, but...
</t>
<t tx="ekr.20071129105210.76">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.77">@language python
@tabwidth -4
@others
# Uncomment the following to automatically activate deep reloading whenever
# this module is imported
#__builtin__.reload = reload
</t>
<t tx="ekr.20071129105210.78">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.80">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.81">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.82">@language python
@tabwidth -4
@others
#*************************** end of file &lt;genutils.py&gt; **********************

</t>
<t tx="ekr.20071129105210.83">@language python
@tabwidth -4
@others
#********************** End of file &lt;Gnuplot2.py&gt; ************************
</t>
<t tx="ekr.20071129105210.84">@language python
@tabwidth -4
@others
try:
    __IPYTHON__
except NameError:
    pass
else:
    # make the global Gnuplot instance known to IPython
    __IPYTHON__.gnuplot = GRun.gp
    __IPYTHON__.gnuplot.shell_first_time = 1

    print """*** Type `gphelp` for help on the Gnuplot integration features."""

    # Add the new magic functions to the class dict
    from IPython.iplib import InteractiveShell
    InteractiveShell.magic_gpc = magic_gpc
    InteractiveShell.magic_gp_set_default = magic_gp_set_default

#********************** End of file &lt;GnuplotInteractive.py&gt; *******************
</t>
<t tx="ekr.20071129105210.85">@language python
@tabwidth -4
@others
# Global-level names.

# A global Gnuplot instance for interactive use:
gp = gp_new()

# Accessors for the main plot object constructors:
Data = Gnuplot.Data
File = Gnuplot.File
Func = Gnuplot.Func
String = Gnuplot.String
GridData = Gnuplot.GridData

# A Unix-only function to fix eps files with bad bounding boxes (which Gnuplot
# generates when the plot size is set to square):
eps_fix_bbox = Gnuplot.eps_fix_bbox

# String for configuring pm3d. Simply call g(pm3d_config) to execute it.  pm3d
# is a very nice mode for plotting colormaps on surfaces. Modify the defaults
# below to suit your taste.
pm3d_config = """
set pm3d solid
set hidden3d
unset surface
set isosamples 50
"""
#******************** End of file &lt;GnuplotRuntime.py&gt; ******************
</t>
<t tx="ekr.20071129105210.87">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.88">@language python
@tabwidth -4
@others
"""#log# Automatic Logger file. *** THIS MUST BE THE FIRST LINE ***
#log# DO NOT CHANGE THIS LINE OR THE TWO BELOW
#log# opts = %s
#log# args = %s
#log# It is safe to make manual edits below here.
#log#-----------------------------------------------------------------------
"""
        # for pushd/popd management
        try:
            self.home_dir = get_home_dir()
        except HomeDirError,msg:
            fatal(msg)

        self.dir_stack = [os.getcwd().replace(self.home_dir,'~')]

        # Functions to call the underlying shell.

        # The first is similar to os.system, but it doesn't return a value,
        # and it allows interpolation of variables in the user's namespace.
        self.system = lambda cmd: \
                      shell(self.var_expand(cmd,depth=2),
                            header=self.rc.system_header,
                            verbose=self.rc.system_verbose)

        # These are for getoutput and getoutputerror:
        self.getoutput = lambda cmd: \
                         getoutput(self.var_expand(cmd,depth=2),
                                   header=self.rc.system_header,
                                   verbose=self.rc.system_verbose)

        self.getoutputerror = lambda cmd: \
                              getoutputerror(self.var_expand(cmd,depth=2),
                                             header=self.rc.system_header,
                                             verbose=self.rc.system_verbose)
 
        # RegExp for splitting line contents into pre-char//first
        # word-method//rest.  For clarity, each group in on one line.

        # WARNING: update the regexp if the above escapes are changed, as they
        # are hardwired in.

        # Don't get carried away with trying to make the autocalling catch too
        # much:  it's better to be conservative rather than to trigger hidden
        # evals() somewhere and end up causing side effects.

        self.line_split = re.compile(r'^([\s*,;/])'
                                     r'([\?\w\.]+\w*\s*)'
                                     r'(\(?.*$)')

        # Original re, keep around for a while in case changes break something
        #self.line_split = re.compile(r'(^[\s*!\?%,/]?)'
        #                             r'(\s*[\?\w\.]+\w*\s*)'
        #                             r'(\(?.*$)')

        # RegExp to identify potential function names
        self.re_fun_name = re.compile(r'[a-zA-Z_]([a-zA-Z0-9_.]*) *$')

        # RegExp to exclude strings with this start from autocalling.  In
        # particular, all binary operators should be excluded, so that if foo
        # is callable, foo OP bar doesn't become foo(OP bar), which is
        # invalid.  The characters '!=()' don't need to be checked for, as the
        # _prefilter routine explicitely does so, to catch direct calls and
        # rebindings of existing names.

        # Warning: the '-' HAS TO BE AT THE END of the first group, otherwise
        # it affects the rest of the group in square brackets.
        self.re_exclude_auto = re.compile(r'^[&lt;&gt;,&amp;^\|\*/\+-]'
                                          '|^is |^not |^in |^and |^or ')

        # try to catch also methods for stuff in lists/tuples/dicts: off
        # (experimental). For this to work, the line_split regexp would need
        # to be modified so it wouldn't break things at '['. That line is
        # nasty enough that I shouldn't change it until I can test it _well_.
        #self.re_fun_name = re.compile (r'[a-zA-Z_]([a-zA-Z0-9_.\[\]]*) ?$')

        # keep track of where we started running (mainly for crash post-mortem)
        self.starting_dir = os.getcwd()

        # Various switches which can be set
        self.CACHELENGTH = 5000  # this is cheap, it's just text
        self.BANNER = "Python %(version)s on %(platform)s\n" % sys.__dict__
        self.banner2 = banner2

        # TraceBack handlers:

        # Syntax error handler.
        self.SyntaxTB = SyntaxTB(color_scheme='NoColor')
        
        # The interactive one is initialized with an offset, meaning we always
        # want to remove the topmost item in the traceback, which is our own
        # internal code. Valid modes: ['Plain','Context','Verbose']
        self.InteractiveTB = ultraTB.AutoFormattedTB(mode = 'Plain',
                                                     color_scheme='NoColor',
                                                     tb_offset = 1)

        # IPython itself shouldn't crash. This will produce a detailed
        # post-mortem if it does.  But we only install the crash handler for
        # non-threaded shells, the threaded ones use a normal verbose reporter
        # and lose the crash handler.  This is because exceptions in the main
        # thread (such as in GUI code) propagate directly to sys.excepthook,
        # and there's no point in printing crash dumps for every user exception.
        if self.isthreaded:
            ipCrashHandler = ultraTB.FormattedTB()
        else:
            from IPython import CrashHandler
            ipCrashHandler = CrashHandler.IPythonCrashHandler(self)
        self.set_crash_handler(ipCrashHandler)

        # and add any custom exception handlers the user may have specified
        self.set_custom_exc(*custom_exceptions)

        # indentation management
        self.autoindent = False
        self.indent_current_nsp = 0

        # Make some aliases automatically
        # Prepare list of shell aliases to auto-define
        if os.name == 'posix':
            auto_alias = ('mkdir mkdir', 'rmdir rmdir',
                          'mv mv -i','rm rm -i','cp cp -i',
                          'cat cat','less less','clear clear',
                          # a better ls
                          'ls ls -F',
                          # long ls
                          'll ls -lF')
            # Extra ls aliases with color, which need special treatment on BSD
            # variants
            ls_extra = ( # color ls
                         'lc ls -F -o --color',
                         # ls normal files only
                         'lf ls -F -o --color %l | grep ^-',
                         # ls symbolic links
                         'lk ls -F -o --color %l | grep ^l',
                         # directories or links to directories,
                         'ldir ls -F -o --color %l | grep /$',
                         # things which are executable
                         'lx ls -F -o --color %l | grep ^-..x',
                         )
            # The BSDs don't ship GNU ls, so they don't understand the
            # --color switch out of the box
            if 'bsd' in sys.platform:
                ls_extra = ( # ls normal files only
                             'lf ls -lF | grep ^-',
                             # ls symbolic links
                             'lk ls -lF | grep ^l',
                             # directories or links to directories,
                             'ldir ls -lF | grep /$',
                             # things which are executable
                             'lx ls -lF | grep ^-..x',
                             )
            auto_alias = auto_alias + ls_extra
        elif os.name in ['nt','dos']:
            auto_alias = ('dir dir /on', 'ls dir /on',
                          'ddir dir /ad /on', 'ldir dir /ad /on',
                          'mkdir mkdir','rmdir rmdir','echo echo',
                          'ren ren','cls cls','copy copy')
        else:
            auto_alias = ()
        self.auto_alias = [s.split(None,1) for s in auto_alias]
        # Call the actual (public) initializer
        self.init_auto_alias()

        # Produce a public API instance
        self.api = IPython.ipapi.IPApi(self)

        # track which builtins we add, so we can clean up later
        self.builtins_added = {}
        # This method will add the necessary builtins for operation, but
        # tracking what it did via the builtins_added dict.
        self.add_builtins()

    # end __init__

    def var_expand(self,cmd,depth=0):
        """Expand python variables in a string.

        The depth argument indicates how many frames above the caller should
        be walked to look for the local namespace where to expand variables.

        The global namespace for expansion is always the user's interactive
        namespace.
        """

        return str(ItplNS(cmd.replace('#','\#'),
                          self.user_ns,  # globals
                          # Skip our own frame in searching for locals:
                          sys._getframe(depth+1).f_locals # locals
                          ))

    def pre_config_initialization(self):
        """Pre-configuration init method

        This is called before the configuration files are processed to
        prepare the services the config files might need.
        
        self.rc already has reasonable default values at this point.
        """
        rc = self.rc
        
        self.db = pickleshare.PickleShareDB(rc.ipythondir + "/db")
    
    def post_config_initialization(self):
        """Post configuration init method

        This is called after the configuration files have been processed to
        'finalize' the initialization."""

        rc = self.rc

        # Object inspector
        self.inspector = OInspect.Inspector(OInspect.InspectColors,
                                            PyColorize.ANSICodeColors,
                                            'NoColor',
                                            rc.object_info_string_level)
        
        # Load readline proper
        if rc.readline:
            self.init_readline()

        # local shortcut, this is used a LOT
        self.log = self.logger.log

        # Initialize cache, set in/out prompts and printing system
        self.outputcache = CachedOutput(self,
                                        rc.cache_size,
                                        rc.pprint,
                                        input_sep = rc.separate_in,
                                        output_sep = rc.separate_out,
                                        output_sep2 = rc.separate_out2,
                                        ps1 = rc.prompt_in1,
                                        ps2 = rc.prompt_in2,
                                        ps_out = rc.prompt_out,
                                        pad_left = rc.prompts_pad_left)

        # user may have over-ridden the default print hook:
        try:
            self.outputcache.__class__.display = self.hooks.display
        except AttributeError:
            pass

        # I don't like assigning globally to sys, because it means when
        # embedding instances, each embedded instance overrides the previous
        # choice. But sys.displayhook seems to be called internally by exec,
        # so I don't see a way around it.  We first save the original and then
        # overwrite it.
        self.sys_displayhook = sys.displayhook
        sys.displayhook = self.outputcache
        
        # Set user colors (don't do it in the constructor above so that it
        # doesn't crash if colors option is invalid)
        self.magic_colors(rc.colors)

        # Set calling of pdb on exceptions
        self.call_pdb = rc.pdb

        # Load user aliases
        for alias in rc.alias:
            self.magic_alias(alias)
        self.hooks.late_startup_hook()
        
        batchrun = False
        for batchfile in [path(arg) for arg in self.rc.args 
            if arg.lower().endswith('.ipy')]:
            if not batchfile.isfile():
                print "No such batch file:", batchfile
                continue
            self.api.runlines(batchfile.text())
            batchrun = True
        if batchrun:
            self.exit_now = True            

    def add_builtins(self):
        """Store ipython references into the builtin namespace.

        Some parts of ipython operate via builtins injected here, which hold a
        reference to IPython itself."""

        # TODO: deprecate all except _ip; 'jobs' should be installed 
        # by an extension and the rest are under _ip, ipalias is redundant
        builtins_new  = dict(__IPYTHON__ = self,
             ip_set_hook = self.set_hook, 
             jobs = self.jobs,
             ipmagic = wrap_deprecated(self.ipmagic,'_ip.magic()'),  
             ipalias = wrap_deprecated(self.ipalias),  
             ipsystem = wrap_deprecated(self.ipsystem,'_ip.system()'),
             _ip = self.api
             )
        for biname,bival in builtins_new.items():
            try:
                # store the orignal value so we can restore it
                self.builtins_added[biname] =  __builtin__.__dict__[biname]
            except KeyError:
                # or mark that it wasn't defined, and we'll just delete it at
                # cleanup
                self.builtins_added[biname] = Undefined
            __builtin__.__dict__[biname] = bival
            
        # Keep in the builtins a flag for when IPython is active.  We set it
        # with setdefault so that multiple nested IPythons don't clobber one
        # another.  Each will increase its value by one upon being activated,
        # which also gives us a way to determine the nesting level.
        __builtin__.__dict__.setdefault('__IPYTHON__active',0)

    def clean_builtins(self):
        """Remove any builtins which might have been added by add_builtins, or
        restore overwritten ones to their previous values."""
        for biname,bival in self.builtins_added.items():
            if bival is Undefined:
                del __builtin__.__dict__[biname]
            else:
                __builtin__.__dict__[biname] = bival
        self.builtins_added.clear()
    
    def set_hook(self,name,hook, priority = 50, str_key = None, re_key = None):
        """set_hook(name,hook) -&gt; sets an internal IPython hook.

        IPython exposes some of its internal API as user-modifiable hooks.  By
        adding your function to one of these hooks, you can modify IPython's 
        behavior to call at runtime your own routines."""

        # At some point in the future, this should validate the hook before it
        # accepts it.  Probably at least check that the hook takes the number
        # of args it's supposed to.
        
        f = new.instancemethod(hook,self,self.__class__)

        # check if the hook is for strdispatcher first
        if str_key is not None:
            sdp = self.strdispatchers.get(name, StrDispatch())
            sdp.add_s(str_key, f, priority )
            self.strdispatchers[name] = sdp
            return
        if re_key is not None:
            sdp = self.strdispatchers.get(name, StrDispatch())
            sdp.add_re(re.compile(re_key), f, priority )
            self.strdispatchers[name] = sdp
            return
            
        dp = getattr(self.hooks, name, None)
        if name not in IPython.hooks.__all__:
            print "Warning! Hook '%s' is not one of %s" % (name, IPython.hooks.__all__ )
        if not dp:
            dp = IPython.hooks.CommandChainDispatcher()
        
        try:
            dp.add(f,priority)
        except AttributeError:
            # it was not commandchain, plain old func - replace
            dp = f

        setattr(self.hooks,name, dp)
        
        
        #setattr(self.hooks,name,new.instancemethod(hook,self,self.__class__))

    def set_crash_handler(self,crashHandler):
        """Set the IPython crash handler.

        This must be a callable with a signature suitable for use as
        sys.excepthook."""

        # Install the given crash handler as the Python exception hook
        sys.excepthook = crashHandler
        
        # The instance will store a pointer to this, so that runtime code
        # (such as magics) can access it.  This is because during the
        # read-eval loop, it gets temporarily overwritten (to deal with GUI
        # frameworks).
        self.sys_excepthook = sys.excepthook


    def set_custom_exc(self,exc_tuple,handler):
        """set_custom_exc(exc_tuple,handler)

        Set a custom exception handler, which will be called if any of the
        exceptions in exc_tuple occur in the mainloop (specifically, in the
        runcode() method.

        Inputs:

          - exc_tuple: a *tuple* of valid exceptions to call the defined
          handler for.  It is very important that you use a tuple, and NOT A
          LIST here, because of the way Python's except statement works.  If
          you only want to trap a single exception, use a singleton tuple:

            exc_tuple == (MyCustomException,)

          - handler: this must be defined as a function with the following
          basic interface: def my_handler(self,etype,value,tb).

          This will be made into an instance method (via new.instancemethod)
          of IPython itself, and it will be called if any of the exceptions
          listed in the exc_tuple are caught.  If the handler is None, an
          internal basic one is used, which just prints basic info.

        WARNING: by putting in your own exception handler into IPython's main
        execution loop, you run a very good chance of nasty crashes.  This
        facility should only be used if you really know what you are doing."""

        assert type(exc_tuple)==type(()) , \
               "The custom exceptions must be given AS A TUPLE."

        def dummy_handler(self,etype,value,tb):
            print '*** Simple custom exception handler ***'
            print 'Exception type :',etype
            print 'Exception value:',value
            print 'Traceback      :',tb
            print 'Source code    :','\n'.join(self.buffer)

        if handler is None: handler = dummy_handler

        self.CustomTB = new.instancemethod(handler,self,self.__class__)
        self.custom_exceptions = exc_tuple

    def set_custom_completer(self,completer,pos=0):
        """set_custom_completer(completer,pos=0)

        Adds a new custom completer function.

        The position argument (defaults to 0) is the index in the completers
        list where you want the completer to be inserted."""

        newcomp = new.instancemethod(completer,self.Completer,
                                     self.Completer.__class__)
        self.Completer.matchers.insert(pos,newcomp)

    def _get_call_pdb(self):
        return self._call_pdb

    def _set_call_pdb(self,val):

        if val not in (0,1,False,True):
            raise ValueError,'new call_pdb value must be boolean'

        # store value in instance
        self._call_pdb = val

        # notify the actual exception handlers
        self.InteractiveTB.call_pdb = val
        if self.isthreaded:
            try:
                self.sys_excepthook.call_pdb = val
            except:
                warn('Failed to activate pdb for threaded exception handler')

    call_pdb = property(_get_call_pdb,_set_call_pdb,None,
                        'Control auto-activation of pdb at exceptions')
 

    # These special functions get installed in the builtin namespace, to
    # provide programmatic (pure python) access to magics, aliases and system
    # calls.  This is important for logging, user scripting, and more.

    # We are basically exposing, via normal python functions, the three
    # mechanisms in which ipython offers special call modes (magics for
    # internal control, aliases for direct system access via pre-selected
    # names, and !cmd for calling arbitrary system commands).

    def ipmagic(self,arg_s):
        """Call a magic function by name.

        Input: a string containing the name of the magic function to call and any
        additional arguments to be passed to the magic.

        ipmagic('name -opt foo bar') is equivalent to typing at the ipython
        prompt:

        In[1]: %name -opt foo bar

        To call a magic without arguments, simply use ipmagic('name').

        This provides a proper Python function to call IPython's magics in any
        valid Python code you can type at the interpreter, including loops and
        compound statements.  It is added by IPython to the Python builtin
        namespace upon initialization."""

        args = arg_s.split(' ',1)
        magic_name = args[0]
        magic_name = magic_name.lstrip(self.ESC_MAGIC)

        try:
            magic_args = args[1]
        except IndexError:
            magic_args = ''
        fn = getattr(self,'magic_'+magic_name,None)
        if fn is None:
            error("Magic function `%s` not found." % magic_name)
        else:
            magic_args = self.var_expand(magic_args,1)
            return fn(magic_args)

    def ipalias(self,arg_s):
        """Call an alias by name.

        Input: a string containing the name of the alias to call and any
        additional arguments to be passed to the magic.

        ipalias('name -opt foo bar') is equivalent to typing at the ipython
        prompt:

        In[1]: name -opt foo bar

        To call an alias without arguments, simply use ipalias('name').

        This provides a proper Python function to call IPython's aliases in any
        valid Python code you can type at the interpreter, including loops and
        compound statements.  It is added by IPython to the Python builtin
        namespace upon initialization."""

        args = arg_s.split(' ',1)
        alias_name = args[0]
        try:
            alias_args = args[1]
        except IndexError:
            alias_args = ''
        if alias_name in self.alias_table:
            self.call_alias(alias_name,alias_args)
        else:
            error("Alias `%s` not found." % alias_name)

    def ipsystem(self,arg_s):
        """Make a system call, using IPython."""

        self.system(arg_s)

    def complete(self,text):
        """Return a sorted list of all possible completions on text.

        Inputs:

          - text: a string of text to be completed on.

        This is a wrapper around the completion mechanism, similar to what
        readline does at the command line when the TAB key is hit.  By
        exposing it as a method, it can be used by other non-readline
        environments (such as GUIs) for text completion.

        Simple usage example:

        In [1]: x = 'hello'

        In [2]: __IP.complete('x.l')
        Out[2]: ['x.ljust', 'x.lower', 'x.lstrip']"""
        
        complete = self.Completer.complete
        state = 0
        # use a dict so we get unique keys, since ipyhton's multiple
        # completers can return duplicates.
        comps = {}
        while True:
            newcomp = complete(text,state)
            if newcomp is None:
                break
            comps[newcomp] = 1
            state += 1
        outcomps = comps.keys()
        outcomps.sort()
        return outcomps
        
    def set_completer_frame(self, frame=None):
        if frame:
            self.Completer.namespace = frame.f_locals
            self.Completer.global_namespace = frame.f_globals
        else:
            self.Completer.namespace = self.user_ns
            self.Completer.global_namespace = self.user_global_ns

    def init_auto_alias(self):
        """Define some aliases automatically.

        These are ALL parameter-less aliases"""

        for alias,cmd in self.auto_alias:
            self.alias_table[alias] = (0,cmd)

    def alias_table_validate(self,verbose=0):
        """Update information about the alias table.

        In particular, make sure no Python keywords/builtins are in it."""

        no_alias = self.no_alias
        for k in self.alias_table.keys():
            if k in no_alias:
                del self.alias_table[k]
                if verbose:
                    print ("Deleting alias &lt;%s&gt;, it's a Python "
                           "keyword or builtin." % k)
    
    def set_autoindent(self,value=None):
        """Set the autoindent flag, checking for readline support.

        If called with no arguments, it acts as a toggle."""

        if not self.has_readline:
            if os.name == 'posix':
                warn("The auto-indent feature requires the readline library")
            self.autoindent = 0
            return
        if value is None:
            self.autoindent = not self.autoindent
        else:
            self.autoindent = value

    def rc_set_toggle(self,rc_field,value=None):
        """Set or toggle a field in IPython's rc config. structure.

        If called with no arguments, it acts as a toggle.

        If called with a non-existent field, the resulting AttributeError
        exception will propagate out."""

        rc_val = getattr(self.rc,rc_field)
        if value is None:
            value = not rc_val
        setattr(self.rc,rc_field,value)

    def user_setup(self,ipythondir,rc_suffix,mode='install'):
        """Install the user configuration directory.

        Can be called when running for the first time or to upgrade the user's
        .ipython/ directory with the mode parameter. Valid modes are 'install'
        and 'upgrade'."""

        def wait():
            try:
                raw_input("Please press &lt;RETURN&gt; to start IPython.")
            except EOFError:
                print &gt;&gt; Term.cout
            print '*'*70

        cwd = os.getcwd()  # remember where we started
        glb = glob.glob
        print '*'*70
        if mode == 'install':
            print \
"""Welcome to IPython. I will try to create a personal configuration directory
where you can customize many aspects of IPython's functionality in:\n"""
        else:
            print 'I am going to upgrade your configuration in:'

        print ipythondir

        rcdirend = os.path.join('IPython','UserConfig')
        cfg = lambda d: os.path.join(d,rcdirend)
        try:
            rcdir = filter(os.path.isdir,map(cfg,sys.path))[0]
        except IOError:
            warning = """
Installation error. IPython's directory was not found.

Check the following:

The ipython/IPython directory should be in a directory belonging to your
PYTHONPATH environment variable (that is, it should be in a directory
belonging to sys.path). You can copy it explicitly there or just link to it.

IPython will proceed with builtin defaults.
"""
            warn(warning)
            wait()
            return

        if mode == 'install':
            try:
                shutil.copytree(rcdir,ipythondir)
                os.chdir(ipythondir)
                rc_files = glb("ipythonrc*")
                for rc_file in rc_files:
                    os.rename(rc_file,rc_file+rc_suffix)
            except:
                warning = """

There was a problem with the installation:
%s
Try to correct it or contact the developers if you think it's a bug.
IPython will proceed with builtin defaults.""" % sys.exc_info()[1]
                warn(warning)
                wait()
                return

        elif mode == 'upgrade':
            try:
                os.chdir(ipythondir)
            except:
                print """
Can not upgrade: changing to directory %s failed. Details:
%s
""" % (ipythondir,sys.exc_info()[1])
                wait()
                return
            else:
                sources = glb(os.path.join(rcdir,'[A-Za-z]*'))
                for new_full_path in sources:
                    new_filename = os.path.basename(new_full_path)
                    if new_filename.startswith('ipythonrc'):
                        new_filename = new_filename + rc_suffix
                    # The config directory should only contain files, skip any
                    # directories which may be there (like CVS)
                    if os.path.isdir(new_full_path):
                        continue
                    if os.path.exists(new_filename):
                        old_file = new_filename+'.old'
                        if os.path.exists(old_file):
                            os.remove(old_file)
                        os.rename(new_filename,old_file)
                    shutil.copy(new_full_path,new_filename)
        else:
            raise ValueError,'unrecognized mode for install:',`mode`

        # Fix line-endings to those native to each platform in the config
        # directory.
        try:
            os.chdir(ipythondir)
        except:
            print """
Problem: changing to directory %s failed.
Details:
%s

Some configuration files may have incorrect line endings.  This should not
cause any problems during execution.  """ % (ipythondir,sys.exc_info()[1])
            wait()
        else:
            for fname in glb('ipythonrc*'):
                try:
                    native_line_ends(fname,backup=0)
                except IOError:
                    pass

        if mode == 'install':
            print """
Successful installation!

Please read the sections 'Initial Configuration' and 'Quick Tips' in the
IPython manual (there are both HTML and PDF versions supplied with the
distribution) to make sure that your system environment is properly configured
to take advantage of IPython's features.

Important note: the configuration system has changed! The old system is
still in place, but its setting may be partly overridden by the settings in 
"~/.ipython/ipy_user_conf.py" config file. Please take a look at the file 
if some of the new settings bother you. 

"""
        else:
            print """
Successful upgrade!

All files in your directory:
%(ipythondir)s
which would have been overwritten by the upgrade were backed up with a .old
extension.  If you had made particular customizations in those files you may
want to merge them back into the new files.""" % locals()
        wait()
        os.chdir(cwd)
        # end user_setup()

    def atexit_operations(self):
        """This will be executed at the time of exit.

        Saving of persistent data should be performed here. """

        #print '*** IPython exit cleanup ***' # dbg
        # input history
        self.savehist()

        # Cleanup all tempfiles left around
        for tfile in self.tempfiles:
            try:
                os.unlink(tfile)
            except OSError:
                pass

        # save the "persistent data" catch-all dictionary
        self.hooks.shutdown_hook()
        
    def savehist(self):
        """Save input history to a file (via readline library)."""
        try:
            self.readline.write_history_file(self.histfile)
        except:
            print 'Unable to save IPython command history to file: ' + \
                  `self.histfile`

    def history_saving_wrapper(self, func):
        """ Wrap func for readline history saving
        
        Convert func into callable that saves &amp; restores
        history around the call """
        
        if not self.has_readline:
            return func
        
        def wrapper():
            self.savehist()
            try:
                func()
            finally:
                readline.read_history_file(self.histfile)
        return wrapper
                
            
    def pre_readline(self):
        """readline hook to be used at the start of each line.

        Currently it handles auto-indent only."""

        #debugx('self.indent_current_nsp','pre_readline:')
        self.readline.insert_text(self.indent_current_str())

    def init_readline(self):
        """Command history completion/saving/reloading."""

        import IPython.rlineimpl as readline
        if not readline.have_readline:
            self.has_readline = 0
            self.readline = None
            # no point in bugging windows users with this every time:
            warn('Readline services not available on this platform.')
        else:
            sys.modules['readline'] = readline
            import atexit
            from IPython.completer import IPCompleter
            self.Completer = IPCompleter(self,
                                            self.user_ns,
                                            self.user_global_ns,
                                            self.rc.readline_omit__names,
                                            self.alias_table)
            sdisp = self.strdispatchers.get('complete_command', StrDispatch())
            self.strdispatchers['complete_command'] = sdisp
            self.Completer.custom_completers = sdisp
            # Platform-specific configuration
            if os.name == 'nt':
                self.readline_startup_hook = readline.set_pre_input_hook
            else:
                self.readline_startup_hook = readline.set_startup_hook

            # Load user's initrc file (readline config)
            inputrc_name = os.environ.get('INPUTRC')
            if inputrc_name is None:
                home_dir = get_home_dir()
                if home_dir is not None:
                    inputrc_name = os.path.join(home_dir,'.inputrc')
            if os.path.isfile(inputrc_name):
                try:
                    readline.read_init_file(inputrc_name)
                except:
                    warn('Problems reading readline initialization file &lt;%s&gt;'
                         % inputrc_name)
            
            self.has_readline = 1
            self.readline = readline
            # save this in sys so embedded copies can restore it properly
            sys.ipcompleter = self.Completer.complete
            readline.set_completer(self.Completer.complete)

            # Configure readline according to user's prefs
            for rlcommand in self.rc.readline_parse_and_bind:
                readline.parse_and_bind(rlcommand)

            # remove some chars from the delimiters list
            delims = readline.get_completer_delims()
            delims = delims.translate(string._idmap,
                                      self.rc.readline_remove_delims)
            readline.set_completer_delims(delims)
            # otherwise we end up with a monster history after a while:
            readline.set_history_length(1000)
            try:
                #print '*** Reading readline history'  # dbg
                readline.read_history_file(self.histfile)
            except IOError:
                pass  # It doesn't exist yet.

            atexit.register(self.atexit_operations)
            del atexit

        # Configure auto-indent for all platforms
        self.set_autoindent(self.rc.autoindent)

    def ask_yes_no(self,prompt,default=True):
        if self.rc.quiet:
            return True
        return ask_yes_no(prompt,default)
    
    def _should_recompile(self,e):
        """Utility routine for edit_syntax_error"""

        if e.filename in ('&lt;ipython console&gt;','&lt;input&gt;','&lt;string&gt;',
                          '&lt;console&gt;','&lt;BackgroundJob compilation&gt;',
                          None):
                              
            return False
        try:
            if (self.rc.autoedit_syntax and 
                not self.ask_yes_no('Return to editor to correct syntax error? '
                              '[Y/n] ','y')):
                return False
        except EOFError:
            return False

        def int0(x):
            try:
                return int(x)
            except TypeError:
                return 0
        # always pass integer line and offset values to editor hook
        self.hooks.fix_error_editor(e.filename,
            int0(e.lineno),int0(e.offset),e.msg)
        return True
        
    def edit_syntax_error(self):
        """The bottom half of the syntax error handler called in the main loop.

        Loop until syntax error is fixed or user cancels.
        """

        while self.SyntaxTB.last_syntax_error:
            # copy and clear last_syntax_error
            err = self.SyntaxTB.clear_err_state()
            if not self._should_recompile(err):
                return
            try:
                # may set last_syntax_error again if a SyntaxError is raised
                self.safe_execfile(err.filename,self.user_ns)
            except:
                self.showtraceback()
            else:
                try:
                    f = file(err.filename)
                    try:
                        sys.displayhook(f.read())
                    finally:
                        f.close()
                except:
                    self.showtraceback()

    def showsyntaxerror(self, filename=None):
        """Display the syntax error that just occurred.

        This doesn't display a stack trace because there isn't one.

        If a filename is given, it is stuffed in the exception instead
        of what was there before (because Python's parser always uses
        "&lt;string&gt;" when reading from a string).
        """
        etype, value, last_traceback = sys.exc_info()

        # See note about these variables in showtraceback() below
        sys.last_type = etype
        sys.last_value = value
        sys.last_traceback = last_traceback
        
        if filename and etype is SyntaxError:
            # Work hard to stuff the correct filename in the exception
            try:
                msg, (dummy_filename, lineno, offset, line) = value
            except:
                # Not the format we expect; leave it alone
                pass
            else:
                # Stuff in the right filename
                try:
                    # Assume SyntaxError is a class exception
                    value = SyntaxError(msg, (filename, lineno, offset, line))
                except:
                    # If that failed, assume SyntaxError is a string
                    value = msg, (filename, lineno, offset, line)
        self.SyntaxTB(etype,value,[])

    def debugger(self,force=False):
        """Call the pydb/pdb debugger.

        Keywords:

          - force(False): by default, this routine checks the instance call_pdb
          flag and does not actually invoke the debugger if the flag is false.
          The 'force' option forces the debugger to activate even if the flag
          is false.
        """

        if not (force or self.call_pdb):
            return

        if not hasattr(sys,'last_traceback'):
            error('No traceback has been produced, nothing to debug.')
            return

        have_pydb = False
        # use pydb if available
        try:
            from pydb import pm
            have_pydb = True
        except ImportError:
            pass
        if not have_pydb:
            # fallback to our internal debugger
            pm = lambda : self.InteractiveTB.debugger(force=True)
        self.history_saving_wrapper(pm)()

    def showtraceback(self,exc_tuple = None,filename=None,tb_offset=None):
        """Display the exception that just occurred.

        If nothing is known about the exception, this is the method which
        should be used throughout the code for presenting user tracebacks,
        rather than directly invoking the InteractiveTB object.

        A specific showsyntaxerror() also exists, but this method can take
        care of calling it if needed, so unless you are explicitly catching a
        SyntaxError exception, don't try to analyze the stack manually and
        simply call this method."""

        # Though this won't be called by syntax errors in the input line,
        # there may be SyntaxError cases whith imported code.
        if exc_tuple is None:
            etype, value, tb = sys.exc_info()
        else:
            etype, value, tb = exc_tuple
        if etype is SyntaxError:
            self.showsyntaxerror(filename)
        else:
            # WARNING: these variables are somewhat deprecated and not
            # necessarily safe to use in a threaded environment, but tools
            # like pdb depend on their existence, so let's set them.  If we
            # find problems in the field, we'll need to revisit their use.
            sys.last_type = etype
            sys.last_value = value
            sys.last_traceback = tb
            
            self.InteractiveTB(etype,value,tb,tb_offset=tb_offset)
            if self.InteractiveTB.call_pdb and self.has_readline:
                # pdb mucks up readline, fix it back
                self.readline.set_completer(self.Completer.complete)

    def mainloop(self,banner=None):
        """Creates the local namespace and starts the mainloop.

        If an optional banner argument is given, it will override the
        internally created default banner."""

        if self.rc.c:  # Emulate Python's -c option
            self.exec_init_cmd()
        if banner is None:
            if not self.rc.banner:
                banner = ''
            # banner is string? Use it directly!
            elif isinstance(self.rc.banner,basestring):
                banner = self.rc.banner
            else:                
                banner = self.BANNER+self.banner2

        self.interact(banner)

    def exec_init_cmd(self):
        """Execute a command given at the command line.

        This emulates Python's -c option."""

        #sys.argv = ['-c']
        self.push(self.rc.c)

    def embed_mainloop(self,header='',local_ns=None,global_ns=None,stack_depth=0):
        """Embeds IPython into a running python program.

        Input:

          - header: An optional header message can be specified.

          - local_ns, global_ns: working namespaces. If given as None, the
          IPython-initialized one is updated with __main__.__dict__, so that
          program variables become visible but user-specific configuration
          remains possible.

          - stack_depth: specifies how many levels in the stack to go to
          looking for namespaces (when local_ns and global_ns are None).  This
          allows an intermediate caller to make sure that this function gets
          the namespace from the intended level in the stack.  By default (0)
          it will get its locals and globals from the immediate caller.

        Warning: it's possible to use this in a program which is being run by
        IPython itself (via %run), but some funny things will happen (a few
        globals get overwritten). In the future this will be cleaned up, as
        there is no fundamental reason why it can't work perfectly."""

        # Get locals and globals from caller
        if local_ns is None or global_ns is None:
            call_frame = sys._getframe(stack_depth).f_back

            if local_ns is None:
                local_ns = call_frame.f_locals
            if global_ns is None:
                global_ns = call_frame.f_globals

        # Update namespaces and fire up interpreter

        # The global one is easy, we can just throw it in
        self.user_global_ns = global_ns

        # but the user/local one is tricky: ipython needs it to store internal
        # data, but we also need the locals.  We'll copy locals in the user
        # one, but will track what got copied so we can delete them at exit.
        # This is so that a later embedded call doesn't see locals from a
        # previous call (which most likely existed in a separate scope).
        local_varnames = local_ns.keys()
        self.user_ns.update(local_ns)

        # Patch for global embedding to make sure that things don't overwrite
        # user globals accidentally. Thanks to Richard &lt;rxe@renre-europe.com&gt;
        # FIXME. Test this a bit more carefully (the if.. is new)
        if local_ns is None and global_ns is None:
            self.user_global_ns.update(__main__.__dict__)

        # make sure the tab-completer has the correct frame information, so it
        # actually completes using the frame's locals/globals
        self.set_completer_frame()

        # before activating the interactive mode, we need to make sure that
        # all names in the builtin namespace needed by ipython point to
        # ourselves, and not to other instances.
        self.add_builtins()
        
        self.interact(header)
        
        # now, purge out the user namespace from anything we might have added
        # from the caller's local namespace
        delvar = self.user_ns.pop
        for var in local_varnames:
            delvar(var,None)
        # and clean builtins we may have overridden
        self.clean_builtins()

    def interact(self, banner=None):
        """Closely emulate the interactive Python console.

        The optional banner argument specify the banner to print
        before the first interaction; by default it prints a banner
        similar to the one printed by the real Python interpreter,
        followed by the current class name in parentheses (so as not
        to confuse this with the real interpreter -- since it's so
        close!).

        """
        
        if self.exit_now:
            # batch run -&gt; do not interact
            return
        cprt = 'Type "copyright", "credits" or "license" for more information.'
        if banner is None:
            self.write("Python %s on %s\n%s\n(%s)\n" %
                       (sys.version, sys.platform, cprt,
                        self.__class__.__name__))
        else:
            self.write(banner)

        more = 0
        
        # Mark activity in the builtins
        __builtin__.__dict__['__IPYTHON__active'] += 1

        # exit_now is set by a call to %Exit or %Quit
        while not self.exit_now:
            if more:
                prompt = self.hooks.generate_prompt(True)
                if self.autoindent:
                    self.readline_startup_hook(self.pre_readline)
            else:
                prompt = self.hooks.generate_prompt(False)
            try:
                line = self.raw_input(prompt,more)
                if self.exit_now:
                    # quick exit on sys.std[in|out] close
                    break
                if self.autoindent:
                    self.readline_startup_hook(None)
            except KeyboardInterrupt:
                self.write('\nKeyboardInterrupt\n')
                self.resetbuffer()
                # keep cache in sync with the prompt counter:
                self.outputcache.prompt_count -= 1

                if self.autoindent:
                    self.indent_current_nsp = 0
                more = 0
            except EOFError:
                if self.autoindent:
                    self.readline_startup_hook(None)
                self.write('\n')
                self.exit()
            except bdb.BdbQuit:
                warn('The Python debugger has exited with a BdbQuit exception.\n'
                     'Because of how pdb handles the stack, it is impossible\n'
                     'for IPython to properly format this particular exception.\n'
                     'IPython will resume normal operation.')
            except:
                # exceptions here are VERY RARE, but they can be triggered
                # asynchronously by signal handlers, for example.
                self.showtraceback()
            else:
                more = self.push(line)
                if (self.SyntaxTB.last_syntax_error and
                    self.rc.autoedit_syntax):
                    self.edit_syntax_error()
            
        # We are off again...
        __builtin__.__dict__['__IPYTHON__active'] -= 1

    def excepthook(self, etype, value, tb):
      """One more defense for GUI apps that call sys.excepthook.

      GUI frameworks like wxPython trap exceptions and call
      sys.excepthook themselves.  I guess this is a feature that
      enables them to keep running after exceptions that would
      otherwise kill their mainloop. This is a bother for IPython
      which excepts to catch all of the program exceptions with a try:
      except: statement.

      Normally, IPython sets sys.excepthook to a CrashHandler instance, so if
      any app directly invokes sys.excepthook, it will look to the user like
      IPython crashed.  In order to work around this, we can disable the
      CrashHandler and replace it with this excepthook instead, which prints a
      regular traceback using our InteractiveTB.  In this fashion, apps which
      call sys.excepthook will generate a regular-looking exception from
      IPython, and the CrashHandler will only be triggered by real IPython
      crashes.

      This hook should be used sparingly, only in places which are not likely
      to be true IPython errors.
      """
      self.showtraceback((etype,value,tb),tb_offset=0)

    def expand_aliases(self,fn,rest):
        """ Expand multiple levels of aliases:
        
        if:
        
        alias foo bar /tmp
        alias baz foo
        
        then:
        
        baz huhhahhei -&gt; bar /tmp huhhahhei
        
        """
        line = fn + " " + rest
        
        done = Set()
        while 1:
            pre,fn,rest = self.split_user_input(line)
            if fn in self.alias_table:
                if fn in done:
                    warn("Cyclic alias definition, repeated '%s'" % fn)
                    return ""
                done.add(fn)

                l2 = self.transform_alias(fn,rest)
                # dir -&gt; dir 
                # print "alias",line, "-&gt;",l2  #dbg
                if l2 == line:
                    break
                # ls -&gt; ls -F should not recurse forever
                if l2.split(None,1)[0] == line.split(None,1)[0]:
                    line = l2
                    break
                
                line=l2
                
                
                # print "al expand to",line #dbg
            else:
                break
                
        return line

    def transform_alias(self, alias,rest=''):
        """ Transform alias to system command string.
        """
        nargs,cmd = self.alias_table[alias]
        if ' ' in cmd and os.path.isfile(cmd):
            cmd = '"%s"' % cmd

        # Expand the %l special to be the user's input line
        if cmd.find('%l') &gt;= 0:
            cmd = cmd.replace('%l',rest)
            rest = ''
        if nargs==0:
            # Simple, argument-less aliases
            cmd = '%s %s' % (cmd,rest)
        else:
            # Handle aliases with positional arguments
            args = rest.split(None,nargs)
            if len(args)&lt; nargs:
                error('Alias &lt;%s&gt; requires %s arguments, %s given.' %
                      (alias,nargs,len(args)))
                return None
            cmd = '%s %s' % (cmd % tuple(args[:nargs]),' '.join(args[nargs:]))
        # Now call the macro, evaluating in the user's namespace
        #print 'new command: &lt;%r&gt;' % cmd  # dbg
        return cmd
        
    def call_alias(self,alias,rest=''):
        """Call an alias given its name and the rest of the line.

        This is only used to provide backwards compatibility for users of
        ipalias(), use of which is not recommended for anymore."""

        # Now call the macro, evaluating in the user's namespace
        cmd = self.transform_alias(alias, rest)
        try:
            self.system(cmd)
        except:
            self.showtraceback()

    def indent_current_str(self):
        """return the current level of indentation as a string"""
        return self.indent_current_nsp * ' '

    def autoindent_update(self,line):
        """Keep track of the indent level."""

        #debugx('line')
        #debugx('self.indent_current_nsp')
        if self.autoindent:
            if line:
                inisp = num_ini_spaces(line)
                if inisp &lt; self.indent_current_nsp:
                    self.indent_current_nsp = inisp

                if line[-1] == ':':
                    self.indent_current_nsp += 4
                elif dedent_re.match(line):
                    self.indent_current_nsp -= 4
            else:
                self.indent_current_nsp = 0

    def runlines(self,lines):
        """Run a string of one or more lines of source.

        This method is capable of running a string containing multiple source
        lines, as if they had been entered at the IPython prompt.  Since it
        exposes IPython's processing machinery, the given strings can contain
        magic calls (%magic), special shell access (!cmd), etc."""

        # We must start with a clean buffer, in case this is run from an
        # interactive IPython session (via a magic, for example).
        self.resetbuffer()
        lines = lines.split('\n')
        more = 0
        for line in lines:
            # skip blank lines so we don't mess up the prompt counter, but do
            # NOT skip even a blank line if we are in a code block (more is
            # true)
            if line or more:
                more = self.push(self.prefilter(line,more))
                # IPython's runsource returns None if there was an error
                # compiling the code.  This allows us to stop processing right
                # away, so the user gets the error message at the right place.
                if more is None:
                    break
        # final newline in case the input didn't have it, so that the code
        # actually does get executed
        if more:
            self.push('\n')

    def runsource(self, source, filename='&lt;input&gt;', symbol='single'):
        """Compile and run some source in the interpreter.

        Arguments are as for compile_command().

        One several things can happen:

        1) The input is incorrect; compile_command() raised an
        exception (SyntaxError or OverflowError).  A syntax traceback
        will be printed by calling the showsyntaxerror() method.

        2) The input is incomplete, and more input is required;
        compile_command() returned None.  Nothing happens.

        3) The input is complete; compile_command() returned a code
        object.  The code is executed by calling self.runcode() (which
        also handles run-time exceptions, except for SystemExit).

        The return value is:

          - True in case 2

          - False in the other cases, unless an exception is raised, where
          None is returned instead.  This can be used by external callers to
          know whether to continue feeding input or not.

        The return value can be used to decide whether to use sys.ps1 or
        sys.ps2 to prompt the next line."""

        # if the source code has leading blanks, add 'if 1:\n' to it
        # this allows execution of indented pasted code. It is tempting
        # to add '\n' at the end of source to run commands like ' a=1'
        # directly, but this fails for more complicated scenarios
        if source[:1] in [' ', '\t']:
            source = 'if 1:\n%s' % source

        try:
            code = self.compile(source,filename,symbol)
        except (OverflowError, SyntaxError, ValueError):
            # Case 1
            self.showsyntaxerror(filename)
            return None

        if code is None:
            # Case 2
            return True

        # Case 3
        # We store the code object so that threaded shells and
        # custom exception handlers can access all this info if needed.
        # The source corresponding to this can be obtained from the
        # buffer attribute as '\n'.join(self.buffer).
        self.code_to_run = code
        # now actually execute the code object
        if self.runcode(code) == 0:
            return False
        else:
            return None

    def runcode(self,code_obj):
        """Execute a code object.

        When an exception occurs, self.showtraceback() is called to display a
        traceback.

        Return value: a flag indicating whether the code to be run completed
        successfully:

          - 0: successful execution.
          - 1: an error occurred.
        """

        # Set our own excepthook in case the user code tries to call it
        # directly, so that the IPython crash handler doesn't get triggered
        old_excepthook,sys.excepthook = sys.excepthook, self.excepthook

        # we save the original sys.excepthook in the instance, in case config
        # code (such as magics) needs access to it.
        self.sys_excepthook = old_excepthook
        outflag = 1  # happens in more places, so it's easier as default
        try:
            try:
                # Embedded instances require separate global/local namespaces
                # so they can see both the surrounding (local) namespace and
                # the module-level globals when called inside another function.
                if self.embedded:
                    exec code_obj in self.user_global_ns, self.user_ns
                # Normal (non-embedded) instances should only have a single
                # namespace for user code execution, otherwise functions won't
                # see interactive top-level globals.
                else:
                    exec code_obj in self.user_ns
            finally:
                # Reset our crash handler in place
                sys.excepthook = old_excepthook
        except SystemExit:
            self.resetbuffer()
            self.showtraceback()
            warn("Type %exit or %quit to exit IPython "
                 "(%Exit or %Quit do so unconditionally).",level=1)
        except self.custom_exceptions:
            etype,value,tb = sys.exc_info()
            self.CustomTB(etype,value,tb)
        except:
            self.showtraceback()
        else:
            outflag = 0
            if softspace(sys.stdout, 0):
                print
        # Flush out code object which has been run (and source)
        self.code_to_run = None
        return outflag
        
    def push(self, line):
        """Push a line to the interpreter.

        The line should not have a trailing newline; it may have
        internal newlines.  The line is appended to a buffer and the
        interpreter's runsource() method is called with the
        concatenated contents of the buffer as source.  If this
        indicates that the command was executed or invalid, the buffer
        is reset; otherwise, the command is incomplete, and the buffer
        is left as it was after the line was appended.  The return
        value is 1 if more input is required, 0 if the line was dealt
        with in some way (this is the same as runsource()).
        """

        # autoindent management should be done here, and not in the
        # interactive loop, since that one is only seen by keyboard input.  We
        # need this done correctly even for code run via runlines (which uses
        # push).

        #print 'push line: &lt;%s&gt;' % line  # dbg
        for subline in line.splitlines():
            self.autoindent_update(subline)
        self.buffer.append(line)
        more = self.runsource('\n'.join(self.buffer), self.filename)
        if not more:
            self.resetbuffer()
        return more

    def resetbuffer(self):
        """Reset the input buffer."""
        self.buffer[:] = []
        
    def raw_input(self,prompt='',continue_prompt=False):
        """Write a prompt and read a line.

        The returned line does not include the trailing newline.
        When the user enters the EOF key sequence, EOFError is raised.

        Optional inputs:

          - prompt(''): a string to be printed to prompt the user.

          - continue_prompt(False): whether this line is the first one or a
          continuation in a sequence of inputs.
        """

        try:
            line = raw_input_original(prompt)
        except ValueError:
            warn("\n********\nYou or a %run:ed script called sys.stdin.close() or sys.stdout.close()!\nExiting IPython!")
            self.exit_now = True
            return ""
        

        # Try to be reasonably smart about not re-indenting pasted input more
        # than necessary.  We do this by trimming out the auto-indent initial
        # spaces, if the user's actual input started itself with whitespace.
        #debugx('self.buffer[-1]')

        if self.autoindent:
            if num_ini_spaces(line) &gt; self.indent_current_nsp:
                line = line[self.indent_current_nsp:]
                self.indent_current_nsp = 0
            
        # store the unfiltered input before the user has any chance to modify
        # it.
        if line.strip():
            if continue_prompt:
                self.input_hist_raw[-1] += '%s\n' % line
                if self.has_readline: # and some config option is set?
                    try:
                        histlen = self.readline.get_current_history_length()
                        newhist = self.input_hist_raw[-1].rstrip()
                        self.readline.remove_history_item(histlen-1)
                        self.readline.replace_history_item(histlen-2,newhist)
                    except AttributeError:
                        pass # re{move,place}_history_item are new in 2.4.                
            else:
                self.input_hist_raw.append('%s\n' % line)

        try:
            lineout = self.prefilter(line,continue_prompt)
        except:
            # blanket except, in case a user-defined prefilter crashes, so it
            # can't take all of ipython with it.
            self.showtraceback()
            return ''
        else:
            return lineout
        
    def split_user_input(self,line):
        """Split user input into pre-char, function part and rest."""

        lsplit = self.line_split.match(line)
        if lsplit is None:  # no regexp match returns None
            try:
                iFun,theRest = line.split(None,1)
            except ValueError:
                iFun,theRest = line,''
            pre = re.match('^(\s*)(.*)',line).groups()[0]
        else:
            pre,iFun,theRest = lsplit.groups()

        #print 'line:&lt;%s&gt;' % line # dbg
        #print 'pre &lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun.strip(),theRest) # dbg
        return pre,iFun.strip(),theRest

    def _prefilter(self, line, continue_prompt):
        """Calls different preprocessors, depending on the form of line."""

        # All handlers *must* return a value, even if it's blank ('').

        # Lines are NOT logged here. Handlers should process the line as
        # needed, update the cache AND log it (so that the input cache array
        # stays synced).

        # This function is _very_ delicate, and since it's also the one which
        # determines IPython's response to user input, it must be as efficient
        # as possible.  For this reason it has _many_ returns in it, trying
        # always to exit as quickly as it can figure out what it needs to do.

        # This function is the main responsible for maintaining IPython's
        # behavior respectful of Python's semantics.  So be _very_ careful if
        # making changes to anything here.

        #.....................................................................
        # Code begins

        #if line.startswith('%crash'): raise RuntimeError,'Crash now!'  # dbg

        # save the line away in case we crash, so the post-mortem handler can
        # record it
        self._last_input_line = line

        #print '***line: &lt;%s&gt;' % line # dbg
        
        # the input history needs to track even empty lines
        stripped = line.strip()
        
        if not stripped:
            if not continue_prompt:
                self.outputcache.prompt_count -= 1
            return self.handle_normal(line,continue_prompt)
            #return self.handle_normal('',continue_prompt)

        # print '***cont',continue_prompt  # dbg
        # special handlers are only allowed for single line statements
        if continue_prompt and not self.rc.multi_line_specials:
            return self.handle_normal(line,continue_prompt)


        # For the rest, we need the structure of the input
        pre,iFun,theRest = self.split_user_input(line)

        # See whether any pre-existing handler can take care of it
        
        rewritten = self.hooks.input_prefilter(stripped)
        if rewritten != stripped: # ok, some prefilter did something
            rewritten = pre + rewritten  # add indentation
            return self.handle_normal(rewritten)
            
        #print 'pre &lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun,theRest)  # dbg

        # First check for explicit escapes in the last/first character
        handler = None
        if line[-1] == self.ESC_HELP:
            handler = self.esc_handlers.get(line[-1])  # the ? can be at the end
        if handler is None:
            # look at the first character of iFun, NOT of line, so we skip
            # leading whitespace in multiline input
            handler = self.esc_handlers.get(iFun[0:1])
        if handler is not None:
            return handler(line,continue_prompt,pre,iFun,theRest)
        # Emacs ipython-mode tags certain input lines
        if line.endswith('# PYTHON-MODE'):
            return self.handle_emacs(line,continue_prompt)

        # Next, check if we can automatically execute this thing

        # Allow ! in multi-line statements if multi_line_specials is on:
        if continue_prompt and self.rc.multi_line_specials and \
               iFun.startswith(self.ESC_SHELL):
            return self.handle_shell_escape(line,continue_prompt,
                                            pre=pre,iFun=iFun,
                                            theRest=theRest)

        # Let's try to find if the input line is a magic fn
        oinfo = None
        if hasattr(self,'magic_'+iFun):
            # WARNING: _ofind uses getattr(), so it can consume generators and
            # cause other side effects.
            oinfo = self._ofind(iFun) # FIXME - _ofind is part of Magic
            if oinfo['ismagic']:
                # Be careful not to call magics when a variable assignment is
                # being made (ls='hi', for example)
                if self.rc.automagic and \
                       (len(theRest)==0 or theRest[0] not in '!=()&lt;&gt;,') and \
                       (self.rc.multi_line_specials or not continue_prompt):
                    return self.handle_magic(line,continue_prompt,
                                             pre,iFun,theRest)
                else:
                    return self.handle_normal(line,continue_prompt)

        # If the rest of the line begins with an (in)equality, assginment or
        # function call, we should not call _ofind but simply execute it.
        # This avoids spurious geattr() accesses on objects upon assignment.
        #
        # It also allows users to assign to either alias or magic names true
        # python variables (the magic/alias systems always take second seat to
        # true python code).
        if theRest and theRest[0] in '!=()':
            return self.handle_normal(line,continue_prompt)

        if oinfo is None:
            # let's try to ensure that _oinfo is ONLY called when autocall is
            # on.  Since it has inevitable potential side effects, at least
            # having autocall off should be a guarantee to the user that no
            # weird things will happen.

            if self.rc.autocall:
                oinfo = self._ofind(iFun) # FIXME - _ofind is part of Magic
            else:
                # in this case, all that's left is either an alias or
                # processing the line normally.
                if iFun in self.alias_table:
                    # if autocall is off, by not running _ofind we won't know
                    # whether the given name may also exist in one of the
                    # user's namespace.  At this point, it's best to do a
                    # quick check just to be sure that we don't let aliases
                    # shadow variables.
                    head = iFun.split('.',1)[0]
                    if head in self.user_ns or head in self.internal_ns \
                       or head in __builtin__.__dict__:
                        return self.handle_normal(line,continue_prompt)
                    else:
                        return self.handle_alias(line,continue_prompt,
                                                 pre,iFun,theRest)
                 
                else:
                    return self.handle_normal(line,continue_prompt)
        
        if not oinfo['found']:
            return self.handle_normal(line,continue_prompt)
        else:
            #print 'pre&lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun,theRest) # dbg
            if oinfo['isalias']:
                return self.handle_alias(line,continue_prompt,
                                             pre,iFun,theRest)

            if (self.rc.autocall 
                 and
                   (
                   #only consider exclusion re if not "," or ";" autoquoting
                   (pre == self.ESC_QUOTE or pre == self.ESC_QUOTE2
                     or pre == self.ESC_PAREN) or 
                   (not self.re_exclude_auto.match(theRest)))
                 and 
                   self.re_fun_name.match(iFun) and 
                   callable(oinfo['obj'])) :
                #print 'going auto'  # dbg
                return self.handle_auto(line,continue_prompt,
                                        pre,iFun,theRest,oinfo['obj'])
            else:
                #print 'was callable?', callable(oinfo['obj'])  # dbg
                return self.handle_normal(line,continue_prompt)

        # If we get here, we have a normal Python line. Log and return.
        return self.handle_normal(line,continue_prompt)

    def _prefilter_dumb(self, line, continue_prompt):
        """simple prefilter function, for debugging"""
        return self.handle_normal(line,continue_prompt)

    
    def multiline_prefilter(self, line, continue_prompt):
        """ Run _prefilter for each line of input
        
        Covers cases where there are multiple lines in the user entry,
        which is the case when the user goes back to a multiline history
        entry and presses enter.
        
        """
        out = []
        for l in line.rstrip('\n').split('\n'):
            out.append(self._prefilter(l, continue_prompt))
        return '\n'.join(out)
    
    # Set the default prefilter() function (this can be user-overridden)
    prefilter = multiline_prefilter

    def handle_normal(self,line,continue_prompt=None,
                      pre=None,iFun=None,theRest=None):
        """Handle normal input lines. Use as a template for handlers."""

        # With autoindent on, we need some way to exit the input loop, and I
        # don't want to force the user to have to backspace all the way to
        # clear the line.  The rule will be in this case, that either two
        # lines of pure whitespace in a row, or a line of pure whitespace but
        # of a size different to the indent level, will exit the input loop.
        
        if (continue_prompt and self.autoindent and line.isspace() and
            (0 &lt; abs(len(line) - self.indent_current_nsp) &lt;= 2 or
             (self.buffer[-1]).isspace() )):
            line = ''

        self.log(line,line,continue_prompt)
        return line

    def handle_alias(self,line,continue_prompt=None,
                     pre=None,iFun=None,theRest=None):
        """Handle alias input lines. """

        # pre is needed, because it carries the leading whitespace.  Otherwise
        # aliases won't work in indented sections.
        transformed = self.expand_aliases(iFun, theRest)        
        line_out = '%s_ip.system(%s)' % (pre, make_quoted_expr( transformed ))        
        self.log(line,line_out,continue_prompt)
        #print 'line out:',line_out # dbg
        return line_out

    def handle_shell_escape(self, line, continue_prompt=None,
                            pre=None,iFun=None,theRest=None):
        """Execute the line in a shell, empty return value"""

        #print 'line in :', `line` # dbg
        # Example of a special handler. Others follow a similar pattern.
        if line.lstrip().startswith('!!'):
            # rewrite iFun/theRest to properly hold the call to %sx and
            # the actual command to be executed, so handle_magic can work
            # correctly
            theRest = '%s %s' % (iFun[2:],theRest)
            iFun = 'sx'
            return self.handle_magic('%ssx %s' % (self.ESC_MAGIC,
                                     line.lstrip()[2:]),
                                     continue_prompt,pre,iFun,theRest)
        else:
            cmd=line.lstrip().lstrip('!')
            line_out = '%s_ip.system(%s)' % (pre,make_quoted_expr(cmd))
        # update cache/log and return
        self.log(line,line_out,continue_prompt)
        return line_out

    def handle_magic(self, line, continue_prompt=None,
                     pre=None,iFun=None,theRest=None):
        """Execute magic functions."""


        cmd = '%s_ip.magic(%s)' % (pre,make_quoted_expr(iFun + " " + theRest))
        self.log(line,cmd,continue_prompt)
        #print 'in handle_magic, cmd=&lt;%s&gt;' % cmd  # dbg
        return cmd

    def handle_auto(self, line, continue_prompt=None,
                    pre=None,iFun=None,theRest=None,obj=None):
        """Hande lines which can be auto-executed, quoting if requested."""

        #print 'pre &lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun,theRest)  # dbg
        
        # This should only be active for single-line input!
        if continue_prompt:
            self.log(line,line,continue_prompt)
            return line

        auto_rewrite = True
        
        if pre == self.ESC_QUOTE:
            # Auto-quote splitting on whitespace
            newcmd = '%s("%s")' % (iFun,'", "'.join(theRest.split()) )
        elif pre == self.ESC_QUOTE2:
            # Auto-quote whole string
            newcmd = '%s("%s")' % (iFun,theRest)
        elif pre == self.ESC_PAREN:
            newcmd = '%s(%s)' % (iFun,",".join(theRest.split()))
        else:
            # Auto-paren.
            # We only apply it to argument-less calls if the autocall
            # parameter is set to 2.  We only need to check that autocall is &lt;
            # 2, since this function isn't called unless it's at least 1.
            if not theRest and (self.rc.autocall &lt; 2):
                newcmd = '%s %s' % (iFun,theRest)
                auto_rewrite = False
            else:
                if theRest.startswith('['):
                    if hasattr(obj,'__getitem__'):
                        # Don't autocall in this case: item access for an object
                        # which is BOTH callable and implements __getitem__.
                        newcmd = '%s %s' % (iFun,theRest)
                        auto_rewrite = False
                    else:
                        # if the object doesn't support [] access, go ahead and
                        # autocall
                        newcmd = '%s(%s)' % (iFun.rstrip(),theRest)
                elif theRest.endswith(';'):
                    newcmd = '%s(%s);' % (iFun.rstrip(),theRest[:-1])
                else:
                    newcmd = '%s(%s)' % (iFun.rstrip(), theRest)

        if auto_rewrite:
            print &gt;&gt;Term.cout, self.outputcache.prompt1.auto_rewrite() + newcmd
        # log what is now valid Python, not the actual user input (without the
        # final newline)
        self.log(line,newcmd,continue_prompt)
        return newcmd

    def handle_help(self, line, continue_prompt=None,
                    pre=None,iFun=None,theRest=None):
        """Try to get some help for the object.

        obj? or ?obj   -&gt; basic information.
        obj?? or ??obj -&gt; more details.
        """

        # We need to make sure that we don't process lines which would be
        # otherwise valid python, such as "x=1 # what?"
        try:
            codeop.compile_command(line)
        except SyntaxError:
            # We should only handle as help stuff which is NOT valid syntax
            if line[0]==self.ESC_HELP:
                line = line[1:]
            elif line[-1]==self.ESC_HELP:
                line = line[:-1]
            self.log(line,'#?'+line,continue_prompt)
            if line:
                self.magic_pinfo(line)
            else:
                page(self.usage,screen_lines=self.rc.screen_length)
            return '' # Empty string is needed here!
        except:
            # Pass any other exceptions through to the normal handler
            return self.handle_normal(line,continue_prompt)
        else:
            # If the code compiles ok, we should handle it normally
            return self.handle_normal(line,continue_prompt)

    def getapi(self):
        """ Get an IPApi object for this shell instance
        
        Getting an IPApi object is always preferable to accessing the shell
        directly, but this holds true especially for extensions.
        
        It should always be possible to implement an extension with IPApi
        alone. If not, contact maintainer to request an addition.
        
        """
        return self.api
    
    def handle_emacs(self,line,continue_prompt=None,
                    pre=None,iFun=None,theRest=None):
        """Handle input lines marked by python-mode."""

        # Currently, nothing is done.  Later more functionality can be added
        # here if needed.

        # The input cache shouldn't be updated

        return line

    def mktempfile(self,data=None):
        """Make a new tempfile and return its filename.

        This makes a call to tempfile.mktemp, but it registers the created
        filename internally so ipython cleans it up at exit time.

        Optional inputs:

          - data(None): if data is given, it gets written out to the temp file
          immediately, and the file is closed again."""

        filename = tempfile.mktemp('.py','ipython_edit_')
        self.tempfiles.append(filename)
        
        if data:
            tmp_file = open(filename,'w')
            tmp_file.write(data)
            tmp_file.close()
        return filename

    def write(self,data):
        """Write a string to the default output"""
        Term.cout.write(data)

    def write_err(self,data):
        """Write a string to the default error output"""
        Term.cerr.write(data)

    def exit(self):
        """Handle interactive exit.

        This method sets the exit_now attribute."""

        if self.rc.confirm_exit:
            if self.ask_yes_no('Do you really want to exit ([y]/n)?','y'):
                self.exit_now = True
        else:
            self.exit_now = True

    def safe_execfile(self,fname,*where,**kw):
        """A safe version of the builtin execfile().

        This version will never throw an exception, and knows how to handle
        ipython logs as well."""

        def syspath_cleanup():
            """Internal cleanup routine for sys.path."""
            if add_dname:
                try:
                    sys.path.remove(dname)
                except ValueError:
                    # For some reason the user has already removed it, ignore.
                    pass
        
        fname = os.path.expanduser(fname)

        # Find things also in current directory.  This is needed to mimic the
        # behavior of running a script from the system command line, where
        # Python inserts the script's directory into sys.path
        dname = os.path.dirname(os.path.abspath(fname))
        add_dname = False
        if dname not in sys.path:
            sys.path.insert(0,dname)
            add_dname = True

        try:
            xfile = open(fname)
        except:
            print &gt;&gt; Term.cerr, \
                  'Could not open file &lt;%s&gt; for safe execution.' % fname
            syspath_cleanup()
            return None

        kw.setdefault('islog',0)
        kw.setdefault('quiet',1)
        kw.setdefault('exit_ignore',0)
        first = xfile.readline()
        loghead = str(self.loghead_tpl).split('\n',1)[0].strip()
        xfile.close()
        # line by line execution
        if first.startswith(loghead) or kw['islog']:
            print 'Loading log file &lt;%s&gt; one line at a time...' % fname
            if kw['quiet']:
                stdout_save = sys.stdout
                sys.stdout = StringIO.StringIO()
            try:
                globs,locs = where[0:2]
            except:
                try:
                    globs = locs = where[0]
                except:
                    globs = locs = globals()
            badblocks = []

            # we also need to identify indented blocks of code when replaying
            # logs and put them together before passing them to an exec
            # statement. This takes a bit of regexp and look-ahead work in the
            # file. It's easiest if we swallow the whole thing in memory
            # first, and manually walk through the lines list moving the
            # counter ourselves.
            indent_re = re.compile('\s+\S')
            xfile = open(fname)
            filelines = xfile.readlines()
            xfile.close()
            nlines = len(filelines)
            lnum = 0
            while lnum &lt; nlines:
                line = filelines[lnum]
                lnum += 1
                # don't re-insert logger status info into cache
                if line.startswith('#log#'):
                    continue
                else:
                    # build a block of code (maybe a single line) for execution
                    block = line
                    try:
                        next = filelines[lnum] # lnum has already incremented
                    except:
                        next = None
                    while next and indent_re.match(next):
                        block += next
                        lnum += 1
                        try:
                            next = filelines[lnum]
                        except:
                            next = None
                    # now execute the block of one or more lines
                    try:
                        exec block in globs,locs
                    except SystemExit:
                        pass
                    except:
                        badblocks.append(block.rstrip())
            if kw['quiet']:  # restore stdout
                sys.stdout.close()
                sys.stdout = stdout_save
            print 'Finished replaying log file &lt;%s&gt;' % fname
            if badblocks:
                print &gt;&gt; sys.stderr, ('\nThe following lines/blocks in file '
                                      '&lt;%s&gt; reported errors:' % fname)
                    
                for badline in badblocks:
                    print &gt;&gt; sys.stderr, badline
        else:  # regular file execution
            try:
                execfile(fname,*where)
            except SyntaxError:
                self.showsyntaxerror()
                warn('Failure executing file: &lt;%s&gt;' % fname)
            except SystemExit,status:
                if not kw['exit_ignore']:
                    self.showtraceback()
                    warn('Failure executing file: &lt;%s&gt;' % fname)
            except:
                self.showtraceback()
                warn('Failure executing file: &lt;%s&gt;' % fname)

        syspath_cleanup()

#************************* end of file &lt;iplib.py&gt; *****************************
</t>
<t tx="ekr.20071129105210.89">@language python
@tabwidth -4
@others
#************************ end of file &lt;ipmaker.py&gt; **************************
</t>
<t tx="ekr.20071129105210.90">@language python
@tabwidth -4
@others
# end class Struct

</t>
<t tx="ekr.20071129105210.91">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    main()
@ignore

@ Line 176 is:
    
     print '&lt; &lt; Starting interactive mode &gt; &gt;',</t>
<t tx="ekr.20071129105210.92">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.93">@language python
@tabwidth -4
@others
@ignore

@

error: @auto did not import the file perfectly
first mismatched line: 149
u"    Logging hasn't been started yet (use logstart for that).\n"
inserting @ignore</t>
<t tx="ekr.20071129105210.95">@language python
@tabwidth -4
@others
# end Magic
@ignore

@

error: @auto did not import @auto Magic.py perfectly
first mismatched line: 101
u'    The profile module could not be found.  If you are a Debian user,\n'
inserting @ignore
</t>
<t tx="ekr.20071129105210.96">@language python
@tabwidth -4
@others
#**************************** end file &lt;numutils.py&gt; ************************
</t>
<t tx="ekr.20071129105210.97">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.98">@language python
@tabwidth -4
@others
if __name__=="__main__":
    # _test_all() # XXX BROKEN.
    pass

#************************ end of file &lt;OutputTrap.py&gt; ************************
</t>
<t tx="ekr.20071129105210.99">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.100">@language python
@tabwidth -4
@others
set_term_title = _dummy

</t>
<t tx="ekr.20071129105210.101">@language python
@tabwidth -4
@others
if os.environ.get('TERM','') == 'xterm':
    set_term_title = _set_term_title_xterm
else:
    set_term_title = _dummy_op

    
</t>
<t tx="ekr.20071129105210.102">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.103">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.104">@language python
@tabwidth -4
@others
if __name__ == "__main__":
    main()
</t>
<t tx="ekr.20071129105210.105">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.106">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.107">@language python
@tabwidth -4
@others
# Some aliases for backwards compatibility
IPythonShell = IPShell
IPythonShellEmbed = IPShellEmbed
#************************ End of file &lt;Shell.py&gt; ***************************
@ignore

@
error: @auto did not import @auto Shell.py perfectly
first mismatched line: 454
u'    Welcome to pylab, a matplotlib-based Python environment.\n'
inserting @ignore
</t>
<t tx="ekr.20071129105210.108">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    test()    </t>
<t tx="ekr.20071129105210.109">@language python
@tabwidth -4
@others
#----------------------------------------------------------------------------
# module testing (minimal)
if __name__ == "__main__":
    def spam(c, (d, e)):
        x = c + d
        y = c * d
        foo(x, y)

    def foo(a, b, bar=1):
        eggs(a, b + bar)

    def eggs(f, g, z=globals()):
        h = f + g
        i = f - g
        return h / i

    print ''
    print '*** Before ***'
    try:
        print spam(1, (2, 3))
    except:
        traceback.print_exc()
    print ''
    
    handler = ColorTB()
    print '*** ColorTB ***'
    try:
        print spam(1, (2, 3))
    except:
        apply(handler, sys.exc_info() )
    print ''
    
    handler = VerboseTB()
    print '*** VerboseTB ***'
    try:
        print spam(1, (2, 3))
    except:
        apply(handler, sys.exc_info() )
    print ''
    
</t>
<t tx="ekr.20071129105210.110">@language python
@tabwidth -4
@others
import sys
if __name__ == "__main__":
    upgrade_dir(path(sys.argv[1]), path(sys.argv[2]))
</t>
<t tx="ekr.20071129105210.111">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.112">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.113">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.114">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.115">@language python
@tabwidth -4
@others
stderr = stderr()


if curses is not None:
    # This is probably just range(8)
    COLOR2CURSES = [
        COLOR_BLACK,
        COLOR_RED,
        COLOR_GREEN,
        COLOR_YELLOW,
        COLOR_BLUE,
        COLOR_MAGENTA,
        COLOR_CYAN,
        COLOR_WHITE,
    ]

    A2CURSES = {
        A_BLINK: curses.A_BLINK,
        A_BOLD: curses.A_BOLD,
        A_DIM: curses.A_DIM,
        A_REVERSE: curses.A_REVERSE,
        A_STANDOUT: curses.A_STANDOUT,
        A_UNDERLINE: curses.A_UNDERLINE,
    }


# default style
style_default = Style.fromstr("white:black")

# Styles for datatypes
style_type_none = Style.fromstr("magenta:black")
style_type_bool = Style.fromstr("magenta:black")
style_type_number = Style.fromstr("yellow:black")
style_type_datetime = Style.fromstr("magenta:black")
style_type_type = Style.fromstr("cyan:black")

# Style for URLs and file/directory names
style_url = Style.fromstr("green:black")
style_dir = Style.fromstr("cyan:black")
style_file = Style.fromstr("green:black")

# Style for ellipsis (when an output has been shortened
style_ellisis = Style.fromstr("red:black")

# Style for displaying exceptions
style_error = Style.fromstr("red:black")

# Style for displaying non-existing attributes
style_nodata = Style.fromstr("red:black")
</t>
<t tx="ekr.20071129105210.116">@language python
@tabwidth -4
@others
ip.expose_magic("clear",clear_f)
    



</t>
<t tx="ekr.20071129105210.117">@language python
@tabwidth -4
@others
ip.expose_magic("rehashdir",rehashdir_f)
</t>
<t tx="ekr.20071129105210.118">@language python
@tabwidth -4
@others
ip.set_hook('input_prefilter', regex_prefilter_f)     
</t>
<t tx="ekr.20071129105210.119">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.120">@language python
@tabwidth -4
@others
# Configure a few things.  Much of this is fairly hackish, since IPython
# doesn't really expose a clean API for it.  Be careful if you start making
# many modifications here.


#  Set the 'cd' command to quiet mode, a more shell-like behavior
__IPYTHON__.default_option('cd','-q')

# This is redundant, ipy_user_conf.py will determine this
# Load all of $PATH as aliases
if os.name == 'posix':
#    # %rehash is very fast, but it doesn't check for executability, it simply
#    # dumps everything in $PATH as an alias. Use rehashx if you want more
#    # checks.
    __IPYTHON__.magic_rehash()
else:
#    # Windows users: the list of extensions considered executable is read from
#    # the environment variable 'pathext'.  If this is undefined, IPython
#    # defaults to EXE, COM and BAT.
#    # %rehashx is the one which does extension analysis, at the cost of
#    # being much slower than %rehash.
    __IPYTHON__.magic_rehashx()

# Remove %sc,%sx if present as aliases
__IPYTHON__.magic_unalias('sc')
__IPYTHON__.magic_unalias('sx')

# We need different criteria for line-splitting, so that aliases such as
# 'gnome-terminal' are interpreted as a single alias instead of variable
# 'gnome' minus variable 'terminal'.
import re
__IPYTHON__.line_split = re.compile(r'^([\s*,;/])'
                                    r'([\?\w\.\-\+]+\w*\s*)'
                                    r'(\(?.*$)')

# Namespace cleanup
del re
</t>
<t tx="ekr.20071129105210.121">@language python
@tabwidth -4
@others
# Rebind this to be the new IPython prefilter:
from IPython.iplib import InteractiveShell
InteractiveShell.prefilter = prefilter_paste

# Clean up the namespace.
del InteractiveShell,prefilter_paste

# Just a heads up at the console
print '*** Pasting of code with "&gt;&gt;&gt;" or "..." has been enabled.'
</t>
<t tx="ekr.20071129105210.122">@language python
@tabwidth -4
@others
try:
    from ibrowse import ibrowse
except ImportError:
    # No curses (probably Windows) =&gt; use ``idump`` as the default display.
    defaultdisplay = idump
else:
    defaultdisplay = ibrowse
    __all__.append("ibrowse")


# If we're running under IPython, install an IPython displayhook that
# returns the object from Display.display(), else install a displayhook
# directly as sys.displayhook
api = None
if ipapi is not None:
    try:
        api = ipapi.get()
    except AttributeError:
        pass

if api is not None:
    def displayhook(self, obj):
        if isinstance(obj, type) and issubclass(obj, Table):
            obj = obj()
        if isinstance(obj, Table):
            obj = obj | defaultdisplay
        if isinstance(obj, Display):
            return obj.display()
        else:
            raise ipapi.TryNext
    api.set_hook("result_display", displayhook)
else:
    def installdisplayhook():
        _originalhook = sys.displayhook
        def displayhook(obj):
            if isinstance(obj, type) and issubclass(obj, Table):
                obj = obj()
            if isinstance(obj, Table):
                obj = obj | defaultdisplay
            if isinstance(obj, Display):
                return obj.display()
            else:
                _originalhook(obj)
        sys.displayhook = displayhook
    installdisplayhook()
</t>
<t tx="ekr.20071129105210.123">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.124">@language python
@tabwidth -4
@others
ip.expose_magic("pydb",call_pydb)    

    
    
    
</t>
<t tx="ekr.20071129105210.125">@language python
@tabwidth -4
@others
init()
    </t>
<t tx="ekr.20071129105210.126">@language python
@tabwidth -4
@others
ip.set_hook('complete_command', cd_completer, str_key = '%cd')
@ignore

@

error: @auto did not import @auto Extensions\ipy_stock_completers.py perfectly
first mismatched line: 9
u'update  upgrade\n'
inserting @ignore

[ipython]|2&gt; apt-get u&lt;&lt;&lt; press tab here &gt;&gt;&gt;
</t>
<t tx="ekr.20071129105210.127">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.128">@language python
@tabwidth -4
@others
install()</t>
<t tx="ekr.20071129105210.129">@language python
@tabwidth -4
@others
ip.set_hook('complete_command', line_edit_complete_f , str_key = '%led')
        
ip.expose_magic('led', line_edit_f)</t>
<t tx="ekr.20071129105210.130">@language python
@tabwidth -4
@others
# setup default format
__IPYTHON__.runtime_rc.numarray_print_format = 'long'

# Bind our new functions to the interpreter
__IPYTHON__.__class__.magic_format = magic_format
__IPYTHON__.hooks.display = num_display
</t>
<t tx="ekr.20071129105210.131">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.132">@language python
@tabwidth -4
@others
# Rebind this to be the new IPython prefilter:
from IPython.iplib import InteractiveShell
InteractiveShell.prefilter = prefilter_PQ

# Clean up the namespace.
del InteractiveShell,prefilter_PQ

# Just a heads up at the console
print '*** Simplified input for physical quantities enabled.'
</t>
<t tx="ekr.20071129105210.133">@language python
@tabwidth -4
@others
# implement the methods defined in PhysicalQuantity as PhysicalQuantityFunctions
sin = PhysicalQuantityFunction('sin')
cos = PhysicalQuantityFunction('cos')
tan = PhysicalQuantityFunction('tan')
sqrt = PhysicalQuantityFunction('sqrt')
</t>
<t tx="ekr.20071129105210.134">@language python
@tabwidth -4
@others
if __name__== "__main__":
    main()
    
    </t>
<t tx="ekr.20071129105210.135">@language python
@tabwidth -4
@others
ip.expose_magic('store',magic_store)
</t>
<t tx="ekr.20071129105210.136">@language python
@tabwidth -4
@others
ip.expose_magic( "clip", clip_f )
</t>
<t tx="ekr.20071129105210.137">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129105210.138">@language python
@tabwidth -4
@others
main()
</t>
<t tx="ekr.20071129105210.139">@language python
@tabwidth -4
@others
main()
</t>
<t tx="ekr.20071129105323">@encoding utf-8</t>
<t tx="ekr.20071129105657.66"># -*- coding: utf-8 -*-
"""sys.excepthook for IPython itself, leaves a detailed report on disk.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__   = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__  = Release.license
__version__  = Release.version

#****************************************************************************
# Required modules

# From the standard library
import os
import sys
from pprint import pprint,pformat

# Homebrewed
from IPython.Itpl import Itpl,itpl,printpl
from IPython.ColorANSI import ColorScheme,ColorSchemeTable  # too long names
from IPython import ultraTB
from IPython.genutils import *

</t>
<t tx="ekr.20071129105657.67">#****************************************************************************
class CrashHandler:
    """Customizable crash handlers for IPython-based systems.

    Instances of this class provide a __call__ method which can be used as a
    sys.excepthook, i.e., the __call__ signature is:

        def __call__(self,etype, evalue, etb)

    """
    @others
</t>
<t tx="ekr.20071129105657.68">
def __init__(self,IP,app_name,contact_name,contact_email,
             bug_tracker,crash_report_fname,
             show_crash_traceback=True):
    """New crash handler.

    Inputs:

    - IP: a running IPython instance, which will be queried at crash time
    for internal information.

    - app_name: a string containing the name of your application.

    - contact_name: a string with the name of the person to contact.

    - contact_email: a string with the email address of the contact.

    - bug_tracker: a string with the URL for your project's bug tracker.

    - crash_report_fname: a string with the filename for the crash report
    to be saved in.  These reports are left in the ipython user directory
    as determined by the running IPython instance.

    Optional inputs:

    - show_crash_traceback(True): if false, don't print the crash
    traceback on stderr, only generate the on-disk report


    Non-argument instance attributes:

    These instances contain some non-argument attributes which allow for 
    further customization of the crash handler's behavior.  Please see the
    source for further details.
    """

    # apply args into instance
    self.IP = IP  # IPython instance
    self.app_name = app_name
    self.contact_name = contact_name
    self.contact_email = contact_email
    self.bug_tracker = bug_tracker
    self.crash_report_fname = crash_report_fname
    self.show_crash_traceback = show_crash_traceback

    # Hardcoded defaults, which can be overridden either by subclasses or
    # at runtime for the instance.

    # Template for the user message.  Subclasses which completely override
    # this, or user apps, can modify it to suit their tastes.  It gets
    # expanded using itpl, so calls of the kind $self.foo are valid.
    self.user_message_template = """
Oops, $self.app_name crashed. We do our best to make it stable, but...

A crash report was automatically generated with the following information:
- A verbatim copy of the crash traceback.
- A copy of your input history during this session.
- Data on your current $self.app_name configuration.

It was left in the file named:
\t'$self.crash_report_fname'
If you can email this file to the developers, the information in it will help
them in understanding and correcting the problem.

You can mail it to: $self.contact_name at $self.contact_email
with the subject '$self.app_name Crash Report'.

If you want to do it now, the following command will work (under Unix):
mail -s '$self.app_name Crash Report' $self.contact_email &lt; $self.crash_report_fname

To ensure accurate tracking of this issue, please file a report about it at:
$self.bug_tracker
"""

</t>
<t tx="ekr.20071129105657.69">def __call__(self,etype, evalue, etb):
    """Handle an exception, call for compatible with sys.excepthook"""

    # Report tracebacks shouldn't use color in general (safer for users)
    color_scheme = 'NoColor'

    # Use this ONLY for developer debugging (keep commented out for release)
    #color_scheme = 'Linux'   # dbg

    try:
        rptdir = self.IP.rc.ipythondir
    except:
        rptdir = os.getcwd()
    if not os.path.isdir(rptdir):
        rptdir = os.getcwd()
    report_name = os.path.join(rptdir,self.crash_report_fname)
    # write the report filename into the instance dict so it can get
    # properly expanded out in the user message template
    self.crash_report_fname = report_name
    TBhandler = ultraTB.VerboseTB(color_scheme=color_scheme,
                                       long_header=1)
    traceback = TBhandler.text(etype,evalue,etb,context=31)

    # print traceback to screen
    if self.show_crash_traceback:
        print &gt;&gt; sys.stderr, traceback

    # and generate a complete report on disk
    try:
        report = open(report_name,'w')
    except:
        print &gt;&gt; sys.stderr, 'Could not create crash report on disk.'
        return

    # Inform user on stderr of what happened
    msg = itpl('\n'+'*'*70+'\n'+self.user_message_template)
    print &gt;&gt; sys.stderr, msg

    # Construct report on disk
    report.write(self.make_report(traceback))
    report.close()

</t>
<t tx="ekr.20071129105657.70">def make_report(self,traceback):
    """Return a string containing a crash report."""

    sec_sep = '\n\n'+'*'*75+'\n\n'

    report = []
    rpt_add = report.append

    rpt_add('*'*75+'\n\n'+'IPython post-mortem report\n\n')
    rpt_add('IPython version: %s \n\n' % Release.version)
    rpt_add('SVN revision   : %s \n\n' % Release.revision)
    rpt_add('Platform info  : os.name -&gt; %s, sys.platform -&gt; %s' %
                 (os.name,sys.platform) )
    rpt_add(sec_sep+'Current user configuration structure:\n\n')
    rpt_add(pformat(self.IP.rc.dict()))
    rpt_add(sec_sep+'Crash traceback:\n\n' + traceback)
    try:
        rpt_add(sec_sep+"History of session input:")
        for line in self.IP.user_ns['_ih']:
            rpt_add(line)
        rpt_add('\n*** Last line of input (may not be in above history):\n')
        rpt_add(self.IP._last_input_line+'\n')
    except:
        pass

    return ''.join(report)

</t>
<t tx="ekr.20071129105657.71">class IPythonCrashHandler(CrashHandler):
    """sys.excepthook for IPython itself, leaves a detailed report on disk."""
    @others
</t>
<t tx="ekr.20071129105657.72">
def __init__(self,IP):

    # Set here which of the IPython authors should be listed as contact
    AUTHOR_CONTACT = 'Ville'

    # Set argument defaults
    app_name = 'IPython'
    bug_tracker = 'http://projects.scipy.org/ipython/ipython/report'
    contact_name,contact_email = Release.authors[AUTHOR_CONTACT][:2]
    crash_report_fname = 'IPython_crash_report.txt'
    # Call parent constructor
    CrashHandler.__init__(self,IP,app_name,contact_name,contact_email,
                          bug_tracker,crash_report_fname)

</t>
<t tx="ekr.20071129105657.73">def make_report(self,traceback):
    """Return a string containing a crash report."""

    sec_sep = '\n\n'+'*'*75+'\n\n'

    report = []
    rpt_add = report.append

    rpt_add('*'*75+'\n\n'+'IPython post-mortem report\n\n')
    rpt_add('IPython version: %s \n\n' % Release.version)
    rpt_add('SVN revision   : %s \n\n' % Release.revision)
    rpt_add('Platform info  : os.name -&gt; %s, sys.platform -&gt; %s' %
                 (os.name,sys.platform) )
    rpt_add(sec_sep+'Current user configuration structure:\n\n')
    rpt_add(pformat(self.IP.rc.dict()))
    rpt_add(sec_sep+'Crash traceback:\n\n' + traceback)
    try:
        rpt_add(sec_sep+"History of session input:")
        for line in self.IP.user_ns['_ih']:
            rpt_add(line)
        rpt_add('\n*** Last line of input (may not be in above history):\n')
        rpt_add(self.IP._last_input_line+'\n')
    except:
        pass

    return ''.join(report)
</t>
<t tx="ekr.20071129105657.366">#!/usr/bin/env python
"""Module for interactively running scripts.

This module implements classes for interactively running scripts written for
any system with a prompt which can be matched by a regexp suitable for
pexpect.  It can be used to run as if they had been typed up interactively, an
arbitrary series of commands for the target system.

The module includes classes ready for IPython (with the default prompts),
plain Python and SAGE, but making a new one is trivial.  To see how to use it,
simply run the module as a script:

./irunner.py --help


This is an extension of Ken Schutte &lt;kschutte-AT-csail.mit.edu&gt;'s script
contributed on the ipython-user list:

http://scipy.net/pipermail/ipython-user/2006-May/001705.html


NOTES:

 - This module requires pexpect, available in most linux distros, or which can
 be downloaded from

    http://pexpect.sourceforge.net

 - Because pexpect only works under Unix or Windows-Cygwin, this has the same
 limitations.  This means that it will NOT work under native windows Python.
"""

# Stdlib imports
import optparse
import os
import sys

# Third-party modules.
import pexpect

# Global usage strings, to avoid indentation issues when typing it below.
USAGE = """
Interactive script runner, type: %s

runner [opts] script_name
"""

</t>
<t tx="ekr.20071129105657.367"># The generic runner class
class InteractiveRunner(object):
    """Class to run a sequence of commands through an interactive program."""
    @others
</t>
<t tx="ekr.20071129105657.368">
def __init__(self,program,prompts,args=None):
    """Construct a runner.

    Inputs:

      - program: command to execute the given program.

      - prompts: a list of patterns to match as valid prompts, in the
      format used by pexpect.  This basically means that it can be either
      a string (to be compiled as a regular expression) or a list of such
      (it must be a true list, as pexpect does type checks).

      If more than one prompt is given, the first is treated as the main
      program prompt and the others as 'continuation' prompts, like
      python's.  This means that blank lines in the input source are
      ommitted when the first prompt is matched, but are NOT ommitted when
      the continuation one matches, since this is how python signals the
      end of multiline input interactively.

    Optional inputs:

      - args(None): optional list of strings to pass as arguments to the
      child program.

    Public members not parameterized in the constructor:

      - delaybeforesend(0): Newer versions of pexpect have a delay before
      sending each new input.  For our purposes here, it's typically best
      to just set this to zero, but if you encounter reliability problems
      or want an interactive run to pause briefly at each prompt, just
      increase this value (it is measured in seconds).  Note that this
      variable is not honored at all by older versions of pexpect.
    """
    
    self.program = program
    self.prompts = prompts
    if args is None: args = []
    self.args = args
    # Other public members which we don't make as parameters, but which
    # users may occasionally want to tweak
    self.delaybeforesend = 0
    
</t>
<t tx="ekr.20071129105657.369">def run_file(self,fname,interact=False):
    """Run the given file interactively.

    Inputs:

      -fname: name of the file to execute.

    See the run_source docstring for the meaning of the optional
    arguments."""

    fobj = open(fname,'r')
    try:
        self.run_source(fobj,interact)
    finally:
        fobj.close()

</t>
<t tx="ekr.20071129105657.370">def run_source(self,source,interact=False):
    """Run the given source code interactively.

    Inputs:

      - source: a string of code to be executed, or an open file object we
      can iterate over.

    Optional inputs:

      - interact(False): if true, start to interact with the running
      program at the end of the script.  Otherwise, just exit.
      """

    # if the source is a string, chop it up in lines so we can iterate
    # over it just as if it were an open file.
    if not isinstance(source,file):
        source = source.splitlines(True)

    # grab the true write method of stdout, in case anything later
    # reassigns sys.stdout, so that we really are writing to the true
    # stdout and not to something else.  We also normalize all strings we
    # write to use the native OS line separators.
    linesep  = os.linesep
    stdwrite = sys.stdout.write
    write    = lambda s: stdwrite(s.replace('\r\n',linesep))

    c = pexpect.spawn(self.program,self.args,timeout=None)
    c.delaybeforesend = self.delaybeforesend

    # pexpect hard-codes the terminal size as (24,80) (rows,columns).
    # This causes problems because any line longer than 80 characters gets
    # completely overwrapped on the printed outptut (even though
    # internally the code runs fine).  We reset this to 99 rows X 200
    # columns (arbitrarily chosen), which should avoid problems in all
    # reasonable cases.
    c.setwinsize(99,200)
        
    prompts = c.compile_pattern_list(self.prompts)

    prompt_idx = c.expect_list(prompts)
    # Flag whether the script ends normally or not, to know whether we can
    # do anything further with the underlying process.
    end_normal = True
    for cmd in source:
        # skip blank lines for all matches to the 'main' prompt, while the
        # secondary prompts do not
        if prompt_idx==0 and \
               (cmd.isspace() or cmd.lstrip().startswith('#')):
            print cmd,
            continue

        write(c.after)
        c.send(cmd)
        try:
            prompt_idx = c.expect_list(prompts)
        except pexpect.EOF:
            # this will happen if the child dies unexpectedly
            write(c.before)
            end_normal = False
            break
        write(c.before)
    
    if end_normal:
        if interact:
            c.send('\n')
            print '&lt;&lt; Starting interactive mode &gt;&gt;',
            try:
                c.interact()
            except OSError:
                # This is what fires when the child stops.  Simply print a
                # newline so the system prompt is aligned.  The extra
                # space is there to make sure it gets printed, otherwise
                # OS buffering sometimes just suppresses it.
                write(' \n')
                sys.stdout.flush()
        else:
            c.close()
    else:
        if interact:
            e="Further interaction is not possible: child process is dead."
            print &gt;&gt; sys.stderr, e
            
</t>
<t tx="ekr.20071129105657.371">def main(self,argv=None):
    """Run as a command-line script."""

    parser = optparse.OptionParser(usage=USAGE % self.__class__.__name__)
    newopt = parser.add_option
    newopt('-i','--interact',action='store_true',default=False,
           help='Interact with the program after the script is run.')

    opts,args = parser.parse_args(argv)

    if len(args) != 1:
        print &gt;&gt; sys.stderr,"You must supply exactly one file to run."
        sys.exit(1)

    self.run_file(args[0],opts.interact)


</t>
<t tx="ekr.20071129105657.372"># Specific runners for particular programs
class IPythonRunner(InteractiveRunner):
    """Interactive IPython runner.

    This initalizes IPython in 'nocolor' mode for simplicity.  This lets us
    avoid having to write a regexp that matches ANSI sequences, though pexpect
    does support them.  If anyone contributes patches for ANSI color support,
    they will be welcome.

    It also sets the prompts manually, since the prompt regexps for
    pexpect need to be matched to the actual prompts, so user-customized
    prompts would break this.
    """
    @others
</t>
<t tx="ekr.20071129105657.373">
def __init__(self,program = 'ipython',args=None):
    """New runner, optionally passing the ipython command to use."""
    
    args0 = ['-colors','NoColor',
             '-pi1','In [\\#]: ',
             '-pi2','   .\\D.: ']
    if args is None: args = args0
    else: args = args0 + args
    prompts = [r'In \[\d+\]: ',r'   \.*: ']
    InteractiveRunner.__init__(self,program,prompts,args)


</t>
<t tx="ekr.20071129105657.374">class PythonRunner(InteractiveRunner):
    """Interactive Python runner."""
    @others
</t>
<t tx="ekr.20071129105657.375">
def __init__(self,program='python',args=None):
    """New runner, optionally passing the python command to use."""

    prompts = [r'&gt;&gt;&gt; ',r'\.\.\. ']
    InteractiveRunner.__init__(self,program,prompts,args)


</t>
<t tx="ekr.20071129105657.376">class SAGERunner(InteractiveRunner):
    """Interactive SAGE runner.
    
    WARNING: this runner only works if you manually configure your SAGE copy
    to use 'colors NoColor' in the ipythonrc config file, since currently the
    prompt matching regexp does not identify color sequences."""
    @others
</t>
<t tx="ekr.20071129105657.377">
def __init__(self,program='sage',args=None):
    """New runner, optionally passing the sage command to use."""

    prompts = ['sage: ',r'\s*\.\.\. ']
    InteractiveRunner.__init__(self,program,prompts,args)

</t>
<t tx="ekr.20071129105657.378"># Global usage string, to avoid indentation issues if typed in a function def.
MAIN_USAGE = """
%prog [options] file_to_run

This is an interface to the various interactive runners available in this
module.  If you want to pass specific options to one of the runners, you need
to first terminate the main options with a '--', and then provide the runner's
options.  For example:

irunner.py --python -- --help

will pass --help to the python runner.  Similarly,

irunner.py --ipython -- --interact script.ipy

will run the script.ipy file under the IPython runner, and then will start to
interact with IPython at the end of the script (instead of exiting).

The already implemented runners are listed below; adding one for a new program
is a trivial task, see the source for examples.

WARNING: the SAGE runner only works if you manually configure your SAGE copy
to use 'colors NoColor' in the ipythonrc config file, since currently the
prompt matching regexp does not identify color sequences.
"""

def main():
    """Run as a command-line script."""

    parser = optparse.OptionParser(usage=MAIN_USAGE)
    newopt = parser.add_option
    parser.set_defaults(mode='ipython')
    newopt('--ipython',action='store_const',dest='mode',const='ipython',
           help='IPython interactive runner (default).')
    newopt('--python',action='store_const',dest='mode',const='python',
           help='Python interactive runner.')
    newopt('--sage',action='store_const',dest='mode',const='sage',
           help='SAGE interactive runner.')

    opts,args = parser.parse_args()
    runners = dict(ipython=IPythonRunner,
                   python=PythonRunner,
                   sage=SAGERunner)

    try:
        ext = os.path.splitext(args[0])
    except IndexError:
        ext = ''
    modes = {'.ipy':'ipython',
             '.py':'python',
             '.sage':'sage'}
    mode = modes.get(ext,opts.mode)
    runners[mode]().main(args)

</t>
<t tx="ekr.20071129105657.404"># -*- coding: utf-8 -*-
"""
Logger class for IPython's logging facilities.

$Id$
"""

#*****************************************************************************
#       Copyright (C) 2001 Janko Hauser &lt;jhauser@zscout.de&gt; and
#       Copyright (C) 2001-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

#****************************************************************************
# Modules and globals

from IPython import Release
__author__  = '%s &lt;%s&gt;\n%s &lt;%s&gt;' % \
              ( Release.authors['Janko'] + Release.authors['Fernando'] )
__license__ = Release.license

# Python standard modules
import glob
import os
import time

</t>
<t tx="ekr.20071129105657.405">#****************************************************************************
# FIXME: This class isn't a mixin anymore, but it still needs attributes from
# ipython and does input cache management.  Finish cleanup later...

class Logger(object):
    """A Logfile class with different policies for file creation"""
    @others
</t>
<t tx="ekr.20071129105657.406">
def __init__(self,shell,logfname='Logger.log',loghead='',logmode='over'):

    self._i00,self._i,self._ii,self._iii = '','','',''

    # this is the full ipython instance, we need some attributes from it
    # which won't exist until later. What a mess, clean up later...
    self.shell = shell

    self.logfname = logfname
    self.loghead = loghead
    self.logmode = logmode
    self.logfile = None

    # Whether to log raw or processed input
    self.log_raw_input = False

    # whether to also log output
    self.log_output = False

    # whether to put timestamps before each log entry
    self.timestamp = False

    # activity control flags
    self.log_active = False

</t>
<t tx="ekr.20071129105657.407"># logmode is a validated property
def _set_mode(self,mode):
    if mode not in ['append','backup','global','over','rotate']:
        raise ValueError,'invalid log mode %s given' % mode
    self._logmode = mode

</t>
<t tx="ekr.20071129105657.408">def _get_mode(self):
    return self._logmode

</t>
<t tx="ekr.20071129105657.409">logmode = property(_get_mode,_set_mode)

def logstart(self,logfname=None,loghead=None,logmode=None,
             log_output=False,timestamp=False,log_raw_input=False):
    """Generate a new log-file with a default header.

    Raises RuntimeError if the log has already been started"""

    if self.logfile is not None:
        raise RuntimeError('Log file is already active: %s' %
                           self.logfname)
    
    self.log_active = True

    # The parameters can override constructor defaults
    if logfname is not None: self.logfname = logfname
    if loghead is not None: self.loghead = loghead
    if logmode is not None: self.logmode = logmode

    # Parameters not part of the constructor
    self.timestamp = timestamp
    self.log_output = log_output
    self.log_raw_input = log_raw_input
    
    # init depending on the log mode requested
    isfile = os.path.isfile
    logmode = self.logmode

    if logmode == 'append':
        self.logfile = open(self.logfname,'a')

    elif logmode == 'backup':
        if isfile(self.logfname):
            backup_logname = self.logfname+'~'
            # Manually remove any old backup, since os.rename may fail
            # under Windows.
            if isfile(backup_logname):
                os.remove(backup_logname)
            os.rename(self.logfname,backup_logname)
        self.logfile = open(self.logfname,'w')

    elif logmode == 'global':
        self.logfname = os.path.join(self.shell.home_dir,self.logfname)
        self.logfile = open(self.logfname, 'a')

    elif logmode == 'over':
        if isfile(self.logfname):
            os.remove(self.logfname) 
        self.logfile = open(self.logfname,'w')

    elif logmode == 'rotate':
        if isfile(self.logfname):
            if isfile(self.logfname+'.001~'): 
                old = glob.glob(self.logfname+'.*~')
                old.sort()
                old.reverse()
                for f in old:
                    root, ext = os.path.splitext(f)
                    num = int(ext[1:-1])+1
                    os.rename(f, root+'.'+`num`.zfill(3)+'~')
            os.rename(self.logfname, self.logfname+'.001~')
        self.logfile = open(self.logfname,'w')
        
    if logmode != 'append':
        self.logfile.write(self.loghead)

    self.logfile.flush()

</t>
<t tx="ekr.20071129105657.410">def switch_log(self,val):
    """Switch logging on/off. val should be ONLY a boolean."""

    if val not in [False,True,0,1]:
        raise ValueError, \
              'Call switch_log ONLY with a boolean argument, not with:',val
    
    label = {0:'OFF',1:'ON',False:'OFF',True:'ON'}

    if self.logfile is None:
        print """
Logging hasn't been started yet (use logstart for that).

%logon/%logoff are for temporarily starting and stopping logging for a logfile
which already exists. But you must first start the logging process with
%logstart (optionally giving a logfile name)."""
        
    else:
        if self.log_active == val:
            print 'Logging is already',label[val]
        else:
            print 'Switching logging',label[val]
            self.log_active = not self.log_active
            self.log_active_out = self.log_active

</t>
<t tx="ekr.20071129105657.411">def logstate(self):
    """Print a status message about the logger."""
    if self.logfile is None:
        print 'Logging has not been activated.'
    else:
        state = self.log_active and 'active' or 'temporarily suspended'
        print 'Filename       :',self.logfname
        print 'Mode           :',self.logmode
        print 'Output logging :',self.log_output
        print 'Raw input log  :',self.log_raw_input
        print 'Timestamping   :',self.timestamp
        print 'State          :',state

</t>
<t tx="ekr.20071129105657.412">def log(self,line_ori,line_mod,continuation=None):
    """Write the line to a log and create input cache variables _i*.

    Inputs:

    - line_ori: unmodified input line from the user.  This is not
    necessarily valid Python.

    - line_mod: possibly modified input, such as the transformations made
    by input prefilters or input handlers of various kinds.  This should
    always be valid Python.

    - continuation: if True, indicates this is part of multi-line input."""

    # update the auto _i tables
    #print '***logging line',line_mod # dbg
    #print '***cache_count', self.shell.outputcache.prompt_count # dbg
    try:
        input_hist = self.shell.user_ns['_ih']
    except:
        print 'userns:',self.shell.user_ns.keys()
        return
    
    if not continuation and line_mod:
        self._iii = self._ii
        self._ii = self._i
        self._i = self._i00
        # put back the final \n of every input line
        self._i00 = line_mod+'\n'
        #print 'Logging input:&lt;%s&gt;' % line_mod  # dbg
        input_hist.append(self._i00)
    #print '---[%s]' % (len(input_hist)-1,) # dbg

    # hackish access to top-level namespace to create _i1,_i2... dynamically
    to_main = {'_i':self._i,'_ii':self._ii,'_iii':self._iii}
    if self.shell.outputcache.do_full_cache:
        in_num = self.shell.outputcache.prompt_count
        # add blank lines if the input cache fell out of sync. This can
        # happen for embedded instances which get killed via C-D and then
        # get resumed.
        while in_num &gt;= len(input_hist):
            input_hist.append('\n')
        # but if the opposite is true (a macro can produce multiple inputs
        # with no output display called), then bring the output counter in
        # sync:
        last_num = len(input_hist)-1
        if in_num != last_num:
            in_num = self.shell.outputcache.prompt_count = last_num
        new_i = '_i%s' % in_num
        if continuation:
            self._i00 = '%s%s\n' % (self.shell.user_ns[new_i],line_mod)
            input_hist[in_num] = self._i00
        to_main[new_i] = self._i00
    self.shell.user_ns.update(to_main)

    # Write the log line, but decide which one according to the
    # log_raw_input flag, set when the log is started.
    if self.log_raw_input:
        self.log_write(line_ori)
    else:
        self.log_write(line_mod)

</t>
<t tx="ekr.20071129105657.413">def log_write(self,data,kind='input'):
    """Write data to the log file, if active"""

    #print 'data: %r' % data # dbg
    if self.log_active and data:
        write = self.logfile.write
        if kind=='input':
            if self.timestamp:
                write(time.strftime('# %a, %d %b %Y %H:%M:%S\n',
                                    time.localtime()))
            write('%s\n' % data)
        elif kind=='output' and self.log_output:
            odata = '\n'.join(['#[Out]# %s' % s
                               for s in data.split('\n')])
            write('%s\n' % odata)
        self.logfile.flush()

</t>
<t tx="ekr.20071129105657.414">def close_log(self):
    self.logfile.close()
    self.logfile = None
    self.logfname = ''
</t>
<t tx="ekr.20071129105657.420"># -*- coding: utf-8 -*-
"""Magic functions for InteractiveShell.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001 Janko Hauser &lt;jhauser@zscout.de&gt; and
#       Copyright (C) 2001-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

#****************************************************************************
# Modules and globals

from IPython import Release
__author__  = '%s &lt;%s&gt;\n%s &lt;%s&gt;' % \
              ( Release.authors['Janko'] + Release.authors['Fernando'] )
__license__ = Release.license

# Python standard modules
import __builtin__
import bdb
import inspect
import os
import pdb
import pydoc
import sys
import re
import tempfile
import time
import cPickle as pickle
import textwrap
from cStringIO import StringIO
from getopt import getopt,GetoptError
from pprint import pprint, pformat

# cProfile was added in Python2.5
try:
    import cProfile as profile
    import pstats
except ImportError:
    # profile isn't bundled by default in Debian for license reasons
    try:
        import profile,pstats
    except ImportError:
        profile = pstats = None

# Homebrewed
import IPython
from IPython import Debugger, OInspect, wildcard
from IPython.FakeModule import FakeModule
from IPython.Itpl import Itpl, itpl, printpl,itplns
from IPython.PyColorize import Parser
from IPython.ipstruct import Struct
from IPython.macro import Macro
from IPython.genutils import *
from IPython import platutils

</t>
<t tx="ekr.20071129105657.421">#***************************************************************************
# Utility functions
def on_off(tag):
    """Return an ON/OFF string for a 1/0 input. Simple utility function."""
    return ['OFF','ON'][tag]

</t>
<t tx="ekr.20071129105657.422">class Bunch: pass

</t>
<t tx="ekr.20071129105657.423">#***************************************************************************
# Main class implementing Magic functionality
class Magic:
    """Magic functions for InteractiveShell.

    Shell functions which can be reached as %function_name. All magic
    functions should accept a string, which they can parse for their own
    needs. This can make some functions easier to type, eg `%cd ../`
    vs. `%cd("../")`

    ALL definitions MUST begin with the prefix magic_. The user won't need it
    at the command line, but it is is needed in the definition. """

    # class globals
    auto_status = ['Automagic is OFF, % prefix IS needed for magic functions.',
                   'Automagic is ON, % prefix NOT needed for magic functions.']

    @others
</t>
<t tx="ekr.20071129105657.424">#......................................................................
# some utility functions

def __init__(self,shell):
    
    self.options_table = {}
    if profile is None:
        self.magic_prun = self.profile_missing_notice
    self.shell = shell

    # namespace for holding state we may need
    self._magic_state = Bunch()

</t>
<t tx="ekr.20071129105657.425">def profile_missing_notice(self, *args, **kwargs):
    error("""\
The profile module could not be found.  If you are a Debian user,
it has been removed from the standard Debian package because of its non-free
license. To use profiling, please install"python2.3-profiler" from non-free.""")

</t>
<t tx="ekr.20071129105657.426">def default_option(self,fn,optstr):
    """Make an entry in the options_table for fn, with value optstr"""

    if fn not in self.lsmagic():
        error("%s is not a magic function" % fn)
    self.options_table[fn] = optstr

</t>
<t tx="ekr.20071129105657.427">def lsmagic(self):
    """Return a list of currently available magic functions.

    Gives a list of the bare names after mangling (['ls','cd', ...], not
    ['magic_ls','magic_cd',...]"""

    # FIXME. This needs a cleanup, in the way the magics list is built.
    
    # magics in class definition
    class_magic = lambda fn: fn.startswith('magic_') and \
                  callable(Magic.__dict__[fn])
    # in instance namespace (run-time user additions)
    inst_magic =  lambda fn: fn.startswith('magic_') and \
                 callable(self.__dict__[fn])
    # and bound magics by user (so they can access self):
    inst_bound_magic =  lambda fn: fn.startswith('magic_') and \
                       callable(self.__class__.__dict__[fn])
    magics = filter(class_magic,Magic.__dict__.keys()) + \
             filter(inst_magic,self.__dict__.keys()) + \
             filter(inst_bound_magic,self.__class__.__dict__.keys())
    out = []
    for fn in magics:
        out.append(fn.replace('magic_','',1))
    out.sort()
    return out

</t>
<t tx="ekr.20071129105657.428">def extract_input_slices(self,slices,raw=False):
    """Return as a string a set of input history slices.

    Inputs:

      - slices: the set of slices is given as a list of strings (like
      ['1','4:8','9'], since this function is for use by magic functions
      which get their arguments as strings.

    Optional inputs:

      - raw(False): by default, the processed input is used.  If this is
      true, the raw input history is used instead.

    Note that slices can be called with two notations:

    N:M -&gt; standard python form, means including items N...(M-1).

    N-M -&gt; include items N..M (closed endpoint)."""

    if raw:
        hist = self.shell.input_hist_raw
    else:
        hist = self.shell.input_hist

    cmds = []
    for chunk in slices:
        if ':' in chunk:
            ini,fin = map(int,chunk.split(':'))
        elif '-' in chunk:
            ini,fin = map(int,chunk.split('-'))
            fin += 1
        else:
            ini = int(chunk)
            fin = ini+1
        cmds.append(hist[ini:fin])
    return cmds
    
</t>
<t tx="ekr.20071129105657.429">def _ofind(self, oname, namespaces=None):
    """Find an object in the available namespaces.

    self._ofind(oname) -&gt; dict with keys: found,obj,ospace,ismagic

    Has special code to detect magic functions.
    """
    
    oname = oname.strip()

    alias_ns = None
    if namespaces is None:
        # Namespaces to search in:
        # Put them in a list. The order is important so that we
        # find things in the same order that Python finds them.
        namespaces = [ ('Interactive', self.shell.user_ns),
                       ('IPython internal', self.shell.internal_ns),
                       ('Python builtin', __builtin__.__dict__),
                       ('Alias', self.shell.alias_table),
                       ]
        alias_ns = self.shell.alias_table

    # initialize results to 'null'
    found = 0; obj = None;  ospace = None;  ds = None;
    ismagic = 0; isalias = 0; parent = None

    # Look for the given name by splitting it in parts.  If the head is
    # found, then we look for all the remaining parts as members, and only
    # declare success if we can find them all.
    oname_parts = oname.split('.')
    oname_head, oname_rest = oname_parts[0],oname_parts[1:]
    for nsname,ns in namespaces:
        try:
            obj = ns[oname_head]
        except KeyError:
            continue
        else:
            for part in oname_rest:
                try:
                    parent = obj
                    obj = getattr(obj,part)
                except:
                    # Blanket except b/c some badly implemented objects
                    # allow __getattr__ to raise exceptions other than
                    # AttributeError, which then crashes IPython.
                    break
            else:
                # If we finish the for loop (no break), we got all members
                found = 1
                ospace = nsname
                if ns == alias_ns:
                    isalias = 1
                break  # namespace loop

    # Try to see if it's magic
    if not found:
        if oname.startswith(self.shell.ESC_MAGIC):
            oname = oname[1:]
        obj = getattr(self,'magic_'+oname,None)
        if obj is not None:
            found = 1
            ospace = 'IPython internal'
            ismagic = 1

    # Last try: special-case some literals like '', [], {}, etc:
    if not found and oname_head in ["''",'""','[]','{}','()']:
        obj = eval(oname_head)
        found = 1
        ospace = 'Interactive'
        
    return {'found':found, 'obj':obj, 'namespace':ospace,
            'ismagic':ismagic, 'isalias':isalias, 'parent':parent}

</t>
<t tx="ekr.20071129105657.430">def arg_err(self,func):
    """Print docstring if incorrect arguments were passed"""
    print 'Error in arguments:'
    print OInspect.getdoc(func)

</t>
<t tx="ekr.20071129105657.431">def format_latex(self,strng):
    """Format a string for latex inclusion."""

    # Characters that need to be escaped for latex:
    escape_re = re.compile(r'(%|_|\$|#|&amp;)',re.MULTILINE)
    # Magic command names as headers:
    cmd_name_re = re.compile(r'^(%s.*?):' % self.shell.ESC_MAGIC,
                             re.MULTILINE)
    # Magic commands 
    cmd_re = re.compile(r'(?P&lt;cmd&gt;%s.+?\b)(?!\}\}:)' % self.shell.ESC_MAGIC,
                        re.MULTILINE)
    # Paragraph continue
    par_re = re.compile(r'\\$',re.MULTILINE)

    # The "\n" symbol
    newline_re = re.compile(r'\\n')

    # Now build the string for output:
    #strng = cmd_name_re.sub(r'\n\\texttt{\\textsl{\\large \1}}:',strng)
    strng = cmd_name_re.sub(r'\n\\bigskip\n\\texttt{\\textbf{ \1}}:',
                            strng)
    strng = cmd_re.sub(r'\\texttt{\g&lt;cmd&gt;}',strng)
    strng = par_re.sub(r'\\\\',strng)
    strng = escape_re.sub(r'\\\1',strng)
    strng = newline_re.sub(r'\\textbackslash{}n',strng)
    return strng

</t>
<t tx="ekr.20071129105657.432">def format_screen(self,strng):
    """Format a string for screen printing.

    This removes some latex-type format codes."""
    # Paragraph continue
    par_re = re.compile(r'\\$',re.MULTILINE)
    strng = par_re.sub('',strng)
    return strng

</t>
<t tx="ekr.20071129105657.433">def parse_options(self,arg_str,opt_str,*long_opts,**kw):
    """Parse options passed to an argument string.

    The interface is similar to that of getopt(), but it returns back a
    Struct with the options as keys and the stripped argument string still
    as a string.

    arg_str is quoted as a true sys.argv vector by using shlex.split.
    This allows us to easily expand variables, glob files, quote
    arguments, etc.

    Options:
      -mode: default 'string'. If given as 'list', the argument string is
      returned as a list (split on whitespace) instead of a string.

      -list_all: put all option values in lists. Normally only options
      appearing more than once are put in a list.

      -posix (True): whether to split the input line in POSIX mode or not,
      as per the conventions outlined in the shlex module from the
      standard library."""

    # inject default options at the beginning of the input line
    caller = sys._getframe(1).f_code.co_name.replace('magic_','')
    arg_str = '%s %s' % (self.options_table.get(caller,''),arg_str)
    
    mode = kw.get('mode','string')
    if mode not in ['string','list']:
        raise ValueError,'incorrect mode given: %s' % mode
    # Get options
    list_all = kw.get('list_all',0)
    posix = kw.get('posix',True)

    # Check if we have more than one argument to warrant extra processing:
    odict = {}  # Dictionary with options
    args = arg_str.split()
    if len(args) &gt;= 1:
        # If the list of inputs only has 0 or 1 thing in it, there's no
        # need to look for options
        argv = arg_split(arg_str,posix)
        # Do regular option processing
        try:
            opts,args = getopt(argv,opt_str,*long_opts)
        except GetoptError,e:
            raise GetoptError('%s ( allowed: "%s" %s)' % (e.msg,opt_str, 
                                    " ".join(long_opts)))
        for o,a in opts:
            if o.startswith('--'):
                o = o[2:]
            else:
                o = o[1:]
            try:
                odict[o].append(a)
            except AttributeError:
                odict[o] = [odict[o],a]
            except KeyError:
                if list_all:
                    odict[o] = [a]
                else:
                    odict[o] = a

    # Prepare opts,args for return
    opts = Struct(odict)
    if mode == 'string':
        args = ' '.join(args)

    return opts,args

</t>
<t tx="ekr.20071129105657.434">#......................................................................
# And now the actual magic functions

# Functions for IPython shell work (vars,funcs, config, etc)
def magic_lsmagic(self, parameter_s = ''):
    """List currently available magic functions."""
    mesc = self.shell.ESC_MAGIC
    print 'Available magic functions:\n'+mesc+\
          ('  '+mesc).join(self.lsmagic())
    print '\n' + Magic.auto_status[self.shell.rc.automagic]
    return None
    
</t>
<t tx="ekr.20071129105657.435">def magic_magic(self, parameter_s = ''):
    """Print information about the magic function system."""

    mode = ''
    try:
        if parameter_s.split()[0] == '-latex':
            mode = 'latex'
        if parameter_s.split()[0] == '-brief':
            mode = 'brief'
    except:
        pass

    magic_docs = []
    for fname in self.lsmagic():
        mname = 'magic_' + fname
        for space in (Magic,self,self.__class__):
            try:
                fn = space.__dict__[mname]
            except KeyError:
                pass
            else:
                break
        if mode == 'brief':
            # only first line
            fndoc = fn.__doc__.split('\n',1)[0]
        else:
            fndoc = fn.__doc__
            
        magic_docs.append('%s%s:\n\t%s\n' %(self.shell.ESC_MAGIC,
                                            fname,fndoc))
    magic_docs = ''.join(magic_docs)

    if mode == 'latex':
        print self.format_latex(magic_docs)
        return
    else:
        magic_docs = self.format_screen(magic_docs)
    if mode == 'brief':
        return magic_docs
    
    outmsg = """
IPython's 'magic' functions
===========================

The magic function system provides a series of functions which allow you to
control the behavior of IPython itself, plus a lot of system-type
features. All these functions are prefixed with a % character, but parameters
are given without parentheses or quotes.

NOTE: If you have 'automagic' enabled (via the command line option or with the
%automagic function), you don't need to type in the % explicitly.  By default,
IPython ships with automagic on, so you should only rarely need the % escape.

Example: typing '%cd mydir' (without the quotes) changes you working directory
to 'mydir', if it exists.

You can define your own magic functions to extend the system. See the supplied
ipythonrc and example-magic.py files for details (in your ipython
configuration directory, typically $HOME/.ipython/).

You can also define your own aliased names for magic functions. In your
ipythonrc file, placing a line like:

execute __IPYTHON__.magic_pf = __IPYTHON__.magic_profile

will define %pf as a new name for %profile.

You can also call magics in code using the ipmagic() function, which IPython
automatically adds to the builtin namespace.  Type 'ipmagic?' for details.

For a list of the available magic functions, use %lsmagic. For a description
of any of them, type %magic_name?, e.g. '%cd?'.

Currently the magic system has the following functions:\n"""

    mesc = self.shell.ESC_MAGIC
    outmsg = ("%s\n%s\n\nSummary of magic functions (from %slsmagic):"
              "\n\n%s%s\n\n%s" % (outmsg,
                                 magic_docs,mesc,mesc,
                                 ('  '+mesc).join(self.lsmagic()),
                                 Magic.auto_status[self.shell.rc.automagic] ) )

    page(outmsg,screen_lines=self.shell.rc.screen_length)

</t>
<t tx="ekr.20071129105657.436">def magic_automagic(self, parameter_s = ''):
    """Make magic functions callable without having to type the initial %.
    
    Toggles on/off (when off, you must call it as %automagic, of
    course). Note that magic functions have lowest priority, so if there's
    a variable whose name collides with that of a magic fn, automagic
    won't work for that function (you get the variable instead). However,
    if you delete the variable (del var), the previously shadowed magic
    function becomes visible to automagic again."""

    rc = self.shell.rc
    rc.automagic = not rc.automagic
    print '\n' + Magic.auto_status[rc.automagic]

</t>
<t tx="ekr.20071129105657.437">def magic_autocall(self, parameter_s = ''):
    """Make functions callable without having to type parentheses.

    Usage:

       %autocall [mode]

    The mode can be one of: 0-&gt;Off, 1-&gt;Smart, 2-&gt;Full.  If not given, the
    value is toggled on and off (remembering the previous state)."""
    
    rc = self.shell.rc

    if parameter_s:
        arg = int(parameter_s)
    else:
        arg = 'toggle'

    if not arg in (0,1,2,'toggle'):
        error('Valid modes: (0-&gt;Off, 1-&gt;Smart, 2-&gt;Full')
        return

    if arg in (0,1,2):
        rc.autocall = arg
    else: # toggle
        if rc.autocall:
            self._magic_state.autocall_save = rc.autocall
            rc.autocall = 0
        else:
            try:
                rc.autocall = self._magic_state.autocall_save
            except AttributeError:
                rc.autocall = self._magic_state.autocall_save = 1
            
    print "Automatic calling is:",['OFF','Smart','Full'][rc.autocall]

</t>
<t tx="ekr.20071129105657.438">def magic_autoindent(self, parameter_s = ''):
    """Toggle autoindent on/off (if available)."""

    self.shell.set_autoindent()
    print "Automatic indentation is:",['OFF','ON'][self.shell.autoindent]

</t>
<t tx="ekr.20071129105657.439">def magic_system_verbose(self, parameter_s = ''):
    """Set verbose printing of system calls.

    If called without an argument, act as a toggle"""

    if parameter_s:
        val = bool(eval(parameter_s))
    else:
        val = None
        
    self.shell.rc_set_toggle('system_verbose',val)
    print "System verbose printing is:",\
          ['OFF','ON'][self.shell.rc.system_verbose]

</t>
<t tx="ekr.20071129105657.440">def magic_history(self, parameter_s = ''):
    """Print input history (_i&lt;n&gt; variables), with most recent last.
    
    %history       -&gt; print at most 40 inputs (some may be multi-line)\\
    %history n     -&gt; print at most n inputs\\
    %history n1 n2 -&gt; print inputs between n1 and n2 (n2 not included)\\
    
    Each input's number &lt;n&gt; is shown, and is accessible as the
    automatically generated variable _i&lt;n&gt;.  Multi-line statements are
    printed starting at a new line for easy copy/paste.
    

    Options:

      -n: do NOT print line numbers.  This is useful if you want to get a
      printout of many lines which can be directly pasted into a text
      editor.

      This feature is only available if numbered prompts are in use.

      -r: print the 'raw' history.  IPython filters your input and
      converts it all into valid Python source before executing it (things
      like magics or aliases are turned into function calls, for
      example).  With this option, you'll see the unfiltered history
      instead of the filtered version: '%cd /' will be seen as '%cd /'
      instead of '_ip.magic("%cd /")'.
    """

    shell = self.shell
    if not shell.outputcache.do_full_cache:
        print 'This feature is only available if numbered prompts are in use.'
        return
    opts,args = self.parse_options(parameter_s,'nr',mode='list')

    if opts.has_key('r'):
        input_hist = shell.input_hist_raw
    else:
        input_hist = shell.input_hist
    
    default_length = 40
    if len(args) == 0:
        final = len(input_hist)
        init = max(1,final-default_length)
    elif len(args) == 1:
        final = len(input_hist)
        init = max(1,final-int(args[0]))
    elif len(args) == 2:
        init,final = map(int,args)
    else:
        warn('%hist takes 0, 1 or 2 arguments separated by spaces.')
        print self.magic_hist.__doc__
        return
    width = len(str(final))
    line_sep = ['','\n']
    print_nums = not opts.has_key('n')
    for in_num in range(init,final):
        inline = input_hist[in_num]
        multiline = int(inline.count('\n') &gt; 1)
        if print_nums:
            print '%s:%s' % (str(in_num).ljust(width),line_sep[multiline]),
        print inline,

</t>
<t tx="ekr.20071129105657.441">def magic_hist(self, parameter_s=''):
    """Alternate name for %history."""
    return self.magic_history(parameter_s)

</t>
<t tx="ekr.20071129105657.442">def magic_p(self, parameter_s=''):
    """Just a short alias for Python's 'print'."""
    exec 'print ' + parameter_s in self.shell.user_ns

</t>
<t tx="ekr.20071129105657.443">def magic_r(self, parameter_s=''):
    """Repeat previous input.

    If given an argument, repeats the previous command which starts with
    the same string, otherwise it just repeats the previous input.

    Shell escaped commands (with ! as first character) are not recognized
    by this system, only pure python code and magic commands.
    """

    start = parameter_s.strip()
    esc_magic = self.shell.ESC_MAGIC
    # Identify magic commands even if automagic is on (which means
    # the in-memory version is different from that typed by the user).
    if self.shell.rc.automagic:
        start_magic = esc_magic+start
    else:
        start_magic = start
    # Look through the input history in reverse
    for n in range(len(self.shell.input_hist)-2,0,-1):
        input = self.shell.input_hist[n]
        # skip plain 'r' lines so we don't recurse to infinity
        if input != '_ip.magic("r")\n' and \
               (input.startswith(start) or input.startswith(start_magic)):
            #print 'match',`input`  # dbg
            print 'Executing:',input,
            self.shell.runlines(input)
            return
    print 'No previous input matching `%s` found.' % start

</t>
<t tx="ekr.20071129105657.444">def magic_page(self, parameter_s=''):
    """Pretty print the object and display it through a pager.
    
    %page [options] OBJECT

    If no object is given, use _ (last output).
    
    Options:

      -r: page str(object), don't pretty-print it."""

    # After a function contributed by Olivier Aubert, slightly modified.

    # Process options/args
    opts,args = self.parse_options(parameter_s,'r')
    raw = 'r' in opts

    oname = args and args or '_'
    info = self._ofind(oname)
    if info['found']:
        txt = (raw and str or pformat)( info['obj'] )
        page(txt)
    else:
        print 'Object `%s` not found' % oname

</t>
<t tx="ekr.20071129105657.445">def magic_profile(self, parameter_s=''):
    """Print your currently active IPyhton profile."""
    if self.shell.rc.profile:
        printpl('Current IPython profile: $self.shell.rc.profile.')
    else:
        print 'No profile active.'
    
</t>
<t tx="ekr.20071129105657.446">def _inspect(self,meth,oname,namespaces=None,**kw):
    """Generic interface to the inspector system.

    This function is meant to be called by pdef, pdoc &amp; friends."""
    
    oname = oname.strip()
    info = Struct(self._ofind(oname, namespaces))
    
    if info.found:
        # Get the docstring of the class property if it exists.
        path = oname.split('.')
        root = '.'.join(path[:-1])
        if info.parent is not None:
            try:
                target = getattr(info.parent, '__class__') 
                # The object belongs to a class instance. 
                try: 
                    target = getattr(target, path[-1])
                    # The class defines the object. 
                    if isinstance(target, property):
                        oname = root + '.__class__.' + path[-1]
                        info = Struct(self._ofind(oname))
                except AttributeError: pass
            except AttributeError: pass
                    
        pmethod = getattr(self.shell.inspector,meth)
        formatter = info.ismagic and self.format_screen or None
        if meth == 'pdoc':
            pmethod(info.obj,oname,formatter)
        elif meth == 'pinfo':
            pmethod(info.obj,oname,formatter,info,**kw)
        else:
            pmethod(info.obj,oname)
    else:
        print 'Object `%s` not found.' % oname
        return 'not found'  # so callers can take other action
    
</t>
<t tx="ekr.20071129105657.447">def magic_pdef(self, parameter_s='', namespaces=None):
    """Print the definition header for any callable object.

    If the object is a class, print the constructor information."""
    self._inspect('pdef',parameter_s, namespaces)
    
</t>
<t tx="ekr.20071129105657.448">def magic_pdoc(self, parameter_s='', namespaces=None):
    """Print the docstring for an object.

    If the given object is a class, it will print both the class and the
    constructor docstrings."""
    self._inspect('pdoc',parameter_s, namespaces)

</t>
<t tx="ekr.20071129105657.449">def magic_psource(self, parameter_s='', namespaces=None):
    """Print (or run through pager) the source code for an object."""
    self._inspect('psource',parameter_s, namespaces)

</t>
<t tx="ekr.20071129105657.450">def magic_pfile(self, parameter_s=''):
    """Print (or run through pager) the file where an object is defined.

    The file opens at the line where the object definition begins. IPython
    will honor the environment variable PAGER if set, and otherwise will
    do its best to print the file in a convenient form.

    If the given argument is not an object currently defined, IPython will
    try to interpret it as a filename (automatically adding a .py extension
    if needed). You can thus use %pfile as a syntax highlighting code
    viewer."""

    # first interpret argument as an object name
    out = self._inspect('pfile',parameter_s)
    # if not, try the input as a filename
    if out == 'not found':
        try:
            filename = get_py_filename(parameter_s)
        except IOError,msg:
            print msg
            return
        page(self.shell.inspector.format(file(filename).read()))
        
</t>
<t tx="ekr.20071129105657.451">def magic_pinfo(self, parameter_s='', namespaces=None):
    """Provide detailed information about an object.

    '%pinfo object' is just a synonym for object? or ?object."""

    #print 'pinfo par: &lt;%s&gt;' % parameter_s  # dbg

    # detail_level: 0 -&gt; obj? , 1 -&gt; obj??
    detail_level = 0
    # We need to detect if we got called as 'pinfo pinfo foo', which can
    # happen if the user types 'pinfo foo?' at the cmd line.
    pinfo,qmark1,oname,qmark2 = \
           re.match('(pinfo )?(\?*)(.*?)(\??$)',parameter_s).groups()
    if pinfo or qmark1 or qmark2:
        detail_level = 1
    if "*" in oname:
        self.magic_psearch(oname)
    else:
        self._inspect('pinfo', oname, detail_level=detail_level,
                      namespaces=namespaces)

</t>
<t tx="ekr.20071129105657.452">def magic_psearch(self, parameter_s=''):
    """Search for object in namespaces by wildcard.

    %psearch [options] PATTERN [OBJECT TYPE]

    Note: ? can be used as a synonym for %psearch, at the beginning or at
    the end: both a*? and ?a* are equivalent to '%psearch a*'.  Still, the
    rest of the command line must be unchanged (options come first), so
    for example the following forms are equivalent

    %psearch -i a* function
    -i a* function?
    ?-i a* function

    Arguments:
    
      PATTERN

      where PATTERN is a string containing * as a wildcard similar to its
      use in a shell.  The pattern is matched in all namespaces on the
      search path. By default objects starting with a single _ are not
      matched, many IPython generated objects have a single
      underscore. The default is case insensitive matching. Matching is
      also done on the attributes of objects and not only on the objects
      in a module.

      [OBJECT TYPE]

      Is the name of a python type from the types module. The name is
      given in lowercase without the ending type, ex. StringType is
      written string. By adding a type here only objects matching the
      given type are matched. Using all here makes the pattern match all
      types (this is the default).

    Options:

      -a: makes the pattern match even objects whose names start with a
      single underscore.  These names are normally ommitted from the
      search.

      -i/-c: make the pattern case insensitive/sensitive.  If neither of
      these options is given, the default is read from your ipythonrc
      file.  The option name which sets this value is
      'wildcards_case_sensitive'.  If this option is not specified in your
      ipythonrc file, IPython's internal default is to do a case sensitive
      search.

      -e/-s NAMESPACE: exclude/search a given namespace.  The pattern you
      specifiy can be searched in any of the following namespaces:
      'builtin', 'user', 'user_global','internal', 'alias', where
      'builtin' and 'user' are the search defaults.  Note that you should
      not use quotes when specifying namespaces.

      'Builtin' contains the python module builtin, 'user' contains all
      user data, 'alias' only contain the shell aliases and no python
      objects, 'internal' contains objects used by IPython.  The
      'user_global' namespace is only used by embedded IPython instances,
      and it contains module-level globals.  You can add namespaces to the
      search with -s or exclude them with -e (these options can be given
      more than once).

    Examples:
   
    %psearch a*            -&gt; objects beginning with an a
    %psearch -e builtin a* -&gt; objects NOT in the builtin space starting in a
    %psearch a* function   -&gt; all functions beginning with an a
    %psearch re.e*         -&gt; objects beginning with an e in module re
    %psearch r*.e*         -&gt; objects that start with e in modules starting in r
    %psearch r*.* string   -&gt; all strings in modules beginning with r

    Case sensitve search:
   
    %psearch -c a*         list all object beginning with lower case a

    Show objects beginning with a single _:
   
    %psearch -a _*         list objects beginning with a single underscore"""

    # default namespaces to be searched
    def_search = ['user','builtin']

    # Process options/args
    opts,args = self.parse_options(parameter_s,'cias:e:',list_all=True)
    opt = opts.get
    shell = self.shell
    psearch = shell.inspector.psearch
    
    # select case options
    if opts.has_key('i'):
        ignore_case = True
    elif opts.has_key('c'):
        ignore_case = False
    else:
        ignore_case = not shell.rc.wildcards_case_sensitive

    # Build list of namespaces to search from user options
    def_search.extend(opt('s',[]))
    ns_exclude = ns_exclude=opt('e',[])
    ns_search = [nm for nm in def_search if nm not in ns_exclude]
    
    # Call the actual search
    try:
        psearch(args,shell.ns_table,ns_search,
                show_all=opt('a'),ignore_case=ignore_case)
    except:
        shell.showtraceback()

</t>
<t tx="ekr.20071129105657.453">def magic_who_ls(self, parameter_s=''):
    """Return a sorted list of all interactive variables.

    If arguments are given, only variables of types matching these
    arguments are returned."""

    user_ns = self.shell.user_ns
    internal_ns = self.shell.internal_ns
    user_config_ns = self.shell.user_config_ns
    out = []
    typelist = parameter_s.split()

    for i in user_ns:
        if not (i.startswith('_') or i.startswith('_i')) \
               and not (i in internal_ns or i in user_config_ns):
            if typelist:
                if type(user_ns[i]).__name__ in typelist:
                    out.append(i)
            else:
                out.append(i)
    out.sort()
    return out
    
</t>
<t tx="ekr.20071129105657.454">def magic_who(self, parameter_s=''):
    """Print all interactive variables, with some minimal formatting.

    If any arguments are given, only variables whose type matches one of
    these are printed.  For example:

      %who function str

    will only list functions and strings, excluding all other types of
    variables.  To find the proper type names, simply use type(var) at a
    command line to see how python prints type names.  For example:

      In [1]: type('hello')\\
      Out[1]: &lt;type 'str'&gt;

    indicates that the type name for strings is 'str'.

    %who always excludes executed names loaded through your configuration
    file and things which are internal to IPython.

    This is deliberate, as typically you may load many modules and the
    purpose of %who is to show you only what you've manually defined."""

    varlist = self.magic_who_ls(parameter_s)
    if not varlist:
        print 'Interactive namespace is empty.'
        return

    # if we have variables, move on...

    # stupid flushing problem: when prompts have no separators, stdout is
    # getting lost. I'm starting to think this is a python bug. I'm having
    # to force a flush with a print because even a sys.stdout.flush
    # doesn't seem to do anything!

    count = 0
    for i in varlist:
        print i+'\t',
        count += 1
        if count &gt; 8:
            count = 0
            print
        sys.stdout.flush()  # FIXME. Why the hell isn't this flushing???
        
    print # well, this does force a flush at the expense of an extra \n

</t>
<t tx="ekr.20071129105657.455">def magic_whos(self, parameter_s=''):
    """Like %who, but gives some extra information about each variable.

    The same type filtering of %who can be applied here.

    For all variables, the type is printed. Additionally it prints:
    
      - For {},[],(): their length.

      - For Numeric arrays, a summary with shape, number of elements,
      typecode and size in memory.

      - Everything else: a string representation, snipping their middle if
      too long."""
    
    varnames = self.magic_who_ls(parameter_s)
    if not varnames:
        print 'Interactive namespace is empty.'
        return

    # if we have variables, move on...

    # for these types, show len() instead of data:
    seq_types = [types.DictType,types.ListType,types.TupleType]

    # for Numeric arrays, display summary info
    try:
        import Numeric
    except ImportError:
        array_type = None
    else:
        array_type = Numeric.ArrayType.__name__
    
    # Find all variable names and types so we can figure out column sizes
    
    def get_vars(i):
        return self.shell.user_ns[i]
    
    # some types are well known and can be shorter
    abbrevs = {'IPython.macro.Macro' : 'Macro'}
    def type_name(v):
        tn = type(v).__name__
        return abbrevs.get(tn,tn)
        
    varlist = map(get_vars,varnames)

    typelist = []
    for vv in varlist:
        tt = type_name(vv)

        if tt=='instance':
            typelist.append( abbrevs.get(str(vv.__class__),str(vv.__class__)))
        else:
            typelist.append(tt)

    # column labels and # of spaces as separator
    varlabel = 'Variable'
    typelabel = 'Type'
    datalabel = 'Data/Info'
    colsep = 3
    # variable format strings
    vformat    = "$vname.ljust(varwidth)$vtype.ljust(typewidth)"
    vfmt_short = '$vstr[:25]&lt;...&gt;$vstr[-25:]'
    aformat    = "%s: %s elems, type `%s`, %s bytes"
    # find the size of the columns to format the output nicely
    varwidth = max(max(map(len,varnames)), len(varlabel)) + colsep
    typewidth = max(max(map(len,typelist)), len(typelabel)) + colsep
    # table header
    print varlabel.ljust(varwidth) + typelabel.ljust(typewidth) + \
          ' '+datalabel+'\n' + '-'*(varwidth+typewidth+len(datalabel)+1)
    # and the table itself
    kb = 1024
    Mb = 1048576  # kb**2
    for vname,var,vtype in zip(varnames,varlist,typelist):
        print itpl(vformat),
        if vtype in seq_types:
            print len(var)
        elif vtype==array_type:
            vshape = str(var.shape).replace(',','').replace(' ','x')[1:-1]
            vsize  = Numeric.size(var)
            vbytes = vsize*var.itemsize()
            if vbytes &lt; 100000:
                print aformat % (vshape,vsize,var.typecode(),vbytes)
            else:
                print aformat % (vshape,vsize,var.typecode(),vbytes),
                if vbytes &lt; Mb:
                    print '(%s kb)' % (vbytes/kb,)
                else:
                    print '(%s Mb)' % (vbytes/Mb,)
        else:
            vstr = str(var).replace('\n','\\n')
            if len(vstr) &lt; 50:
                print vstr
            else:
                printpl(vfmt_short)
            
</t>
<t tx="ekr.20071129105657.456">def magic_reset(self, parameter_s=''):
    """Resets the namespace by removing all names defined by the user.

    Input/Output history are left around in case you need them."""

    ans = self.shell.ask_yes_no(
      "Once deleted, variables cannot be recovered. Proceed (y/[n])? ")
    if not ans:
        print 'Nothing done.'
        return
    user_ns = self.shell.user_ns
    for i in self.magic_who_ls():
        del(user_ns[i])

</t>
<t tx="ekr.20071129105657.457">def magic_logstart(self,parameter_s=''):
    """Start logging anywhere in a session.

    %logstart [-o|-r|-t] [log_name [log_mode]]

    If no name is given, it defaults to a file named 'ipython_log.py' in your
    current directory, in 'rotate' mode (see below).

    '%logstart name' saves to file 'name' in 'backup' mode.  It saves your
    history up to that point and then continues logging.

    %logstart takes a second optional parameter: logging mode. This can be one
    of (note that the modes are given unquoted):\\
      append: well, that says it.\\
      backup: rename (if exists) to name~ and start name.\\
      global: single logfile in your home dir, appended to.\\
      over  : overwrite existing log.\\
      rotate: create rotating logs name.1~, name.2~, etc.

    Options:

      -o: log also IPython's output.  In this mode, all commands which
      generate an Out[NN] prompt are recorded to the logfile, right after
      their corresponding input line.  The output lines are always
      prepended with a '#[Out]# ' marker, so that the log remains valid
      Python code.

      Since this marker is always the same, filtering only the output from
      a log is very easy, using for example a simple awk call:

        awk -F'#\\[Out\\]# ' '{if($2) {print $2}}' ipython_log.py

      -r: log 'raw' input.  Normally, IPython's logs contain the processed
      input, so that user lines are logged in their final form, converted
      into valid Python.  For example, %Exit is logged as
      '_ip.magic("Exit").  If the -r flag is given, all input is logged
      exactly as typed, with no transformations applied.

      -t: put timestamps before each input line logged (these are put in
      comments)."""
    
    opts,par = self.parse_options(parameter_s,'ort')
    log_output = 'o' in opts
    log_raw_input = 'r' in opts
    timestamp = 't' in opts

    rc = self.shell.rc
    logger = self.shell.logger

    # if no args are given, the defaults set in the logger constructor by
    # ipytohn remain valid
    if par:
        try:
            logfname,logmode = par.split()
        except:
            logfname = par
            logmode = 'backup'
    else:
        logfname = logger.logfname
        logmode = logger.logmode
    # put logfname into rc struct as if it had been called on the command
    # line, so it ends up saved in the log header Save it in case we need
    # to restore it...
    old_logfile = rc.opts.get('logfile','')  
    if logfname:
        logfname = os.path.expanduser(logfname)
    rc.opts.logfile = logfname
    loghead = self.shell.loghead_tpl % (rc.opts,rc.args)
    try:
        started  = logger.logstart(logfname,loghead,logmode,
                                   log_output,timestamp,log_raw_input)
    except:
        rc.opts.logfile = old_logfile
        warn("Couldn't start log: %s" % sys.exc_info()[1])
    else:
        # log input history up to this point, optionally interleaving
        # output if requested

        if timestamp:
            # disable timestamping for the previous history, since we've
            # lost those already (no time machine here).
            logger.timestamp = False

        if log_raw_input:
            input_hist = self.shell.input_hist_raw
        else:
            input_hist = self.shell.input_hist
            
        if log_output:
            log_write = logger.log_write
            output_hist = self.shell.output_hist
            for n in range(1,len(input_hist)-1):
                log_write(input_hist[n].rstrip())
                if n in output_hist:
                    log_write(repr(output_hist[n]),'output')
        else:
            logger.log_write(input_hist[1:])
        if timestamp:
            # re-enable timestamping
            logger.timestamp = True
            
        print ('Activating auto-logging. '
               'Current session state plus future input saved.')
        logger.logstate()

</t>
<t tx="ekr.20071129105657.458">def magic_logoff(self,parameter_s=''):
    """Temporarily stop logging.

    You must have previously started logging."""
    self.shell.logger.switch_log(0)
    
</t>
<t tx="ekr.20071129105657.459">def magic_logon(self,parameter_s=''):
    """Restart logging.

    This function is for restarting logging which you've temporarily
    stopped with %logoff. For starting logging for the first time, you
    must use the %logstart function, which allows you to specify an
    optional log filename."""
    
    self.shell.logger.switch_log(1)

</t>
<t tx="ekr.20071129105657.460">def magic_logstate(self,parameter_s=''):
    """Print the status of the logging system."""

    self.shell.logger.logstate()
    
</t>
<t tx="ekr.20071129105657.461">def magic_pdb(self, parameter_s=''):
    """Control the automatic calling of the pdb interactive debugger.

    Call as '%pdb on', '%pdb 1', '%pdb off' or '%pdb 0'. If called without
    argument it works as a toggle.

    When an exception is triggered, IPython can optionally call the
    interactive pdb debugger after the traceback printout. %pdb toggles
    this feature on and off.

    The initial state of this feature is set in your ipythonrc
    configuration file (the variable is called 'pdb').

    If you want to just activate the debugger AFTER an exception has fired,
    without having to type '%pdb on' and rerunning your code, you can use
    the %debug magic."""

    par = parameter_s.strip().lower()

    if par:
        try:
            new_pdb = {'off':0,'0':0,'on':1,'1':1}[par]
        except KeyError:
            print ('Incorrect argument. Use on/1, off/0, '
                   'or nothing for a toggle.')
            return
    else:
        # toggle
        new_pdb = not self.shell.call_pdb

    # set on the shell
    self.shell.call_pdb = new_pdb
    print 'Automatic pdb calling has been turned',on_off(new_pdb)

</t>
<t tx="ekr.20071129105657.462">def magic_debug(self, parameter_s=''):
    """Activate the interactive debugger in post-mortem mode.

    If an exception has just occurred, this lets you inspect its stack
    frames interactively.  Note that this will always work only on the last
    traceback that occurred, so you must call this quickly after an
    exception that you wish to inspect has fired, because if another one
    occurs, it clobbers the previous one.

    If you want IPython to automatically do this on every exception, see
    the %pdb magic for more details.
    """
    
    self.shell.debugger(force=True)

</t>
<t tx="ekr.20071129105657.463">def magic_prun(self, parameter_s ='',user_mode=1,
               opts=None,arg_lst=None,prog_ns=None):

    """Run a statement through the python code profiler.

    Usage:\\
      %prun [options] statement

    The given statement (which doesn't require quote marks) is run via the
    python profiler in a manner similar to the profile.run() function.
    Namespaces are internally managed to work correctly; profile.run
    cannot be used in IPython because it makes certain assumptions about
    namespaces which do not hold under IPython.

    Options:

    -l &lt;limit&gt;: you can place restrictions on what or how much of the
    profile gets printed. The limit value can be:

      * A string: only information for function names containing this string
      is printed.

      * An integer: only these many lines are printed.

      * A float (between 0 and 1): this fraction of the report is printed
      (for example, use a limit of 0.4 to see the topmost 40% only).

    You can combine several limits with repeated use of the option. For
    example, '-l __init__ -l 5' will print only the topmost 5 lines of
    information about class constructors.

    -r: return the pstats.Stats object generated by the profiling. This
    object has all the information about the profile in it, and you can
    later use it for further analysis or in other functions.

   -s &lt;key&gt;: sort profile by given key. You can provide more than one key
    by using the option several times: '-s key1 -s key2 -s key3...'. The
    default sorting key is 'time'.

    The following is copied verbatim from the profile documentation
    referenced below:

    When more than one key is provided, additional keys are used as
    secondary criteria when the there is equality in all keys selected
    before them.
    
    Abbreviations can be used for any key names, as long as the
    abbreviation is unambiguous.  The following are the keys currently
    defined:

            Valid Arg       Meaning\\
              "calls"      call count\\
              "cumulative" cumulative time\\
              "file"       file name\\
              "module"     file name\\
              "pcalls"     primitive call count\\
              "line"       line number\\
              "name"       function name\\
              "nfl"        name/file/line\\
              "stdname"    standard name\\
              "time"       internal time

    Note that all sorts on statistics are in descending order (placing
    most time consuming items first), where as name, file, and line number
    searches are in ascending order (i.e., alphabetical). The subtle
    distinction between "nfl" and "stdname" is that the standard name is a
    sort of the name as printed, which means that the embedded line
    numbers get compared in an odd way.  For example, lines 3, 20, and 40
    would (if the file names were the same) appear in the string order
    "20" "3" and "40".  In contrast, "nfl" does a numeric compare of the
    line numbers.  In fact, sort_stats("nfl") is the same as
    sort_stats("name", "file", "line").

    -T &lt;filename&gt;: save profile results as shown on screen to a text
    file. The profile is still shown on screen.

    -D &lt;filename&gt;: save (via dump_stats) profile statistics to given
    filename. This data is in a format understod by the pstats module, and
    is generated by a call to the dump_stats() method of profile
    objects. The profile is still shown on screen.

    If you want to run complete programs under the profiler's control, use
    '%run -p [prof_opts] filename.py [args to program]' where prof_opts
    contains profiler specific options as described here.
    
    You can read the complete documentation for the profile module with:\\
      In [1]: import profile; profile.help() """

    opts_def = Struct(D=[''],l=[],s=['time'],T=[''])
    # protect user quote marks
    parameter_s = parameter_s.replace('"',r'\"').replace("'",r"\'")
    
    if user_mode:  # regular user call
        opts,arg_str = self.parse_options(parameter_s,'D:l:rs:T:',
                                          list_all=1)
        namespace = self.shell.user_ns
    else:  # called to run a program by %run -p
        try:
            filename = get_py_filename(arg_lst[0])
        except IOError,msg:
            error(msg)
            return

        arg_str = 'execfile(filename,prog_ns)'
        namespace = locals()

    opts.merge(opts_def)
    
    prof = profile.Profile()
    try:
        prof = prof.runctx(arg_str,namespace,namespace)
        sys_exit = ''
    except SystemExit:
        sys_exit = """*** SystemExit exception caught in code being profiled."""

    stats = pstats.Stats(prof).strip_dirs().sort_stats(*opts.s)

    lims = opts.l
    if lims:
        lims = []  # rebuild lims with ints/floats/strings
        for lim in opts.l:
            try:
                lims.append(int(lim))
            except ValueError:
                try:
                    lims.append(float(lim))
                except ValueError:
                    lims.append(lim)
                
    # trap output
    sys_stdout = sys.stdout
    stdout_trap = StringIO()
    try:
        sys.stdout = stdout_trap
        stats.print_stats(*lims)
    finally:
        sys.stdout = sys_stdout
    output = stdout_trap.getvalue()
    output = output.rstrip()

    page(output,screen_lines=self.shell.rc.screen_length)
    print sys_exit,

    dump_file = opts.D[0]
    text_file = opts.T[0]
    if dump_file:
        prof.dump_stats(dump_file)
        print '\n*** Profile stats marshalled to file',\
              `dump_file`+'.',sys_exit
    if text_file:
        file(text_file,'w').write(output)
        print '\n*** Profile printout saved to text file',\
              `text_file`+'.',sys_exit

    if opts.has_key('r'):
        return stats
    else:
        return None

</t>
<t tx="ekr.20071129105657.464">def magic_run(self, parameter_s ='',runner=None):
    """Run the named file inside IPython as a program.

    Usage:\\
      %run [-n -i -t [-N&lt;N&gt;] -d [-b&lt;N&gt;] -p [profile options]] file [args]
    
    Parameters after the filename are passed as command-line arguments to
    the program (put in sys.argv). Then, control returns to IPython's
    prompt.

    This is similar to running at a system prompt:\\
      $ python file args\\
    but with the advantage of giving you IPython's tracebacks, and of
    loading all variables into your interactive namespace for further use
    (unless -p is used, see below).

    The file is executed in a namespace initially consisting only of
    __name__=='__main__' and sys.argv constructed as indicated. It thus
    sees its environment as if it were being run as a stand-alone
    program. But after execution, the IPython interactive namespace gets
    updated with all variables defined in the program (except for __name__
    and sys.argv). This allows for very convenient loading of code for
    interactive work, while giving each program a 'clean sheet' to run in.

    Options:
    
    -n: __name__ is NOT set to '__main__', but to the running file's name
    without extension (as python does under import).  This allows running
    scripts and reloading the definitions in them without calling code
    protected by an ' if __name__ == "__main__" ' clause.

    -i: run the file in IPython's namespace instead of an empty one. This
    is useful if you are experimenting with code written in a text editor
    which depends on variables defined interactively.

    -e: ignore sys.exit() calls or SystemExit exceptions in the script
    being run.  This is particularly useful if IPython is being used to
    run unittests, which always exit with a sys.exit() call.  In such
    cases you are interested in the output of the test results, not in
    seeing a traceback of the unittest module.

    -t: print timing information at the end of the run.  IPython will give
    you an estimated CPU time consumption for your script, which under
    Unix uses the resource module to avoid the wraparound problems of
    time.clock().  Under Unix, an estimate of time spent on system tasks
    is also given (for Windows platforms this is reported as 0.0).

    If -t is given, an additional -N&lt;N&gt; option can be given, where &lt;N&gt;
    must be an integer indicating how many times you want the script to
    run.  The final timing report will include total and per run results.

    For example (testing the script uniq_stable.py):

        In [1]: run -t uniq_stable

        IPython CPU timings (estimated):\\
          User  :    0.19597 s.\\
          System:        0.0 s.\\

        In [2]: run -t -N5 uniq_stable

        IPython CPU timings (estimated):\\
        Total runs performed: 5\\
          Times :      Total       Per run\\
          User  :   0.910862 s,  0.1821724 s.\\
          System:        0.0 s,        0.0 s.

    -d: run your program under the control of pdb, the Python debugger.
    This allows you to execute your program step by step, watch variables,
    etc.  Internally, what IPython does is similar to calling:
    
      pdb.run('execfile("YOURFILENAME")')

    with a breakpoint set on line 1 of your file.  You can change the line
    number for this automatic breakpoint to be &lt;N&gt; by using the -bN option
    (where N must be an integer).  For example:

      %run -d -b40 myscript

    will set the first breakpoint at line 40 in myscript.py.  Note that
    the first breakpoint must be set on a line which actually does
    something (not a comment or docstring) for it to stop execution.

    When the pdb debugger starts, you will see a (Pdb) prompt.  You must
    first enter 'c' (without qoutes) to start execution up to the first
    breakpoint.

    Entering 'help' gives information about the use of the debugger.  You
    can easily see pdb's full documentation with "import pdb;pdb.help()"
    at a prompt.

    -p: run program under the control of the Python profiler module (which
    prints a detailed report of execution times, function calls, etc).

    You can pass other options after -p which affect the behavior of the
    profiler itself. See the docs for %prun for details.

    In this mode, the program's variables do NOT propagate back to the
    IPython interactive namespace (because they remain in the namespace
    where the profiler executes them).

    Internally this triggers a call to %prun, see its documentation for
    details on the options available specifically for profiling.

    There is one special usage for which the text above doesn't apply:
    if the filename ends with .ipy, the file is run as ipython script,
    just as if the commands were written on IPython prompt.
    """

    # get arguments and set sys.argv for program to be run.
    opts,arg_lst = self.parse_options(parameter_s,'nidtN:b:pD:l:rs:T:e',
                                      mode='list',list_all=1)

    try:
        filename = get_py_filename(arg_lst[0])
    except IndexError:
        warn('you must provide at least a filename.')
        print '\n%run:\n',OInspect.getdoc(self.magic_run)
        return
    except IOError,msg:
        error(msg)
        return

    if filename.lower().endswith('.ipy'):
        self.api.runlines(open(filename).read())
        return
    
    # Control the response to exit() calls made by the script being run
    exit_ignore = opts.has_key('e')
    
    # Make sure that the running script gets a proper sys.argv as if it
    # were run from a system shell.
    save_argv = sys.argv # save it for later restoring
    sys.argv = [filename]+ arg_lst[1:]  # put in the proper filename

    if opts.has_key('i'):
        prog_ns = self.shell.user_ns
        __name__save = self.shell.user_ns['__name__']
        prog_ns['__name__'] = '__main__'
    else:
        if opts.has_key('n'):
            name = os.path.splitext(os.path.basename(filename))[0]
        else:
            name = '__main__'
        prog_ns = {'__name__':name}

    # Since '%run foo' emulates 'python foo.py' at the cmd line, we must
    # set the __file__ global in the script's namespace
    prog_ns['__file__'] = filename

    # pickle fix.  See iplib for an explanation.  But we need to make sure
    # that, if we overwrite __main__, we replace it at the end
    if prog_ns['__name__'] == '__main__':
        restore_main = sys.modules['__main__']
    else:
        restore_main = False
        
    sys.modules[prog_ns['__name__']] = FakeModule(prog_ns)
    
    stats = None
    try:
        if self.shell.has_readline:
            self.shell.savehist()

        if opts.has_key('p'):
            stats = self.magic_prun('',0,opts,arg_lst,prog_ns)
        else:
            if opts.has_key('d'):
                deb = Debugger.Pdb(self.shell.rc.colors)
                # reset Breakpoint state, which is moronically kept
                # in a class
                bdb.Breakpoint.next = 1
                bdb.Breakpoint.bplist = {}
                bdb.Breakpoint.bpbynumber = [None]
                # Set an initial breakpoint to stop execution
                maxtries = 10
                bp = int(opts.get('b',[1])[0])
                checkline = deb.checkline(filename,bp)
                if not checkline:
                    for bp in range(bp+1,bp+maxtries+1):
                        if deb.checkline(filename,bp):
                            break
                    else:
                        msg = ("\nI failed to find a valid line to set "
                               "a breakpoint\n"
                               "after trying up to line: %s.\n"
                               "Please set a valid breakpoint manually "
                               "with the -b option." % bp)
                        error(msg)
                        return
                # if we find a good linenumber, set the breakpoint
                deb.do_break('%s:%s' % (filename,bp))
                # Start file run
                print "NOTE: Enter 'c' at the",
                print "%s prompt to start your script." % deb.prompt
                try:
                    deb.run('execfile("%s")' % filename,prog_ns)
                    
                except:
                    etype, value, tb = sys.exc_info()
                    # Skip three frames in the traceback: the %run one,
                    # one inside bdb.py, and the command-line typed by the
                    # user (run by exec in pdb itself).
                    self.shell.InteractiveTB(etype,value,tb,tb_offset=3)
            else:
                if runner is None:
                    runner = self.shell.safe_execfile
                if opts.has_key('t'):
                    try:
                        nruns = int(opts['N'][0])
                        if nruns &lt; 1:
                            error('Number of runs must be &gt;=1')
                            return
                    except (KeyError):
                        nruns = 1
                    if nruns == 1:
                        t0 = clock2()
                        runner(filename,prog_ns,prog_ns,
                               exit_ignore=exit_ignore)
                        t1 = clock2()
                        t_usr = t1[0]-t0[0]
                        t_sys = t1[1]-t1[1]
                        print "\nIPython CPU timings (estimated):"
                        print "  User  : %10s s." % t_usr
                        print "  System: %10s s." % t_sys
                    else:
                        runs = range(nruns)
                        t0 = clock2()
                        for nr in runs:
                            runner(filename,prog_ns,prog_ns,
                                   exit_ignore=exit_ignore)
                        t1 = clock2()
                        t_usr = t1[0]-t0[0]
                        t_sys = t1[1]-t1[1]
                        print "\nIPython CPU timings (estimated):"
                        print "Total runs performed:",nruns
                        print "  Times : %10s    %10s" % ('Total','Per run')
                        print "  User  : %10s s, %10s s." % (t_usr,t_usr/nruns)
                        print "  System: %10s s, %10s s." % (t_sys,t_sys/nruns)
                        
                else:
                    runner(filename,prog_ns,prog_ns,exit_ignore=exit_ignore)
            if opts.has_key('i'):
                self.shell.user_ns['__name__'] = __name__save
            else:
                # update IPython interactive namespace
                del prog_ns['__name__']
                self.shell.user_ns.update(prog_ns)
    finally:
        sys.argv = save_argv
        if restore_main:
            sys.modules['__main__'] = restore_main
        if self.shell.has_readline:
            self.shell.readline.read_history_file(self.shell.histfile)
            
    return stats

</t>
<t tx="ekr.20071129105657.465">def magic_runlog(self, parameter_s =''):
    """Run files as logs.

    Usage:\\
      %runlog file1 file2 ...

    Run the named files (treating them as log files) in sequence inside
    the interpreter, and return to the prompt.  This is much slower than
    %run because each line is executed in a try/except block, but it
    allows running files with syntax errors in them.

    Normally IPython will guess when a file is one of its own logfiles, so
    you can typically use %run even for logs. This shorthand allows you to
    force any file to be treated as a log file."""

    for f in parameter_s.split():
        self.shell.safe_execfile(f,self.shell.user_ns,
                                 self.shell.user_ns,islog=1)

</t>
<t tx="ekr.20071129105657.466">def magic_timeit(self, parameter_s =''):
    """Time execution of a Python statement or expression

    Usage:\\
      %timeit [-n&lt;N&gt; -r&lt;R&gt; [-t|-c]] statement

    Time execution of a Python statement or expression using the timeit
    module.

    Options:
    -n&lt;N&gt;: execute the given statement &lt;N&gt; times in a loop. If this value
    is not given, a fitting value is chosen. 
    
    -r&lt;R&gt;: repeat the loop iteration &lt;R&gt; times and take the best result.
    Default: 3
    
    -t: use time.time to measure the time, which is the default on Unix.
    This function measures wall time.
    
    -c: use time.clock to measure the time, which is the default on
    Windows and measures wall time. On Unix, resource.getrusage is used
    instead and returns the CPU user time.

    -p&lt;P&gt;: use a precision of &lt;P&gt; digits to display the timing result.
    Default: 3

    
    Examples:\\
      In [1]: %timeit pass
      10000000 loops, best of 3: 53.3 ns per loop

      In [2]: u = None

      In [3]: %timeit u is None
      10000000 loops, best of 3: 184 ns per loop

      In [4]: %timeit -r 4 u == None
      1000000 loops, best of 4: 242 ns per loop

      In [5]: import time

      In [6]: %timeit -n1 time.sleep(2)
      1 loops, best of 3: 2 s per loop
      

    The times reported by %timeit will be slightly higher than those
    reported by the timeit.py script when variables are accessed. This is
    due to the fact that %timeit executes the statement in the namespace
    of the shell, compared with timeit.py, which uses a single setup
    statement to import function or create variables. Generally, the bias
    does not matter as long as results from timeit.py are not mixed with
    those from %timeit."""

    import timeit
    import math

    units = ["s", "ms", "\xc2\xb5s", "ns"]
    scaling = [1, 1e3, 1e6, 1e9]

    opts, stmt = self.parse_options(parameter_s,'n:r:tcp:',
                                    posix=False)
    if stmt == "":
        return
    timefunc = timeit.default_timer
    number = int(getattr(opts, "n", 0))
    repeat = int(getattr(opts, "r", timeit.default_repeat))
    precision = int(getattr(opts, "p", 3))
    if hasattr(opts, "t"):
        timefunc = time.time
    if hasattr(opts, "c"):
        timefunc = clock

    timer = timeit.Timer(timer=timefunc)
    # this code has tight coupling to the inner workings of timeit.Timer,
    # but is there a better way to achieve that the code stmt has access
    # to the shell namespace?

    src = timeit.template % {'stmt': timeit.reindent(stmt, 8),
                             'setup': "pass"}
    code = compile(src, "&lt;magic-timeit&gt;", "exec")
    ns = {}
    exec code in self.shell.user_ns, ns
    timer.inner = ns["inner"]
    
    if number == 0:
        # determine number so that 0.2 &lt;= total time &lt; 2.0
        number = 1
        for i in range(1, 10):
            number *= 10
            if timer.timeit(number) &gt;= 0.2:
                break
    
    best = min(timer.repeat(repeat, number)) / number

    if best &gt; 0.0:
        order = min(-int(math.floor(math.log10(best)) // 3), 3)
    else:
        order = 3
    print "%d loops, best of %d: %.*g %s per loop" % (number, repeat,
                                                      precision,
                                                      best * scaling[order],
                                                      units[order])
    
</t>
<t tx="ekr.20071129105657.467">def magic_time(self,parameter_s = ''):
    """Time execution of a Python statement or expression.

    The CPU and wall clock times are printed, and the value of the
    expression (if any) is returned.  Note that under Win32, system time
    is always reported as 0, since it can not be measured.

    This function provides very basic timing functionality.  In Python
    2.3, the timeit module offers more control and sophistication, so this
    could be rewritten to use it (patches welcome).
    
    Some examples:

      In [1]: time 2**128
      CPU times: user 0.00 s, sys: 0.00 s, total: 0.00 s
      Wall time: 0.00
      Out[1]: 340282366920938463463374607431768211456L

      In [2]: n = 1000000

      In [3]: time sum(range(n))
      CPU times: user 1.20 s, sys: 0.05 s, total: 1.25 s
      Wall time: 1.37
      Out[3]: 499999500000L

      In [4]: time print 'hello world'
      hello world
      CPU times: user 0.00 s, sys: 0.00 s, total: 0.00 s
      Wall time: 0.00
      """
    
    # fail immediately if the given expression can't be compiled
    try:
        mode = 'eval'
        code = compile(parameter_s,'&lt;timed eval&gt;',mode)
    except SyntaxError:
        mode = 'exec'
        code = compile(parameter_s,'&lt;timed exec&gt;',mode)
    # skew measurement as little as possible
    glob = self.shell.user_ns
    clk = clock2
    wtime = time.time
    # time execution
    wall_st = wtime()
    if mode=='eval':
        st = clk()
        out = eval(code,glob)
        end = clk()
    else:
        st = clk()
        exec code in glob
        end = clk()
        out = None
    wall_end = wtime()
    # Compute actual times and report
    wall_time = wall_end-wall_st
    cpu_user = end[0]-st[0]
    cpu_sys = end[1]-st[1]
    cpu_tot = cpu_user+cpu_sys
    print "CPU times: user %.2f s, sys: %.2f s, total: %.2f s" % \
          (cpu_user,cpu_sys,cpu_tot)
    print "Wall time: %.2f" % wall_time
    return out

</t>
<t tx="ekr.20071129105657.468">def magic_macro(self,parameter_s = ''):
    """Define a set of input lines as a macro for future re-execution.

    Usage:\\
      %macro [options] name n1-n2 n3-n4 ... n5 .. n6 ...

    Options:
    
      -r: use 'raw' input.  By default, the 'processed' history is used,
      so that magics are loaded in their transformed version to valid
      Python.  If this option is given, the raw input as typed as the
      command line is used instead.

    This will define a global variable called `name` which is a string
    made of joining the slices and lines you specify (n1,n2,... numbers
    above) from your input history into a single string. This variable
    acts like an automatic function which re-executes those lines as if
    you had typed them. You just type 'name' at the prompt and the code
    executes.

    The notation for indicating number ranges is: n1-n2 means 'use line
    numbers n1,...n2' (the endpoint is included).  That is, '5-7' means
    using the lines numbered 5,6 and 7.

    Note: as a 'hidden' feature, you can also use traditional python slice
    notation, where N:M means numbers N through M-1.

    For example, if your history contains (%hist prints it):
    
      44: x=1\\
      45: y=3\\
      46: z=x+y\\
      47: print x\\
      48: a=5\\
      49: print 'x',x,'y',y\\

    you can create a macro with lines 44 through 47 (included) and line 49
    called my_macro with:

      In [51]: %macro my_macro 44-47 49

    Now, typing `my_macro` (without quotes) will re-execute all this code
    in one pass.

    You don't need to give the line-numbers in order, and any given line
    number can appear multiple times. You can assemble macros with any
    lines from your input history in any order.

    The macro is a simple object which holds its value in an attribute,
    but IPython's display system checks for macros and executes them as
    code instead of printing them when you type their name.

    You can view a macro's contents by explicitly printing it with:
    
      'print macro_name'.

    For one-off cases which DON'T contain magic function calls in them you
    can obtain similar results by explicitly executing slices from your
    input history with:

      In [60]: exec In[44:48]+In[49]"""

    opts,args = self.parse_options(parameter_s,'r',mode='list')
    name,ranges = args[0], args[1:]
    #print 'rng',ranges  # dbg
    lines = self.extract_input_slices(ranges,opts.has_key('r'))
    macro = Macro(lines)
    self.shell.user_ns.update({name:macro})
    print 'Macro `%s` created. To execute, type its name (without quotes).' % name
    print 'Macro contents:'
    print macro,

</t>
<t tx="ekr.20071129105657.469">def magic_save(self,parameter_s = ''):
    """Save a set of lines to a given filename.

    Usage:\\
      %save [options] filename n1-n2 n3-n4 ... n5 .. n6 ...

    Options:
    
      -r: use 'raw' input.  By default, the 'processed' history is used,
      so that magics are loaded in their transformed version to valid
      Python.  If this option is given, the raw input as typed as the
      command line is used instead.

    This function uses the same syntax as %macro for line extraction, but
    instead of creating a macro it saves the resulting string to the
    filename you specify.

    It adds a '.py' extension to the file if you don't do so yourself, and
    it asks for confirmation before overwriting existing files."""

    opts,args = self.parse_options(parameter_s,'r',mode='list')
    fname,ranges = args[0], args[1:]
    if not fname.endswith('.py'):
        fname += '.py'
    if os.path.isfile(fname):
        ans = raw_input('File `%s` exists. Overwrite (y/[N])? ' % fname)
        if ans.lower() not in ['y','yes']:
            print 'Operation cancelled.'
            return
    cmds = ''.join(self.extract_input_slices(ranges,opts.has_key('r')))
    f = file(fname,'w')
    f.write(cmds)
    f.close()
    print 'The following commands were written to file `%s`:' % fname
    print cmds

</t>
<t tx="ekr.20071129105657.470">def _edit_macro(self,mname,macro):
    """open an editor with the macro data in a file"""
    filename = self.shell.mktempfile(macro.value)
    self.shell.hooks.editor(filename)

    # and make a new macro object, to replace the old one
    mfile = open(filename)
    mvalue = mfile.read()
    mfile.close()
    self.shell.user_ns[mname] = Macro(mvalue)

</t>
<t tx="ekr.20071129105657.471">def magic_ed(self,parameter_s=''):
    """Alias to %edit."""
    return self.magic_edit(parameter_s)

</t>
<t tx="ekr.20071129105657.472">def magic_edit(self,parameter_s='',last_call=['','']):
    """Bring up an editor and execute the resulting code.

    Usage:
      %edit [options] [args]

    %edit runs IPython's editor hook.  The default version of this hook is
    set to call the __IPYTHON__.rc.editor command.  This is read from your
    environment variable $EDITOR.  If this isn't found, it will default to
    vi under Linux/Unix and to notepad under Windows.  See the end of this
    docstring for how to change the editor hook.

    You can also set the value of this editor via the command line option
    '-editor' or in your ipythonrc file. This is useful if you wish to use
    specifically for IPython an editor different from your typical default
    (and for Windows users who typically don't set environment variables).

    This command allows you to conveniently edit multi-line code right in
    your IPython session.
    
    If called without arguments, %edit opens up an empty editor with a
    temporary file and will execute the contents of this file when you
    close it (don't forget to save it!).


    Options:

    -n &lt;number&gt;: open the editor at a specified line number.  By default,
    the IPython editor hook uses the unix syntax 'editor +N filename', but
    you can configure this by providing your own modified hook if your
    favorite editor supports line-number specifications with a different
    syntax.
    
    -p: this will call the editor with the same data as the previous time
    it was used, regardless of how long ago (in your current session) it
    was.

    -r: use 'raw' input.  This option only applies to input taken from the
    user's history.  By default, the 'processed' history is used, so that
    magics are loaded in their transformed version to valid Python.  If
    this option is given, the raw input as typed as the command line is
    used instead.  When you exit the editor, it will be executed by
    IPython's own processor.
    
    -x: do not execute the edited code immediately upon exit. This is
    mainly useful if you are editing programs which need to be called with
    command line arguments, which you can then do using %run.


    Arguments:

    If arguments are given, the following possibilites exist:

    - The arguments are numbers or pairs of colon-separated numbers (like
    1 4:8 9). These are interpreted as lines of previous input to be
    loaded into the editor. The syntax is the same of the %macro command.

    - If the argument doesn't start with a number, it is evaluated as a
    variable and its contents loaded into the editor. You can thus edit
    any string which contains python code (including the result of
    previous edits).

    - If the argument is the name of an object (other than a string),
    IPython will try to locate the file where it was defined and open the
    editor at the point where it is defined. You can use `%edit function`
    to load an editor exactly at the point where 'function' is defined,
    edit it and have the file be executed automatically.

    If the object is a macro (see %macro for details), this opens up your
    specified editor with a temporary file containing the macro's data.
    Upon exit, the macro is reloaded with the contents of the file.

    Note: opening at an exact line is only supported under Unix, and some
    editors (like kedit and gedit up to Gnome 2.8) do not understand the
    '+NUMBER' parameter necessary for this feature. Good editors like
    (X)Emacs, vi, jed, pico and joe all do.

    - If the argument is not found as a variable, IPython will look for a
    file with that name (adding .py if necessary) and load it into the
    editor. It will execute its contents with execfile() when you exit,
    loading any code in the file into your interactive namespace.

    After executing your code, %edit will return as output the code you
    typed in the editor (except when it was an existing file). This way
    you can reload the code in further invocations of %edit as a variable,
    via _&lt;NUMBER&gt; or Out[&lt;NUMBER&gt;], where &lt;NUMBER&gt; is the prompt number of
    the output.

    Note that %edit is also available through the alias %ed.

    This is an example of creating a simple function inside the editor and
    then modifying it. First, start up the editor:

    In [1]: ed\\
    Editing... done. Executing edited code...\\
    Out[1]: 'def foo():\\n    print "foo() was defined in an editing session"\\n'

    We can then call the function foo():
    
    In [2]: foo()\\
    foo() was defined in an editing session

    Now we edit foo.  IPython automatically loads the editor with the
    (temporary) file where foo() was previously defined:
    
    In [3]: ed foo\\
    Editing... done. Executing edited code...

    And if we call foo() again we get the modified version:
    
    In [4]: foo()\\
    foo() has now been changed!

    Here is an example of how to edit a code snippet successive
    times. First we call the editor:

    In [8]: ed\\
    Editing... done. Executing edited code...\\
    hello\\
    Out[8]: "print 'hello'\\n"

    Now we call it again with the previous output (stored in _):

    In [9]: ed _\\
    Editing... done. Executing edited code...\\
    hello world\\
    Out[9]: "print 'hello world'\\n"

    Now we call it with the output #8 (stored in _8, also as Out[8]):

    In [10]: ed _8\\
    Editing... done. Executing edited code...\\
    hello again\\
    Out[10]: "print 'hello again'\\n"


    Changing the default editor hook:

    If you wish to write your own editor hook, you can put it in a
    configuration file which you load at startup time.  The default hook
    is defined in the IPython.hooks module, and you can use that as a
    starting example for further modifications.  That file also has
    general instructions on how to set a new hook for use once you've
    defined it."""
    
    # FIXME: This function has become a convoluted mess.  It needs a
    # ground-up rewrite with clean, simple logic.

    def make_filename(arg):
        "Make a filename from the given args"
        try:
            filename = get_py_filename(arg)
        except IOError:
            if args.endswith('.py'):
                filename = arg
            else:
                filename = None
        return filename

    # custom exceptions
    class DataIsObject(Exception): pass

    opts,args = self.parse_options(parameter_s,'prxn:')
    # Set a few locals from the options for convenience:
    opts_p = opts.has_key('p')
    opts_r = opts.has_key('r')
    
    # Default line number value
    lineno = opts.get('n',None)

    if opts_p:
        args = '_%s' % last_call[0]
        if not self.shell.user_ns.has_key(args):
            args = last_call[1]
        
    # use last_call to remember the state of the previous call, but don't
    # let it be clobbered by successive '-p' calls.
    try:
        last_call[0] = self.shell.outputcache.prompt_count
        if not opts_p:
            last_call[1] = parameter_s
    except:
        pass

    # by default this is done with temp files, except when the given
    # arg is a filename
    use_temp = 1

    if re.match(r'\d',args):
        # Mode where user specifies ranges of lines, like in %macro.
        # This means that you can't edit files whose names begin with
        # numbers this way. Tough.
        ranges = args.split()
        data = ''.join(self.extract_input_slices(ranges,opts_r))
    elif args.endswith('.py'):
        filename = make_filename(args)
        data = ''
        use_temp = 0
    elif args:
        try:
            # Load the parameter given as a variable. If not a string,
            # process it as an object instead (below)

            #print '*** args',args,'type',type(args)  # dbg
            data = eval(args,self.shell.user_ns)
            if not type(data) in StringTypes:
                raise DataIsObject

        except (NameError,SyntaxError):
            # given argument is not a variable, try as a filename
            filename = make_filename(args)
            if filename is None:
                warn("Argument given (%s) can't be found as a variable "
                     "or as a filename." % args)
                return

            data = ''
            use_temp = 0
        except DataIsObject:

            # macros have a special edit function
            if isinstance(data,Macro):
                self._edit_macro(args,data)
                return
            
            # For objects, try to edit the file where they are defined
            try:
                filename = inspect.getabsfile(data)
                datafile = 1
            except TypeError:
                filename = make_filename(args)
                datafile = 1
                warn('Could not find file where `%s` is defined.\n'
                     'Opening a file named `%s`' % (args,filename))
            # Now, make sure we can actually read the source (if it was in
            # a temp file it's gone by now).
            if datafile:
                try:
                    if lineno is None:
                        lineno = inspect.getsourcelines(data)[1]
                except IOError:
                    filename = make_filename(args)
                    if filename is None:
                        warn('The file `%s` where `%s` was defined cannot '
                             'be read.' % (filename,data))
                        return
            use_temp = 0
    else:
        data = ''

    if use_temp:
        filename = self.shell.mktempfile(data)
        print 'IPython will make a temporary file named:',filename

    # do actual editing here
    print 'Editing...',
    sys.stdout.flush()
    self.shell.hooks.editor(filename,lineno)
    if opts.has_key('x'):  # -x prevents actual execution
        print
    else:
        print 'done. Executing edited code...'
        if opts_r:
            self.shell.runlines(file_read(filename))
        else:
            self.shell.safe_execfile(filename,self.shell.user_ns)
    if use_temp:
        try:
            return open(filename).read()
        except IOError,msg:
            if msg.filename == filename:
                warn('File not found. Did you forget to save?')
                return
            else:
                self.shell.showtraceback()

</t>
<t tx="ekr.20071129105657.473">def magic_xmode(self,parameter_s = ''):
    """Switch modes for the exception handlers.

    Valid modes: Plain, Context and Verbose.

    If called without arguments, acts as a toggle."""

    def xmode_switch_err(name):
        warn('Error changing %s exception modes.\n%s' %
             (name,sys.exc_info()[1]))

    shell = self.shell
    new_mode = parameter_s.strip().capitalize()
    try:
        shell.InteractiveTB.set_mode(mode=new_mode)
        print 'Exception reporting mode:',shell.InteractiveTB.mode
    except:
        xmode_switch_err('user')

    # threaded shells use a special handler in sys.excepthook
    if shell.isthreaded:
        try:
            shell.sys_excepthook.set_mode(mode=new_mode)
        except:
            xmode_switch_err('threaded')
        
</t>
<t tx="ekr.20071129105657.474">def magic_colors(self,parameter_s = ''):
    """Switch color scheme for prompts, info system and exception handlers.

    Currently implemented schemes: NoColor, Linux, LightBG.

    Color scheme names are not case-sensitive."""

    def color_switch_err(name):
        warn('Error changing %s color schemes.\n%s' %
             (name,sys.exc_info()[1]))
        
    
    new_scheme = parameter_s.strip()
    if not new_scheme:
        print 'You must specify a color scheme.'
        return
    import IPython.rlineimpl as readline
    if not readline.have_readline:
        msg = """\
Proper color support under MS Windows requires the pyreadline library.
You can find it at:
http://ipython.scipy.org/moin/PyReadline/Intro
Gary's readline needs the ctypes module, from:
http://starship.python.net/crew/theller/ctypes
(Note that ctypes is already part of Python versions 2.5 and newer).

Defaulting color scheme to 'NoColor'"""
        new_scheme = 'NoColor'
        warn(msg)
    # local shortcut
    shell = self.shell
    
    # Set prompt colors
    try:
        shell.outputcache.set_colors(new_scheme)
    except:
        color_switch_err('prompt')
    else:
        shell.rc.colors = \
                   shell.outputcache.color_table.active_scheme_name
    # Set exception colors
    try:
        shell.InteractiveTB.set_colors(scheme = new_scheme)
        shell.SyntaxTB.set_colors(scheme = new_scheme)
    except:
        color_switch_err('exception')

    # threaded shells use a verbose traceback in sys.excepthook
    if shell.isthreaded:
        try:
            shell.sys_excepthook.set_colors(scheme=new_scheme)
        except:
            color_switch_err('system exception handler')
    
    # Set info (for 'object?') colors
    if shell.rc.color_info:
        try:
            shell.inspector.set_active_scheme(new_scheme)
        except:
            color_switch_err('object inspector')
    else:
        shell.inspector.set_active_scheme('NoColor')
            
</t>
<t tx="ekr.20071129105657.475">def magic_color_info(self,parameter_s = ''):
    """Toggle color_info.

    The color_info configuration parameter controls whether colors are
    used for displaying object details (by things like %psource, %pfile or
    the '?' system). This function toggles this value with each call.

    Note that unless you have a fairly recent pager (less works better
    than more) in your system, using colored object information displays
    will not work properly. Test it and see."""
    
    self.shell.rc.color_info = 1 - self.shell.rc.color_info
    self.magic_colors(self.shell.rc.colors)
    print 'Object introspection functions have now coloring:',
    print ['OFF','ON'][self.shell.rc.color_info]

</t>
<t tx="ekr.20071129105657.476">def magic_Pprint(self, parameter_s=''):
    """Toggle pretty printing on/off."""
    
    self.shell.rc.pprint = 1 - self.shell.rc.pprint
    print 'Pretty printing has been turned', \
          ['OFF','ON'][self.shell.rc.pprint]
    
</t>
<t tx="ekr.20071129105657.477">def magic_exit(self, parameter_s=''):
    """Exit IPython, confirming if configured to do so.

    You can configure whether IPython asks for confirmation upon exit by
    setting the confirm_exit flag in the ipythonrc file."""

    self.shell.exit()

</t>
<t tx="ekr.20071129105657.478">def magic_quit(self, parameter_s=''):
    """Exit IPython, confirming if configured to do so (like %exit)"""

    self.shell.exit()
    
</t>
<t tx="ekr.20071129105657.479">def magic_Exit(self, parameter_s=''):
    """Exit IPython without confirmation."""

    self.shell.exit_now = True

</t>
<t tx="ekr.20071129105657.480">def magic_Quit(self, parameter_s=''):
    """Exit IPython without confirmation (like %Exit)."""

    self.shell.exit_now = True
    
</t>
<t tx="ekr.20071129105657.481">#......................................................................
# Functions to implement unix shell-type things

def magic_alias(self, parameter_s = ''):
    """Define an alias for a system command.

    '%alias alias_name cmd' defines 'alias_name' as an alias for 'cmd'

    Then, typing 'alias_name params' will execute the system command 'cmd
    params' (from your underlying operating system).

    Aliases have lower precedence than magic functions and Python normal
    variables, so if 'foo' is both a Python variable and an alias, the
    alias can not be executed until 'del foo' removes the Python variable.

    You can use the %l specifier in an alias definition to represent the
    whole line when the alias is called.  For example:

      In [2]: alias all echo "Input in brackets: &lt;%l&gt;"\\
      In [3]: all hello world\\
      Input in brackets: &lt;hello world&gt;

    You can also define aliases with parameters using %s specifiers (one
    per parameter):
    
      In [1]: alias parts echo first %s second %s\\
      In [2]: %parts A B\\
      first A second B\\
      In [3]: %parts A\\
      Incorrect number of arguments: 2 expected.\\
      parts is an alias to: 'echo first %s second %s'

    Note that %l and %s are mutually exclusive.  You can only use one or
    the other in your aliases.

    Aliases expand Python variables just like system calls using ! or !! 
    do: all expressions prefixed with '$' get expanded.  For details of
    the semantic rules, see PEP-215:
    http://www.python.org/peps/pep-0215.html.  This is the library used by
    IPython for variable expansion.  If you want to access a true shell
    variable, an extra $ is necessary to prevent its expansion by IPython:

    In [6]: alias show echo\\
    In [7]: PATH='A Python string'\\
    In [8]: show $PATH\\
    A Python string\\
    In [9]: show $$PATH\\
    /usr/local/lf9560/bin:/usr/local/intel/compiler70/ia32/bin:...

    You can use the alias facility to acess all of $PATH.  See the %rehash
    and %rehashx functions, which automatically create aliases for the
    contents of your $PATH.

    If called with no parameters, %alias prints the current alias table."""

    par = parameter_s.strip()
    if not par:
        stored = self.db.get('stored_aliases', {} )
        atab = self.shell.alias_table
        aliases = atab.keys()
        aliases.sort()
        res = []
        showlast = []
        for alias in aliases:
            tgt = atab[alias][1]
            # 'interesting' aliases
            if (alias in stored or 
                alias != os.path.splitext(tgt)[0] or
                ' ' in tgt):
                showlast.append((alias, tgt))
            else:
                res.append((alias, tgt ))                
        
        # show most interesting aliases last
        res.extend(showlast)
        print "Total number of aliases:",len(aliases)
        return res
    try:
        alias,cmd = par.split(None,1)
    except:
        print OInspect.getdoc(self.magic_alias)
    else:
        nargs = cmd.count('%s')
        if nargs&gt;0 and cmd.find('%l')&gt;=0:
            error('The %s and %l specifiers are mutually exclusive '
                  'in alias definitions.')
        else:  # all looks OK
            self.shell.alias_table[alias] = (nargs,cmd)
            self.shell.alias_table_validate(verbose=0)
</t>
<t tx="ekr.20071129105657.482"># end magic_alias

def magic_unalias(self, parameter_s = ''):
    """Remove an alias"""

    aname = parameter_s.strip()
    if aname in self.shell.alias_table:
        del self.shell.alias_table[aname]
    stored = self.db.get('stored_aliases', {} )
    if aname in stored:
        print "Removing %stored alias",aname
        del stored[aname]
        self.db['stored_aliases'] = stored
        
</t>
<t tx="ekr.20071129105657.483">def magic_rehash(self, parameter_s = ''):
    """Update the alias table with all entries in $PATH.

    This version does no checks on execute permissions or whether the
    contents of $PATH are truly files (instead of directories or something
    else).  For such a safer (but slower) version, use %rehashx."""

    # This function (and rehashx) manipulate the alias_table directly
    # rather than calling magic_alias, for speed reasons.  A rehash on a
    # typical Linux box involves several thousand entries, so efficiency
    # here is a top concern.
    
    path = filter(os.path.isdir,os.environ['PATH'].split(os.pathsep))
    alias_table = self.shell.alias_table
    for pdir in path:
        for ff in os.listdir(pdir):
            # each entry in the alias table must be (N,name), where
            # N is the number of positional arguments of the alias.
            alias_table[ff] = (0,ff)
    # Make sure the alias table doesn't contain keywords or builtins
    self.shell.alias_table_validate()
    # Call again init_auto_alias() so we get 'rm -i' and other modified
    # aliases since %rehash will probably clobber them
    self.shell.init_auto_alias()

</t>
<t tx="ekr.20071129105657.484">def magic_rehashx(self, parameter_s = ''):
    """Update the alias table with all executable files in $PATH.

    This version explicitly checks that every entry in $PATH is a file
    with execute access (os.X_OK), so it is much slower than %rehash.

    Under Windows, it checks executability as a match agains a
    '|'-separated string of extensions, stored in the IPython config
    variable win_exec_ext.  This defaults to 'exe|com|bat'. """
    
    path = [os.path.abspath(os.path.expanduser(p)) for p in 
        os.environ['PATH'].split(os.pathsep)]
    path = filter(os.path.isdir,path)
    
    alias_table = self.shell.alias_table
    syscmdlist = []
    if os.name == 'posix':
        isexec = lambda fname:os.path.isfile(fname) and \
                 os.access(fname,os.X_OK)
    else:

        try:
            winext = os.environ['pathext'].replace(';','|').replace('.','')
        except KeyError:
            winext = 'exe|com|bat|py'
        if 'py' not in winext:
            winext += '|py'
        execre = re.compile(r'(.*)\.(%s)$' % winext,re.IGNORECASE)
        isexec = lambda fname:os.path.isfile(fname) and execre.match(fname)
    savedir = os.getcwd()
    try:
        # write the whole loop for posix/Windows so we don't have an if in
        # the innermost part
        if os.name == 'posix':
            for pdir in path:
                os.chdir(pdir)
                for ff in os.listdir(pdir):
                    if isexec(ff) and ff not in self.shell.no_alias:
                        # each entry in the alias table must be (N,name),
                        # where N is the number of positional arguments of the
                        # alias.
                        alias_table[ff] = (0,ff)
                        syscmdlist.append(ff)
        else:
            for pdir in path:
                os.chdir(pdir)
                for ff in os.listdir(pdir):
                    base, ext = os.path.splitext(ff)
                    if isexec(ff) and base not in self.shell.no_alias:
                        if ext.lower() == '.exe':
                            ff = base
                        alias_table[base] = (0,ff)
                        syscmdlist.append(ff)
        # Make sure the alias table doesn't contain keywords or builtins
        self.shell.alias_table_validate()
        # Call again init_auto_alias() so we get 'rm -i' and other
        # modified aliases since %rehashx will probably clobber them
        self.shell.init_auto_alias()
        db = self.getapi().db
        db['syscmdlist'] = syscmdlist
    finally:
        os.chdir(savedir)
    
</t>
<t tx="ekr.20071129105657.485">def magic_pwd(self, parameter_s = ''):
    """Return the current working directory path."""
    return os.getcwd()

</t>
<t tx="ekr.20071129105657.486">def magic_cd(self, parameter_s=''):
    """Change the current working directory.

    This command automatically maintains an internal list of directories
    you visit during your IPython session, in the variable _dh. The
    command %dhist shows this history nicely formatted. You can also
    do 'cd -&lt;tab&gt;' to see directory history conveniently.

    Usage:

      cd 'dir': changes to directory 'dir'.

      cd -: changes to the last visited directory.

      cd -&lt;n&gt;: changes to the n-th directory in the directory history.

      cd -b &lt;bookmark_name&gt;: jump to a bookmark set by %bookmark
         (note: cd &lt;bookmark_name&gt; is enough if there is no
          directory &lt;bookmark_name&gt;, but a bookmark with the name exists.)
          'cd -b &lt;tab&gt;' allows you to tab-complete bookmark names. 

    Options:

    -q: quiet.  Do not print the working directory after the cd command is
    executed.  By default IPython's cd command does print this directory,
    since the default prompts do not display path information.
    
    Note that !cd doesn't work for this purpose because the shell where
    !command runs is immediately discarded after executing 'command'."""

    parameter_s = parameter_s.strip()
    #bkms = self.shell.persist.get("bookmarks",{})

    numcd = re.match(r'(-)(\d+)$',parameter_s)
    # jump in directory history by number
    if numcd:
        nn = int(numcd.group(2))
        try:
            ps = self.shell.user_ns['_dh'][nn]
        except IndexError:
            print 'The requested directory does not exist in history.'
            return
        else:
            opts = {}
    else:
        #turn all non-space-escaping backslashes to slashes, 
        # for c:\windows\directory\names\
        parameter_s = re.sub(r'\\(?! )','/', parameter_s)            
        opts,ps = self.parse_options(parameter_s,'qb',mode='string')
    # jump to previous
    if ps == '-':
        try:
            ps = self.shell.user_ns['_dh'][-2]
        except IndexError:
            print 'No previous directory to change to.'
            return
    # jump to bookmark if needed
    else:
        if not os.path.isdir(ps) or opts.has_key('b'):
            bkms = self.db.get('bookmarks', {})
        
            if bkms.has_key(ps):
                target = bkms[ps]
                print '(bookmark:%s) -&gt; %s' % (ps,target)
                ps = target
            else:
                if opts.has_key('b'):
                    error("Bookmark '%s' not found.  "
                          "Use '%%bookmark -l' to see your bookmarks." % ps)
                    return
        
    # at this point ps should point to the target dir
    if ps:
        try:
            os.chdir(os.path.expanduser(ps))
            ttitle = ("IPy:" + (
                os.getcwd() == '/' and '/' or os.path.basename(os.getcwd())))
            platutils.set_term_title(ttitle)
        except OSError:
            print sys.exc_info()[1]
        else:
            self.shell.user_ns['_dh'].append(os.getcwd())
    else:
        os.chdir(self.shell.home_dir)
        platutils.set_term_title("IPy:~")
        self.shell.user_ns['_dh'].append(os.getcwd())
    if not 'q' in opts:
        print self.shell.user_ns['_dh'][-1]

</t>
<t tx="ekr.20071129105657.487">def magic_dhist(self, parameter_s=''):
    """Print your history of visited directories.

    %dhist       -&gt; print full history\\
    %dhist n     -&gt; print last n entries only\\
    %dhist n1 n2 -&gt; print entries between n1 and n2 (n1 not included)\\

    This history is automatically maintained by the %cd command, and
    always available as the global list variable _dh. You can use %cd -&lt;n&gt;
    to go to directory number &lt;n&gt;."""

    dh = self.shell.user_ns['_dh']
    if parameter_s:
        try:
            args = map(int,parameter_s.split())
        except:
            self.arg_err(Magic.magic_dhist)
            return
        if len(args) == 1:
            ini,fin = max(len(dh)-(args[0]),0),len(dh)
        elif len(args) == 2:
            ini,fin = args
        else:
            self.arg_err(Magic.magic_dhist)
            return
    else:
        ini,fin = 0,len(dh)
    nlprint(dh,
            header = 'Directory history (kept in _dh)',
            start=ini,stop=fin)

</t>
<t tx="ekr.20071129105657.488">def magic_env(self, parameter_s=''):
    """List environment variables."""
    
    return os.environ.data

</t>
<t tx="ekr.20071129105657.489">def magic_pushd(self, parameter_s=''):
    """Place the current dir on stack and change directory.
    
    Usage:\\
      %pushd ['dirname']

    %pushd with no arguments does a %pushd to your home directory.
    """
    if parameter_s == '': parameter_s = '~'
    dir_s = self.shell.dir_stack
    if len(dir_s)&gt;0 and os.path.expanduser(parameter_s) != \
       os.path.expanduser(self.shell.dir_stack[0]):
        try:
            self.magic_cd(parameter_s)
            dir_s.insert(0,os.getcwd().replace(self.home_dir,'~'))
            self.magic_dirs()
        except:
            print 'Invalid directory'
    else:
        print 'You are already there!'

</t>
<t tx="ekr.20071129105657.490">def magic_popd(self, parameter_s=''):
    """Change to directory popped off the top of the stack.
    """
    if len (self.shell.dir_stack) &gt; 1:
        self.shell.dir_stack.pop(0)
        self.magic_cd(self.shell.dir_stack[0])
        print self.shell.dir_stack[0]
    else:
        print "You can't remove the starting directory from the stack:",\
              self.shell.dir_stack

</t>
<t tx="ekr.20071129105657.491">def magic_dirs(self, parameter_s=''):
    """Return the current directory stack."""

    return self.shell.dir_stack[:]

</t>
<t tx="ekr.20071129105657.492">def magic_sc(self, parameter_s=''):
    """Shell capture - execute a shell command and capture its output.

    DEPRECATED. Suboptimal, retained for backwards compatibility.
    
    You should use the form 'var = !command' instead. Example:
     
     "%sc -l myfiles = ls ~" should now be written as
        
     "myfiles = !ls ~"
     
    myfiles.s, myfiles.l and myfiles.n still apply as documented
    below.

    --
    %sc [options] varname=command

    IPython will run the given command using commands.getoutput(), and
    will then update the user's interactive namespace with a variable
    called varname, containing the value of the call.  Your command can
    contain shell wildcards, pipes, etc.

    The '=' sign in the syntax is mandatory, and the variable name you
    supply must follow Python's standard conventions for valid names.
    
    (A special format without variable name exists for internal use)

    Options:

      -l: list output.  Split the output on newlines into a list before
      assigning it to the given variable.  By default the output is stored
      as a single string.

      -v: verbose.  Print the contents of the variable.

    In most cases you should not need to split as a list, because the
    returned value is a special type of string which can automatically
    provide its contents either as a list (split on newlines) or as a
    space-separated string.  These are convenient, respectively, either
    for sequential processing or to be passed to a shell command.

    For example:

        # Capture into variable a
        In [9]: sc a=ls *py

        # a is a string with embedded newlines
        In [10]: a
        Out[10]: 'setup.py\nwin32_manual_post_install.py'

        # which can be seen as a list:
        In [11]: a.l
        Out[11]: ['setup.py', 'win32_manual_post_install.py']

        # or as a whitespace-separated string:
        In [12]: a.s
        Out[12]: 'setup.py win32_manual_post_install.py'

        # a.s is useful to pass as a single command line:
        In [13]: !wc -l $a.s
          146 setup.py
          130 win32_manual_post_install.py
          276 total

        # while the list form is useful to loop over:
        In [14]: for f in a.l:
           ....:      !wc -l $f
           ....:
        146 setup.py
        130 win32_manual_post_install.py

    Similiarly, the lists returned by the -l option are also special, in
    the sense that you can equally invoke the .s attribute on them to
    automatically get a whitespace-separated string from their contents:

        In [1]: sc -l b=ls *py

        In [2]: b
        Out[2]: ['setup.py', 'win32_manual_post_install.py']

        In [3]: b.s
        Out[3]: 'setup.py win32_manual_post_install.py'

    In summary, both the lists and strings used for ouptut capture have
    the following special attributes:

        .l (or .list) : value as list.
        .n (or .nlstr): value as newline-separated string.
        .s (or .spstr): value as space-separated string.
    """

    opts,args = self.parse_options(parameter_s,'lv')
    # Try to get a variable name and command to run
    try:
        # the variable name must be obtained from the parse_options
        # output, which uses shlex.split to strip options out.
        var,_ = args.split('=',1)
        var = var.strip()
        # But the the command has to be extracted from the original input
        # parameter_s, not on what parse_options returns, to avoid the
        # quote stripping which shlex.split performs on it.
        _,cmd = parameter_s.split('=',1)
    except ValueError:
        var,cmd = '',''
    # If all looks ok, proceed
    out,err = self.shell.getoutputerror(cmd)
    if err:
        print &gt;&gt; Term.cerr,err
    if opts.has_key('l'):
        out = SList(out.split('\n'))
    else:
        out = LSString(out)
    if opts.has_key('v'):
        print '%s ==\n%s' % (var,pformat(out))
    if var:
        self.shell.user_ns.update({var:out})
    else:
        return out

</t>
<t tx="ekr.20071129105657.493">def magic_sx(self, parameter_s=''):
    """Shell execute - run a shell command and capture its output.

    %sx command

    IPython will run the given command using commands.getoutput(), and
    return the result formatted as a list (split on '\\n').  Since the
    output is _returned_, it will be stored in ipython's regular output
    cache Out[N] and in the '_N' automatic variables.

    Notes:

    1) If an input line begins with '!!', then %sx is automatically
    invoked.  That is, while:
      !ls
    causes ipython to simply issue system('ls'), typing
      !!ls
    is a shorthand equivalent to:
      %sx ls
    
    2) %sx differs from %sc in that %sx automatically splits into a list,
    like '%sc -l'.  The reason for this is to make it as easy as possible
    to process line-oriented shell output via further python commands.
    %sc is meant to provide much finer control, but requires more
    typing.

    3) Just like %sc -l, this is a list with special attributes:

      .l (or .list) : value as list.
      .n (or .nlstr): value as newline-separated string.
      .s (or .spstr): value as whitespace-separated string.

    This is very useful when trying to use such lists as arguments to
    system commands."""

    if parameter_s:
        out,err = self.shell.getoutputerror(parameter_s)
        if err:
            print &gt;&gt; Term.cerr,err
        return SList(out.split('\n'))

</t>
<t tx="ekr.20071129105657.494">def magic_bg(self, parameter_s=''):
    """Run a job in the background, in a separate thread.

    For example,

      %bg myfunc(x,y,z=1)

    will execute 'myfunc(x,y,z=1)' in a background thread.  As soon as the
    execution starts, a message will be printed indicating the job
    number.  If your job number is 5, you can use

      myvar = jobs.result(5)  or  myvar = jobs[5].result

    to assign this result to variable 'myvar'.

    IPython has a job manager, accessible via the 'jobs' object.  You can
    type jobs? to get more information about it, and use jobs.&lt;TAB&gt; to see
    its attributes.  All attributes not starting with an underscore are
    meant for public use.

    In particular, look at the jobs.new() method, which is used to create
    new jobs.  This magic %bg function is just a convenience wrapper
    around jobs.new(), for expression-based jobs.  If you want to create a
    new job with an explicit function object and arguments, you must call
    jobs.new() directly.

    The jobs.new docstring also describes in detail several important
    caveats associated with a thread-based model for background job
    execution.  Type jobs.new? for details.

    You can check the status of all jobs with jobs.status().

    The jobs variable is set by IPython into the Python builtin namespace.
    If you ever declare a variable named 'jobs', you will shadow this
    name.  You can either delete your global jobs variable to regain
    access to the job manager, or make a new name and assign it manually
    to the manager (stored in IPython's namespace).  For example, to
    assign the job manager to the Jobs name, use:

      Jobs = __builtins__.jobs"""
    
    self.shell.jobs.new(parameter_s,self.shell.user_ns)
    

</t>
<t tx="ekr.20071129105657.495">def magic_bookmark(self, parameter_s=''):
    """Manage IPython's bookmark system.

    %bookmark &lt;name&gt;       - set bookmark to current dir
    %bookmark &lt;name&gt; &lt;dir&gt; - set bookmark to &lt;dir&gt;
    %bookmark -l           - list all bookmarks
    %bookmark -d &lt;name&gt;    - remove bookmark
    %bookmark -r           - remove all bookmarks

    You can later on access a bookmarked folder with:
      %cd -b &lt;name&gt;
    or simply '%cd &lt;name&gt;' if there is no directory called &lt;name&gt; AND
    there is such a bookmark defined.

    Your bookmarks persist through IPython sessions, but they are
    associated with each profile."""

    opts,args = self.parse_options(parameter_s,'drl',mode='list')
    if len(args) &gt; 2:
        error('You can only give at most two arguments')
        return

    bkms = self.db.get('bookmarks',{})
        
    if opts.has_key('d'):
        try:
            todel = args[0]
        except IndexError:
            error('You must provide a bookmark to delete')
        else:
            try:
                del bkms[todel]
            except:
                error("Can't delete bookmark '%s'" % todel)
    elif opts.has_key('r'):
        bkms = {}
    elif opts.has_key('l'):
        bks = bkms.keys()
        bks.sort()
        if bks:
            size = max(map(len,bks))
        else:
            size = 0
        fmt = '%-'+str(size)+'s -&gt; %s'
        print 'Current bookmarks:'
        for bk in bks:
            print fmt % (bk,bkms[bk])
    else:
        if not args:
            error("You must specify the bookmark name")
        elif len(args)==1:
            bkms[args[0]] = os.getcwd()
        elif len(args)==2:
            bkms[args[0]] = args[1]
    self.db['bookmarks'] = bkms

</t>
<t tx="ekr.20071129105657.496">def magic_pycat(self, parameter_s=''):
    """Show a syntax-highlighted file through a pager.

    This magic is similar to the cat utility, but it will assume the file
    to be Python source and will show it with syntax highlighting. """
    
    try:
        filename = get_py_filename(parameter_s)
        cont = file_read(filename)
    except IOError:
        try:
            cont = eval(parameter_s,self.user_ns)
        except NameError:
            cont = None
    if cont is None:
        print "Error: no such file or variable"
        return
        
    page(self.shell.pycolorize(cont),
         screen_lines=self.shell.rc.screen_length)

</t>
<t tx="ekr.20071129105657.497">def magic_cpaste(self, parameter_s=''):
    """Allows you to paste &amp; execute a pre-formatted code block from clipboard
    
    You must terminate the block with '--' (two minus-signs) alone on the
    line. You can also provide your own sentinel with '%paste -s %%' ('%%' 
    is the new sentinel for this operation)
    
    The block is dedented prior to execution to enable execution of 
    method definitions. '&gt;' characters at the beginning of a line is
    ignored, to allow pasting directly from e-mails. The executed block
    is also assigned to variable named 'pasted_block' for later editing
    with '%edit pasted_block'.
    
    You can also pass a variable name as an argument, e.g. '%cpaste foo'.
    This assigns the pasted block to variable 'foo' as string, without 
    dedenting or executing it.
    
    Do not be alarmed by garbled output on Windows (it's a readline bug). 
    Just press enter and type -- (and press enter again) and the block 
    will be what was just pasted.
    
    IPython statements (magics, shell escapes) are not supported (yet).
    """
    opts,args = self.parse_options(parameter_s,'s:',mode='string')
    par = args.strip()
    sentinel = opts.get('s','--')
    
    from IPython import iplib
    lines = []
    print "Pasting code; enter '%s' alone on the line to stop." % sentinel
    while 1:
        l = iplib.raw_input_original(':')
        if l ==sentinel:
            break
        lines.append(l.lstrip('&gt;'))
    block = "\n".join(lines) + '\n'
    #print "block:\n",block
    if not par:
        b = textwrap.dedent(block)
        exec b in self.user_ns            
        self.user_ns['pasted_block'] = b
    else:
        self.user_ns[par] = block
        print "Block assigned to '%s'" % par
        
</t>
<t tx="ekr.20071129105657.498">def magic_quickref(self,arg):
    """ Show a quick reference sheet """
    import IPython.usage
    qr = IPython.usage.quick_reference + self.magic_magic('-brief')
    
    page(qr)
    
</t>
<t tx="ekr.20071129105657.499">def magic_upgrade(self,arg):
    """ Upgrade your IPython installation
    
    This will copy the config files that don't yet exist in your 
    ipython dir from the system config dir. Use this after upgrading 
    IPython if you don't wish to delete your .ipython dir.

    Call with -nolegacy to get rid of ipythonrc* files (recommended for
    new users)

    """
    ip = self.getapi()
    ipinstallation = path(IPython.__file__).dirname()
    upgrade_script = '%s "%s"' % (sys.executable,ipinstallation / 'upgrade_dir.py')
    src_config = ipinstallation / 'UserConfig'
    userdir = path(ip.options.ipythondir)
    cmd = '%s "%s" "%s"' % (upgrade_script, src_config, userdir)
    print "&gt;",cmd
    shell(cmd)
    if arg == '-nolegacy':
        legacy = userdir.files('ipythonrc*')
        print "Nuking legacy files:",legacy
        
        [p.remove() for p in legacy]
        suffix = (sys.platform == 'win32' and '.ini' or '')
        (userdir / ('ipythonrc' + suffix)).write_text('# Empty, see ipy_user_conf.py\n')


</t>
<t tx="ekr.20071129105657.603"># -*- coding: utf-8 -*-
"""IPython Shell classes.

All the matplotlib support code was co-developed with John Hunter,
matplotlib's author.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

# Code begins
import __builtin__
import __main__
import Queue
import os
import signal
import sys
import threading
import time

import IPython
from IPython import ultraTB
from IPython.genutils import Term,warn,error,flag_calls
from IPython.iplib import InteractiveShell
from IPython.ipmaker import make_IPython
from IPython.Magic import Magic
from IPython.ipstruct import Struct

# global flag to pass around information about Ctrl-C without exceptions
KBINT = False

# global flag to turn on/off Tk support.
USE_TK = False

</t>
<t tx="ekr.20071129105657.604">#-----------------------------------------------------------------------------
# This class is trivial now, but I want to have it in to publish a clean
# interface. Later when the internals are reorganized, code that uses this
# shouldn't have to change.

class IPShell:
    """Create an IPython instance."""
    @others
</t>
<t tx="ekr.20071129105657.605">
def __init__(self,argv=None,user_ns=None,user_global_ns=None,
             debug=1,shell_class=InteractiveShell):
    self.IP = make_IPython(argv,user_ns=user_ns,
                           user_global_ns=user_global_ns,
                           debug=debug,shell_class=shell_class)

</t>
<t tx="ekr.20071129105657.606">def mainloop(self,sys_exit=0,banner=None):
    self.IP.mainloop(banner)
    if sys_exit:
        sys.exit()

</t>
<t tx="ekr.20071129105657.607">#-----------------------------------------------------------------------------
class IPShellEmbed:
    """Allow embedding an IPython shell into a running program.

    Instances of this class are callable, with the __call__ method being an
    alias to the embed() method of an InteractiveShell instance.

    Usage (see also the example-embed.py file for a running example):

    ipshell = IPShellEmbed([argv,banner,exit_msg,rc_override])

    - argv: list containing valid command-line options for IPython, as they
    would appear in sys.argv[1:].

    For example, the following command-line options:

      $ ipython -prompt_in1 'Input &lt;\\#&gt;' -colors LightBG

    would be passed in the argv list as:

      ['-prompt_in1','Input &lt;\\#&gt;','-colors','LightBG']

    - banner: string which gets printed every time the interpreter starts.

    - exit_msg: string which gets printed every time the interpreter exits.

    - rc_override: a dict or Struct of configuration options such as those
    used by IPython. These options are read from your ~/.ipython/ipythonrc
    file when the Shell object is created. Passing an explicit rc_override
    dict with any options you want allows you to override those values at
    creation time without having to modify the file. This way you can create
    embeddable instances configured in any way you want without editing any
    global files (thus keeping your interactive IPython configuration
    unchanged).

    Then the ipshell instance can be called anywhere inside your code:
    
    ipshell(header='') -&gt; Opens up an IPython shell.

    - header: string printed by the IPython shell upon startup. This can let
    you know where in your code you are when dropping into the shell. Note
    that 'banner' gets prepended to all calls, so header is used for
    location-specific information.

    For more details, see the __call__ method below.

    When the IPython shell is exited with Ctrl-D, normal program execution
    resumes.

    This functionality was inspired by a posting on comp.lang.python by cmkl
    &lt;cmkleffner@gmx.de&gt; on Dec. 06/01 concerning similar uses of pyrepl, and
    by the IDL stop/continue commands."""
    @others
</t>
<t tx="ekr.20071129105657.608">
def __init__(self,argv=None,banner='',exit_msg=None,rc_override=None,
             user_ns=None):
    """Note that argv here is a string, NOT a list."""
    self.set_banner(banner)
    self.set_exit_msg(exit_msg)
    self.set_dummy_mode(0)

    # sys.displayhook is a global, we need to save the user's original
    # Don't rely on __displayhook__, as the user may have changed that.
    self.sys_displayhook_ori = sys.displayhook

    # save readline completer status
    try:
        #print 'Save completer',sys.ipcompleter  # dbg
        self.sys_ipcompleter_ori = sys.ipcompleter
    except:
        pass # not nested with IPython
    
    self.IP = make_IPython(argv,rc_override=rc_override,
                           embedded=True,
                           user_ns=user_ns)

    # copy our own displayhook also
    self.sys_displayhook_embed = sys.displayhook
    # and leave the system's display hook clean
    sys.displayhook = self.sys_displayhook_ori
    # don't use the ipython crash handler so that user exceptions aren't
    # trapped
    sys.excepthook = ultraTB.FormattedTB(color_scheme = self.IP.rc.colors,
                                         mode = self.IP.rc.xmode,
                                         call_pdb = self.IP.rc.pdb)
    self.restore_system_completer()

</t>
<t tx="ekr.20071129105657.609">def restore_system_completer(self):
    """Restores the readline completer which was in place.

    This allows embedded IPython within IPython not to disrupt the
    parent's completion.
    """
    
    try:
        self.IP.readline.set_completer(self.sys_ipcompleter_ori)
        sys.ipcompleter = self.sys_ipcompleter_ori
    except:
        pass

</t>
<t tx="ekr.20071129105657.610">def __call__(self,header='',local_ns=None,global_ns=None,dummy=None):
    """Activate the interactive interpreter.

    __call__(self,header='',local_ns=None,global_ns,dummy=None) -&gt; Start
    the interpreter shell with the given local and global namespaces, and
    optionally print a header string at startup.

    The shell can be globally activated/deactivated using the
    set/get_dummy_mode methods. This allows you to turn off a shell used
    for debugging globally.

    However, *each* time you call the shell you can override the current
    state of dummy_mode with the optional keyword parameter 'dummy'. For
    example, if you set dummy mode on with IPShell.set_dummy_mode(1), you
    can still have a specific call work by making it as IPShell(dummy=0).

    The optional keyword parameter dummy controls whether the call
    actually does anything.  """

    # Allow the dummy parameter to override the global __dummy_mode
    if dummy or (dummy != 0 and self.__dummy_mode):
        return

    # Set global subsystems (display,completions) to our values
    sys.displayhook = self.sys_displayhook_embed
    if self.IP.has_readline:
        self.IP.readline.set_completer(self.IP.Completer.complete)

    if self.banner and header:
        format = '%s\n%s\n'
    else:
        format = '%s%s\n'
    banner =  format % (self.banner,header)

    # Call the embedding code with a stack depth of 1 so it can skip over
    # our call and get the original caller's namespaces.
    self.IP.embed_mainloop(banner,local_ns,global_ns,stack_depth=1)

    if self.exit_msg:
        print self.exit_msg
        
    # Restore global systems (display, completion)
    sys.displayhook = self.sys_displayhook_ori
    self.restore_system_completer()

</t>
<t tx="ekr.20071129105657.611">def set_dummy_mode(self,dummy):
    """Sets the embeddable shell's dummy mode parameter.

    set_dummy_mode(dummy): dummy = 0 or 1.

    This parameter is persistent and makes calls to the embeddable shell
    silently return without performing any action. This allows you to
    globally activate or deactivate a shell you're using with a single call.

    If you need to manually"""

    if dummy not in [0,1,False,True]:
        raise ValueError,'dummy parameter must be boolean'
    self.__dummy_mode = dummy

</t>
<t tx="ekr.20071129105657.612">def get_dummy_mode(self):
    """Return the current value of the dummy mode parameter.
    """
    return self.__dummy_mode

</t>
<t tx="ekr.20071129105657.613">def set_banner(self,banner):
    """Sets the global banner.

    This banner gets prepended to every header printed when the shell
    instance is called."""

    self.banner = banner

</t>
<t tx="ekr.20071129105657.614">def set_exit_msg(self,exit_msg):
    """Sets the global exit_msg.

    This exit message gets printed upon exiting every time the embedded
    shell is called. It is None by default. """

    self.exit_msg = exit_msg

</t>
<t tx="ekr.20071129105657.615">#-----------------------------------------------------------------------------
def sigint_handler (signum,stack_frame):
    """Sigint handler for threaded apps.

    This is a horrible hack to pass information about SIGINT _without_ using
    exceptions, since I haven't been able to properly manage cross-thread
    exceptions in GTK/WX.  In fact, I don't think it can be done (or at least
    that's my understanding from a c.l.py thread where this was discussed)."""

    global KBINT
    
    print '\nKeyboardInterrupt - Press &lt;Enter&gt; to continue.',
    Term.cout.flush()
    # Set global flag so that runsource can know that Ctrl-C was hit
    KBINT = True

</t>
<t tx="ekr.20071129105657.616">class MTInteractiveShell(InteractiveShell):
    """Simple multi-threaded shell."""

    # Threading strategy taken from:
    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/65109, by Brian
    # McErlean and John Finlay.  Modified with corrections by Antoon Pardon,
    # from the pygtk mailing list, to avoid lockups with system calls.

    # class attribute to indicate whether the class supports threads or not.
    # Subclasses with thread support should override this as needed.
    isthreaded = True

    @others
</t>
<t tx="ekr.20071129105657.617">def __init__(self,name,usage=None,rc=Struct(opts=None,args=None),
             user_ns=None,user_global_ns=None,banner2='',**kw):
    """Similar to the normal InteractiveShell, but with threading control"""
    
    InteractiveShell.__init__(self,name,usage,rc,user_ns,
                              user_global_ns,banner2)

    # Locking control variable.  We need to use a norma lock, not an RLock
    # here.  I'm not exactly sure why, it seems to me like it should be
    # the opposite, but we deadlock with an RLock.  Puzzled...
    self.thread_ready = threading.Condition(threading.Lock())

    # A queue to hold the code to be executed.  A scalar variable is NOT
    # enough, because uses like macros cause reentrancy.
    self.code_queue = Queue.Queue()
    
    # Stuff to do at closing time
    self._kill = False
    on_kill = kw.get('on_kill')
    if on_kill is None:
        on_kill = []
    # Check that all things to kill are callable:
    for t in on_kill:
        if not callable(t):
            raise TypeError,'on_kill must be a list of callables'
    self.on_kill = on_kill

</t>
<t tx="ekr.20071129105657.618">def runsource(self, source, filename="&lt;input&gt;", symbol="single"):
    """Compile and run some source in the interpreter.

    Modified version of code.py's runsource(), to handle threading issues.
    See the original for full docstring details."""

    global KBINT
    
    # If Ctrl-C was typed, we reset the flag and return right away
    if KBINT:
        KBINT = False
        return False
    
    try:
        code = self.compile(source, filename, symbol)
    except (OverflowError, SyntaxError, ValueError):
        # Case 1
        self.showsyntaxerror(filename)
        return False

    if code is None:
        # Case 2
        return True

    # Case 3
    # Store code in queue, so the execution thread can handle it.

    # Note that with macros and other applications, we MAY re-enter this
    # section, so we have to acquire the lock with non-blocking semantics,
    # else we deadlock.
    got_lock = self.thread_ready.acquire(False)
    self.code_queue.put(code)
    if got_lock:
        self.thread_ready.wait()  # Wait until processed in timeout interval
        self.thread_ready.release()

    return False

</t>
<t tx="ekr.20071129105657.619">def runcode(self):
    """Execute a code object.

    Multithreaded wrapper around IPython's runcode()."""

    # lock thread-protected stuff
    got_lock = self.thread_ready.acquire(False)

    # Install sigint handler
    try:
        signal.signal(signal.SIGINT, sigint_handler)
    except SystemError:
        # This happens under Windows, which seems to have all sorts
        # of problems with signal handling.  Oh well...
        pass

    if self._kill:
        print &gt;&gt;Term.cout, 'Closing threads...',
        Term.cout.flush()
        for tokill in self.on_kill:
            tokill()
        print &gt;&gt;Term.cout, 'Done.'

    # Flush queue of pending code by calling the run methood of the parent
    # class with all items which may be in the queue.
    while 1:
        try:
            code_to_run = self.code_queue.get_nowait()
        except Queue.Empty:
            break
        if got_lock:
            self.thread_ready.notify()
            InteractiveShell.runcode(self,code_to_run)
        else:
            break
        
    # We're done with thread-protected variables
    if got_lock:
        self.thread_ready.release()
    # This MUST return true for gtk threading to work
    return True

</t>
<t tx="ekr.20071129105657.620">def kill(self):
    """Kill the thread, returning when it has been shut down."""
    got_lock = self.thread_ready.acquire(False)
    self._kill = True
    if got_lock:
        self.thread_ready.release()

</t>
<t tx="ekr.20071129105657.621">class MatplotlibShellBase:
    """Mixin class to provide the necessary modifications to regular IPython
    shell classes for matplotlib support.

    Given Python's MRO, this should be used as the FIRST class in the
    inheritance hierarchy, so that it overrides the relevant methods."""
    @others
    # Fix the docstring so users see the original as well
    magic_run.__doc__ = "%s\n%s" % (Magic.magic_run.__doc__,
                                    "\n        *** Modified %run for Matplotlib,"
                                    " with proper interactive handling ***")

</t>
<t tx="ekr.20071129105657.622">
def _matplotlib_config(self,name,user_ns):
    """Return items needed to setup the user's shell with matplotlib"""

    # Initialize matplotlib to interactive mode always
    import matplotlib
    from matplotlib import backends
    matplotlib.interactive(True)

    def use(arg):
        """IPython wrapper for matplotlib's backend switcher.

        In interactive use, we can not allow switching to a different
        interactive backend, since thread conflicts will most likely crash
        the python interpreter.  This routine does a safety check first,
        and refuses to perform a dangerous switch.  It still allows
        switching to non-interactive backends."""

        if arg in backends.interactive_bk and arg != self.mpl_backend:
            m=('invalid matplotlib backend switch.\n'
               'This script attempted to switch to the interactive '
               'backend: `%s`\n'
               'Your current choice of interactive backend is: `%s`\n\n'
               'Switching interactive matplotlib backends at runtime\n'
               'would crash the python interpreter, '
               'and IPython has blocked it.\n\n'
               'You need to either change your choice of matplotlib backend\n'
               'by editing your .matplotlibrc file, or run this script as a \n'
               'standalone file from the command line, not using IPython.\n' %
               (arg,self.mpl_backend) )
            raise RuntimeError, m
        else:
            self.mpl_use(arg)
            self.mpl_use._called = True
    
    self.matplotlib = matplotlib
    self.mpl_backend = matplotlib.rcParams['backend']

    # we also need to block switching of interactive backends by use()
    self.mpl_use = matplotlib.use
    self.mpl_use._called = False
    # overwrite the original matplotlib.use with our wrapper
    matplotlib.use = use

    # This must be imported last in the matplotlib series, after
    # backend/interactivity choices have been made
    import matplotlib.pylab as pylab
    self.pylab = pylab

    self.pylab.show._needmain = False
    # We need to detect at runtime whether show() is called by the user.
    # For this, we wrap it into a decorator which adds a 'called' flag.
    self.pylab.draw_if_interactive = flag_calls(self.pylab.draw_if_interactive)

    # Build a user namespace initialized with matplotlib/matlab features.
    user_ns = IPython.ipapi.make_user_ns(user_ns)

    exec ("import matplotlib\n"
          "import matplotlib.pylab as pylab\n"
          "from matplotlib.pylab import *") in user_ns
    
    # Build matplotlib info banner
    b="""
Welcome to pylab, a matplotlib-based Python environment.
For more information, type 'help(pylab)'.
"""
    return user_ns,b

</t>
<t tx="ekr.20071129105657.623">def mplot_exec(self,fname,*where,**kw):
    """Execute a matplotlib script.

    This is a call to execfile(), but wrapped in safeties to properly
    handle interactive rendering and backend switching."""

    #print '*** Matplotlib runner ***' # dbg
    # turn off rendering until end of script
    isInteractive = self.matplotlib.rcParams['interactive']
    self.matplotlib.interactive(False)
    self.safe_execfile(fname,*where,**kw)
    self.matplotlib.interactive(isInteractive)
    # make rendering call now, if the user tried to do it
    if self.pylab.draw_if_interactive.called:
        self.pylab.draw()
        self.pylab.draw_if_interactive.called = False
            
    # if a backend switch was performed, reverse it now
    if self.mpl_use._called:
        self.matplotlib.rcParams['backend'] = self.mpl_backend
    
</t>
<t tx="ekr.20071129105657.624">def magic_run(self,parameter_s=''):
    Magic.magic_run(self,parameter_s,runner=self.mplot_exec)

</t>
<t tx="ekr.20071129105657.625"># Now we provide 2 versions of a matplotlib-aware IPython base shells, single
# and multithreaded.  Note that these are meant for internal use, the IPShell*
# classes below are the ones meant for public consumption.

class MatplotlibShell(MatplotlibShellBase,InteractiveShell):
    """Single-threaded shell with matplotlib support."""
    @others
</t>
<t tx="ekr.20071129105657.626">
def __init__(self,name,usage=None,rc=Struct(opts=None,args=None),
             user_ns=None,user_global_ns=None,**kw):
    user_ns,b2 = self._matplotlib_config(name,user_ns)
    InteractiveShell.__init__(self,name,usage,rc,user_ns,user_global_ns,
                              banner2=b2,**kw)

</t>
<t tx="ekr.20071129105657.627">class MatplotlibMTShell(MatplotlibShellBase,MTInteractiveShell):
    """Multi-threaded shell with matplotlib support."""
    @others
</t>
<t tx="ekr.20071129105657.628">
def __init__(self,name,usage=None,rc=Struct(opts=None,args=None),
             user_ns=None,user_global_ns=None, **kw):
    user_ns,b2 = self._matplotlib_config(name,user_ns)
    MTInteractiveShell.__init__(self,name,usage,rc,user_ns,user_global_ns,
                                banner2=b2,**kw)

</t>
<t tx="ekr.20071129105657.629">#-----------------------------------------------------------------------------
# Utility functions for the different GUI enabled IPShell* classes.

def get_tk():
    """Tries to import Tkinter and returns a withdrawn Tkinter root
    window.  If Tkinter is already imported or not available, this
    returns None.  This function calls `hijack_tk` underneath.
    """
    if not USE_TK or sys.modules.has_key('Tkinter'):
        return None
    else:
        try:
            import Tkinter
        except ImportError:
            return None
        else:
            hijack_tk()
            r = Tkinter.Tk()
            r.withdraw()
            return r

</t>
<t tx="ekr.20071129105657.630">def hijack_tk():
    """Modifies Tkinter's mainloop with a dummy so when a module calls
    mainloop, it does not block.

    """
    def misc_mainloop(self, n=0):
        pass
    def tkinter_mainloop(n=0):
        pass
    
    import Tkinter
    Tkinter.Misc.mainloop = misc_mainloop
    Tkinter.mainloop = tkinter_mainloop

</t>
<t tx="ekr.20071129105657.631">def update_tk(tk):
    """Updates the Tkinter event loop.  This is typically called from
    the respective WX or GTK mainloops.
    """    
    if tk:
        tk.update()

</t>
<t tx="ekr.20071129105657.632">def hijack_wx():
    """Modifies wxPython's MainLoop with a dummy so user code does not
    block IPython.  The hijacked mainloop function is returned.
    """    
    def dummy_mainloop(*args, **kw):
        pass
    import wxPython
    ver = wxPython.__version__
    orig_mainloop = None
    if ver[:3] &gt;= '2.5':
        import wx
        if hasattr(wx, '_core_'): core = getattr(wx, '_core_')
        elif hasattr(wx, '_core'): core = getattr(wx, '_core')
        else: raise AttributeError('Could not find wx core module')
        orig_mainloop = core.PyApp_MainLoop
        core.PyApp_MainLoop = dummy_mainloop
    elif ver[:3] == '2.4':
        orig_mainloop = wxPython.wxc.wxPyApp_MainLoop
        wxPython.wxc.wxPyApp_MainLoop = dummy_mainloop
    else:
        warn("Unable to find either wxPython version 2.4 or &gt;= 2.5.")
    return orig_mainloop

</t>
<t tx="ekr.20071129105657.633">def hijack_gtk():
    """Modifies pyGTK's mainloop with a dummy so user code does not
    block IPython.  This function returns the original `gtk.mainloop`
    function that has been hijacked.
    """    
    def dummy_mainloop(*args, **kw):
        pass
    import gtk
    if gtk.pygtk_version &gt;= (2,4,0): orig_mainloop = gtk.main
    else:                            orig_mainloop = gtk.mainloop
    gtk.mainloop = dummy_mainloop
    gtk.main = dummy_mainloop
    return orig_mainloop

</t>
<t tx="ekr.20071129105657.634">#-----------------------------------------------------------------------------
# The IPShell* classes below are the ones meant to be run by external code as
# IPython instances.  Note that unless a specific threading strategy is
# desired, the factory function start() below should be used instead (it
# selects the proper threaded class).

class IPShellGTK(threading.Thread):
    """Run a gtk mainloop() in a separate thread.
    
    Python commands can be passed to the thread where they will be executed.
    This is implemented by periodically checking for passed code using a
    GTK timeout callback."""
    
    TIMEOUT = 100 # Millisecond interval between timeouts.

    @others
</t>
<t tx="ekr.20071129105657.635">def __init__(self,argv=None,user_ns=None,user_global_ns=None,
             debug=1,shell_class=MTInteractiveShell):

    import gtk
    
    self.gtk = gtk
    self.gtk_mainloop = hijack_gtk()

    # Allows us to use both Tk and GTK.
    self.tk = get_tk()
    
    if gtk.pygtk_version &gt;= (2,4,0): mainquit = self.gtk.main_quit
    else:                            mainquit = self.gtk.mainquit

    self.IP = make_IPython(argv,user_ns=user_ns,
                           user_global_ns=user_global_ns,
                           debug=debug,
                           shell_class=shell_class,
                           on_kill=[mainquit])

    # HACK: slot for banner in self; it will be passed to the mainloop
    # method only and .run() needs it.  The actual value will be set by
    # .mainloop().
    self._banner = None 

    threading.Thread.__init__(self)

</t>
<t tx="ekr.20071129105657.636">def run(self):
    self.IP.mainloop(self._banner)
    self.IP.kill()

</t>
<t tx="ekr.20071129105657.637">def mainloop(self,sys_exit=0,banner=None):

    self._banner = banner
    
    if self.gtk.pygtk_version &gt;= (2,4,0):
        import gobject
        gobject.idle_add(self.on_timer)
    else:
        self.gtk.idle_add(self.on_timer)

    if sys.platform != 'win32':
        try:
            if self.gtk.gtk_version[0] &gt;= 2:
                self.gtk.threads_init()
        except AttributeError:
            pass
        except RuntimeError:
            error('Your pyGTK likely has not been compiled with '
                  'threading support.\n'
                  'The exception printout is below.\n'
                  'You can either rebuild pyGTK with threads, or '
                  'try using \n'
                  'matplotlib with a different backend (like Tk or WX).\n'
                  'Note that matplotlib will most likely not work in its '
                  'current state!')
            self.IP.InteractiveTB()
    self.start()
    self.gtk.threads_enter()
    self.gtk_mainloop()
    self.gtk.threads_leave()
    self.join()

</t>
<t tx="ekr.20071129105657.638">def on_timer(self):
    """Called when GTK is idle.

    Must return True always, otherwise GTK stops calling it"""
    
    update_tk(self.tk)
    self.IP.runcode()
    time.sleep(0.01)
    return True

</t>
<t tx="ekr.20071129105657.639">class IPShellWX(threading.Thread):
    """Run a wx mainloop() in a separate thread.
    
    Python commands can be passed to the thread where they will be executed.
    This is implemented by periodically checking for passed code using a
    GTK timeout callback."""
    
    TIMEOUT = 100 # Millisecond interval between timeouts.

    @others
</t>
<t tx="ekr.20071129105657.640">def __init__(self,argv=None,user_ns=None,user_global_ns=None,
             debug=1,shell_class=MTInteractiveShell):

    self.IP = make_IPython(argv,user_ns=user_ns,
                           user_global_ns=user_global_ns,
                           debug=debug,
                           shell_class=shell_class,
                           on_kill=[self.wxexit])

    wantedwxversion=self.IP.rc.wxversion
    if wantedwxversion!="0":
        try:
            import wxversion
        except ImportError:
            error('The wxversion module is needed for WX version selection')
        else:
            try:
                wxversion.select(wantedwxversion)
            except:
                self.IP.InteractiveTB()
                error('Requested wxPython version %s could not be loaded' %
                                                           wantedwxversion)

    import wxPython.wx as wx

    threading.Thread.__init__(self)
    self.wx = wx
    self.wx_mainloop = hijack_wx()

    # Allows us to use both Tk and GTK.
    self.tk = get_tk()
    
    
    # HACK: slot for banner in self; it will be passed to the mainloop
    # method only and .run() needs it.  The actual value will be set by
    # .mainloop().
    self._banner = None 

    self.app = None

</t>
<t tx="ekr.20071129105657.641">def wxexit(self, *args):
    if self.app is not None:
        self.app.agent.timer.Stop()
        self.app.ExitMainLoop()

</t>
<t tx="ekr.20071129105657.642">def run(self):
    self.IP.mainloop(self._banner)
    self.IP.kill()

</t>
<t tx="ekr.20071129105657.643">def mainloop(self,sys_exit=0,banner=None):

    self._banner = banner
    
    self.start()

    class TimerAgent(self.wx.wxMiniFrame):
        wx = self.wx
        IP = self.IP
        tk = self.tk
        def __init__(self, parent, interval):
            style = self.wx.wxDEFAULT_FRAME_STYLE | self.wx.wxTINY_CAPTION_HORIZ
            self.wx.wxMiniFrame.__init__(self, parent, -1, ' ', pos=(200, 200),
                                         size=(100, 100),style=style)
            self.Show(False)
            self.interval = interval
            self.timerId = self.wx.wxNewId()                                

        def StartWork(self):
            self.timer = self.wx.wxTimer(self, self.timerId)
            self.wx.EVT_TIMER(self,  self.timerId, self.OnTimer)
            self.timer.Start(self.interval)

        def OnTimer(self, event):
            update_tk(self.tk)
            self.IP.runcode()

    class App(self.wx.wxApp):
        wx = self.wx
        TIMEOUT = self.TIMEOUT
        def OnInit(self):
            'Create the main window and insert the custom frame'
            self.agent = TimerAgent(None, self.TIMEOUT)
            self.agent.Show(self.wx.false)
            self.agent.StartWork()
            return self.wx.true
    
    self.app = App(redirect=False)
    self.wx_mainloop(self.app)
    self.join()


</t>
<t tx="ekr.20071129105657.644">class IPShellQt(threading.Thread):
    """Run a Qt event loop in a separate thread.
    
    Python commands can be passed to the thread where they will be executed.
    This is implemented by periodically checking for passed code using a
    Qt timer / slot."""
    
    TIMEOUT = 100 # Millisecond interval between timeouts.

    @others
</t>
<t tx="ekr.20071129105657.645">def __init__(self,argv=None,user_ns=None,user_global_ns=None,
             debug=0,shell_class=MTInteractiveShell):
    
    import qt

    class newQApplication:
        def __init__( self ):
            self.QApplication = qt.QApplication
            
        def __call__( *args, **kwargs ):
            return qt.qApp

        def exec_loop( *args, **kwargs ):
            pass

        def __getattr__( self, name ):
            return getattr( self.QApplication, name )
      
    qt.QApplication = newQApplication()

    # Allows us to use both Tk and QT.
    self.tk = get_tk()

    self.IP = make_IPython(argv,user_ns=user_ns,
                           user_global_ns=user_global_ns,
                           debug=debug,
                           shell_class=shell_class,
                           on_kill=[qt.qApp.exit])

    # HACK: slot for banner in self; it will be passed to the mainloop
    # method only and .run() needs it.  The actual value will be set by
    # .mainloop().
    self._banner = None 
    
    threading.Thread.__init__(self)

</t>
<t tx="ekr.20071129105657.646">def run(self):
    self.IP.mainloop(self._banner)
    self.IP.kill()

</t>
<t tx="ekr.20071129105657.647">def mainloop(self,sys_exit=0,banner=None):

    import qt

    self._banner = banner

    if qt.QApplication.startingUp():
      a = qt.QApplication.QApplication(sys.argv)
    self.timer = qt.QTimer()
    qt.QObject.connect( self.timer, qt.SIGNAL( 'timeout()' ), self.on_timer )

    self.start()
    self.timer.start( self.TIMEOUT, True )
    while True:
        if self.IP._kill: break
        qt.qApp.exec_loop()
    self.join()

</t>
<t tx="ekr.20071129105657.648">def on_timer(self):
    update_tk(self.tk)
    result = self.IP.runcode()
    self.timer.start( self.TIMEOUT, True )
    return result


</t>
<t tx="ekr.20071129105657.649">class IPShellQt4(threading.Thread):
    """Run a Qt event loop in a separate thread.

    Python commands can be passed to the thread where they will be executed.
    This is implemented by periodically checking for passed code using a
    Qt timer / slot."""

    TIMEOUT = 100 # Millisecond interval between timeouts.

    @others
</t>
<t tx="ekr.20071129105657.650">def __init__(self,argv=None,user_ns=None,user_global_ns=None,
             debug=0,shell_class=MTInteractiveShell):

    from PyQt4 import QtCore, QtGui

    class newQApplication:
        def __init__( self ):
            self.QApplication = QtGui.QApplication

        def __call__( *args, **kwargs ):
            return QtGui.qApp

        def exec_loop( *args, **kwargs ):
            pass

        def __getattr__( self, name ):
            return getattr( self.QApplication, name )

    QtGui.QApplication = newQApplication()

    # Allows us to use both Tk and QT.
    self.tk = get_tk()

    self.IP = make_IPython(argv,user_ns=user_ns,
                           user_global_ns=user_global_ns,
                           debug=debug,
                           shell_class=shell_class,
                           on_kill=[QtGui.qApp.exit])

    # HACK: slot for banner in self; it will be passed to the mainloop
    # method only and .run() needs it.  The actual value will be set by
    # .mainloop().
    self._banner = None

    threading.Thread.__init__(self)

</t>
<t tx="ekr.20071129105657.651">def run(self):
    self.IP.mainloop(self._banner)
    self.IP.kill()

</t>
<t tx="ekr.20071129105657.652">def mainloop(self,sys_exit=0,banner=None):

    from PyQt4 import QtCore, QtGui

    self._banner = banner

    if QtGui.QApplication.startingUp():
      a = QtGui.QApplication.QApplication(sys.argv)
    self.timer = QtCore.QTimer()
    QtCore.QObject.connect( self.timer, QtCore.SIGNAL( 'timeout()' ), self.on_timer )

    self.start()
    self.timer.start( self.TIMEOUT )
    while True:
        if self.IP._kill: break
        QtGui.qApp.exec_()
    self.join()

</t>
<t tx="ekr.20071129105657.653">def on_timer(self):
    update_tk(self.tk)
    result = self.IP.runcode()
    self.timer.start( self.TIMEOUT )
    return result


</t>
<t tx="ekr.20071129105657.654"># A set of matplotlib public IPython shell classes, for single-threaded
# (Tk* and FLTK* backends) and multithreaded (GTK* and WX* backends) use.
class IPShellMatplotlib(IPShell):
    """Subclass IPShell with MatplotlibShell as the internal shell.

    Single-threaded class, meant for the Tk* and FLTK* backends.

    Having this on a separate class simplifies the external driver code."""
    @others
</t>
<t tx="ekr.20071129105657.655">
def __init__(self,argv=None,user_ns=None,user_global_ns=None,debug=1):
    IPShell.__init__(self,argv,user_ns,user_global_ns,debug,
                     shell_class=MatplotlibShell)

</t>
<t tx="ekr.20071129105657.656">class IPShellMatplotlibGTK(IPShellGTK):
    """Subclass IPShellGTK with MatplotlibMTShell as the internal shell.

    Multi-threaded class, meant for the GTK* backends."""
    @others
</t>
<t tx="ekr.20071129105657.657">
def __init__(self,argv=None,user_ns=None,user_global_ns=None,debug=1):
    IPShellGTK.__init__(self,argv,user_ns,user_global_ns,debug,
                        shell_class=MatplotlibMTShell)

</t>
<t tx="ekr.20071129105657.658">class IPShellMatplotlibWX(IPShellWX):
    """Subclass IPShellWX with MatplotlibMTShell as the internal shell.

    Multi-threaded class, meant for the WX* backends."""
    @others
</t>
<t tx="ekr.20071129105657.659">
def __init__(self,argv=None,user_ns=None,user_global_ns=None,debug=1):
    IPShellWX.__init__(self,argv,user_ns,user_global_ns,debug,
                       shell_class=MatplotlibMTShell)

</t>
<t tx="ekr.20071129105657.660">class IPShellMatplotlibQt(IPShellQt):
    """Subclass IPShellQt with MatplotlibMTShell as the internal shell.

    Multi-threaded class, meant for the Qt* backends."""
    @others
</t>
<t tx="ekr.20071129105657.661">
def __init__(self,argv=None,user_ns=None,user_global_ns=None,debug=1):
    IPShellQt.__init__(self,argv,user_ns,user_global_ns,debug,
                       shell_class=MatplotlibMTShell)

</t>
<t tx="ekr.20071129105657.662">class IPShellMatplotlibQt4(IPShellQt4):
    """Subclass IPShellQt4 with MatplotlibMTShell as the internal shell.

    Multi-threaded class, meant for the Qt4* backends."""
    @others
</t>
<t tx="ekr.20071129105657.663">
def __init__(self,argv=None,user_ns=None,user_global_ns=None,debug=1):
    IPShellQt4.__init__(self,argv,user_ns,user_global_ns,debug,
                       shell_class=MatplotlibMTShell)

</t>
<t tx="ekr.20071129105657.664">#-----------------------------------------------------------------------------
# Factory functions to actually start the proper thread-aware shell

def _matplotlib_shell_class():
    """Factory function to handle shell class selection for matplotlib.

    The proper shell class to use depends on the matplotlib backend, since
    each backend requires a different threading strategy."""

    try:
        import matplotlib
    except ImportError:
        error('matplotlib could NOT be imported!  Starting normal IPython.')
        sh_class = IPShell
    else:
        backend = matplotlib.rcParams['backend']
        if backend.startswith('GTK'):
            sh_class = IPShellMatplotlibGTK
        elif backend.startswith('WX'):
            sh_class = IPShellMatplotlibWX
        elif backend.startswith('Qt4'):
            sh_class = IPShellMatplotlibQt4
        elif backend.startswith('Qt'):
            sh_class = IPShellMatplotlibQt
        else:
            sh_class = IPShellMatplotlib
    #print 'Using %s with the %s backend.' % (sh_class,backend) # dbg
    return sh_class

</t>
<t tx="ekr.20071129105657.665"># This is the one which should be called by external code.
def start(user_ns = None):
    """Return a running shell instance, dealing with threading options.

    This is a factory function which will instantiate the proper IPython shell
    based on the user's threading choice.  Such a selector is needed because
    different GUI toolkits require different thread handling details."""

    global USE_TK
    # Crude sys.argv hack to extract the threading options.
    argv = sys.argv
    if len(argv) &gt; 1:
        if len(argv) &gt; 2:
            arg2 = argv[2]
            if arg2.endswith('-tk'):
                USE_TK = True
        arg1 = argv[1]
        if arg1.endswith('-gthread'):
            shell = IPShellGTK
        elif arg1.endswith( '-qthread' ):
            shell = IPShellQt
        elif arg1.endswith( '-q4thread' ):
            shell = IPShellQt4
        elif arg1.endswith('-wthread'):
            shell = IPShellWX
        elif arg1.endswith('-pylab'):
            shell = _matplotlib_shell_class()
        else:
            shell = IPShell
    else:
        shell = IPShell
    return shell(user_ns = user_ns)

</t>
<t tx="ekr.20071129110439.932">""" Tab completion support for a couple of linux package managers

This is also an example of how to write custom completer plugins
or hooks.

Practical use:

[ipython]|1&gt; import ipy_linux_package_managers
[ipython]|2&gt; apt-get u&lt;&lt;&lt; press tab here &gt;&gt;&gt;
update  upgrade
[ipython]|2&gt; apt-get up

"""
import IPython.ipapi
import glob,os,shlex,sys

ip = IPython.ipapi.get()

</t>
<t tx="ekr.20071129110439.933">def vcs_completer(commands, event):
    """ utility to make writing typical version control app completers easier

    VCS command line apps typically have the format:

    [sudo ]PROGNAME [help] [command] file file...

    """


    cmd_param = event.line.split()
    if event.line.endswith(' '):
        cmd_param.append('')

    if cmd_param[0] == 'sudo':
        cmd_param = cmd_param[1:]

    if len(cmd_param) == 2 or 'help' in cmd_param:
        return commands.split()

    return ip.IP.Completer.file_matches(event.symbol)



</t>
<t tx="ekr.20071129110439.934">def apt_completers(self, event):
    """ This should return a list of strings with possible completions.

    Note that all the included strings that don't start with event.symbol
    are removed, in order to not confuse readline.

    """
    # print event # dbg

    # commands are only suggested for the 'command' part of package manager
    # invocation

    cmd = (event.line + "&lt;placeholder&gt;").rsplit(None,1)[0]
    # print cmd
    if cmd.endswith('apt-get') or cmd.endswith('yum'):
        return ['update', 'upgrade', 'install', 'remove']

    # later on, add dpkg -l / whatever to get list of possible
    # packages, add switches etc. for the rest of command line
    # filling

    raise IPython.ipapi.TryNext


</t>
<t tx="ekr.20071129110439.935"># re_key specifies the regexp that triggers the specified completer

ip.set_hook('complete_command', apt_completers, re_key = '.*apt-get')
ip.set_hook('complete_command', apt_completers, re_key = '.*yum')

pkg_cache = None

def module_completer(self,event):
    """ Give completions after user has typed 'import' """

    # only a local version for py 2.4, pkgutil has no walk_packages() there
    if sys.version_info &lt; (2,5):
        for el in [f[:-3] for f in glob.glob("*.py")]:
            yield el
        return

    global pkg_cache
    import pkgutil,imp,time
    #current =
    if pkg_cache is None:
        print "\n\n[Standby while scanning modules, this can take a while]\n\n"
        pkg_cache = list(pkgutil.walk_packages())

    already = set()
    for ld, name, ispkg in pkg_cache:
        if name.count('.') &lt; event.symbol.count('.') + 1:
            if name not in already:
                already.add(name)
                yield name + (ispkg and '.' or '')
    return

</t>
<t tx="ekr.20071129110439.936">ip.set_hook('complete_command', module_completer, str_key = 'import')
ip.set_hook('complete_command', module_completer, str_key = 'from')

svn_commands = """\
add blame praise annotate ann cat checkout co cleanup commit ci copy
cp delete del remove rm diff di export help ? h import info list ls
lock log merge mkdir move mv rename ren propdel pdel pd propedit pedit
pe propget pget pg proplist plist pl propset pset ps resolved revert
status stat st switch sw unlock update
"""

def svn_completer(self,event):
    return vcs_completer(svn_commands, event)

</t>
<t tx="ekr.20071129110439.937">ip.set_hook('complete_command', svn_completer, str_key = 'svn')

hg_commands = """
add addremove annotate archive backout branch branches bundle cat
clone commit copy diff export grep heads help identify import incoming
init locate log manifest merge outgoing parents paths pull push
qapplied qclone qcommit qdelete qdiff qfold qguard qheader qimport
qinit qnew qnext qpop qprev qpush qrefresh qrename qrestore qsave
qselect qseries qtop qunapplied recover remove rename revert rollback
root serve showconfig status strip tag tags tip unbundle update verify
version
"""

def hg_completer(self,event):
    """ Completer for mercurial commands """

    return vcs_completer(hg_commands, event)

</t>
<t tx="ekr.20071129110439.938">ip.set_hook('complete_command', hg_completer, str_key = 'hg')


bzr_commands = """
add annotate bind branch break-lock bundle-revisions cat check
checkout commit conflicts deleted diff export gannotate gbranch
gcommit gdiff help ignore ignored info init init-repository inventory
log merge missing mkdir mv nick pull push reconcile register-branch
remerge remove renames resolve revert revno root serve sign-my-commits
status testament unbind uncommit unknowns update upgrade version
version-info visualise whoami
"""

def bzr_completer(self,event):
    """ Completer for bazaar commands """
    cmd_param = event.line.split()
    if event.line.endswith(' '):
        cmd_param.append('')

    if len(cmd_param) &gt; 2:
        cmd = cmd_param[1]
        param = cmd_param[-1]
        output_file = (param == '--output=')
        if cmd == 'help':
            return bzr_commands.split()
        elif cmd in ['bundle-revisions','conflicts',
                     'deleted','nick','register-branch',
                     'serve','unbind','upgrade','version',
                     'whoami'] and not output_file:
            return []
        else:
            # the rest are probably file names
            return ip.IP.Completer.file_matches(event.symbol)

    return bzr_commands.split()

</t>
<t tx="ekr.20071129110439.939">ip.set_hook('complete_command', bzr_completer, str_key = 'bzr')


def runlistpy(self, event):
    comps = shlex.split(event.line)
    relpath = (len(comps) &gt; 1 and comps[-1] or '')

    #print "rp",relpath  # dbg
    lglob = glob.glob
    isdir = os.path.isdir
    if relpath.startswith('~'):
        relpath = os.path.expanduser(relpath)
    dirs = [f.replace('\\','/') + "/" for f in lglob(relpath+'*')
            if isdir(f)]
    pys =  [f.replace('\\','/') for f in lglob(relpath+'*.py') + lglob(relpath+'*.ipy')]
    return dirs + pys

</t>
<t tx="ekr.20071129110439.940">ip.set_hook('complete_command', runlistpy, str_key = '%run')

def cd_completer(self, event):
    relpath = event.symbol
    #print event # dbg
    if '-b' in event.line:
        # return only bookmark completions
        bkms = self.db.get('bookmarks',{})
        return bkms.keys()


    if event.symbol == '-':
        # jump in directory history by number
        ents = ['-%d [%s]' % (i,s) for i,s in enumerate(ip.user_ns['_dh'])]
        if len(ents) &gt; 1:
            return ents
        return []

    if relpath.startswith('~'):
        relpath = os.path.expanduser(relpath).replace('\\','/')
    found = []
    for d in [f.replace('\\','/') + '/' for f in glob.glob(relpath+'*')
              if os.path.isdir(f)]:
        if ' ' in d:
            # we don't want to deal with any of that, complex code
            # for this is elsewhere
            raise IPython.ipapi.TryNext
        found.append( d )

    if not found:
        if os.path.isdir(relpath):
            return [relpath]
        raise IPython.ipapi.TryNext
    return found

</t>
<t tx="ekr.20071129110733"></t>
<t tx="ekr.20071129110733.514"></t>
<t tx="ekr.20071129110733.1043"></t>
<t tx="ekr.20071129111837">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129121210">This option has effect only when importing so-called non-strict languages,
for which leading whitespace is not terribly significant.

True: @auto warns about mismatches that occur solely in leading whitespace.</t>
<t tx="ekr.20071129121221"></t>
<t tx="ekr.20071129122202.272">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071129124043">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201082618"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = False

baseDir = r'c:\Python25\Lib\site-packages\pyreadline'
dirs = ('','clipboard','configuration','console','keysyms','lineeditor','modes',)
print '-----'

c.beginUpdate()
try:
    for theDir in dirs:
        pattern = g.os_path_join(baseDir,theDir,'*.py')
        files = glob.glob(pattern)
        print pattern
        # print g.listToString(files)
        for name in files:
            h = '@auto %s' % (name[len(baseDir) + 1:].strip())
            print 'creating',h
            if reallyCreate:
                child = p.insertAsLastChild()
                child.initHeadString(h)
finally:
    c.endUpdate()
</t>
<t tx="ekr.20071201083431"></t>
<t tx="ekr.20071201083431.1"></t>
<t tx="ekr.20071201083431.2">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    txt=GetClipboardText()                            # display last text clipped
    print txt
     
     
     
     </t>
<t tx="ekr.20071201083431.3">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    import time, sys
    c = Console(0)
    sys.stdout = c
    sys.stderr = c
    c.page()
    c.pos(5, 10)
    c.write('hi there')
    print 'some printed output'
    for i in range(10):
        c.getkeypress()
    del c
@ignore

@
error: @auto did not import @auto console.py perfectly
first mismatched line: 233
        terminal_escape = re.compile('(\\001?\\033\\\\[[0-9;]*m\\002?)')\n</t>
<t tx="ekr.20071201083431.4">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.5">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.6">@language python
@tabwidth -4
@others
# make these available so this looks like the python readline module
parse_and_bind = rl.parse_and_bind
get_line_buffer = rl.get_line_buffer
insert_text = rl.insert_text
read_init_file = rl.read_init_file
read_history_file = rl.read_history_file
write_history_file = rl.write_history_file
get_history_length = rl.get_history_length
set_history_length = rl.set_history_length
set_startup_hook = rl.set_startup_hook
set_pre_input_hook = rl.set_pre_input_hook
set_completer = rl.set_completer
get_completer = rl.get_completer
get_begidx = rl.get_begidx
get_endidx = rl.get_endidx
set_completer_delims = rl.set_completer_delims
get_completer_delims = rl.get_completer_delims
add_history = rl.add_history

if __name__ == '__main__':
    res = [ rl.readline('In[%d] ' % i) for i in range(3) ]
    print res
else:
    console.install_readline(rl.readline)

</t>
<t tx="ekr.20071201083431.7">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.8">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.9">@language python
@tabwidth -4
@others
while 1:
    try:
        data,addr=s.recvfrom(1024)
    except socket.timeout:
        if check_key():
            print "Quitting logserver"
            break
        else:
            continue
    if data.startswith("@@"):
        continue
    if singleline:
        print "\r"," "*78,"\r",data,#,addr
    else:
        print data
    
    

</t>
<t tx="ekr.20071201083431.10">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.11">@language python
@tabwidth -4
@others
# make these available so this looks like the python readline module
parse_and_bind = rl.parse_and_bind
get_line_buffer = rl.get_line_buffer
insert_text = rl.insert_text
read_init_file = rl.read_init_file
add_history = rl.add_history
get_history_length = rl.get_history_length
set_history_length = rl.set_history_length
clear_history = rl.clear_history
read_history_file = rl.read_history_file
write_history_file = rl.write_history_file
set_completer = rl.set_completer
get_completer = rl.get_completer
get_begidx = rl.get_begidx
get_endidx = rl.get_endidx
set_completer_delims = rl.set_completer_delims
get_completer_delims = rl.get_completer_delims
set_startup_hook = rl.set_startup_hook
set_pre_input_hook = rl.set_pre_input_hook

if __name__ == '__main__':
    res = [ rl.readline('In[%d] ' % i) for i in range(3) ]
    print res
else:
    console.install_readline(rl.readline)
    pass
</t>
<t tx="ekr.20071201083431.12">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.13">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.14"></t>
<t tx="ekr.20071201083431.15">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    txt=GetClipboardText()                            # display last text clipped
    print txt
     
     
     
     </t>
<t tx="ekr.20071201083431.16">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    txt=GetClipboardText()                            # display last text clipped
    print txt
     
     
     
     </t>
<t tx="ekr.20071201083431.17">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.18">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.19"></t>
<t tx="ekr.20071201083431.20">@language python
@tabwidth -4
@others
#trtable={0:"black",1:"red",2:"green",3:"yellow",4:"blue",5:"magenta",6:"cyan",7:"white"}

if __name__=="__main__":
    import pprint
    pprint=pprint.pprint

    s="\033[0;31mred\033[0;32mgreen\033[0;33myellow\033[0;34mblue\033[0;35mmagenta\033[0;36mcyan\033[0;37mwhite\033[0m"
    pprint (write_color(s))    
    pprint (write_color_old(s))
    s="\033[1;31mred\033[1;32mgreen\033[1;33myellow\033[1;34mblue\033[1;35mmagenta\033[1;36mcyan\033[1;37mwhite\033[0m"
    pprint (write_color(s))    
    pprint (write_color_old(s))    

    s="\033[0;7;31mred\033[0;7;32mgreen\033[0;7;33myellow\033[0;7;34mblue\033[0;7;35mmagenta\033[0;7;36mcyan\033[0;7;37mwhite\033[0m"
    pprint (write_color(s))    
    pprint (write_color_old(s))
    s="\033[1;7;31mred\033[1;7;32mgreen\033[1;7;33myellow\033[1;7;34mblue\033[1;7;35mmagenta\033[1;7;36mcyan\033[1;7;37mwhite\033[0m"
    pprint (write_color(s))    
    pprint (write_color_old(s))    

    
if __name__=="__main__":
    import console
    
    c=console.Console()
    c.write_color("dhsjdhs")
    c.write_color("\033[0;32mIn [\033[1;32m1\033[0;32m]:")
    print
    pprint (write_color("\033[0;32mIn [\033[1;32m1\033[0;32m]:"))    
    
@ignore
</t>
<t tx="ekr.20071201083431.21">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    import time, sys

    
    def p(char):
        return chr(VkKeyScan(ord(char)) &amp; 0xff)

    c = Console(0)
    sys.stdout = c
    sys.stderr = c
    c.page()
    print p("d"),p("D")
    c.pos(5, 10)
    c.write('hi there')
    print 'some printed output'
    for i in range(10):
        c.getkeypress()
    del c
@ignore

@
error: @auto did not import @auto console\console.py perfectly
first mismatched line: 260
u"        terminal_escape = re.compile('(\\001?\\033\\\\[[0-9;]+m\\002?)')\n"
</t>
<t tx="ekr.20071201083431.22">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.23">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.24">@language python
@tabwidth -4
@others
#    def __str__(self):
#        return "('%s',%s,%s,%s)"%(self.char,self.key,self.state,self.keyinfo)</t>
<t tx="ekr.20071201083431.25">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    import time, sys
    c = Console(0)
    sys.stdout = c
    sys.stderr = c
    c.page()
    c.pos(5, 10)
    c.write('hi there')
    c.title("Testing console")
#    c.bell()
    print
    print "size",c.size()
    print '  some printed output'
    for i in range(10):
        e=c.getkeypress()
        print e.Key,chr(e.KeyChar),ord(e.KeyChar),e.Modifiers
    del c

    System.Console.Clear()
@ignore</t>
<t tx="ekr.20071201083431.26">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.27">@language python
@tabwidth -4
@others
if __name__=="__main__":
    import startup
    </t>
<t tx="ekr.20071201083431.28">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.29">@language python
@tabwidth -4
@others
if __name__=="__main__":
    import startup
    </t>
<t tx="ekr.20071201083431.30">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.31">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.32"></t>
<t tx="ekr.20071201083431.33">@language python
@tabwidth -4
@others
if __name__=="__main__":
    q=LineHistory()
    RL=lineobj.ReadLineTextBuffer
    q.add_history(RL("aaaa"))
    q.add_history(RL("aaba"))
    q.add_history(RL("aaca"))
    q.add_history(RL("akca"))
    q.add_history(RL("bbb"))
    q.add_history(RL("ako"))
</t>
<t tx="ekr.20071201083431.34">@language python
@tabwidth -4
@others
if __name__=="__main__":
    import startup

    print '%-15s "%s"'%("Position",q.get_line_text())
    print '%-15s "%s"'%("Point",show_pos(q,q.point))


    for name,positioner in all_positioners:
        pos=positioner(q)
        []
        print '%-15s "%s"'%(name,show_pos(q,pos,"^"))

    l=ReadLineTextBuffer("kjjk asads   asad")
    l.point=EndOfLine
</t>
<t tx="ekr.20071201083431.35">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.36">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.37"></t>
<t tx="ekr.20071201083431.38">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.39">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.40">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.41">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20071201083431.42">@language python
@tabwidth -4
@others
#add check to ensure all modes have unique mode names</t>
<t tx="ekr.20071201084507.10"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
'''Cursor control and color for the Windows console.

This was modeled after the C extension of the same name by Fredrik Lundh. 
'''

# primitive debug printing that won't interfere with the screen

import sys
import traceback
import re
from logger import log
import os

try:
    # I developed this with ctypes 0.6
    from ctypes import *
    from _ctypes import call_function
except ImportError:
    print 'you need the ctypes module to run this code'
    print 'http://starship.python.net/crew/theller/ctypes/'
    raise

# my code
from keysyms import make_keysym, make_keyinfo

# some constants we need
STD_INPUT_HANDLE = -10
STD_OUTPUT_HANDLE = -11
ENABLE_WINDOW_INPUT = 0x0008
ENABLE_MOUSE_INPUT = 0x0010
ENABLE_PROCESSED_INPUT = 0x0001
WHITE = 0x7
BLACK = 0
MENU_EVENT = 0x0008
KEY_EVENT = 0x0001
MOUSE_MOVED = 0x0001
MOUSE_EVENT = 0x0002
WINDOW_BUFFER_SIZE_EVENT = 0x0004
FOCUS_EVENT = 0x0010
MENU_EVENT = 0x0008
VK_SHIFT = 0x10
VK_CONTROL = 0x11
VK_MENU = 0x12
GENERIC_READ = int(0x80000000L)
GENERIC_WRITE = 0x40000000

</t>
<t tx="ekr.20071201084507.11"># Windows structures we'll need later
class COORD(Structure):
    _fields_ = [("X", c_short),
                ("Y", c_short)]

</t>
<t tx="ekr.20071201084507.12">class SMALL_RECT(Structure):
    _fields_ = [("Left", c_short),
                ("Top", c_short),
                ("Right", c_short),
                ("Bottom", c_short)]

</t>
<t tx="ekr.20071201084507.13">class CONSOLE_SCREEN_BUFFER_INFO(Structure):
    _fields_ = [("dwSize", COORD),
                ("dwCursorPosition", COORD),
                ("wAttributes", c_short),
                ("srWindow", SMALL_RECT),
                ("dwMaximumWindowSize", COORD)]

</t>
<t tx="ekr.20071201084507.14">class CHAR_UNION(Union):
    _fields_ = [("UnicodeChar", c_short),
                ("AsciiChar", c_char)]

</t>
<t tx="ekr.20071201084507.15">class CHAR_INFO(Structure):
    _fields_ = [("Char", CHAR_UNION),
                ("Attributes", c_short)]

</t>
<t tx="ekr.20071201084507.16">class KEY_EVENT_RECORD(Structure):
    _fields_ = [("bKeyDown", c_byte),
                ("pad2", c_byte),
                ('pad1', c_short),
                ("wRepeatCount", c_short),
                ("wVirtualKeyCode", c_short),
                ("wVirtualScanCode", c_short),
                ("uChar", CHAR_UNION),
                ("dwControlKeyState", c_int)]

</t>
<t tx="ekr.20071201084507.17">class MOUSE_EVENT_RECORD(Structure):
    _fields_ = [("dwMousePosition", COORD),
                ("dwButtonState", c_int),
                ("dwControlKeyState", c_int),
                ("dwEventFlags", c_int)]

</t>
<t tx="ekr.20071201084507.18">class WINDOW_BUFFER_SIZE_RECORD(Structure):
    _fields_ = [("dwSize", COORD)]

</t>
<t tx="ekr.20071201084507.19">class MENU_EVENT_RECORD(Structure):
    _fields_ = [("dwCommandId", c_uint)]

</t>
<t tx="ekr.20071201084507.20">class FOCUS_EVENT_RECORD(Structure):
    _fields_ = [("bSetFocus", c_byte)]

</t>
<t tx="ekr.20071201084507.21">class INPUT_UNION(Union):
    _fields_ = [("KeyEvent", KEY_EVENT_RECORD),
                ("MouseEvent", MOUSE_EVENT_RECORD),
                ("WindowBufferSizeEvent", WINDOW_BUFFER_SIZE_RECORD),
                ("MenuEvent", MENU_EVENT_RECORD),
                ("FocusEvent", FOCUS_EVENT_RECORD)]

</t>
<t tx="ekr.20071201084507.22">class INPUT_RECORD(Structure):
    _fields_ = [("EventType", c_short),
                ("Event", INPUT_UNION)]

</t>
<t tx="ekr.20071201084507.23">class CONSOLE_CURSOR_INFO(Structure):
    _fields_ = [("dwSize", c_int),
                ("bVisible", c_byte)]

</t>
<t tx="ekr.20071201084507.24"># I didn't want to have to individually import these so I made a list, they are
# added to the Console class later in this file.

funcs = [
    'AllocConsole',
    'CreateConsoleScreenBuffer',
    'FillConsoleOutputAttribute',
    'FillConsoleOutputCharacterA',
    'FreeConsole',
    'GetConsoleCursorInfo',
    'GetConsoleMode',
    'GetConsoleScreenBufferInfo',
    'GetConsoleTitleA',
    'GetProcAddress',
    'GetStdHandle',
    'PeekConsoleInputA',
    'ReadConsoleInputA',
    'ScrollConsoleScreenBufferA',
    'SetConsoleActiveScreenBuffer',
    'SetConsoleCursorInfo',
    'SetConsoleCursorPosition',
    'SetConsoleMode',
    'SetConsoleScreenBufferSize',
    'SetConsoleTextAttribute',
    'SetConsoleTitleA',
    'SetConsoleWindowInfo',
    'WriteConsoleA',
    'WriteFile',
    'WriteConsoleOutputCharacterA',
    ]

# I don't want events for these keys, they are just a bother for my application
key_modifiers = { VK_SHIFT:1,
                  VK_CONTROL:1,
                  VK_MENU:1, # alt key
                  0x5b:1, # windows key
                 }

class Console(object):
    '''Console driver for Windows.

    '''
    @others
</t>
<t tx="ekr.20071201084507.25">
def __init__(self, newbuffer=0):
    '''Initialize the Console object.

    newbuffer=1 will allocate a new buffer so the old content will be restored
    on exit.
    '''
    #Do I need the following line? It causes a console to be created whenever
    #readline is imported into a pythonw application which seems wrong. Things
    #seem to work without it...
    #self.AllocConsole()

    if newbuffer:
        self.hout = self.CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                                                                             0, None, 1, None)
        self.SetConsoleActiveScreenBuffer(self.hout)
    else:
        self.hout = self.GetStdHandle(STD_OUTPUT_HANDLE)

    self.hin = self.GetStdHandle(STD_INPUT_HANDLE)
    self.inmode = c_int(0)
    self.GetConsoleMode(self.hin, byref(self.inmode))
    self.SetConsoleMode(self.hin, 0xf)
    info = CONSOLE_SCREEN_BUFFER_INFO()
    self.GetConsoleScreenBufferInfo(self.hout, byref(info))
    self.attr = info.wAttributes
    self.saveattr = info.wAttributes # remember the initial colors
    log('initial attr=%x' % self.attr)
    self.softspace = 0 # this is for using it as a file-like object
    self.serial = 0

    self.pythondll = CDLL('python%s%s' % (sys.version[0], sys.version[2]))
    self.inputHookPtr = c_int.from_address(addressof(self.pythondll.PyOS_InputHook)).value
    setattr(Console, 'PyMem_Malloc', self.pythondll.PyMem_Malloc)

</t>
<t tx="ekr.20071201084507.26">def __del__(self):
    '''Cleanup the console when finished.'''
    # I don't think this ever gets called
    self.SetConsoleTextAttribute(self.hout, self.saveattr)
    self.SetConsoleMode(self.hin, self.inmode)
    self.FreeConsole()

</t>
<t tx="ekr.20071201084507.27">def fixcoord(self, x, y):
    '''Return a long with x and y packed inside, also handle negative x and y.'''
    if x &lt; 0 or y &lt; 0:
        info = CONSOLE_SCREEN_BUFFER_INFO()
        self.GetConsoleScreenBufferInfo(self.hout, byref(info))
        if x &lt; 0:
            x = info.srWindow.Right - x
            y = info.srWindow.Bottom + y

    # this is a hack! ctypes won't pass structures but COORD is just like a
    # long, so this works.
    return c_int(y &lt;&lt; 16 | x)

</t>
<t tx="ekr.20071201084507.28">def pos(self, x=None, y=None):
    '''Move or query the window cursor.'''
    if x is None:
        info = CONSOLE_SCREEN_BUFFER_INFO()
        self.GetConsoleScreenBufferInfo(self.hout, byref(info))
        return (info.dwCursorPosition.X, info.dwCursorPosition.Y)
    else:
        return self.SetConsoleCursorPosition(self.hout, self.fixcoord(x, y))

</t>
<t tx="ekr.20071201084507.29">def home(self):
    '''Move to home.'''
    self.pos(0,0)

</t>
<t tx="ekr.20071201084507.30"># Map ANSI color escape sequences into Windows Console Attributes

    terminal_escape = re.compile('(\001?\033\\[[0-9;]*m\002?)')
    escape_parts = re.compile('\001?\033\\[([0-9;]*)m\002?')

    # This pattern should match all characters that change the cursor position differently
    # than a normal character.
    motion_char_re = re.compile('([\n\r\t\010\007])')

def write_scrolling(self, text, attr=None):
    '''write text at current cursor position while watching for scrolling.

    If the window scrolls because you are at the bottom of the screen
    buffer, all positions that you are storing will be shifted by the
    scroll amount. For example, I remember the cursor position of the
    prompt so that I can redraw the line but if the window scrolls,
    the remembered position is off.

    This variant of write tries to keep track of the cursor position
    so that it will know when the screen buffer is scrolled. It
    returns the number of lines that the buffer scrolled.

    '''
    x, y = self.pos()
    w, h = self.size()
    scroll = 0 # the result

    # split the string into ordinary characters and funny characters
    chunks = self.motion_char_re.split(text)
    for chunk in chunks:
        log('C:'+chunk)
        n = self.write_color(chunk, attr)
        if len(chunk) == 1: # the funny characters will be alone
            if chunk[0] == '\n': # newline
                x = 0
                y += 1
            elif chunk[0] == '\r': # carriage return
                x = 0
            elif chunk[0] == '\t': # tab
                x = 8*(int(x/8)+1)
                if x &gt; w: # newline
                    x -= w
                    y += 1
            elif chunk[0] == '\007': # bell
                pass
            elif chunk[0] == '\010':
                x -= 1
                if x &lt; 0:
                    y -= 1 # backed up 1 line
            else: # ordinary character
                x += 1
            if x == w: # wrap
                x = 0
                y += 1
            if y == h: # scroll
                scroll += 1
                y = h - 1
        else: # chunk of ordinary characters
            x += n
            l = int(x / w) # lines we advanced
            x = x % w # new x value
            y += l
            if y &gt;= h: # scroll
                scroll += y - h + 1
                y = h - 1
    return scroll

</t>
<t tx="ekr.20071201084507.31">def write_color(self, text, attr=None):
    '''write text at current cursor position and interpret color escapes.

    return the number of characters written.
    '''
    log('write_color("%s", %s)' % (text, attr))
    chunks = self.terminal_escape.split(text)
    log('chunks=%s' % repr(chunks))
    junk = c_int(0)
    n = 0 # count the characters we actually write, omitting the escapes
    if attr is None:
        info = CONSOLE_SCREEN_BUFFER_INFO()
        self.GetConsoleScreenBufferInfo(self.hout, byref(info))
        attr = info.wAttributes # fetch current colors
    for chunk in chunks:
        m = self.escape_parts.match(chunk)
        if m:
            for part in m.group(1).split(";"):
                if part == "0": # switch to default
                    attr = self.attr
                    attr = attr &amp; ~0x08
                elif part == "7": # switch on reverse
                    attr |= 0x4000
                if part == "1": # switch on bold (i.e. intensify foreground color)
                    attr |= 0x08
                elif len(part) == 2 and "30" &lt;= part &lt;= "37": # set foreground color
                    part = int(part)-30
                    # we have to mirror bits
                    attr = (attr &amp; ~0x07) | ((part &amp; 0x1) &lt;&lt; 2) | (part &amp; 0x2) | ((part &amp; 0x4) &gt;&gt; 2)
                elif len(part) == 2 and "40" &lt;= part &lt;= "47": # set background color
                    part = int(part)-40
                    # we have to mirror bits
                    attr = (attr &amp; ~0x70) | ((part &amp; 0x1) &lt;&lt; 6) | ((part &amp; 0x2) &lt;&lt; 4) | ((part &amp; 0x4) &lt;&lt; 2)
                # ignore blink, underline and anything we don't understand
            continue
        n += len(chunk)
        log('attr=%s' % attr)
        self.SetConsoleTextAttribute(self.hout, attr)
        self.WriteConsoleA(self.hout, chunk, len(chunk), byref(junk), None)
    return n

</t>
<t tx="ekr.20071201084507.32">def write_plain(self, text, attr=None):
    '''write text at current cursor position.'''
    log('write("%s", %s)' %(text,attr))
    if attr is None:
        attr = self.attr
    n = c_int(0)
    self.SetConsoleTextAttribute(self.hout, attr)
    self.WriteConsoleA(self.hout, text, len(text), byref(n), None)
    return len(text)

</t>
<t tx="ekr.20071201084507.33">if os.environ.has_key("EMACS"):
    def write_color(self, text, attr=None):
        junk = c_int(0)
        self.WriteFile(self.hout, text, len(text), byref(junk), None)
        return len(text)
    write_plain = write_color

# make this class look like a file object
def write(self, text):
    log('write("%s")' % text)
    return self.write_color(text)

</t>
<t tx="ekr.20071201084507.34">#write = write_scrolling

def isatty(self):
    return True

</t>
<t tx="ekr.20071201084507.35">def flush(self):
    pass

</t>
<t tx="ekr.20071201084507.36">def page(self, attr=None, fill=' '):
    '''Fill the entire screen.'''
    if attr is None:
        attr = self.attr
    if len(fill) != 1:
        raise ValueError
    info = CONSOLE_SCREEN_BUFFER_INFO()
    self.GetConsoleScreenBufferInfo(self.hout, byref(info))
    if info.dwCursorPosition.X != 0 or info.dwCursorPosition.Y != 0:
        self.SetConsoleCursorPosition(self.hout, self.fixcoord(0, 0))

    w = info.dwSize.X
    n = c_int(0)
    for y in range(info.dwSize.Y):
        self.FillConsoleOutputAttribute(self.hout, attr, w, self.fixcoord(0, y), byref(n))
        self.FillConsoleOutputCharacterA(self.hout, ord(fill[0]), w, self.fixcoord(0, y), byref(n))

    self.attr = attr

</t>
<t tx="ekr.20071201084507.37">def text(self, x, y, text, attr=None):
    '''Write text at the given position.'''
    if attr is None:
        attr = self.attr

    pos = self.fixcoord(x, y)
    n = c_int(0)
    self.WriteConsoleOutputCharacterA(self.hout, text, len(text), pos, byref(n))
    self.FillConsoleOutputAttribute(self.hout, attr, n, pos, byref(n))

</t>
<t tx="ekr.20071201084507.38">def rectangle(self, rect, attr=None, fill=' '):
    '''Fill Rectangle.'''
    x0, y0, x1, y1 = rect
    n = c_int(0)
    if attr is None:
        attr = self.attr
    for y in range(y0, y1):
        pos = self.fixcoord(x0, y)
        self.FillConsoleOutputAttribute(self.hout, attr, x1-x0, pos, byref(n))
        self.FillConsoleOutputCharacterA(self.hout, ord(fill[0]), x1-x0, pos, byref(n))

</t>
<t tx="ekr.20071201084507.39">def scroll(self, rect, dx, dy, attr=None, fill=' '):
    '''Scroll a rectangle.'''
    if attr is None:
        attr = self.attr

    x0, y0, x1, y1 = rect
    source = SMALL_RECT(x0, y0, x1-1, y1-1)
    dest = self.fixcoord(x0+dx, y0+dy)
    style = CHAR_INFO()
    style.Char.AsciiChar = fill[0]
    style.Attributes = attr

    return self.ScrollConsoleScreenBufferA(self.hout, byref(source), byref(source),
                                                                                 dest, byref(style))

</t>
<t tx="ekr.20071201084507.40">def scroll_window(self, lines):
    '''Scroll the window by the indicated number of lines.'''
    info = CONSOLE_SCREEN_BUFFER_INFO()
    self.GetConsoleScreenBufferInfo(self.hout, byref(info))
    rect = info.srWindow
    log('sw: rtop=%d rbot=%d' % (rect.Top, rect.Bottom))
    top = rect.Top + lines
    bot = rect.Bottom + lines
    h = bot - top
    maxbot = info.dwSize.Y-1
    log('sw: lines=%d mb=%d top=%d bot=%d' % (lines,maxbot,top,bot))
    if top &lt; 0:
        top = 0
        bot = h
    if bot &gt; maxbot:
        bot = maxbot
        top = bot - h

    nrect = SMALL_RECT()
    nrect.Top = top
    nrect.Bottom = bot
    nrect.Left = rect.Left
    nrect.Right = rect.Right
    log('sn: top=%d bot=%d' % (top,bot))
    r=self.SetConsoleWindowInfo(self.hout, True, byref(nrect))
    log('r=%d' % r)

</t>
<t tx="ekr.20071201084507.41">def get(self):
    '''Get next event from queue.'''
    inputHookFunc = c_int.from_address(self.inputHookPtr).value

    Cevent = INPUT_RECORD()
    count = c_int(0)
    while 1:
        if inputHookFunc:
            call_function(inputHookFunc, ())
        status = self.ReadConsoleInputA(self.hin, byref(Cevent), 1, byref(count))
        if status and count.value == 1:
            e = event(self, Cevent)
            return e

</t>
<t tx="ekr.20071201084507.42">def getkeypress(self):
    '''Return next key press event from the queue, ignoring others.'''
    while 1:
        e = self.get()
        if e.type == 'KeyPress' and e.keycode not in key_modifiers:
            log(e)
            if e.keysym == 'Next':
                self.scroll_window(12)
            elif e.keysym == 'Prior':
                self.scroll_window(-12)
            else:
                return e

</t>
<t tx="ekr.20071201084507.43">def getchar(self):
    '''Get next character from queue.'''

    Cevent = INPUT_RECORD()
    count = c_int(0)
    while 1:
        status = self.ReadConsoleInputA(self.hin, byref(Cevent), 1, byref(count))
        if (status and count.value==1 and Cevent.EventType == 1 and
                Cevent.Event.KeyEvent.bKeyDown):
            sym = keysym(Cevent.Event.KeyEvent.wVirtualKeyCode)
            if len(sym) == 0:
                sym = Cevent.Event.KeyEvent.uChar.AsciiChar
            return sym

</t>
<t tx="ekr.20071201084507.44">def peek(self):
    '''Check event queue.'''
    Cevent = INPUT_RECORD()
    count = c_int(0)
    status = PeekConsoleInput(self.hin, byref(Cevent), 1, byref(count))
    if status and count == 1:
        return event(self, Cevent)

</t>
<t tx="ekr.20071201084507.45">def title(self, txt=None):
    '''Set/get title.'''
    if txt:
        self.SetConsoleTitleA(txt)
    else:
        buffer = c_buffer(200)
        n = self.GetConsoleTitleA(buffer, 200)
        if n &gt; 0:
            return buffer.value[:n]

</t>
<t tx="ekr.20071201084507.46">def size(self, width=None, height=None):
    '''Set/get window size.'''
    info = CONSOLE_SCREEN_BUFFER_INFO()
    status = self.GetConsoleScreenBufferInfo(self.hout, byref(info))
    if not status:
        return None
    if width is not None and height is not None:
        wmin = info.srWindow.Right - info.srWindow.Left + 1
        hmin = info.srWindow.Bottom - info.srWindow.Top + 1
        #print wmin, hmin
        width = max(width, wmin)
        height = max(height, hmin)
        #print width, height
        self.SetConsoleScreenBufferSize(self.hout, self.fixcoord(width, height))
    else:
        return (info.dwSize.X, info.dwSize.Y)

</t>
<t tx="ekr.20071201084507.47">def cursor(self, visible):
    '''Set cursor on or off.'''
    info = CONSOLE_CURSOR_INFO()
    if self.GetConsoleCursorInfo(self.hout, byref(info)):
        info.bVisible = visible
        self.SetConsoleCursorInfo(self.hout, byref(info))

</t>
<t tx="ekr.20071201084507.48">def bell(self):
    self.write('\007')

</t>
<t tx="ekr.20071201084507.49">def next_serial(self):
    '''Get next event serial number.'''
    self.serial += 1
    return self.serial

</t>
<t tx="ekr.20071201084507.50"># add the functions from the dll to the class
for func in funcs:
    setattr(Console, func, getattr(windll.kernel32, func))

class event(object):
    '''Represent events from the console.'''
    @others
</t>
<t tx="ekr.20071201084507.51">def __init__(self, console, input):
    '''Initialize an event from the Windows input structure.'''
    self.type = '??'
    self.serial = console.next_serial()
    self.width = 0
    self.height = 0
    self.x = 0
    self.y = 0
    self.char = ''
    self.keycode = 0
    self.keysym = '??'
    self.keyinfo = '' # a tuple with (control, meta, shift, keycode) for dispatch
    self.width = None

    if input.EventType == KEY_EVENT:
        if input.Event.KeyEvent.bKeyDown:
            self.type = "KeyPress"
        else:
            self.type = "KeyRelease"
        self.char = input.Event.KeyEvent.uChar.AsciiChar
        self.keycode = input.Event.KeyEvent.wVirtualKeyCode
        self.state = input.Event.KeyEvent.dwControlKeyState
        self.keysym = make_keysym(self.keycode)
        self.keyinfo = make_keyinfo(self.keycode, self.state)
    elif input.EventType == MOUSE_EVENT:
        if input.Event.MouseEvent.dwEventFlags &amp; MOUSE_MOVED:
            self.type = "Motion"
        else:
            self.type = "Button"
        self.x = input.Event.MouseEvent.dwMousePosition.X
        self.y = input.Event.MouseEvent.dwMousePosition.Y
        self.state = input.Event.MouseEvent.dwButtonState
    elif input.EventType == WINDOW_BUFFER_SIZE_EVENT:
        self.type = "Configure"
        self.width = input.Event.WindowBufferSizeEvent.dwSize.X
        self.height = input.Event.WindowBufferSizeEvent.dwSize.Y
    elif input.EventType == FOCUS_EVENT:
        if input.Event.FocusEvent.bSetFocus:
            self.type = "FocusIn"
        else:
            self.type = "FocusOut"
    elif input.EventType == MENU_EVENT:
        self.type = "Menu"
        self.state = input.Event.MenuEvent.dwCommandId

</t>
<t tx="ekr.20071201084507.52">def __repr__(self):
    '''Display an event for debugging.'''
    if self.type in ['KeyPress', 'KeyRelease']:
        s = "%s char='%s'%d keysym='%s' keycode=%d:%x state=%x keyinfo=%s" % \
                (self.type, self.char, ord(self.char), self.keysym, self.keycode, self.keycode,
                 self.state, self.keyinfo)
    elif self.type in ['Motion', 'Button']:
        s = '%s x=%d y=%d state=%x' % (self.type, self.x, self.y, self.state)
    elif self.type == 'Configure':
        s = '%s w=%d h=%d' % (self.type, self.width, self.height)
    elif self.type in ['FocusIn', 'FocusOut']:
        s = self.type
    elif self.type == 'Menu':
        s = '%s state=%x' % (self.type, self.state)
    else:
        s = 'unknown event type'
    return s

</t>
<t tx="ekr.20071201084507.53">def getconsole(buffer=1):
        """Get a console handle.

        If buffer is non-zero, a new console buffer is allocated and
        installed.  Otherwise, this returns a handle to the current
        console buffer"""

        c = Console(buffer)

        return c

</t>
<t tx="ekr.20071201084507.54"># The following code uses ctypes to allow a Python callable to
# substitute for GNU readline within the Python interpreter. Calling
# raw_input or other functions that do input, inside your callable
# might be a bad idea, then again, it might work.

# The Python callable can raise EOFError or KeyboardInterrupt and
# these will be translated into the appropriate outputs from readline
# so that they will then be translated back!

# If the Python callable raises any other exception, a traceback will
# be printed and readline will appear to return an empty line.

# I use ctypes to create a C-callable from a Python wrapper that
# handles the exceptions and gets the result into the right form.

# the type for our C-callable wrapper
HOOKFUNC22 = CFUNCTYPE(c_char_p, c_char_p)
HOOKFUNC23 = CFUNCTYPE(c_char_p, c_void_p, c_void_p, c_char_p)

readline_hook = None # the python hook goes here
readline_ref = None  # this holds a reference to the c-callable to keep it alive

def hook_wrapper_23(stdin, stdout, prompt):
    '''Wrap a Python readline so it behaves like GNU readline.'''
    try:
        # call the Python hook
        res = readline_hook(prompt)
        # make sure it returned the right sort of thing
        if res and not isinstance(res, str):
            raise TypeError, 'readline must return a string.'
    except KeyboardInterrupt:
        # GNU readline returns 0 on keyboard interrupt
        return 0
    except EOFError:
        # It returns an empty string on EOF
        res = ''
    except:
        print &gt;&gt;sys.stderr, 'Readline internal error'
        traceback.print_exc()
        res = '\n'
    # we have to make a copy because the caller expects to free the result
    n = len(res)
    p = Console.PyMem_Malloc(n+1)
    cdll.msvcrt.strncpy(p, res, n+1)
    return p

</t>
<t tx="ekr.20071201084507.55">def hook_wrapper(prompt):
    '''Wrap a Python readline so it behaves like GNU readline.'''
    try:
        # call the Python hook
        res = readline_hook(prompt)
        # make sure it returned the right sort of thing
        if res and not isinstance(res, str):
            raise TypeError, 'readline must return a string.'
    except KeyboardInterrupt:
        # GNU readline returns 0 on keyboard interrupt
        return 0
    except EOFError:
        # It returns an empty string on EOF
        res = ''
    except:
        print &gt;&gt;sys.stderr, 'Readline internal error'
        traceback.print_exc()
        res = '\n'
    # we have to make a copy because the caller expects to free the result
    p = cdll.msvcrt._strdup(res)
    return p

</t>
<t tx="ekr.20071201084507.56">def install_readline(hook):
    '''Set up things for the interpreter to call our function like GNU readline.'''
    global readline_hook, readline_ref
    # save the hook so the wrapper can call it
    readline_hook = hook
    # get the address of PyOS_ReadlineFunctionPointer so we can update it
    PyOS_RFP = c_int.from_address(Console.GetProcAddress(sys.dllhandle,
                                                 "PyOS_ReadlineFunctionPointer"))
    # save a reference to the generated C-callable so it doesn't go away
    if sys.version &lt; '2.3':
        readline_ref = HOOKFUNC22(hook_wrapper)
    else:
        readline_ref = HOOKFUNC23(hook_wrapper_23)
    # get the address of the function
    func_start = c_int.from_address(addressof(readline_ref)).value
    # write the function address into PyOS_ReadlineFunctionPointer
    PyOS_RFP.value = func_start

</t>
<t tx="ekr.20071201084507.130"># -*- coding: ISO-8859-1 -*-
import re,sys,os

terminal_escape = re.compile('(\001?\033\\[[0-9;]*m\002?)')
escape_parts = re.compile('\001?\033\\[([0-9;]*)m\002?')


</t>
<t tx="ekr.20071201084507.131">class AnsiState(object):
    @others
</t>
<t tx="ekr.20071201084507.132">def __init__(self,bold=False,inverse=False,color="white",background="black",backgroundbold=False):
    self.bold=bold
    self.inverse=inverse
    self.color=color
    self.background=background
    self.backgroundbold=backgroundbold

</t>
<t tx="ekr.20071201084507.133">trtable={"black":0,"red":4,"green":2,"yellow":6,"blue":1,"magenta":5,"cyan":3,"white":7}
revtable=dict(zip(trtable.values(),trtable.keys()))
def get_winattr(self):
    attr=0
    if self.bold:
        attr|=0x0008
    if self.backgroundbold:
        attr|=0x0080
    if self.inverse:
        attr|=0x4000
    attr|=self.trtable[self.color]
    attr|=(self.trtable[self.background]&lt;&lt;4)
    return attr

</t>
<t tx="ekr.20071201084507.134">def set_winattr(self,attr):
    self.bold=bool(attr&amp;0x0008)
    self.backgroundbold=bool(attr&amp;0x0080)
    self.inverse=bool(attr&amp;0x4000)
    self.color=self.revtable[attr&amp;0x0007]
    self.background=self.revtable[(attr&amp;0x0070)&gt;&gt;4]
    
</t>
<t tx="ekr.20071201084507.135">winattr=property(get_winattr,set_winattr)
def __repr__(self):
    return 'AnsiState(bold=%s,inverse=%s,color=%9s,background=%9s,backgroundbold=%s)# 0x%x'%(self.bold,
                                                                                             self.inverse,
                                                                                             '"%s"'%self.color,
                                                                                             '"%s"'%self.background,
                                                                                             self.backgroundbold,
                                                                                             self.winattr)

</t>
<t tx="ekr.20071201084507.136">def copy(self):
    x=AnsiState()
    x.bold=self.bold
    x.inverse=self.inverse
    x.color=self.color
    x.background=self.background
    x.backgroundbold=self.backgroundbold
    return x
</t>
<t tx="ekr.20071201084507.137">defaultstate=AnsiState(False,False,"white")

trtable={0:"black",1:"red",2:"green",3:"yellow",4:"blue",5:"magenta",6:"cyan",7:"white"}

class AnsiWriter(object):
    @others
</t>
<t tx="ekr.20071201084507.138">def __init__(self,default=defaultstate):
    if isinstance(defaultstate,AnsiState):
        self.defaultstate=default
    else:
        self.defaultstate=AnsiState()
        self.defaultstate.winattr=defaultstate
        
        
</t>
<t tx="ekr.20071201084507.139">def write_color(self,text, attr=None):
    '''write text at current cursor position and interpret color escapes.

    return the number of characters written.
    '''
    if isinstance(attr,AnsiState):
        defaultstate=attr
    elif attr is None:  #use attribute form initial console
        attr = self.defaultstate.copy()
    else:
        defaultstate=AnsiState()
        defaultstate.winattr=attr
        attr=defaultstate
    chunks = terminal_escape.split(text)
    n = 0 # count the characters we actually write, omitting the escapes
    res=[]
    for chunk in chunks:
        m = escape_parts.match(chunk)
        if m:
            parts=m.group(1).split(";")
            if len(parts)==1 and parts[0]=="0":
                attr = self.defaultstate.copy()
                continue
            for part in parts:
                if part == "0": # No text attribute
                    attr = self.defaultstate.copy()
                    attr.bold=False
                elif part == "7": # switch on reverse
                    attr.inverse=True
                elif part == "1": # switch on bold (i.e. intensify foreground color)
                    attr.bold=True 
                elif len(part) == 2 and "30" &lt;= part &lt;= "37": # set foreground color
                    attr.color = trtable[int(part)-30]
                elif len(part) == 2 and "40" &lt;= part &lt;= "47": # set background color
                    attr.color = trtable[int(part)-40]
            continue
        n += len(chunk)
        if True:
            res.append((attr.copy(),chunk))
    return n,res

</t>
<t tx="ekr.20071201084507.140">def parse_color(self,text, attr=None):
    n,res=self.write_color(text,attr)
    return n,[attr.winattr for attr,text in res]

</t>
<t tx="ekr.20071201084507.141">def write_color(text,attr=None):
    a=AnsiWriter(defaultstate)
    return a.write_color(text,attr)

</t>
<t tx="ekr.20071201084507.142">def write_color_old( text, attr=None):
    '''write text at current cursor position and interpret color escapes.

    return the number of characters written.
    '''
    res=[]
    chunks = terminal_escape.split(text)
    n = 0 # count the characters we actually write, omitting the escapes
    if attr is None:#use attribute from initial console
        attr = 15
    for chunk in chunks:
        m = escape_parts.match(chunk)
        if m:
            for part in m.group(1).split(";"):
                if part == "0": # No text attribute
                    attr = 0
                elif part == "7": # switch on reverse
                    attr |= 0x4000
                if part == "1": # switch on bold (i.e. intensify foreground color)
                    attr |= 0x08
                elif len(part) == 2 and "30" &lt;= part &lt;= "37": # set foreground color
                    part = int(part)-30
                    # we have to mirror bits
                    attr = (attr &amp; ~0x07) | ((part &amp; 0x1) &lt;&lt; 2) | (part &amp; 0x2) | ((part &amp; 0x4) &gt;&gt; 2)
                elif len(part) == 2 and "40" &lt;= part &lt;= "47": # set background color
                    part = int(part)-40
                    # we have to mirror bits
                    attr = (attr &amp; ~0x70) | ((part &amp; 0x1) &lt;&lt; 6) | ((part &amp; 0x2) &lt;&lt; 4) | ((part &amp; 0x4) &lt;&lt; 2)
                # ignore blink, underline and anything we don't understand
            continue
        n += len(chunk)
        if chunk:
            res.append(("0x%x"%attr,chunk))
    return res


</t>
<t tx="ekr.20071201084507.143"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
'''Cursor control and color for the Windows console.

This was modeled after the C extension of the same name by Fredrik Lundh. 
'''

# primitive debug printing that won't interfere with the screen

import sys
import traceback
import re
from pyreadline.logger import log,log_sock

try:
    from ctypes import *
    from _ctypes import call_function
except ImportError:
    raise ImportError("You need ctypes to run this code")

# my code
from pyreadline.keysyms import make_KeyPress
from pyreadline.console.ansi import AnsiState,AnsiWriter

# some constants we need
STD_INPUT_HANDLE = -10
STD_OUTPUT_HANDLE = -11
ENABLE_WINDOW_INPUT = 0x0008
ENABLE_MOUSE_INPUT = 0x0010
ENABLE_PROCESSED_INPUT = 0x0001
WHITE = 0x7
BLACK = 0
MENU_EVENT = 0x0008
KEY_EVENT = 0x0001
MOUSE_MOVED = 0x0001
MOUSE_EVENT = 0x0002
WINDOW_BUFFER_SIZE_EVENT = 0x0004
FOCUS_EVENT = 0x0010
MENU_EVENT = 0x0008
VK_SHIFT = 0x10
VK_CONTROL = 0x11
VK_MENU = 0x12
GENERIC_READ = int(0x80000000L)
GENERIC_WRITE = 0x40000000

</t>
<t tx="ekr.20071201084507.144"># Windows structures we'll need later
class COORD(Structure):
    _fields_ = [("X", c_short),
                ("Y", c_short)]

</t>
<t tx="ekr.20071201084507.145">class SMALL_RECT(Structure):
    _fields_ = [("Left", c_short),
                ("Top", c_short),
                ("Right", c_short),
                ("Bottom", c_short)]

</t>
<t tx="ekr.20071201084507.146">class CONSOLE_SCREEN_BUFFER_INFO(Structure):
    _fields_ = [("dwSize", COORD),
                ("dwCursorPosition", COORD),
                ("wAttributes", c_short),
                ("srWindow", SMALL_RECT),
                ("dwMaximumWindowSize", COORD)]

</t>
<t tx="ekr.20071201084507.147">class CHAR_UNION(Union):
    _fields_ = [("UnicodeChar", c_short),
                ("AsciiChar", c_char)]

</t>
<t tx="ekr.20071201084507.148">class CHAR_INFO(Structure):
    _fields_ = [("Char", CHAR_UNION),
                ("Attributes", c_short)]

</t>
<t tx="ekr.20071201084507.149">class KEY_EVENT_RECORD(Structure):
    _fields_ = [("bKeyDown", c_byte),
                ("pad2", c_byte),
                ('pad1', c_short),
                ("wRepeatCount", c_short),
                ("wVirtualKeyCode", c_short),
                ("wVirtualScanCode", c_short),
                ("uChar", CHAR_UNION),
                ("dwControlKeyState", c_int)]

</t>
<t tx="ekr.20071201084507.150">class MOUSE_EVENT_RECORD(Structure):
    _fields_ = [("dwMousePosition", COORD),
                ("dwButtonState", c_int),
                ("dwControlKeyState", c_int),
                ("dwEventFlags", c_int)]

</t>
<t tx="ekr.20071201084507.151">class WINDOW_BUFFER_SIZE_RECORD(Structure):
    _fields_ = [("dwSize", COORD)]

</t>
<t tx="ekr.20071201084507.152">class MENU_EVENT_RECORD(Structure):
    _fields_ = [("dwCommandId", c_uint)]

</t>
<t tx="ekr.20071201084507.153">class FOCUS_EVENT_RECORD(Structure):
    _fields_ = [("bSetFocus", c_byte)]

</t>
<t tx="ekr.20071201084507.154">class INPUT_UNION(Union):
    _fields_ = [("KeyEvent", KEY_EVENT_RECORD),
                ("MouseEvent", MOUSE_EVENT_RECORD),
                ("WindowBufferSizeEvent", WINDOW_BUFFER_SIZE_RECORD),
                ("MenuEvent", MENU_EVENT_RECORD),
                ("FocusEvent", FOCUS_EVENT_RECORD)]

</t>
<t tx="ekr.20071201084507.155">class INPUT_RECORD(Structure):
    _fields_ = [("EventType", c_short),
                ("Event", INPUT_UNION)]

</t>
<t tx="ekr.20071201084507.156">class CONSOLE_CURSOR_INFO(Structure):
    _fields_ = [("dwSize", c_int),
                ("bVisible", c_byte)]


</t>
<t tx="ekr.20071201084507.157">try:
    consolecodepage=sys.stdout.encoding
except AttributeError:        #This error occurs when pdb imports readline and doctest has replaced 
                              #stdout with stdout collector
    consolecodepage="ascii"   #assume ascii codepage
    
def ensure_text(text):
    """helper to ensure that text passed to WriteConsoleA is ascii"""
    if isinstance(text, unicode):
        return text.encode(consolecodepage,"replace")
    return text

</t>
<t tx="ekr.20071201084507.158"># I didn't want to have to individually import these so I made a list, they are
# added to the Console class later in this file.

funcs = [
    'AllocConsole',
    'CreateConsoleScreenBuffer',
    'FillConsoleOutputAttribute',
    'FillConsoleOutputCharacterA',
    'FreeConsole',
    'GetConsoleCursorInfo',
    'GetConsoleMode',
    'GetConsoleScreenBufferInfo',
    'GetConsoleTitleA',
    'GetProcAddress',
    'GetStdHandle',
    'PeekConsoleInputA',
    'ReadConsoleInputA',
    'ScrollConsoleScreenBufferA',
    'SetConsoleActiveScreenBuffer',
    'SetConsoleCursorInfo',
    'SetConsoleCursorPosition',
    'SetConsoleMode',
    'SetConsoleScreenBufferSize',
    'SetConsoleTextAttribute',
    'SetConsoleTitleA',
    'SetConsoleWindowInfo',
    'WriteConsoleA',
    'WriteConsoleOutputCharacterA',
    ]

# I don't want events for these keys, they are just a bother for my application
key_modifiers = { VK_SHIFT:1,
                  VK_CONTROL:1,
                  VK_MENU:1, # alt key
                  0x5b:1, # windows key
                 }

class Console(object):
    '''Console driver for Windows.

    '''
    @others
</t>
<t tx="ekr.20071201084507.159">
def __init__(self, newbuffer=0):
    '''Initialize the Console object.

    newbuffer=1 will allocate a new buffer so the old content will be restored
    on exit.
    '''
    #Do I need the following line? It causes a console to be created whenever
    #readline is imported into a pythonw application which seems wrong. Things
    #seem to work without it...
    #self.AllocConsole()

    if newbuffer:
        self.hout = self.CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                                                                             0, None, 1, None)
        self.SetConsoleActiveScreenBuffer(self.hout)
    else:
        self.hout = self.GetStdHandle(STD_OUTPUT_HANDLE)

    self.hin = self.GetStdHandle(STD_INPUT_HANDLE)
    self.inmode = c_int(0)
    self.GetConsoleMode(self.hin, byref(self.inmode))
    self.SetConsoleMode(self.hin, 0xf)
    info = CONSOLE_SCREEN_BUFFER_INFO()
    self.GetConsoleScreenBufferInfo(self.hout, byref(info))
    self.attr = info.wAttributes
    self.saveattr = info.wAttributes # remember the initial colors

    self.defaultstate=AnsiState()
    self.defaultstate.winattr=info.wAttributes
    self.ansiwriter=AnsiWriter(self.defaultstate)
#        self.ansiwriter.defaultstate.bold=False
    
    background = self.attr &amp; 0xf0
    for escape in self.escape_to_color:
        if self.escape_to_color[escape] is not None:
            self.escape_to_color[escape] |= background
    log('initial attr=%x' % self.attr)
    self.softspace = 0 # this is for using it as a file-like object
    self.serial = 0

    self.pythondll = CDLL('python%s%s' % (sys.version[0], sys.version[2]))
    self.inputHookPtr = c_int.from_address(addressof(self.pythondll.PyOS_InputHook)).value
    setattr(Console, 'PyMem_Malloc', self.pythondll.PyMem_Malloc)

</t>
<t tx="ekr.20071201084507.160">def __del__(self):
    '''Cleanup the console when finished.'''
    # I don't think this ever gets called
    self.SetConsoleTextAttribute(self.hout, self.saveattr)
    self.SetConsoleMode(self.hin, self.inmode)
    self.FreeConsole()

</t>
<t tx="ekr.20071201084507.161">def _get_top_bot(self):
    info = CONSOLE_SCREEN_BUFFER_INFO()
    self.GetConsoleScreenBufferInfo(self.hout, byref(info))
    rect = info.srWindow
    top = rect.Top 
    bot = rect.Bottom 
    return top,bot

</t>
<t tx="ekr.20071201084507.162">def fixcoord(self, x, y):
    '''Return a long with x and y packed inside, also handle negative x and y.'''
    if x &lt; 0 or y &lt; 0:
        info = CONSOLE_SCREEN_BUFFER_INFO()
        self.GetConsoleScreenBufferInfo(self.hout, byref(info))
        if x &lt; 0:
            x = info.srWindow.Right - x
            y = info.srWindow.Bottom + y

    # this is a hack! ctypes won't pass structures but COORD is just like a
    # long, so this works.
    return c_int(y &lt;&lt; 16 | x)

</t>
<t tx="ekr.20071201084507.163">def pos(self, x=None, y=None):
    '''Move or query the window cursor.'''
    if x is None:
        info = CONSOLE_SCREEN_BUFFER_INFO()
        self.GetConsoleScreenBufferInfo(self.hout, byref(info))
        return (info.dwCursorPosition.X, info.dwCursorPosition.Y)
    else:
        return self.SetConsoleCursorPosition(self.hout, self.fixcoord(x, y))

</t>
<t tx="ekr.20071201084507.164">def home(self):
    '''Move to home.'''
    self.pos(0,0)

</t>
<t tx="ekr.20071201084507.165"># Map ANSI color escape sequences into Windows Console Attributes

    terminal_escape = re.compile('(\001?\033\\[[0-9;]+m\002?)')
    escape_parts = re.compile('\001?\033\\[([0-9;]+)m\002?')
    escape_to_color = { '0;30': 0x0,             #black
                        '0;31': 0x4,             #red
                        '0;32': 0x2,             #green
                        '0;33': 0x4+0x2,         #brown?
                        '0;34': 0x1,             #blue
                        '0;35': 0x1+0x4,         #purple
                        '0;36': 0x2+0x4,         #cyan
                        '0;37': 0x1+0x2+0x4,     #grey
                        '1;30': 0x1+0x2+0x4,     #dark gray
                        '1;31': 0x4+0x8,         #red
                        '1;32': 0x2+0x8,         #light green
                        '1;33': 0x4+0x2+0x8,     #yellow
                        '1;34': 0x1+0x8,         #light blue
                        '1;35': 0x1+0x4+0x8,     #light purple
                        '1;36': 0x1+0x2+0x8,     #light cyan
                        '1;37': 0x1+0x2+0x4+0x8, #white
                        '0': None,
                       }

    # This pattern should match all characters that change the cursor position differently
    # than a normal character.
    motion_char_re = re.compile('([\n\r\t\010\007])')

def write_scrolling(self, text, attr=None):
    '''write text at current cursor position while watching for scrolling.

    If the window scrolls because you are at the bottom of the screen
    buffer, all positions that you are storing will be shifted by the
    scroll amount. For example, I remember the cursor position of the
    prompt so that I can redraw the line but if the window scrolls,
    the remembered position is off.

    This variant of write tries to keep track of the cursor position
    so that it will know when the screen buffer is scrolled. It
    returns the number of lines that the buffer scrolled.

    '''
    x, y = self.pos()
    w, h = self.size()
    scroll = 0 # the result
    # split the string into ordinary characters and funny characters
    chunks = self.motion_char_re.split(text)
    for chunk in chunks:
        log('C:'+chunk)
        n = self.write_color(chunk, attr)
        if len(chunk) == 1: # the funny characters will be alone
            if chunk[0] == '\n': # newline
                x = 0
                y += 1
            elif chunk[0] == '\r': # carriage return
                x = 0
            elif chunk[0] == '\t': # tab
                x = 8*(int(x/8)+1)
                if x &gt; w: # newline
                    x -= w
                    y += 1
            elif chunk[0] == '\007': # bell
                pass
            elif chunk[0] == '\010':
                x -= 1
                if x &lt; 0:
                    y -= 1 # backed up 1 line
            else: # ordinary character
                x += 1
            if x == w: # wrap
                x = 0
                y += 1
            if y == h: # scroll
                scroll += 1
                y = h - 1
        else: # chunk of ordinary characters
            x += n
            l = int(x / w) # lines we advanced
            x = x % w # new x value
            y += l
            if y &gt;= h: # scroll
                scroll += y - h + 1
                y = h - 1
    return scroll

</t>
<t tx="ekr.20071201084507.166">def write_color(self, text, attr=None):
    '''write text at current cursor position and interpret color escapes.

    return the number of characters written.
    '''
    log('write_color("%s", %s)' % (text, attr))
    chunks = self.terminal_escape.split(text)
    log('chunks=%s' % repr(chunks))
    junk = c_int(0)
    n = 0 # count the characters we actually write, omitting the escapes
    for chunk in chunks:
        m = self.escape_parts.match(chunk)
        if m:
            attr = self.escape_to_color[m.group(1)]
            continue
        n += len(chunk)
        log('attr=%s' % attr)
        if attr is None:
            attr = self.attr
        self.SetConsoleTextAttribute(self.hout, attr)
        self.WriteConsoleA(self.hout, ensure_text(chunk), len(chunk), byref(junk), None)
    return n

</t>
<t tx="ekr.20071201084507.167">def write_color(self, text, attr=None):
    n,res= self.ansiwriter.write_color(text,attr)
    junk = c_int(0)
    for attr,chunk in res:
        log(str(attr))
        log(str(chunk))
        self.SetConsoleTextAttribute(self.hout, attr.winattr)
        self.WriteConsoleA(self.hout, ensure_text(chunk), len(chunk), byref(junk), None)
    return n


</t>
<t tx="ekr.20071201084507.168">def write_plain(self, text, attr=None):
    '''write text at current cursor position.'''
    log('write("%s", %s)' %(text,attr))
    if attr is None:
        attr = self.attr
    n = c_int(0)
    self.SetConsoleTextAttribute(self.hout, attr)
    self.WriteConsoleA(self.hout, ensure_text(chunk), len(chunk), byref(junk), None)
    return len(text)

</t>
<t tx="ekr.20071201084507.169"># make this class look like a file object
def write(self, text):
    log('write("%s")' % text)
    return self.write_color(text)

</t>
<t tx="ekr.20071201084507.170">#write = write_scrolling

def isatty(self):
    return True

</t>
<t tx="ekr.20071201084507.171">def flush(self):
    pass

</t>
<t tx="ekr.20071201084507.172">def page(self, attr=None, fill=' '):
    '''Fill the entire screen.'''
    if attr is None:
        attr = self.attr
    if len(fill) != 1:
        raise ValueError
    info = CONSOLE_SCREEN_BUFFER_INFO()
    self.GetConsoleScreenBufferInfo(self.hout, byref(info))
    if info.dwCursorPosition.X != 0 or info.dwCursorPosition.Y != 0:
        self.SetConsoleCursorPosition(self.hout, self.fixcoord(0, 0))

    w = info.dwSize.X
    n = c_int(0)
    for y in range(info.dwSize.Y):
        self.FillConsoleOutputAttribute(self.hout, attr, w, self.fixcoord(0, y), byref(n))
        self.FillConsoleOutputCharacterA(self.hout, ord(fill[0]), w, self.fixcoord(0, y), byref(n))

    self.attr = attr

</t>
<t tx="ekr.20071201084507.173">def text(self, x, y, text, attr=None):
    '''Write text at the given position.'''
    if attr is None:
        attr = self.attr

    pos = self.fixcoord(x, y)
    n = c_int(0)
    self.WriteConsoleOutputCharacterA(self.hout, text, len(text), pos, byref(n))
    self.FillConsoleOutputAttribute(self.hout, attr, n, pos, byref(n))

</t>
<t tx="ekr.20071201084507.174">def clear_to_end_of_window(self):
    top,bot=self._get_top_bot()
    pos=self.pos()
    w,h=self.size()
    self.rectangle( (pos[0],pos[1],w,pos[1]+1))
    if pos[1]&lt;bot:
        self.rectangle((0,pos[1]+1,w,bot+1))

</t>
<t tx="ekr.20071201084507.175">def rectangle(self, rect, attr=None, fill=' '):
    '''Fill Rectangle.'''
    log_sock("rect:%s"%[rect])
    x0, y0, x1, y1 = rect
    n = c_int(0)
    if attr is None:
        attr = self.attr
    for y in range(y0, y1):
        pos = self.fixcoord(x0, y)
        self.FillConsoleOutputAttribute(self.hout, attr, x1-x0, pos, byref(n))
        self.FillConsoleOutputCharacterA(self.hout, ord(fill[0]), x1-x0, pos, byref(n))

</t>
<t tx="ekr.20071201084507.176">def scroll(self, rect, dx, dy, attr=None, fill=' '):
    '''Scroll a rectangle.'''
    if attr is None:
        attr = self.attr

    x0, y0, x1, y1 = rect
    source = SMALL_RECT(x0, y0, x1-1, y1-1)
    dest = self.fixcoord(x0+dx, y0+dy)
    style = CHAR_INFO()
    style.Char.AsciiChar = fill[0]
    style.Attributes = attr

    return self.ScrollConsoleScreenBufferA(self.hout, byref(source), byref(source),
                                                                                 dest, byref(style))

</t>
<t tx="ekr.20071201084507.177">def scroll_window(self, lines):
    '''Scroll the window by the indicated number of lines.'''
    info = CONSOLE_SCREEN_BUFFER_INFO()
    self.GetConsoleScreenBufferInfo(self.hout, byref(info))
    rect = info.srWindow
    log('sw: rtop=%d rbot=%d' % (rect.Top, rect.Bottom))
    top = rect.Top + lines
    bot = rect.Bottom + lines
    h = bot - top
    maxbot = info.dwSize.Y-1
    if top &lt; 0:
        top = 0
        bot = h
    if bot &gt; maxbot:
        bot = maxbot
        top = bot - h

    nrect = SMALL_RECT()
    nrect.Top = top
    nrect.Bottom = bot
    nrect.Left = rect.Left
    nrect.Right = rect.Right
    log('sn: top=%d bot=%d' % (top,bot))
    r=self.SetConsoleWindowInfo(self.hout, True, byref(nrect))
    log('r=%d' % r)

</t>
<t tx="ekr.20071201084507.178">def get(self):
    '''Get next event from queue.'''
    inputHookFunc = c_int.from_address(self.inputHookPtr).value

    Cevent = INPUT_RECORD()
    count = c_int(0)
    while 1:
        if inputHookFunc:
            call_function(inputHookFunc, ())
        status = self.ReadConsoleInputA(self.hin, byref(Cevent), 1, byref(count))
        if status and count.value == 1:
            e = event(self, Cevent)
            log_sock(str(e.keyinfo),"keypress")
            return e

</t>
<t tx="ekr.20071201084507.179">def getkeypress(self):
    '''Return next key press event from the queue, ignoring others.'''
    while 1:
        e = self.get()
        if e.type == 'KeyPress' and e.keycode not in key_modifiers:
            log(e)
            if e.keyinfo.keyname == 'next':
                self.scroll_window(12)
            elif e.keyinfo.keyname == 'prior':
                self.scroll_window(-12)
            else:
                return e
        elif e.type == 'KeyRelease' and e.keyinfo==(True, False, False, 83):
            log("getKeypress:%s,%s,%s"%(e.keyinfo,e.keycode,e.type))
            return e
            
</t>
<t tx="ekr.20071201084507.180">def getchar(self):
    '''Get next character from queue.'''

    Cevent = INPUT_RECORD()
    count = c_int(0)
    while 1:
        status = self.ReadConsoleInputA(self.hin, byref(Cevent), 1, byref(count))
        if (status and count.value==1 and Cevent.EventType == 1 and
                Cevent.Event.KeyEvent.bKeyDown):
            sym = keysym(Cevent.Event.KeyEvent.wVirtualKeyCode)
            if len(sym) == 0:
                sym = Cevent.Event.KeyEvent.uChar.AsciiChar
            return sym

</t>
<t tx="ekr.20071201084507.181">def peek(self):
    '''Check event queue.'''
    Cevent = INPUT_RECORD()
    count = c_int(0)
    status = self.PeekConsoleInputA(self.hin, byref(Cevent), 1, byref(count))
    log_sock("%s %s %s"%(status,count,Cevent))
    if status and count == 1:
        return event(self, Cevent)

</t>
<t tx="ekr.20071201084507.182">def title(self, txt=None):
    '''Set/get title.'''
    if txt:
        self.SetConsoleTitleA(txt)
    else:
        buffer = c_buffer(200)
        n = self.GetConsoleTitleA(buffer, 200)
        if n &gt; 0:
            return buffer.value[:n]

</t>
<t tx="ekr.20071201084507.183">def size(self, width=None, height=None):
    '''Set/get window size.'''
    info = CONSOLE_SCREEN_BUFFER_INFO()
    status = self.GetConsoleScreenBufferInfo(self.hout, byref(info))
    if not status:
        return None
    if width is not None and height is not None:
        wmin = info.srWindow.Right - info.srWindow.Left + 1
        hmin = info.srWindow.Bottom - info.srWindow.Top + 1
        #print wmin, hmin
        width = max(width, wmin)
        height = max(height, hmin)
        #print width, height
        self.SetConsoleScreenBufferSize(self.hout, self.fixcoord(width, height))
    else:
        return (info.dwSize.X, info.dwSize.Y)

</t>
<t tx="ekr.20071201084507.184">def cursor(self, visible=None, size=None):
    '''Set cursor on or off.'''
    info = CONSOLE_CURSOR_INFO()
    if self.GetConsoleCursorInfo(self.hout, byref(info)):
        if visible is not None:
            info.bVisible = visible
        if size is not None:
            info.dwSize = size
        self.SetConsoleCursorInfo(self.hout, byref(info))

</t>
<t tx="ekr.20071201084507.185">def bell(self):
    self.write('\007')

</t>
<t tx="ekr.20071201084507.186">def next_serial(self):
    '''Get next event serial number.'''
    self.serial += 1
    return self.serial

</t>
<t tx="ekr.20071201084507.187"># add the functions from the dll to the class
for func in funcs:
    setattr(Console, func, getattr(windll.kernel32, func))

from event import Event

VkKeyScan = windll.user32.VkKeyScanA


class event(Event):
    '''Represent events from the console.'''
    @others
</t>
<t tx="ekr.20071201084507.188">def __init__(self, console, input):
    '''Initialize an event from the Windows input structure.'''
    self.type = '??'
    self.serial = console.next_serial()
    self.width = 0
    self.height = 0
    self.x = 0
    self.y = 0
    self.char = ''
    self.keycode = 0
    self.keysym = '??'
    self.keyinfo = None # a tuple with (control, meta, shift, keycode) for dispatch
    self.width = None
    
    if input.EventType == KEY_EVENT:
        if input.Event.KeyEvent.bKeyDown:
            self.type = "KeyPress"
        else:
            self.type = "KeyRelease"
        self.char = input.Event.KeyEvent.uChar.AsciiChar
        self.keycode = input.Event.KeyEvent.wVirtualKeyCode
        self.state = input.Event.KeyEvent.dwControlKeyState
        self.keyinfo=make_KeyPress(self.char,self.state,self.keycode)

    elif input.EventType == MOUSE_EVENT:
        if input.Event.MouseEvent.dwEventFlags &amp; MOUSE_MOVED:
            self.type = "Motion"
        else:
            self.type = "Button"
        self.x = input.Event.MouseEvent.dwMousePosition.X
        self.y = input.Event.MouseEvent.dwMousePosition.Y
        self.state = input.Event.MouseEvent.dwButtonState
    elif input.EventType == WINDOW_BUFFER_SIZE_EVENT:
        self.type = "Configure"
        self.width = input.Event.WindowBufferSizeEvent.dwSize.X
        self.height = input.Event.WindowBufferSizeEvent.dwSize.Y
    elif input.EventType == FOCUS_EVENT:
        if input.Event.FocusEvent.bSetFocus:
            self.type = "FocusIn"
        else:
            self.type = "FocusOut"
    elif input.EventType == MENU_EVENT:
        self.type = "Menu"
        self.state = input.Event.MenuEvent.dwCommandId

</t>
<t tx="ekr.20071201084507.189">def getconsole(buffer=1):
        """Get a console handle.

        If buffer is non-zero, a new console buffer is allocated and
        installed.  Otherwise, this returns a handle to the current
        console buffer"""

        c = Console(buffer)

        return c

</t>
<t tx="ekr.20071201084507.190"># The following code uses ctypes to allow a Python callable to
# substitute for GNU readline within the Python interpreter. Calling
# raw_input or other functions that do input, inside your callable
# might be a bad idea, then again, it might work.

# The Python callable can raise EOFError or KeyboardInterrupt and
# these will be translated into the appropriate outputs from readline
# so that they will then be translated back!

# If the Python callable raises any other exception, a traceback will
# be printed and readline will appear to return an empty line.

# I use ctypes to create a C-callable from a Python wrapper that
# handles the exceptions and gets the result into the right form.

# the type for our C-callable wrapper
HOOKFUNC22 = CFUNCTYPE(c_char_p, c_char_p)
HOOKFUNC23 = CFUNCTYPE(c_char_p, c_void_p, c_void_p, c_char_p)

readline_hook = None # the python hook goes here
readline_ref = None  # this holds a reference to the c-callable to keep it alive

def hook_wrapper_23(stdin, stdout, prompt):
    '''Wrap a Python readline so it behaves like GNU readline.'''
    try:
        # call the Python hook
        res = readline_hook(prompt)
        # make sure it returned the right sort of thing
        if res and not isinstance(res, str):
            raise TypeError, 'readline must return a string.'
    except KeyboardInterrupt:
        # GNU readline returns 0 on keyboard interrupt
        return 0
    except EOFError:
        # It returns an empty string on EOF
        res = ''
    except:
        print &gt;&gt;sys.stderr, 'Readline internal error'
        traceback.print_exc()
        res = '\n'
    # we have to make a copy because the caller expects to free the result
    n = len(res)
    p = Console.PyMem_Malloc(n+1)
    cdll.msvcrt.strncpy(p, res, n+1)
    return p

</t>
<t tx="ekr.20071201084507.191">def hook_wrapper(prompt):
    '''Wrap a Python readline so it behaves like GNU readline.'''
    try:
        # call the Python hook
        res = readline_hook(prompt)
        # make sure it returned the right sort of thing
        if res and not isinstance(res, str):
            raise TypeError, 'readline must return a string.'
    except KeyboardInterrupt:
        # GNU readline returns 0 on keyboard interrupt
        return 0
    except EOFError:
        # It returns an empty string on EOF
        res = ''
    except:
        print &gt;&gt;sys.stderr, 'Readline internal error'
        traceback.print_exc()
        res = '\n'
    # we have to make a copy because the caller expects to free the result
    p = cdll.msvcrt._strdup(res)
    return p

</t>
<t tx="ekr.20071201084507.192">def install_readline(hook):
    '''Set up things for the interpreter to call our function like GNU readline.'''
    global readline_hook, readline_ref
    # save the hook so the wrapper can call it
    readline_hook = hook
    # get the address of PyOS_ReadlineFunctionPointer so we can update it
    PyOS_RFP = c_int.from_address(Console.GetProcAddress(sys.dllhandle,
                                                 "PyOS_ReadlineFunctionPointer"))
    # save a reference to the generated C-callable so it doesn't go away
    if sys.version &lt; '2.3':
        readline_ref = HOOKFUNC22(hook_wrapper)
    else:
        readline_ref = HOOKFUNC23(hook_wrapper_23)
    # get the address of the function
    func_start = c_int.from_address(addressof(readline_ref)).value
    # write the function address into PyOS_ReadlineFunctionPointer
    PyOS_RFP.value = func_start

</t>
<t tx="ekr.20071201084507.209"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
'''Cursor control and color for the .NET console.
'''

#
# Ironpython requires a patch to work do:
#
# In file PythonCommandLine.cs patch line:     
#    class PythonCommandLine
#    {

# to:
#    public class PythonCommandLine
#    {
#
#
#
# primitive debug printing that won't interfere with the screen

import clr,sys
clr.AddReferenceToFileAndPath(sys.executable)
import IronPythonConsole

import sys
import re
import os

import System

from event import Event
from pyreadline.logger import log,log_sock

#print "Codepage",System.Console.InputEncoding.CodePage
from pyreadline.keysyms import make_keysym, make_keyinfo,make_KeyPress,make_KeyPress_from_keydescr
from pyreadline.console.ansi import AnsiState
color=System.ConsoleColor

ansicolor={"0;30": color.Black,
           "0;31": color.DarkRed,
           "0;32": color.DarkGreen,
           "0;33": color.DarkYellow,
           "0;34": color.DarkBlue,
           "0;35": color.DarkMagenta,
           "0;36": color.DarkCyan,
           "0;37": color.DarkGray,
           "1;30": color.Gray,
           "1;31": color.Red,
           "1;32": color.Green,
           "1;33": color.Yellow,
           "1;34": color.Blue,
           "1;35": color.Magenta,
           "1;36": color.Cyan,
           "1;37": color.White
          }

winattr={"black":0,"darkgray":0+8,
         "darkred":4,"red":4+8,
         "darkgreen":2,"green":2+8,
         "darkyellow":6,"yellow":6+8,
         "darkblue":1,"blue":1+8,
         "darkmagenta":5, "magenta":5+8,
         "darkcyan":3,"cyan":3+8,
         "gray":7,"white":7+8}

</t>
<t tx="ekr.20071201084507.210">class Console(object):
    '''Console driver for Windows.

    '''
    @others
</t>
<t tx="ekr.20071201084507.211">
def __init__(self, newbuffer=0):
    '''Initialize the Console object.

    newbuffer=1 will allocate a new buffer so the old content will be restored
    on exit.
    '''
    self.serial=0
    self.attr = System.Console.ForegroundColor
    self.saveattr = winattr[str(System.Console.ForegroundColor).lower()]
    self.savebg=System.Console.BackgroundColor
    log('initial attr=%s' % self.attr)
    log_sock("%s"%self.saveattr)

</t>
<t tx="ekr.20071201084507.212">def _get(self):
    top=System.Console.WindowTop
    log_sock("WindowTop:%s"%top,"console")
    return top
</t>
<t tx="ekr.20071201084507.213">def _set(self,value):
    top=System.Console.WindowTop
    log_sock("Set WindowTop:old:%s,new:%s"%(top,value),"console")
</t>
<t tx="ekr.20071201084507.214">WindowTop=property(_get,_set)
del _get,_set

def __del__(self):
    '''Cleanup the console when finished.'''
    # I don't think this ever gets called
    pass

</t>
<t tx="ekr.20071201084507.215">def pos(self, x=None, y=None):
    '''Move or query the window cursor.'''
    if x is not None:
        System.Console.CursorLeft=x
    else:
        x=System.Console.CursorLeft
    if y is not None:
        System.Console.CursorTop=y
    else:
        y=System.Console.CursorTop
    return x,y

</t>
<t tx="ekr.20071201084507.216">def home(self):
    '''Move to home.'''
    self.pos(0,0)

</t>
<t tx="ekr.20071201084507.217"># Map ANSI color escape sequences into Windows Console Attributes

    terminal_escape = re.compile('(\001?\033\\[[0-9;]*m\002?)')
    escape_parts = re.compile('\001?\033\\[([0-9;]*)m\002?')

    # This pattern should match all characters that change the cursor position differently
    # than a normal character.
    motion_char_re = re.compile('([\n\r\t\010\007])')

def write_scrolling(self, text, attr=None):
    '''write text at current cursor position while watching for scrolling.

    If the window scrolls because you are at the bottom of the screen
    buffer, all positions that you are storing will be shifted by the
    scroll amount. For example, I remember the cursor position of the
    prompt so that I can redraw the line but if the window scrolls,
    the remembered position is off.

    This variant of write tries to keep track of the cursor position
    so that it will know when the screen buffer is scrolled. It
    returns the number of lines that the buffer scrolled.

    '''
    x, y = self.pos()
    w, h = self.size()
    scroll = 0 # the result

    # split the string into ordinary characters and funny characters
    chunks = self.motion_char_re.split(text)
    for chunk in chunks:
        log('C:'+chunk)
        n = self.write_color(chunk, attr)
        if len(chunk) == 1: # the funny characters will be alone
            if chunk[0] == '\n': # newline
                x = 0
                y += 1
            elif chunk[0] == '\r': # carriage return
                x = 0
            elif chunk[0] == '\t': # tab
                x = 8*(int(x/8)+1)
                if x &gt; w: # newline
                    x -= w
                    y += 1
            elif chunk[0] == '\007': # bell
                pass
            elif chunk[0] == '\010':
                x -= 1
                if x &lt; 0:
                    y -= 1 # backed up 1 line
            else: # ordinary character
                x += 1
            if x == w: # wrap
                x = 0
                y += 1
            if y == h: # scroll
                scroll += 1
                y = h - 1
        else: # chunk of ordinary characters
            x += n
            l = int(x / w) # lines we advanced
            x = x % w # new x value
            y += l
            if y &gt;= h: # scroll
                scroll += y - h + 1
                y = h - 1
    return scroll

</t>
<t tx="ekr.20071201084507.218">trtable={0:color.Black,4:color.DarkRed,2:color.DarkGreen,6:color.DarkYellow,
         1:color.DarkBlue,5:color.DarkMagenta,3:color.DarkCyan,7:color.Gray,
         8:color.DarkGray,4+8:color.Red,2+8:color.Green,6+8:color.Yellow,
         1+8:color.Blue,5+8:color.Magenta,3+8:color.Cyan,7+8:color.White}

def write_color(self, text, attr=None):
    '''write text at current cursor position and interpret color escapes.

    return the number of characters written.
    '''
    log('write_color("%s", %s)' % (text, attr))
    chunks = self.terminal_escape.split(text)
    log('chunks=%s' % repr(chunks))
    bg=self.savebg
    n = 0 # count the characters we actually write, omitting the escapes
    if attr is None:#use attribute from initial console
        attr = self.attr
    try:
        fg=self.trtable[(0x000f&amp;attr)]
        bg=self.trtable[(0x00f0&amp;attr)&gt;&gt;4]
    except TypeError:
        fg=attr
        
    for chunk in chunks:
        m = self.escape_parts.match(chunk)
        if m:
            log(m.group(1))
            attr=ansicolor.get(m.group(1),self.attr)
        n += len(chunk)
        System.Console.ForegroundColor=fg
        System.Console.BackgroundColor=bg
        #self.WriteConsoleA(self.hout, chunk, len(chunk), byref(junk), None)
        System.Console.Write(chunk)
    return n

</t>
<t tx="ekr.20071201084507.219">def write_plain(self, text, attr=None):
    '''write text at current cursor position.'''
    log('write("%s", %s)' %(text,attr))
    if attr is None:
        attr = self.attr
    n = c_int(0)
    self.SetConsoleTextAttribute(self.hout, attr)
    self.WriteConsoleA(self.hout, text, len(text), byref(n), None)
    return len(text)
    
</t>
<t tx="ekr.20071201084507.220">if os.environ.has_key("EMACS"):
    def write_color(self, text, attr=None):
        junk = c_int(0)
        self.WriteFile(self.hout, text, len(text), byref(junk), None)
        return len(text)
    write_plain = write_color

# make this class look like a file object
def write(self, text):
    log('write("%s")' % text)
    return self.write_color(text)

</t>
<t tx="ekr.20071201084507.221">#write = write_scrolling

def isatty(self):
    return True

</t>
<t tx="ekr.20071201084507.222">def flush(self):
    pass

</t>
<t tx="ekr.20071201084507.223">def page(self, attr=None, fill=' '):
    '''Fill the entire screen.'''
    System.Console.Clear()

</t>
<t tx="ekr.20071201084507.224">def text(self, x, y, text, attr=None):
    '''Write text at the given position.'''
    self.pos(x,y)
    self.write_color(text,attr)

</t>
<t tx="ekr.20071201084507.225">def clear_to_end_of_window(self):
    oldtop=self.WindowTop
    lastline=self.WindowTop+System.Console.WindowHeight
    pos=self.pos()
    w,h=self.size()
    length=w-pos[0]+min((lastline-pos[1]-1),5)*w-1
    self.write_color(length*" ")
    self.pos(*pos)
    self.WindowTop=oldtop
    
</t>
<t tx="ekr.20071201084507.226">def rectangle(self, rect, attr=None, fill=' '):
    '''Fill Rectangle.'''
    pass
    oldtop=self.WindowTop
    oldpos=self.pos()
    #raise NotImplementedError
    x0, y0, x1, y1 = rect
    if attr is None:
        attr = self.attr
    if fill:
        rowfill=fill[:1]*abs(x1-x0)
    else:
        rowfill=' '*abs(x1-x0)
    for y in range(y0, y1):
            System.Console.SetCursorPosition(x0,y)
            self.write_color(rowfill,attr)
    self.pos(*oldpos)

</t>
<t tx="ekr.20071201084507.227">def scroll(self, rect, dx, dy, attr=None, fill=' '):
    '''Scroll a rectangle.'''
    pass
    raise NotImplementedError

</t>
<t tx="ekr.20071201084507.228">def scroll_window(self, lines):
    '''Scroll the window by the indicated number of lines.'''
    top=self.WindowTop+lines
    if top&lt;0:
        top=0
    if top+System.Console.WindowHeight&gt;System.Console.BufferHeight:
        top=System.Console.BufferHeight
    self.WindowTop=top

</t>
<t tx="ekr.20071201084507.229">def getkeypress(self):
    '''Return next key press event from the queue, ignoring others.'''
    ck=System.ConsoleKey
    while 1:
        e = System.Console.ReadKey(True)
        if e.Key == System.ConsoleKey.PageDown: #PageDown
            self.scroll_window(12)
        elif e.Key == System.ConsoleKey.PageUp:#PageUp
            self.scroll_window(-12)
        elif str(e.KeyChar)=="\000":#Drop deadkeys
            log_sock("Deadkey: %s"%e)
            return event(self,e)
            pass
        else:
            return event(self,e)

</t>
<t tx="ekr.20071201084507.230">def title(self, txt=None):
    '''Set/get title.'''
    if txt:
        System.Console.Title=txt
    else:
        return System.Console.Title

</t>
<t tx="ekr.20071201084507.231">def size(self, width=None, height=None):
    '''Set/get window size.'''
    sc=System.Console
    

    if width is not None and height is not None:
        sc.BufferWidth,sc.BufferHeight=width,height
    else:
        return sc.BufferWidth,sc.BufferHeight

    if width is not None and height is not None:
        sc.WindowWidth,sc.WindowHeight=width,height
    else:
        return sc.WindowWidth-1,sc.WindowHeight-1

</t>
<t tx="ekr.20071201084507.232">def cursor(self, visible=True, size=None):
    '''Set cursor on or off.'''
    System.Console.CursorVisible=visible

</t>
<t tx="ekr.20071201084507.233">def bell(self):
    System.Console.Beep()

</t>
<t tx="ekr.20071201084507.234">def next_serial(self):
    '''Get next event serial number.'''
    self.serial += 1
    return self.serial

</t>
<t tx="ekr.20071201084507.235">class event(Event):
    '''Represent events from the console.'''
    @others
</t>
<t tx="ekr.20071201084507.236">def __init__(self, console, input):
    '''Initialize an event from the Windows input structure.'''
    self.type = '??'
    self.serial = console.next_serial()
    self.width = 0
    self.height = 0
    self.x = 0
    self.y = 0
    self.char = str(input.KeyChar)
    self.keycode = input.Key
    self.state = input.Modifiers
    log_sock("%s,%s,%s"%(input.Modifiers,input.Key,input.KeyChar),"console")
    self.type="KeyRelease"
    self.keysym = make_keysym(self.keycode)
    self.keyinfo = make_KeyPress(self.char, self.state, self.keycode)

</t>
<t tx="ekr.20071201084507.237">def make_event_from_keydescr(keydescr):
    def input():
        return 1
    input.KeyChar="a"
    input.Key=System.ConsoleKey.A
    input.Modifiers=System.ConsoleModifiers.Shift
    input.next_serial=input
    e=event(input,input)
    del input.next_serial
    keyinfo=make_KeyPress_from_keydescr(keydescr)
    e.keyinfo=keyinfo
    return e

</t>
<t tx="ekr.20071201084507.238">CTRL_C_EVENT=make_event_from_keydescr("Control-c")

def install_readline(hook):
    def hook_wrap():
        try:
            res=hook()
        except KeyboardInterrupt,x:   #this exception does not seem to be caught
            res=""
        except EOFError:
            return None
        if res[-1:]=="\n":
            return res[:-1]
        else:
            return res
    class IronPythonWrapper(IronPythonConsole.IConsole):
        def ReadLine(self,autoIndentSize): 
            return hook_wrap()
        def Write(self,text, style):
            System.Console.Write(text)
        def WriteLine(self,text, style): 
            System.Console.WriteLine(text)
    IronPythonConsole.PythonCommandLine.MyConsole = IronPythonWrapper()



</t>
<t tx="ekr.20071201085451"></t>
<t tx="ekr.20071201085451.1098">import sys,textwrap

rlmain=sys.modules["pyreadline.rlmain"]
rl=rlmain.rl

</t>
<t tx="ekr.20071201085451.1099">def get_doc(rl):
    methods=[(x,getattr(rl,x)) for x in dir(rl) if callable(getattr(rl,x))]
    return [ (x,m.__doc__ )for x,m in methods if m.__doc__]
    
    
</t>
<t tx="ekr.20071201085451.1100">def get_rest(rl):
    q=get_doc(rl)
    out=[]
    for funcname,doc in q:
        out.append(funcname)
        out.append("\n".join(textwrap.wrap(doc,80,initial_indent="   ")))
        out.append("")
    return out     </t>
<t tx="ekr.20071201085751"># -*- coding: utf-8 -*-
"""Manage background (threaded) jobs conveniently from an interactive shell.

This module provides a BackgroundJobManager class.  This is the main class
meant for public usage, it implements an object which can create and manage
new background jobs.

It also provides the actual job classes managed by these BackgroundJobManager
objects, see their docstrings below.


This system was inspired by discussions with B. Granger and the
BackgroundCommand class described in the book Python Scripting for
Computational Science, by H. P. Langtangen:

http://folk.uio.no/hpl/scripting

(although ultimately no code from this text was used, as IPython's system is a
separate implementation).

$Id$
"""

#*****************************************************************************
#       Copyright (C) 2005-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

# Code begins
import sys
import threading

from IPython.ultraTB import AutoFormattedTB
from IPython.genutils import warn,error

</t>
<t tx="ekr.20071201085751.1">class BackgroundJobManager:
    """Class to manage a pool of backgrounded threaded jobs.

    Below, we assume that 'jobs' is a BackgroundJobManager instance.
    
    Usage summary (see the method docstrings for details):

      jobs.new(...) -&gt; start a new job
      
      jobs() or jobs.status() -&gt; print status summary of all jobs

      jobs[N] -&gt; returns job number N.

      foo = jobs[N].result -&gt; assign to variable foo the result of job N

      jobs[N].traceback() -&gt; print the traceback of dead job N

      jobs.remove(N) -&gt; remove (finished) job N

      jobs.flush_finished() -&gt; remove all finished jobs
      
    As a convenience feature, BackgroundJobManager instances provide the
    utility result and traceback methods which retrieve the corresponding
    information from the jobs list:

      jobs.result(N) &lt;--&gt; jobs[N].result
      jobs.traceback(N) &lt;--&gt; jobs[N].traceback()

    While this appears minor, it allows you to use tab completion
    interactively on the job manager instance.

    In interactive mode, IPython provides the magic fuction %bg for quick
    creation of backgrounded expression-based jobs. Type bg? for details."""
    @others
</t>
<t tx="ekr.20071201085751.2">
def __init__(self):
    # Lists for job management
    self.jobs_run  = []
    self.jobs_comp = []
    self.jobs_dead = []
    # A dict of all jobs, so users can easily access any of them
    self.jobs_all = {}
    # For reporting
    self._comp_report = []
    self._dead_report = []
    # Store status codes locally for fast lookups
    self._s_created   = BackgroundJobBase.stat_created_c
    self._s_running   = BackgroundJobBase.stat_running_c
    self._s_completed = BackgroundJobBase.stat_completed_c
    self._s_dead      = BackgroundJobBase.stat_dead_c

</t>
<t tx="ekr.20071201085751.3">def new(self,func_or_exp,*args,**kwargs):
    """Add a new background job and start it in a separate thread.

    There are two types of jobs which can be created:

    1. Jobs based on expressions which can be passed to an eval() call.
    The expression must be given as a string.  For example:

      job_manager.new('myfunc(x,y,z=1)'[,glob[,loc]])

    The given expression is passed to eval(), along with the optional
    global/local dicts provided.  If no dicts are given, they are
    extracted automatically from the caller's frame.
    
    A Python statement is NOT a valid eval() expression.  Basically, you
    can only use as an eval() argument something which can go on the right
    of an '=' sign and be assigned to a variable.

    For example,"print 'hello'" is not valid, but '2+3' is.

    2. Jobs given a function object, optionally passing additional
    positional arguments:

      job_manager.new(myfunc,x,y)

    The function is called with the given arguments.

    If you need to pass keyword arguments to your function, you must
    supply them as a dict named kw:

      job_manager.new(myfunc,x,y,kw=dict(z=1))

    The reason for this assymmetry is that the new() method needs to
    maintain access to its own keywords, and this prevents name collisions
    between arguments to new() and arguments to your own functions.

    In both cases, the result is stored in the job.result field of the
    background job object.


    Notes and caveats:

    1. All threads running share the same standard output.  Thus, if your
    background jobs generate output, it will come out on top of whatever
    you are currently writing.  For this reason, background jobs are best
    used with silent functions which simply return their output.

    2. Threads also all work within the same global namespace, and this
    system does not lock interactive variables.  So if you send job to the
    background which operates on a mutable object for a long time, and
    start modifying that same mutable object interactively (or in another
    backgrounded job), all sorts of bizarre behaviour will occur.

    3. If a background job is spending a lot of time inside a C extension
    module which does not release the Python Global Interpreter Lock
    (GIL), this will block the IPython prompt.  This is simply because the
    Python interpreter can only switch between threads at Python
    bytecodes.  While the execution is inside C code, the interpreter must
    simply wait unless the extension module releases the GIL.

    4. There is no way, due to limitations in the Python threads library,
    to kill a thread once it has started."""
    
    if callable(func_or_exp):
        kw  = kwargs.get('kw',{})
        job = BackgroundJobFunc(func_or_exp,*args,**kw)
    elif isinstance(func_or_exp,basestring):
        if not args:
            frame = sys._getframe(1)
            glob, loc = frame.f_globals, frame.f_locals
        elif len(args)==1:
            glob = loc = args[0]
        elif len(args)==2:
            glob,loc = args
        else:
            raise ValueError,\
                  'Expression jobs take at most 2 args (globals,locals)'
        job = BackgroundJobExpr(func_or_exp,glob,loc)
    else:
        raise
    jkeys = self.jobs_all.keys()
    if jkeys:
        job.num = max(jkeys)+1
    else:
        job.num = 0
    self.jobs_run.append(job)
    self.jobs_all[job.num] = job
    print 'Starting job # %s in a separate thread.' % job.num
    job.start()
    return job

</t>
<t tx="ekr.20071201085751.4">def __getitem__(self,key):
    return self.jobs_all[key]

</t>
<t tx="ekr.20071201085751.5">def __call__(self):
    """An alias to self.status(),

    This allows you to simply call a job manager instance much like the
    Unix jobs shell command."""

    return self.status()

</t>
<t tx="ekr.20071201085751.6">def _update_status(self):
    """Update the status of the job lists.

    This method moves finished jobs to one of two lists:
      - self.jobs_comp: jobs which completed successfully
      - self.jobs_dead: jobs which finished but died.

    It also copies those jobs to corresponding _report lists.  These lists
    are used to report jobs completed/dead since the last update, and are
    then cleared by the reporting function after each call."""
    
    run,comp,dead = self._s_running,self._s_completed,self._s_dead
    jobs_run = self.jobs_run
    for num in range(len(jobs_run)):
        job  = jobs_run[num]
        stat = job.stat_code
        if stat == run:
            continue
        elif stat == comp:
            self.jobs_comp.append(job)
            self._comp_report.append(job)
            jobs_run[num] = False
        elif stat == dead:
            self.jobs_dead.append(job)
            self._dead_report.append(job)
            jobs_run[num] = False
    self.jobs_run = filter(None,self.jobs_run)

</t>
<t tx="ekr.20071201085751.7">def _group_report(self,group,name):
    """Report summary for a given job group.

    Return True if the group had any elements."""

    if group:
        print '%s jobs:' % name
        for job in group:
            print '%s : %s' % (job.num,job)
        print
        return True

</t>
<t tx="ekr.20071201085751.8">def _group_flush(self,group,name):
    """Flush a given job group

    Return True if the group had any elements."""

    njobs = len(group)
    if njobs:
        plural = {1:''}.setdefault(njobs,'s')
        print 'Flushing %s %s job%s.' % (njobs,name,plural)
        group[:] = []
        return True
    
</t>
<t tx="ekr.20071201085751.9">def _status_new(self):
    """Print the status of newly finished jobs.

    Return True if any new jobs are reported.

    This call resets its own state every time, so it only reports jobs
    which have finished since the last time it was called."""

    self._update_status()
    new_comp = self._group_report(self._comp_report,'Completed')
    new_dead = self._group_report(self._dead_report,
                                  'Dead, call job.traceback() for details')
    self._comp_report[:] = []
    self._dead_report[:] = []
    return new_comp or new_dead
            
</t>
<t tx="ekr.20071201085751.10">def status(self,verbose=0):
    """Print a status of all jobs currently being managed."""

    self._update_status()
    self._group_report(self.jobs_run,'Running')
    self._group_report(self.jobs_comp,'Completed')
    self._group_report(self.jobs_dead,'Dead')
    # Also flush the report queues
    self._comp_report[:] = []
    self._dead_report[:] = []

</t>
<t tx="ekr.20071201085751.11">def remove(self,num):
    """Remove a finished (completed or dead) job."""

    try:
        job = self.jobs_all[num]
    except KeyError:
        error('Job #%s not found' % num)
    else:
        stat_code = job.stat_code
        if stat_code == self._s_running:
            error('Job #%s is still running, it can not be removed.' % num)
            return
        elif stat_code == self._s_completed:
            self.jobs_comp.remove(job)
        elif stat_code == self._s_dead:
            self.jobs_dead.remove(job)

</t>
<t tx="ekr.20071201085751.12">def flush_finished(self):
    """Flush all jobs finished (completed and dead) from lists.

    Running jobs are never flushed.

    It first calls _status_new(), to update info. If any jobs have
    completed since the last _status_new() call, the flush operation
    aborts."""

    if self._status_new():
        error('New jobs completed since last '\
              '_status_new(), aborting flush.')
        return

    # Remove the finished jobs from the master dict
    jobs_all = self.jobs_all
    for job in self.jobs_comp+self.jobs_dead:
        del(jobs_all[job.num])

    # Now flush these lists completely
    fl_comp = self._group_flush(self.jobs_comp,'Completed')
    fl_dead = self._group_flush(self.jobs_dead,'Dead')
    if not (fl_comp or fl_dead):
        print 'No jobs to flush.'

</t>
<t tx="ekr.20071201085751.13">def result(self,num):
    """result(N) -&gt; return the result of job N."""
    try:
        return self.jobs_all[num].result
    except KeyError:
        error('Job #%s not found' % num)

</t>
<t tx="ekr.20071201085751.14">def traceback(self,num):
    try:
        self.jobs_all[num].traceback()
    except KeyError:
        error('Job #%s not found' % num)


</t>
<t tx="ekr.20071201085751.15">class BackgroundJobBase(threading.Thread):
    """Base class to build BackgroundJob classes.

    The derived classes must implement:

    - Their own __init__, since the one here raises NotImplementedError.  The
    derived constructor must call self._init() at the end, to provide common
    initialization.

    - A strform attribute used in calls to __str__.

    - A call() method, which will make the actual execution call and must
    return a value to be held in the 'result' field of the job object."""

    # Class constants for status, in string and as numerical codes (when
    # updating jobs lists, we don't want to do string comparisons).  This will
    # be done at every user prompt, so it has to be as fast as possible
    stat_created   = 'Created'; stat_created_c = 0
    stat_running   = 'Running'; stat_running_c = 1
    stat_completed = 'Completed'; stat_completed_c = 2
    stat_dead      = 'Dead (Exception), call job.traceback() for details'
    stat_dead_c = -1

    @others
</t>
<t tx="ekr.20071201085751.16">def __init__(self):
    raise NotImplementedError, \
          "This class can not be instantiated directly."

</t>
<t tx="ekr.20071201085751.17">def _init(self):
    """Common initialization for all BackgroundJob objects"""
    
    for attr in ['call','strform']:
        assert hasattr(self,attr), "Missing attribute &lt;%s&gt;" % attr
    
    # The num tag can be set by an external job manager
    self.num = None
  
    self.status    = BackgroundJobBase.stat_created
    self.stat_code = BackgroundJobBase.stat_created_c
    self.finished  = False
    self.result    = '&lt;BackgroundJob has not completed&gt;'
    # reuse the ipython traceback handler if we can get to it, otherwise
    # make a new one
    try:
        self._make_tb = __IPYTHON__.InteractiveTB.text
    except:
        self._make_tb = AutoFormattedTB(mode = 'Context',
                                       color_scheme='NoColor',
                                       tb_offset = 1).text
    # Hold a formatted traceback if one is generated.
    self._tb = None
    
    threading.Thread.__init__(self)

</t>
<t tx="ekr.20071201085751.18">def __str__(self):
    return self.strform

</t>
<t tx="ekr.20071201085751.19">def __repr__(self):
    return '&lt;BackgroundJob: %s&gt;' % self.strform

</t>
<t tx="ekr.20071201085751.20">def traceback(self):
    print self._tb
    
</t>
<t tx="ekr.20071201085751.21">def run(self):
    try:
        self.status    = BackgroundJobBase.stat_running
        self.stat_code = BackgroundJobBase.stat_running_c
        self.result    = self.call()
    except:
        self.status    = BackgroundJobBase.stat_dead
        self.stat_code = BackgroundJobBase.stat_dead_c
        self.finished  = None
        self.result    = ('&lt;BackgroundJob died, call job.traceback() for details&gt;')
        self._tb       = self._make_tb()
    else:
        self.status    = BackgroundJobBase.stat_completed
        self.stat_code = BackgroundJobBase.stat_completed_c
        self.finished  = True

</t>
<t tx="ekr.20071201085751.22">class BackgroundJobExpr(BackgroundJobBase):
    """Evaluate an expression as a background job (uses a separate thread)."""
    @others
</t>
<t tx="ekr.20071201085751.23">
def __init__(self,expression,glob=None,loc=None):
    """Create a new job from a string which can be fed to eval().

    global/locals dicts can be provided, which will be passed to the eval
    call."""

    # fail immediately if the given expression can't be compiled
    self.code = compile(expression,'&lt;BackgroundJob compilation&gt;','eval')
            
    if glob is None:
        glob = {}
    if loc is None:
        loc = {}
        
    self.expression = self.strform = expression
    self.glob = glob
    self.loc = loc
    self._init()
    
</t>
<t tx="ekr.20071201085751.24">def call(self):
    return eval(self.code,self.glob,self.loc)

</t>
<t tx="ekr.20071201085751.25">class BackgroundJobFunc(BackgroundJobBase):
    """Run a function call as a background job (uses a separate thread)."""
    @others
</t>
<t tx="ekr.20071201085751.26">
def __init__(self,func,*args,**kwargs):
    """Create a new job from a callable object.

    Any positional arguments and keyword args given to this constructor
    after the initial callable are passed directly to it."""

    assert callable(func),'first argument must be callable'
    
    if args is None:
        args = []
    if kwargs is None:
        kwargs = {}
    
    self.func = func
    self.args = args
    self.kwargs = kwargs
    # The string form will only include the function passed, because
    # generating string representations of the arguments is a potentially
    # _very_ expensive operation (e.g. with large arrays).
    self.strform = str(func)
    self._init()

</t>
<t tx="ekr.20071201085751.27">def call(self):
    return self.func(*self.args,**self.kwargs)


</t>
<t tx="ekr.20071201085751.28"># -*- coding: utf-8 -*-
"""Tools for coloring text in ANSI terminals.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2002-2006 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

__all__ = ['TermColors','InputTermColors','ColorScheme','ColorSchemeTable']

import os

from IPython.ipstruct import Struct

</t>
<t tx="ekr.20071201085751.29">def make_color_table(in_class):
    """Build a set of color attributes in a class.

    Helper function for building the *TermColors classes."""
    
    color_templates = (
        ("Black"       , "0;30"),
        ("Red"         , "0;31"),
        ("Green"       , "0;32"),
        ("Brown"       , "0;33"),
        ("Blue"        , "0;34"),
        ("Purple"      , "0;35"),
        ("Cyan"        , "0;36"),
        ("LightGray"   , "0;37"),
        ("DarkGray"    , "1;30"),
        ("LightRed"    , "1;31"),
        ("LightGreen"  , "1;32"),
        ("Yellow"      , "1;33"),
        ("LightBlue"   , "1;34"),
        ("LightPurple" , "1;35"),
        ("LightCyan"   , "1;36"),
        ("White"       , "1;37"),  )

    for name,value in color_templates:
        setattr(in_class,name,in_class._base % value)

</t>
<t tx="ekr.20071201085751.30">class TermColors:
    """Color escape sequences.

    This class defines the escape sequences for all the standard (ANSI?) 
    colors in terminals. Also defines a NoColor escape which is just the null
    string, suitable for defining 'dummy' color schemes in terminals which get
    confused by color escapes.

    This class should be used as a mixin for building color schemes."""
    
    NoColor = ''  # for color schemes in color-less terminals.
    Normal = '\033[0m'   # Reset normal coloring
    _base  = '\033[%sm'  # Template for all other colors

</t>
<t tx="ekr.20071201085751.31"># Build the actual color table as a set of class attributes:
make_color_table(TermColors)

class InputTermColors:
    """Color escape sequences for input prompts.

    This class is similar to TermColors, but the escapes are wrapped in \001
    and \002 so that readline can properly know the length of each line and
    can wrap lines accordingly.  Use this class for any colored text which
    needs to be used in input prompts, such as in calls to raw_input().

    This class defines the escape sequences for all the standard (ANSI?) 
    colors in terminals. Also defines a NoColor escape which is just the null
    string, suitable for defining 'dummy' color schemes in terminals which get
    confused by color escapes.

    This class should be used as a mixin for building color schemes."""
    
    NoColor = ''  # for color schemes in color-less terminals.
    Normal = '\001\033[0m\002'   # Reset normal coloring
    _base  = '\001\033[%sm\002'  # Template for all other colors

</t>
<t tx="ekr.20071201085751.32"># Build the actual color table as a set of class attributes:
make_color_table(InputTermColors)

class ColorScheme:
    """Generic color scheme class. Just a name and a Struct."""
    @others
</t>
<t tx="ekr.20071201085751.33">def __init__(self,__scheme_name_,colordict=None,**colormap):
    self.name = __scheme_name_
    if colordict is None:
        self.colors = Struct(**colormap)
    else:
        self.colors = Struct(colordict)

</t>
<t tx="ekr.20071201085751.34">def copy(self,name=None):
    """Return a full copy of the object, optionally renaming it."""
    if name is None:
        name = self.name
    return ColorScheme(name,self.colors.__dict__)
    
</t>
<t tx="ekr.20071201085751.35">class ColorSchemeTable(dict):
    """General class to handle tables of color schemes.

    It's basically a dict of color schemes with a couple of shorthand
    attributes and some convenient methods.
    
    active_scheme_name -&gt; obvious
    active_colors -&gt; actual color table of the active scheme"""
    @others
</t>
<t tx="ekr.20071201085751.36">
def __init__(self,scheme_list=None,default_scheme=''):
    """Create a table of color schemes.

    The table can be created empty and manually filled or it can be
    created with a list of valid color schemes AND the specification for
    the default active scheme.
    """
    
    # create object attributes to be set later
    self.active_scheme_name = ''
    self.active_colors = None
    
    if scheme_list:
        if default_scheme == '':
            raise ValueError,'you must specify the default color scheme'
        for scheme in scheme_list:
            self.add_scheme(scheme)
        self.set_active_scheme(default_scheme)

</t>
<t tx="ekr.20071201085751.37">def copy(self):
    """Return full copy of object"""
    return ColorSchemeTable(self.values(),self.active_scheme_name)

</t>
<t tx="ekr.20071201085751.38">def add_scheme(self,new_scheme):
    """Add a new color scheme to the table."""
    if not isinstance(new_scheme,ColorScheme):
        raise ValueError,'ColorSchemeTable only accepts ColorScheme instances'
    self[new_scheme.name] = new_scheme
    
</t>
<t tx="ekr.20071201085751.39">def set_active_scheme(self,scheme,case_sensitive=0):
    """Set the currently active scheme.

    Names are by default compared in a case-insensitive way, but this can
    be changed by setting the parameter case_sensitive to true."""

    scheme_names = self.keys()
    if case_sensitive:
        valid_schemes = scheme_names
        scheme_test = scheme
    else:
        valid_schemes = [s.lower() for s in scheme_names]
        scheme_test = scheme.lower()
    try:
        scheme_idx = valid_schemes.index(scheme_test)
    except ValueError:
        raise ValueError,'Unrecognized color scheme: ' + scheme + \
              '\nValid schemes: '+str(scheme_names).replace("'', ",'')
    else:
        active = scheme_names[scheme_idx]
        self.active_scheme_name = active
        self.active_colors = self[active].colors
        # Now allow using '' as an index for the current active scheme
        self[''] = self[active]
</t>
<t tx="ekr.20071201085751.40">"""Word completion for IPython.

This module is a fork of the rlcompleter module in the Python standard
library.  The original enhancements made to rlcompleter have been sent
upstream and were accepted as of Python 2.3, but we need a lot more
functionality specific to IPython, so this module will continue to live as an
IPython-specific utility.

---------------------------------------------------------------------------
Original rlcompleter documentation:

This requires the latest extension to the readline module (the
completes keywords, built-ins and globals in __main__; when completing
NAME.NAME..., it evaluates (!) the expression up to the last dot and
completes its attributes.

It's very cool to do "import string" type "string.", hit the
completion key (twice), and see the list of names defined by the
string module!

Tip: to use the tab key as the completion key, call

    readline.parse_and_bind("tab: complete")

Notes:

- Exceptions raised by the completer function are *ignored* (and
generally cause the completion to fail).  This is a feature -- since
readline sets the tty device in raw (or cbreak) mode, printing a
traceback wouldn't work well without some complicated hoopla to save,
reset and restore the tty state.

- The evaluation of the NAME.NAME... form may cause arbitrary
application defined code to be executed if an object with a
__getattr__ hook is found.  Since it is the responsibility of the
application (or the user) to enable this feature, I consider this an
acceptable risk.  More complicated expressions (e.g. function calls or
indexing operations) are *not* evaluated.

- GNU readline is also used by the built-in functions input() and
raw_input(), and thus these also benefit/suffer from the completer
features.  Clearly an interactive application can benefit by
specifying its own completer function and using raw_input() for all
its input.

- When the original stdin is not a tty device, GNU readline is never
used, and this module (and the readline module) are silently inactive.

"""

#*****************************************************************************
#
# Since this file is essentially a minimally modified copy of the rlcompleter
# module which is part of the standard Python distribution, I assume that the
# proper procedure is to maintain its copyright as belonging to the Python
# Software Foundation (in addition to my own, for all new code).
#
#       Copyright (C) 2001 Python Software Foundation, www.python.org
#       Copyright (C) 2001-2006 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#
#*****************************************************************************

import __builtin__
import __main__
import glob
import keyword
import os
import re
import shlex
import sys
import IPython.rlineimpl as readline    
import itertools
from IPython.ipstruct import Struct
from IPython import ipapi

import types

# Python 2.4 offers sets as a builtin
try:
    set([1,2])
except NameError:
    from sets import Set as set

from IPython.genutils import debugx

__all__ = ['Completer','IPCompleter']

</t>
<t tx="ekr.20071201085751.41">def get_class_members(cls):
    ret = dir(cls)
    if hasattr(cls,'__bases__'):
        for base in cls.__bases__:
            ret.extend(get_class_members(base))
    return ret

</t>
<t tx="ekr.20071201085751.42">class Completer:
    @others
</t>
<t tx="ekr.20071201085751.43">def __init__(self,namespace=None,global_namespace=None):
    """Create a new completer for the command line.

    Completer([namespace,global_namespace]) -&gt; completer instance.

    If unspecified, the default namespace where completions are performed
    is __main__ (technically, __main__.__dict__). Namespaces should be
    given as dictionaries.

    An optional second namespace can be given.  This allows the completer
    to handle cases where both the local and global scopes need to be
    distinguished.

    Completer instances should be used as the completion mechanism of
    readline via the set_completer() call:

    readline.set_completer(Completer(my_namespace).complete)
    """

    # some minimal strict typechecks.  For some core data structures, I
    # want actual basic python types, not just anything that looks like
    # one.  This is especially true for namespaces.
    for ns in (namespace,global_namespace):
        if ns is not None and type(ns) != types.DictType:
            raise TypeError,'namespace must be a dictionary'

    # Don't bind to namespace quite yet, but flag whether the user wants a
    # specific namespace or to use __main__.__dict__. This will allow us
    # to bind to __main__.__dict__ at completion time, not now.
    if namespace is None:
        self.use_main_ns = 1
    else:
        self.use_main_ns = 0
        self.namespace = namespace

    # The global namespace, if given, can be bound directly
    if global_namespace is None:
        self.global_namespace = {}
    else:
        self.global_namespace = global_namespace

</t>
<t tx="ekr.20071201085751.44">def complete(self, text, state):
    """Return the next possible completion for 'text'.

    This is called successively with state == 0, 1, 2, ... until it
    returns None.  The completion should begin with 'text'.

    """
    if self.use_main_ns:
        self.namespace = __main__.__dict__
        
    if state == 0:
        if "." in text:
            self.matches = self.attr_matches(text)
        else:
            self.matches = self.global_matches(text)
    try:
        return self.matches[state]
    except IndexError:
        return None

</t>
<t tx="ekr.20071201085751.45">def global_matches(self, text):
    """Compute matches when text is a simple name.

    Return a list of all keywords, built-in functions and names currently
    defined in self.namespace or self.global_namespace that match.

    """
    matches = []
    match_append = matches.append
    n = len(text)
    for lst in [keyword.kwlist,
                __builtin__.__dict__.keys(),
                self.namespace.keys(),
                self.global_namespace.keys()]:
        for word in lst:
            if word[:n] == text and word != "__builtins__":
                match_append(word)
    return matches

</t>
<t tx="ekr.20071201085751.46">def attr_matches(self, text):
    """Compute matches when text contains a dot.

    Assuming the text is of the form NAME.NAME....[NAME], and is
    evaluatable in self.namespace or self.global_namespace, it will be
    evaluated and its attributes (as revealed by dir()) are used as
    possible completions.  (For class instances, class members are are
    also considered.)

    WARNING: this can still invoke arbitrary C code, if an object
    with a __getattr__ hook is evaluated.

    """
    import re

    # Another option, seems to work great. Catches things like ''.&lt;tab&gt;
    m = re.match(r"(\S+(\.\w+)*)\.(\w*)$", text)

    if not m:
        return []
    
    expr, attr = m.group(1, 3)
    try:
        object = eval(expr, self.namespace)
    except:
        try:
            object = eval(expr, self.global_namespace)
        except:
            return []
            

    # Start building the attribute list via dir(), and then complete it
    # with a few extra special-purpose calls.
    words = dir(object)

    if hasattr(object,'__class__'):
        words.append('__class__')
        words.extend(get_class_members(object.__class__))

    # this is the 'dir' function for objects with Enthought's traits
    if hasattr(object, 'trait_names'):
        try:
            words.extend(object.trait_names())
            # eliminate possible duplicates, as some traits may also
            # appear as normal attributes in the dir() call.
            words = set(words)
        except TypeError:
            # This will happen if `object` is a class and not an instance.
            pass

    # Support for PyCrust-style _getAttributeNames magic method.
    if hasattr(object, '_getAttributeNames'):
        try:
            words.extend(object._getAttributeNames())
            # Eliminate duplicates.
            words = set(words)
        except TypeError:
            # `object` is a class and not an instance.  Ignore
            # this error.
            pass

    # filter out non-string attributes which may be stuffed by dir() calls
    # and poor coding in third-party modules
    words = [w for w in words
             if isinstance(w, basestring) and w != "__builtins__"]
    # Build match list to return
    n = len(attr)
    return ["%s.%s" % (expr, w) for w in words if w[:n] == attr ]

</t>
<t tx="ekr.20071201085751.47">class IPCompleter(Completer):
    """Extension of the completer class with IPython-specific features"""
    @others
</t>
<t tx="ekr.20071201085751.48">
def __init__(self,shell,namespace=None,global_namespace=None,
             omit__names=0,alias_table=None):
    """IPCompleter() -&gt; completer

    Return a completer object suitable for use by the readline library
    via readline.set_completer().

    Inputs:

    - shell: a pointer to the ipython shell itself.  This is needed
    because this completer knows about magic functions, and those can
    only be accessed via the ipython instance.

    - namespace: an optional dict where completions are performed.

    - global_namespace: secondary optional dict for completions, to
    handle cases (such as IPython embedded inside functions) where
    both Python scopes are visible.

    - The optional omit__names parameter sets the completer to omit the
    'magic' names (__magicname__) for python objects unless the text
    to be completed explicitly starts with one or more underscores.

    - If alias_table is supplied, it should be a dictionary of aliases
    to complete. """

    Completer.__init__(self,namespace,global_namespace)
    self.magic_prefix = shell.name+'.magic_'
    self.magic_escape = shell.ESC_MAGIC
    self.readline = readline
    delims = self.readline.get_completer_delims()
    delims = delims.replace(self.magic_escape,'')
    self.readline.set_completer_delims(delims)
    self.get_line_buffer = self.readline.get_line_buffer
    self.omit__names = omit__names
    self.merge_completions = shell.rc.readline_merge_completions

    if alias_table is None:
        alias_table = {}
    self.alias_table = alias_table
    # Regexp to split filenames with spaces in them
    self.space_name_re = re.compile(r'([^\\] )')
    # Hold a local ref. to glob.glob for speed
    self.glob = glob.glob

    # Determine if we are running on 'dumb' terminals, like (X)Emacs
    # buffers, to avoid completion problems.
    term = os.environ.get('TERM','xterm')
    self.dumb_terminal = term in ['dumb','emacs']
    
    # Special handling of backslashes needed in win32 platforms
    if sys.platform == "win32":
        self.clean_glob = self._clean_glob_win32
    else:
        self.clean_glob = self._clean_glob
    self.matchers = [self.python_matches,
                     self.file_matches,
                     self.alias_matches,
                     self.python_func_kw_matches]

</t>
<t tx="ekr.20071201085751.49"># Code contributed by Alex Schmolck, for ipython/emacs integration
def all_completions(self, text):
    """Return all possible completions for the benefit of emacs."""

    completions = []
    comp_append = completions.append
    try:
        for i in xrange(sys.maxint):
            res = self.complete(text, i)

            if not res: break

            comp_append(res)
    #XXX workaround for ``notDefined.&lt;tab&gt;``
    except NameError:
        pass
    return completions
</t>
<t tx="ekr.20071201085751.50"># /end Alex Schmolck code.

def _clean_glob(self,text):
    return self.glob("%s*" % text)

</t>
<t tx="ekr.20071201085751.51">def _clean_glob_win32(self,text):
    return [f.replace("\\","/")
            for f in self.glob("%s*" % text)]            

</t>
<t tx="ekr.20071201085751.52">def file_matches(self, text):
    """Match filenames, expanding ~USER type strings.

    Most of the seemingly convoluted logic in this completer is an
    attempt to handle filenames with spaces in them.  And yet it's not
    quite perfect, because Python's readline doesn't expose all of the
    GNU readline details needed for this to be done correctly.

    For a filename with a space in it, the printed completions will be
    only the parts after what's already been typed (instead of the
    full completions, as is normally done).  I don't think with the
    current (as of Python 2.3) Python readline it's possible to do
    better."""

    #print 'Completer-&gt;file_matches: &lt;%s&gt;' % text # dbg

    # chars that require escaping with backslash - i.e. chars
    # that readline treats incorrectly as delimiters, but we
    # don't want to treat as delimiters in filename matching
    # when escaped with backslash

    protectables = ' ()[]{}'

    if text.startswith('!'):
        text = text[1:]
        text_prefix = '!'
    else:
        text_prefix = ''
        
    def protect_filename(s):
        return "".join([(ch in protectables and '\\' + ch or ch)
                        for ch in s])
    
    lbuf = self.lbuf
    open_quotes = 0  # track strings with open quotes
    try:
        lsplit = shlex.split(lbuf)[-1]
    except ValueError:
        # typically an unmatched ", or backslash without escaped char.
        if lbuf.count('"')==1:
            open_quotes = 1
            lsplit = lbuf.split('"')[-1]
        elif lbuf.count("'")==1:
            open_quotes = 1
            lsplit = lbuf.split("'")[-1]
        else:
            return []
    except IndexError:
        # tab pressed on empty line
        lsplit = ""

    if lsplit != protect_filename(lsplit):
        # if protectables are found, do matching on the whole escaped
        # name
        has_protectables = 1
        text0,text = text,lsplit
    else:
        has_protectables = 0
        text = os.path.expanduser(text)

    if text == "":
        return [text_prefix + protect_filename(f) for f in self.glob("*")]

    m0 = self.clean_glob(text.replace('\\',''))
    if has_protectables:
        # If we had protectables, we need to revert our changes to the
        # beginning of filename so that we don't double-write the part
        # of the filename we have so far
        len_lsplit = len(lsplit)
        matches = [text_prefix + text0 + 
                   protect_filename(f[len_lsplit:]) for f in m0]
    else:
        if open_quotes:
            # if we have a string with an open quote, we don't need to
            # protect the names at all (and we _shouldn't_, as it
            # would cause bugs when the filesystem call is made).
            matches = m0
        else:
            matches = [text_prefix + 
                       protect_filename(f) for f in m0]
    if len(matches) == 1 and os.path.isdir(matches[0]):
        # Takes care of links to directories also.  Use '/'
        # explicitly, even under Windows, so that name completions
        # don't end up escaped.            
        d = matches[0]
        if d[-1] in ['/','\\']:
            d = d[:-1]
        
        matches = [ (d + '/' + p) for p in os.listdir(d) ]
        
    return matches

</t>
<t tx="ekr.20071201085751.53">def alias_matches(self, text):
    """Match internal system aliases"""        
    #print 'Completer-&gt;alias_matches:',text,'lb',self.lbuf # dbg
    
    # if we are not in the first 'item', alias matching 
    # doesn't make sense
    if ' ' in self.lbuf:
        return []
    text = os.path.expanduser(text)
    aliases =  self.alias_table.keys()
    if text == "":
        return aliases
    else:
        return [alias for alias in aliases if alias.startswith(text)]

</t>
<t tx="ekr.20071201085751.54">def python_matches(self,text):
    """Match attributes or global python names"""

    #print 'Completer-&gt;python_matches, txt=&lt;%s&gt;' % text # dbg
    if "." in text:
        try:
            matches = self.attr_matches(text)
            if text.endswith('.') and self.omit__names:
                if self.omit__names == 1:
                    # true if txt is _not_ a __ name, false otherwise:
                    no__name = (lambda txt:
                                re.match(r'.*\.__.*?__',txt) is None)
                else:
                    # true if txt is _not_ a _ name, false otherwise:
                    no__name = (lambda txt:
                                re.match(r'.*\._.*?',txt) is None)
                matches = filter(no__name, matches)
        except NameError:
            # catches &lt;undefined attributes&gt;.&lt;tab&gt;
            matches = []
    else:
        matches = self.global_matches(text)
        # this is so completion finds magics when automagic is on:
        if (matches == [] and 
             not text.startswith(os.sep) and
             not ' ' in self.lbuf):
            matches = self.attr_matches(self.magic_prefix+text)
    return matches

</t>
<t tx="ekr.20071201085751.55">def _default_arguments(self, obj):
    """Return the list of default arguments of obj if it is callable,
    or empty list otherwise."""

    if not (inspect.isfunction(obj) or inspect.ismethod(obj)):
        # for classes, check for __init__,__new__
        if inspect.isclass(obj):
            obj = (getattr(obj,'__init__',None) or
                   getattr(obj,'__new__',None))
        # for all others, check if they are __call__able
        elif hasattr(obj, '__call__'):
            obj = obj.__call__
        # XXX: is there a way to handle the builtins ?
    try:
        args,_,_1,defaults = inspect.getargspec(obj)
        if defaults:
            return args[-len(defaults):]
    except TypeError: pass
    return []

</t>
<t tx="ekr.20071201085751.56">def python_func_kw_matches(self,text):
    """Match named parameters (kwargs) of the last open function"""

    if "." in text: # a parameter cannot be dotted
        return []
    try: regexp = self.__funcParamsRegex
    except AttributeError:
        regexp = self.__funcParamsRegex = re.compile(r'''
            '.*?' |    # single quoted strings or
            ".*?" |    # double quoted strings or
            \w+   |    # identifier
            \S         # other characters
            ''', re.VERBOSE | re.DOTALL)
    # 1. find the nearest identifier that comes before an unclosed
    # parenthesis e.g. for "foo (1+bar(x), pa", the candidate is "foo"
    tokens = regexp.findall(self.get_line_buffer())
    tokens.reverse()
    iterTokens = iter(tokens); openPar = 0
    for token in iterTokens:
        if token == ')':
            openPar -= 1
        elif token == '(':
            openPar += 1
            if openPar &gt; 0:
                # found the last unclosed parenthesis
                break
    else:
        return []
    # 2. Concatenate dotted names ("foo.bar" for "foo.bar(x, pa" )
    ids = []
    isId = re.compile(r'\w+$').match
    while True:
        try:
            ids.append(iterTokens.next())
            if not isId(ids[-1]):
                ids.pop(); break
            if not iterTokens.next() == '.':
                break
        except StopIteration:
            break
    # lookup the candidate callable matches either using global_matches
    # or attr_matches for dotted names
    if len(ids) == 1:
        callableMatches = self.global_matches(ids[0])
    else:
        callableMatches = self.attr_matches('.'.join(ids[::-1]))
    argMatches = []
    for callableMatch in callableMatches:
        try: namedArgs = self._default_arguments(eval(callableMatch,
                                                     self.namespace))
        except: continue
        for namedArg in namedArgs:
            if namedArg.startswith(text):
                argMatches.append("%s=" %namedArg)
    return argMatches

</t>
<t tx="ekr.20071201085751.57">def dispatch_custom_completer(self,text):
    # print "Custom! '%s' %s" % (text, self.custom_completers) # dbg
    line = self.full_lbuf        
    if not line.strip():
        return None

    event = Struct()
    event.line = line
    event.symbol = text
    cmd = line.split(None,1)[0]
    event.command = cmd
    #print "\ncustom:{%s]\n" % event # dbg
    
    # for foo etc, try also to find completer for %foo
    if not cmd.startswith(self.magic_escape):
        try_magic = self.custom_completers.s_matches(
          self.magic_escape + cmd)            
    else:
        try_magic = []
    
    
    for c in itertools.chain(
                             self.custom_completers.s_matches(cmd),
                             try_magic,
                             self.custom_completers.flat_matches(self.lbuf)):
        # print "try",c # dbg
        try:
            res = c(event)
            return [r for r in res if r.lower().startswith(text.lower())]
        except ipapi.TryNext:
            pass
        
    return None
    


</t>
<t tx="ekr.20071201085751.58">def complete(self, text, state):
    """Return the next possible completion for 'text'.

    This is called successively with state == 0, 1, 2, ... until it
    returns None.  The completion should begin with 'text'.  """

    #print '\n*** COMPLETE: &lt;%s&gt; (%s)' % (text,state)  # dbg

    # if there is only a tab on a line with only whitespace, instead
    # of the mostly useless 'do you want to see all million
    # completions' message, just do the right thing and give the user
    # his tab!  Incidentally, this enables pasting of tabbed text from
    # an editor (as long as autoindent is off).

    # don't apply this on 'dumb' terminals, such as emacs buffers, so we
    # don't interfere with their own tab-completion mechanism.
    self.full_lbuf = self.get_line_buffer()
    self.lbuf = self.full_lbuf[:self.readline.get_endidx()]
    if not (self.dumb_terminal or self.get_line_buffer().strip()):
        self.readline.insert_text('\t')
        return None

    
    magic_escape = self.magic_escape
    magic_prefix = self.magic_prefix

    try:
        if text.startswith(magic_escape):
            text = text.replace(magic_escape,magic_prefix)
        elif text.startswith('~'):
            text = os.path.expanduser(text)
        if state == 0:
            custom_res = self.dispatch_custom_completer(text)
            if custom_res is not None:
                # did custom completers produce something?
                self.matches = custom_res
            else:
                # Extend the list of completions with the results of each
                # matcher, so we return results to the user from all
                # namespaces.
                if self.merge_completions:
                    self.matches = []
                    for matcher in self.matchers:
                        self.matches.extend(matcher(text))
                else:
                    for matcher in self.matchers:
                        self.matches = matcher(text)
                        if self.matches:
                            break

        try:
            return self.matches[state].replace(magic_prefix,magic_escape)
        except IndexError:
            return None
    except:
        from IPython.ultraTB import AutoFormattedTB; # dbg
        tb=AutoFormattedTB('Verbose');tb() #dbg

        # If completion fails, don't annoy the user.
        return None
</t>
<t tx="ekr.20071201085751.59"># -*- coding: utf-8 -*-
"""Configuration loader

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

import exceptions
import os
from pprint import pprint

from IPython import ultraTB
from IPython.ipstruct import Struct
from IPython.genutils import *

</t>
<t tx="ekr.20071201085751.60">class ConfigLoaderError(exceptions.Exception):
    """Exception for ConfigLoader class."""
    @others
</t>
<t tx="ekr.20071201085751.61">
def __init__(self,args=None):
    self.args = args

</t>
<t tx="ekr.20071201085751.62">class ConfigLoader:

    """Configuration file loader capable of handling recursive inclusions and
    with parametrized conflict resolution for multiply found keys."""
    @others
</t>
<t tx="ekr.20071201085751.63">
def __init__(self,conflict=None,field_sep=None,reclimit=15):

    """The reclimit parameter controls the number of recursive
    configuration file inclusions. This way we can stop early on (before
    python's own recursion limit is hit) if there is a circular
    inclusion.

    - conflict: dictionary for conflict resolutions (see Struct.merge())

    """
    self.conflict = conflict
    self.field_sep = field_sep
    self.reset(reclimit)
    
</t>
<t tx="ekr.20071201085751.64">def reset(self,reclimit=15):
    self.reclimit = reclimit
    self.recdepth = 0
    self.included = []
    
</t>
<t tx="ekr.20071201085751.65">def load(self,fname,convert=None,recurse_key='',incpath = '.',**kw):
    """Load a configuration file, return the resulting Struct.

    Call: load_config(fname,convert=None,conflict=None,recurse_key='')

     - fname: file to load from.
     - convert: dictionary of type conversions (see read_dict())
     - recurse_key: keyword in dictionary to trigger recursive file
     inclusions.
     """

    if self.recdepth &gt; self.reclimit:
        raise ConfigLoaderError, 'maximum recursive inclusion of rcfiles '+\
              'exceeded: ' + `self.recdepth` + \
              '.\nMaybe you have a circular chain of inclusions?'
    self.recdepth += 1
    fname = filefind(fname,incpath)
    data = Struct()
    # avoid including the same file more than once
    if fname in self.included:
        return data
    Xinfo = ultraTB.AutoFormattedTB()
    if convert==None and recurse_key : convert = {qwflat:recurse_key}
    # for production, change warn to 0:
    data.merge(read_dict(fname,convert,fs=self.field_sep,strip=1,
                         warn=0,no_empty=0,**kw))
    # keep track of successfully loaded files
    self.included.append(fname)
    if recurse_key in data.keys():
        for incfilename in data[recurse_key]:
            found=0
            try:
                incfile = filefind(incfilename,incpath)
            except IOError:
                if os.name in ['nt','dos']:
                    try:
                        # Try again with '.ini' extension
                        incfilename += '.ini'
                        incfile = filefind(incfilename,incpath)
                    except IOError:
                        found = 0
                    else:
                        found = 1
                else:
                    found = 0
            else:
                found = 1
            if found:
                try:
                    data.merge(self.load(incfile,convert,recurse_key,
                                         incpath,**kw),
                               self.conflict)
                except:
                    Xinfo()
                    warn('Problem loading included file: '+
                         `incfilename` + '. Ignoring it...')
            else:
                warn('File `%s` not found. Included by %s' % (incfilename,fname))

    return data

</t>
<t tx="ekr.20071201085751.66"># -*- coding: utf-8 -*-
"""
Pdb debugger class.

Modified from the standard pdb.Pdb class to avoid including readline, so that
the command line completion of other programs which include this isn't
damaged.

In the future, this class will be expanded with improvements over the standard
pdb.

The code in this file is mainly lifted out of cmd.py in Python 2.2, with minor
changes. Licensing should therefore be under the standard Python terms.  For
details on the PSF (Python Software Foundation) standard license, see:

http://www.python.org/2.2.3/license.html

$Id$"""

#*****************************************************************************
#
# Since this file is essentially a modified copy of the pdb module which is
# part of the standard Python distribution, I assume that the proper procedure
# is to maintain its copyright as belonging to the Python Software Foundation
# (in addition to my own, for all new code).
#
#       Copyright (C) 2001 Python Software Foundation, www.python.org
#       Copyright (C) 2005-2006 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = 'Python'

import bdb
import cmd
import linecache
import os
import sys

from IPython import PyColorize, ColorANSI
from IPython.genutils import Term
from IPython.excolors import ExceptionColors

# See if we can use pydb.
has_pydb = False
prompt = 'ipdb&gt;'
try:
    import pydb
    if hasattr(pydb.pydb, "runl"):
        has_pydb = True
        from pydb import Pdb as OldPdb
        prompt = 'ipydb&gt;'
except ImportError:
    pass

if has_pydb:
    from pydb import Pdb as OldPdb
else:
    from pdb import Pdb as OldPdb

</t>
<t tx="ekr.20071201085751.67">def decorate_fn_with_doc(new_fn, old_fn, additional_text=""):
    """Make new_fn have old_fn's doc string. This is particularly useful
    for the do_... commands that hook into the help system.
    Adapted from from a comp.lang.python posting
    by Duncan Booth."""
    def wrapper(*args, **kw):
        return new_fn(*args, **kw)
    if old_fn.__doc__:
        wrapper.__doc__ = old_fn.__doc__ + additional_text
    return wrapper

</t>
<t tx="ekr.20071201085751.68">def _file_lines(fname):
    """Return the contents of a named file as a list of lines.

    This function never raises an IOError exception: if the file can't be
    read, it simply returns an empty list."""

    try:
        outfile = open(fname)
    except IOError:
        return []
    else:
        out = outfile.readlines()
        outfile.close()
        return out

</t>
<t tx="ekr.20071201085751.69">class Pdb(OldPdb):
    """Modified Pdb class, does not load readline."""

    if sys.version[:3] &gt;= '2.5' or has_pydb:
        def __init__(self,color_scheme='NoColor',completekey=None,
                     stdin=None, stdout=None):

            # Parent constructor:
            if has_pydb and completekey is None:
                OldPdb.__init__(self,stdin=stdin,stdout=stdout)
            else:
                OldPdb.__init__(self,completekey,stdin,stdout)
                self.prompt = prompt # The default prompt is '(Pdb)'
            
            # IPython changes...
            self.is_pydb = has_pydb

            if self.is_pydb:

                # iplib.py's ipalias seems to want pdb's checkline
                # which located in pydb.fn
                import pydb.fns
                self.checkline = lambda filename, lineno: \
                                 pydb.fns.checkline(self, filename, lineno)

                self.curframe = None
                self.do_restart = self.new_do_restart

                self.old_all_completions = __IPYTHON__.Completer.all_completions
                __IPYTHON__.Completer.all_completions=self.all_completions

                self.do_list = decorate_fn_with_doc(self.list_command_pydb,
                                                    OldPdb.do_list)
                self.do_l     = self.do_list
                self.do_frame = decorate_fn_with_doc(self.new_do_frame,
                                                     OldPdb.do_frame)

            self.aliases = {}

            # Create color table: we copy the default one from the traceback
            # module and add a few attributes needed for debugging
            self.color_scheme_table = ExceptionColors.copy()

            # shorthands 
            C = ColorANSI.TermColors
            cst = self.color_scheme_table

            cst['NoColor'].colors.breakpoint_enabled = C.NoColor
            cst['NoColor'].colors.breakpoint_disabled = C.NoColor

            cst['Linux'].colors.breakpoint_enabled = C.LightRed
            cst['Linux'].colors.breakpoint_disabled = C.Red

            cst['LightBG'].colors.breakpoint_enabled = C.LightRed
            cst['LightBG'].colors.breakpoint_disabled = C.Red

            self.set_colors(color_scheme)

    else:
        # Ugly hack: for Python 2.3-2.4, we can't call the parent constructor,
        # because it binds readline and breaks tab-completion.  This means we
        # have to COPY the constructor here.
        def __init__(self,color_scheme='NoColor'):
            bdb.Bdb.__init__(self)
            cmd.Cmd.__init__(self,completekey=None) # don't load readline
            self.prompt = 'ipdb&gt; ' # The default prompt is '(Pdb)'
            self.aliases = {}

            # These two lines are part of the py2.4 constructor, let's put them
            # unconditionally here as they won't cause any problems in 2.3.
            self.mainpyfile = ''
            self._wait_for_mainpyfile = 0

            # Read $HOME/.pdbrc and ./.pdbrc
            try:
                self.rcLines = _file_lines(os.path.join(os.environ['HOME'],
                                                        ".pdbrc"))
            except KeyError:
                self.rcLines = []
            self.rcLines.extend(_file_lines(".pdbrc"))

            # Create color table: we copy the default one from the traceback
            # module and add a few attributes needed for debugging
            self.color_scheme_table = ExceptionColors.copy()

            # shorthands 
            C = ColorANSI.TermColors
            cst = self.color_scheme_table

            cst['NoColor'].colors.breakpoint_enabled = C.NoColor
            cst['NoColor'].colors.breakpoint_disabled = C.NoColor

            cst['Linux'].colors.breakpoint_enabled = C.LightRed
            cst['Linux'].colors.breakpoint_disabled = C.Red

            cst['LightBG'].colors.breakpoint_enabled = C.LightRed
            cst['LightBG'].colors.breakpoint_disabled = C.Red

            self.set_colors(color_scheme)
        
    @others
</t>
<t tx="ekr.20071201085751.70">def set_colors(self, scheme):
    """Shorthand access to the color table scheme selector method."""
    self.color_scheme_table.set_active_scheme(scheme)

</t>
<t tx="ekr.20071201085751.71">def interaction(self, frame, traceback):
    __IPYTHON__.set_completer_frame(frame)
    OldPdb.interaction(self, frame, traceback)

</t>
<t tx="ekr.20071201085751.72">def new_do_up(self, arg):
    OldPdb.do_up(self, arg)
    __IPYTHON__.set_completer_frame(self.curframe)
</t>
<t tx="ekr.20071201085751.73">do_u = do_up = decorate_fn_with_doc(new_do_up, OldPdb.do_up)

def new_do_down(self, arg):
    OldPdb.do_down(self, arg)
    __IPYTHON__.set_completer_frame(self.curframe)

</t>
<t tx="ekr.20071201085751.74">do_d = do_down = decorate_fn_with_doc(new_do_down, OldPdb.do_down)

def new_do_frame(self, arg):
    OldPdb.do_frame(self, arg)
    __IPYTHON__.set_completer_frame(self.curframe)

</t>
<t tx="ekr.20071201085751.75">def new_do_quit(self, arg):
    
    if hasattr(self, 'old_all_completions'):
        __IPYTHON__.Completer.all_completions=self.old_all_completions
    
    
    return OldPdb.do_quit(self, arg)

</t>
<t tx="ekr.20071201085751.76">do_q = do_quit = decorate_fn_with_doc(new_do_quit, OldPdb.do_quit)

def new_do_restart(self, arg):
    """Restart command. In the context of ipython this is exactly the same
    thing as 'quit'."""
    self.msg("Restart doesn't make sense here. Using 'quit' instead.")
    return self.do_quit(arg)

</t>
<t tx="ekr.20071201085751.77">def postloop(self):
    __IPYTHON__.set_completer_frame(None)

</t>
<t tx="ekr.20071201085751.78">def print_stack_trace(self):
    try:
        for frame_lineno in self.stack:
            self.print_stack_entry(frame_lineno, context = 5)
    except KeyboardInterrupt:
        pass

</t>
<t tx="ekr.20071201085751.79">def print_stack_entry(self,frame_lineno,prompt_prefix='\n-&gt; ',
                      context = 3):
    frame, lineno = frame_lineno
    print &gt;&gt;Term.cout, self.format_stack_entry(frame_lineno, '', context)

</t>
<t tx="ekr.20071201085751.80">def format_stack_entry(self, frame_lineno, lprefix=': ', context = 3):
    import linecache, repr
    
    ret = []
    
    Colors = self.color_scheme_table.active_colors
    ColorsNormal = Colors.Normal
    tpl_link = '%s%%s%s' % (Colors.filenameEm, ColorsNormal)
    tpl_call = '%s%%s%s%%s%s' % (Colors.vName, Colors.valEm, ColorsNormal)
    tpl_line = '%%s%s%%s %s%%s' % (Colors.lineno, ColorsNormal)
    tpl_line_em = '%%s%s%%s %s%%s%s' % (Colors.linenoEm, Colors.line,
                                        ColorsNormal)
    
    frame, lineno = frame_lineno
    
    return_value = ''
    if '__return__' in frame.f_locals:
        rv = frame.f_locals['__return__']
        #return_value += '-&gt;'
        return_value += repr.repr(rv) + '\n'
    ret.append(return_value)

    #s = filename + '(' + `lineno` + ')'
    filename = self.canonic(frame.f_code.co_filename)
    link = tpl_link % filename
    
    if frame.f_code.co_name:
        func = frame.f_code.co_name
    else:
        func = "&lt;lambda&gt;"
        
    call = ''
    if func != '?':         
        if '__args__' in frame.f_locals:
            args = repr.repr(frame.f_locals['__args__'])
        else:
            args = '()'
        call = tpl_call % (func, args)

    # The level info should be generated in the same format pdb uses, to
    # avoid breaking the pdbtrack functionality of python-mode in *emacs.
    ret.append('&gt; %s(%s)%s\n' % (link,lineno,call))
        
    start = lineno - 1 - context//2
    lines = linecache.getlines(filename)
    start = max(start, 0)
    start = min(start, len(lines) - context)
    lines = lines[start : start + context]
        
    for i,line in enumerate(lines):
        show_arrow = (start + 1 + i == lineno)
        ret.append(self.__format_line(tpl_line_em, filename,
                                      start + 1 + i, line,
                                      arrow = show_arrow) )

    return ''.join(ret)

</t>
<t tx="ekr.20071201085751.81">def __format_line(self, tpl_line, filename, lineno, line, arrow = False):
    bp_mark = ""
    bp_mark_color = ""

    bp = None
    if lineno in self.get_file_breaks(filename):
        bps = self.get_breaks(filename, lineno)
        bp = bps[-1]
    
    if bp:
        Colors = self.color_scheme_table.active_colors
        bp_mark = str(bp.number)
        bp_mark_color = Colors.breakpoint_enabled
        if not bp.enabled:
            bp_mark_color = Colors.breakpoint_disabled

    numbers_width = 7
    if arrow:
        # This is the line with the error
        pad = numbers_width - len(str(lineno)) - len(bp_mark)
        if pad &gt;= 3:
            marker = '-'*(pad-3) + '-&gt; '
        elif pad == 2:
             marker = '&gt; '
        elif pad == 1:
             marker = '&gt;'
        else:
             marker = ''
        num = '%s%s' % (marker, str(lineno))
        line = tpl_line % (bp_mark_color + bp_mark, num, line)
    else:
        num = '%*s' % (numbers_width - len(bp_mark), str(lineno))
        line = tpl_line % (bp_mark_color + bp_mark, num, line)
        
    return line

</t>
<t tx="ekr.20071201085751.82">def list_command_pydb(self, arg):
    """List command to use if we have a newer pydb installed"""
    filename, first, last = OldPdb.parse_list_cmd(self, arg)
    if filename is not None:
        self.print_list_lines(filename, first, last)
    
</t>
<t tx="ekr.20071201085751.83">def print_list_lines(self, filename, first, last):
    """The printing (as opposed to the parsing part of a 'list'
    command."""
    try:
        Colors = self.color_scheme_table.active_colors
        ColorsNormal = Colors.Normal
        tpl_line = '%%s%s%%s %s%%s' % (Colors.lineno, ColorsNormal)
        tpl_line_em = '%%s%s%%s %s%%s%s' % (Colors.linenoEm, Colors.line, ColorsNormal)
        src = []
        for lineno in range(first, last+1):
            line = linecache.getline(filename, lineno)
            if not line:
                break

            if lineno == self.curframe.f_lineno:
                line = self.__format_line(tpl_line_em, filename, lineno, line, arrow = True)
            else:
                line = self.__format_line(tpl_line, filename, lineno, line, arrow = False)

            src.append(line)
            self.lineno = lineno

        print &gt;&gt;Term.cout, ''.join(src)

    except KeyboardInterrupt:
        pass

</t>
<t tx="ekr.20071201085751.84">def do_list(self, arg):
    self.lastcmd = 'list'
    last = None
    if arg:
        try:
            x = eval(arg, {}, {})
            if type(x) == type(()):
                first, last = x
                first = int(first)
                last = int(last)
                if last &lt; first:
                    # Assume it's a count
                    last = first + last
            else:
                first = max(1, int(x) - 5)
        except:
            print '*** Error in argument:', `arg`
            return
    elif self.lineno is None:
        first = max(1, self.curframe.f_lineno - 5)
    else:
        first = self.lineno + 1
    if last is None:
        last = first + 10
    self.print_list_lines(self.curframe.f_code.co_filename, first, last)

</t>
<t tx="ekr.20071201085751.85">do_l = do_list

def do_pdef(self, arg):
    """The debugger interface to magic_pdef"""
    namespaces = [('Locals', self.curframe.f_locals),
                  ('Globals', self.curframe.f_globals)]
    __IPYTHON__.magic_pdef(arg, namespaces=namespaces)

</t>
<t tx="ekr.20071201085751.86">def do_pdoc(self, arg):
    """The debugger interface to magic_pdoc"""
    namespaces = [('Locals', self.curframe.f_locals),
                  ('Globals', self.curframe.f_globals)]
    __IPYTHON__.magic_pdoc(arg, namespaces=namespaces)

</t>
<t tx="ekr.20071201085751.87">def do_pinfo(self, arg):
    """The debugger equivalant of ?obj"""
    namespaces = [('Locals', self.curframe.f_locals),
                  ('Globals', self.curframe.f_globals)]
    __IPYTHON__.magic_pinfo("pinfo %s" % arg, namespaces=namespaces)
</t>
<t tx="ekr.20071201085751.88"># -*- coding: utf-8 -*-
"""
A module to change reload() so that it acts recursively.
To enable it type:
    &gt;&gt;&gt; import __builtin__, deep_reload
    &gt;&gt;&gt; __builtin__.reload = deep_reload.reload
You can then disable it with:
    &gt;&gt;&gt; __builtin__.reload = deep_reload.original_reload
    
Alternatively, you can add a dreload builtin alongside normal reload with:
    &gt;&gt;&gt; __builtin__.dreload = deep_reload.reload
    
This code is almost entirely based on knee.py from the standard library.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001 Nathaniel Gray &lt;n8gray@caltech.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release # do it explicitly so pydoc can see it - pydoc bug
__author__  = '%s &lt;%s&gt;' %  Release.authors['Nathan']
__license__ = Release.license
__version__ = "0.5"
__date__    = "21 August 2001"

import __builtin__
import imp
import sys

</t>
<t tx="ekr.20071201085751.89"># Replacement for __import__()
def deep_import_hook(name, globals=None, locals=None, fromlist=None):
    parent = determine_parent(globals)
    q, tail = find_head_package(parent, name)
    m = load_tail(q, tail)
    if not fromlist:
        return q
    if hasattr(m, "__path__"):
        ensure_fromlist(m, fromlist)
    return m

</t>
<t tx="ekr.20071201085751.90">def determine_parent(globals):
    if not globals or  not globals.has_key("__name__"):
        return None
    pname = globals['__name__']
    if globals.has_key("__path__"):
        parent = sys.modules[pname]
        assert globals is parent.__dict__
        return parent
    if '.' in pname:
        i = pname.rfind('.')
        pname = pname[:i]
        parent = sys.modules[pname]
        assert parent.__name__ == pname
        return parent
    return None

</t>
<t tx="ekr.20071201085751.91">def find_head_package(parent, name):
    # Import the first
    if '.' in name:
        # 'some.nested.package' -&gt; head = 'some', tail = 'nested.package'
        i = name.find('.')
        head = name[:i]
        tail = name[i+1:]
    else:
        # 'packagename' -&gt; head = 'packagename', tail = ''
        head = name
        tail = ""
    if parent:
        # If this is a subpackage then qname = parent's name + head
        qname = "%s.%s" % (parent.__name__, head)
    else:
        qname = head
    q = import_module(head, qname, parent)
    if q: return q, tail
    if parent:
        qname = head
        parent = None
        q = import_module(head, qname, parent)
        if q: return q, tail
    raise ImportError, "No module named " + qname

</t>
<t tx="ekr.20071201085751.92">def load_tail(q, tail):
    m = q
    while tail:
        i = tail.find('.')
        if i &lt; 0: i = len(tail)
        head, tail = tail[:i], tail[i+1:]

        # fperez: fix dotted.name reloading failures by changing:
        #mname = "%s.%s" % (m.__name__, head)
        # to:
        mname = m.__name__
        # This needs more testing!!! (I don't understand this module too well)
        
        #print '** head,tail=|%s|-&gt;|%s|, mname=|%s|' % (head,tail,mname)  # dbg
        m = import_module(head, mname, m)
        if not m:
            raise ImportError, "No module named " + mname
    return m

</t>
<t tx="ekr.20071201085751.93">def ensure_fromlist(m, fromlist, recursive=0):
    for sub in fromlist:
        if sub == "*":
            if not recursive:
                try:
                    all = m.__all__
                except AttributeError:
                    pass
                else:
                    ensure_fromlist(m, all, 1)
            continue
        if sub != "*" and not hasattr(m, sub):
            subname = "%s.%s" % (m.__name__, sub)
            submod = import_module(sub, subname, m)
            if not submod:
                raise ImportError, "No module named " + subname

</t>
<t tx="ekr.20071201085751.94"># Need to keep track of what we've already reloaded to prevent cyclic evil
found_now = {}

def import_module(partname, fqname, parent):
    global found_now
    if found_now.has_key(fqname):
        try:
            return sys.modules[fqname]    
        except KeyError:
            pass
    
    print 'Reloading', fqname #, sys.excepthook is sys.__excepthook__, \
            #sys.displayhook is sys.__displayhook__
    
    found_now[fqname] = 1
    try:
        fp, pathname, stuff = imp.find_module(partname,
                                              parent and parent.__path__)
    except ImportError:
        return None
        
    try:
        m = imp.load_module(fqname, fp, pathname, stuff)
    finally:
        if fp: fp.close()
        
    if parent:
        setattr(parent, partname, m)

    return m

</t>
<t tx="ekr.20071201085751.95">def deep_reload_hook(module):
    name = module.__name__
    if '.' not in name:
        return import_module(name, name, None)
    i = name.rfind('.')
    pname = name[:i]
    parent = sys.modules[pname]
    return import_module(name[i+1:], name, parent)

</t>
<t tx="ekr.20071201085751.96"># Save the original hooks
original_reload = __builtin__.reload

# Replacement for reload()
def reload(module, exclude=['sys', '__builtin__', '__main__']):
    """Recursively reload all modules used in the given module.  Optionally
    takes a list of modules to exclude from reloading.  The default exclude
    list contains sys, __main__, and __builtin__, to prevent, e.g., resetting 
    display, exception, and io hooks.
    """
    global found_now
    for i in exclude:
        found_now[i] = 1
    original_import = __builtin__.__import__
    __builtin__.__import__ = deep_import_hook    
    try:
        ret = deep_reload_hook(module)
    finally:
        __builtin__.__import__ = original_import
        found_now = {}
    return ret

</t>
<t tx="ekr.20071201085751.97">"""Module for interactive demos using IPython.

This module implements a few classes for running Python scripts interactively
in IPython for demonstrations.  With very simple markup (a few tags in
comments), you can control points where the script stops executing and returns
control to IPython.

The classes are (see their docstrings for further details):

 - Demo: pure python demos

 - IPythonDemo: demos with input to be processed by IPython as if it had been
 typed interactively (so magics work, as well as any other special syntax you
 may have added via input prefilters).

 - LineDemo: single-line version of the Demo class.  These demos are executed
 one line at a time, and require no markup.

 - IPythonLineDemo: IPython version of the LineDemo class (the demo is
 executed a line at a time, but processed via IPython).


The file is run in its own empty namespace (though you can pass it a string of
arguments as if in a command line environment, and it will see those as
sys.argv).  But at each stop, the global IPython namespace is updated with the
current internal demo namespace, so you can work interactively with the data
accumulated so far.

By default, each block of code is printed (with syntax highlighting) before
executing it and you have to confirm execution.  This is intended to show the
code to an audience first so you can discuss it, and only proceed with
execution once you agree.  There are a few tags which allow you to modify this
behavior.

The supported tags are:

# &lt;demo&gt; --- stop ---

  Defines block boundaries, the points where IPython stops execution of the
  file and returns to the interactive prompt.

# &lt;demo&gt; silent

  Make a block execute silently (and hence automatically).  Typically used in
  cases where you have some boilerplate or initialization code which you need
  executed but do not want to be seen in the demo.
  
# &lt;demo&gt; auto

  Make a block execute automatically, but still being printed.  Useful for
  simple code which does not warrant discussion, since it avoids the extra
  manual confirmation.

# &lt;demo&gt; auto_all

  This tag can _only_ be in the first block, and if given it overrides the
  individual auto tags to make the whole demo fully automatic (no block asks
  for confirmation).  It can also be given at creation time (or the attribute
  set later) to override what's in the file.

While _any_ python file can be run as a Demo instance, if there are no stop
tags the whole file will run in a single block (no different that calling
first %pycat and then %run).  The minimal markup to make this useful is to
place a set of stop tags; the other tags are only there to let you fine-tune
the execution.

This is probably best explained with the simple example file below.  You can
copy this into a file named ex_demo.py, and try running it via:

from IPython.demo import Demo
d = Demo('ex_demo.py')
d()  &lt;--- Call the d object (omit the parens if you have autocall set to 2).

Each time you call the demo object, it runs the next block.  The demo object
has a few useful methods for navigation, like again(), edit(), jump(), seek()
and back().  It can be reset for a new run via reset() or reloaded from disk
(in case you've edited the source) via reload().  See their docstrings below.

#################### EXAMPLE DEMO &lt;ex_demo.py&gt; ###############################
'''A simple interactive demo to illustrate the use of IPython's Demo class.'''

print 'Hello, welcome to an interactive IPython demo.'

# The mark below defines a block boundary, which is a point where IPython will
# stop execution and return to the interactive prompt.
# Note that in actual interactive execution, 
# &lt;demo&gt; --- stop ---

x = 1
y = 2

# &lt;demo&gt; --- stop ---

# the mark below makes this block as silent
# &lt;demo&gt; silent

print 'This is a silent block, which gets executed but not printed.'

# &lt;demo&gt; --- stop ---
# &lt;demo&gt; auto
print 'This is an automatic block.'
print 'It is executed without asking for confirmation, but printed.'
z = x+y

print 'z=',x

# &lt;demo&gt; --- stop ---
# This is just another normal block.
print 'z is now:', z

print 'bye!'
################### END EXAMPLE DEMO &lt;ex_demo.py&gt; ############################
"""
#*****************************************************************************
#     Copyright (C) 2005-2006 Fernando Perez. &lt;Fernando.Perez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#
#*****************************************************************************

import exceptions
import os
import re
import shlex
import sys

from IPython.PyColorize import Parser
from IPython.genutils import marquee, file_read, file_readlines

__all__ = ['Demo','IPythonDemo','LineDemo','IPythonLineDemo','DemoError']

</t>
<t tx="ekr.20071201085751.98">class DemoError(exceptions.Exception): pass

</t>
<t tx="ekr.20071201085751.99">def re_mark(mark):
    return re.compile(r'^\s*#\s+&lt;demo&gt;\s+%s\s*$' % mark,re.MULTILINE)

</t>
<t tx="ekr.20071201085751.100">class Demo:

    re_stop     = re_mark('---\s?stop\s?---')
    re_silent   = re_mark('silent')
    re_auto     = re_mark('auto')
    re_auto_all = re_mark('auto_all')

    @others
</t>
<t tx="ekr.20071201085751.101">def __init__(self,fname,arg_str='',auto_all=None):
    """Make a new demo object.  To run the demo, simply call the object.

    See the module docstring for full details and an example (you can use
    IPython.Demo? in IPython to see it).

    Inputs:
    
      - fname = filename.

    Optional inputs:

      - arg_str(''): a string of arguments, internally converted to a list
      just like sys.argv, so the demo script can see a similar
      environment.

      - auto_all(None): global flag to run all blocks automatically without
      confirmation.  This attribute overrides the block-level tags and
      applies to the whole demo.  It is an attribute of the object, and
      can be changed at runtime simply by reassigning it to a boolean
      value.
      """
    
    self.fname    = fname
    self.sys_argv = [fname] + shlex.split(arg_str)
    self.auto_all = auto_all
    
    # get a few things from ipython.  While it's a bit ugly design-wise,
    # it ensures that things like color scheme and the like are always in
    # sync with the ipython mode being used.  This class is only meant to
    # be used inside ipython anyways,  so it's OK.
    self.ip_ns       = __IPYTHON__.user_ns
    self.ip_colorize = __IPYTHON__.pycolorize
    self.ip_showtb   = __IPYTHON__.showtraceback
    self.ip_runlines = __IPYTHON__.runlines
    self.shell       = __IPYTHON__

    # load user data and initialize data structures
    self.reload()

</t>
<t tx="ekr.20071201085751.102">def reload(self):
    """Reload source from disk and initialize state."""
    # read data and parse into blocks
    self.src     = file_read(self.fname)
    src_b        = [b.strip() for b in self.re_stop.split(self.src) if b]
    self._silent = [bool(self.re_silent.findall(b)) for b in src_b]
    self._auto   = [bool(self.re_auto.findall(b)) for b in src_b]

    # if auto_all is not given (def. None), we read it from the file
    if self.auto_all is None:
        self.auto_all = bool(self.re_auto_all.findall(src_b[0]))
    else:
        self.auto_all = bool(self.auto_all)

    # Clean the sources from all markup so it doesn't get displayed when
    # running the demo
    src_blocks = []
    auto_strip = lambda s: self.re_auto.sub('',s)
    for i,b in enumerate(src_b):
        if self._auto[i]:
            src_blocks.append(auto_strip(b))
        else:
            src_blocks.append(b)
    # remove the auto_all marker
    src_blocks[0] = self.re_auto_all.sub('',src_blocks[0])

    self.nblocks = len(src_blocks)
    self.src_blocks = src_blocks

    # also build syntax-highlighted source
    self.src_blocks_colored = map(self.ip_colorize,self.src_blocks)

    # ensure clean namespace and seek offset
    self.reset()

</t>
<t tx="ekr.20071201085751.103">def reset(self):
    """Reset the namespace and seek pointer to restart the demo"""
    self.user_ns     = {}
    self.finished    = False
    self.block_index = 0

</t>
<t tx="ekr.20071201085751.104">def _validate_index(self,index):
    if index&lt;0 or index&gt;=self.nblocks:
        raise ValueError('invalid block index %s' % index)

</t>
<t tx="ekr.20071201085751.105">def _get_index(self,index):
    """Get the current block index, validating and checking status.

    Returns None if the demo is finished"""
    
    if index is None:
        if self.finished:
            print 'Demo finished.  Use reset() if you want to rerun it.'
            return None
        index = self.block_index
    else:
        self._validate_index(index)
    return index

</t>
<t tx="ekr.20071201085751.106">def seek(self,index):
    """Move the current seek pointer to the given block"""
    self._validate_index(index)
    self.block_index = index
    self.finished = False

</t>
<t tx="ekr.20071201085751.107">def back(self,num=1):
    """Move the seek pointer back num blocks (default is 1)."""
    self.seek(self.block_index-num)

</t>
<t tx="ekr.20071201085751.108">def jump(self,num):
    """Jump a given number of blocks relative to the current one."""
    self.seek(self.block_index+num)

</t>
<t tx="ekr.20071201085751.109">def again(self):
    """Move the seek pointer back one block and re-execute."""
    self.back(1)
    self()

</t>
<t tx="ekr.20071201085751.110">def edit(self,index=None):
    """Edit a block.

    If no number is given, use the last block executed.

    This edits the in-memory copy of the demo, it does NOT modify the
    original source file.  If you want to do that, simply open the file in
    an editor and use reload() when you make changes to the file.  This
    method is meant to let you change a block during a demonstration for
    explanatory purposes, without damaging your original script."""

    index = self._get_index(index)
    if index is None:
        return
    # decrease the index by one (unless we're at the very beginning), so
    # that the default demo.edit() call opens up the sblock we've last run
    if index&gt;0:
        index -= 1
        
    filename = self.shell.mktempfile(self.src_blocks[index])
    self.shell.hooks.editor(filename,1)
    new_block = file_read(filename)
    # update the source and colored block
    self.src_blocks[index] = new_block
    self.src_blocks_colored[index] = self.ip_colorize(new_block)
    self.block_index = index
    # call to run with the newly edited index
    self()
    
</t>
<t tx="ekr.20071201085751.111">def show(self,index=None):
    """Show a single block on screen"""

    index = self._get_index(index)
    if index is None:
        return

    print marquee('&lt;%s&gt; block # %s (%s remaining)' %
                  (self.fname,index,self.nblocks-index-1))
    print self.src_blocks_colored[index],
    sys.stdout.flush()

</t>
<t tx="ekr.20071201085751.112">def show_all(self):
    """Show entire demo on screen, block by block"""

    fname = self.fname
    nblocks = self.nblocks
    silent = self._silent
    for index,block in enumerate(self.src_blocks_colored):
        if silent[index]:
            print marquee('&lt;%s&gt; SILENT block # %s (%s remaining)' %
                          (fname,index,nblocks-index-1))
        else:
            print marquee('&lt;%s&gt; block # %s (%s remaining)' %
                          (fname,index,nblocks-index-1))
        print block,
    sys.stdout.flush()

</t>
<t tx="ekr.20071201085751.113">def runlines(self,source):
    """Execute a string with one or more lines of code"""

    exec source in self.user_ns
    
</t>
<t tx="ekr.20071201085751.114">def __call__(self,index=None):
    """run a block of the demo.

    If index is given, it should be an integer &gt;=1 and &lt;= nblocks.  This
    means that the calling convention is one off from typical Python
    lists.  The reason for the inconsistency is that the demo always
    prints 'Block n/N, and N is the total, so it would be very odd to use
    zero-indexing here."""

    index = self._get_index(index)
    if index is None:
        return
    try:
        next_block = self.src_blocks[index]
        self.block_index += 1
        if self._silent[index]:
            print marquee('Executing silent block # %s (%s remaining)' %
                          (index,self.nblocks-index-1))
        else:
            self.show(index)
            if self.auto_all or self._auto[index]:
                print marquee('output')
            else:
                print marquee('Press &lt;q&gt; to quit, &lt;Enter&gt; to execute...'),
                ans = raw_input().strip()
                if ans:
                    print marquee('Block NOT executed')
                    return
        try:
            save_argv = sys.argv
            sys.argv = self.sys_argv
            self.runlines(next_block)
        finally:
            sys.argv = save_argv
        
    except:
        self.ip_showtb(filename=self.fname)
    else:
        self.ip_ns.update(self.user_ns)

    if self.block_index == self.nblocks:
        print
        print marquee(' END OF DEMO ')
        print marquee('Use reset() if you want to rerun it.')
        self.finished = True

</t>
<t tx="ekr.20071201085751.115">class IPythonDemo(Demo):
    """Class for interactive demos with IPython's input processing applied.

    This subclasses Demo, but instead of executing each block by the Python
    interpreter (via exec), it actually calls IPython on it, so that any input
    filters which may be in place are applied to the input block.

    If you have an interactive environment which exposes special input
    processing, you can use this class instead to write demo scripts which
    operate exactly as if you had typed them interactively.  The default Demo
    class requires the input to be valid, pure Python code.
    """
    @others
</t>
<t tx="ekr.20071201085751.116">
def runlines(self,source):
    """Execute a string with one or more lines of code"""

    self.runlines(source)
    
</t>
<t tx="ekr.20071201085751.117">class LineDemo(Demo):
    """Demo where each line is executed as a separate block.

    The input script should be valid Python code.

    This class doesn't require any markup at all, and it's meant for simple
    scripts (with no nesting or any kind of indentation) which consist of
    multiple lines of input to be executed, one at a time, as if they had been
    typed in the interactive prompt."""
    @others
</t>
<t tx="ekr.20071201085751.118">
def reload(self):
    """Reload source from disk and initialize state."""
    # read data and parse into blocks
    src_b           = [l for l in file_readlines(self.fname) if l.strip()]
    nblocks         = len(src_b)
    self.src        = os.linesep.join(file_readlines(self.fname))
    self._silent    = [False]*nblocks
    self._auto      = [True]*nblocks
    self.auto_all   = True
    self.nblocks    = nblocks
    self.src_blocks = src_b

    # also build syntax-highlighted source
    self.src_blocks_colored = map(self.ip_colorize,self.src_blocks)

    # ensure clean namespace and seek offset
    self.reset()

</t>
<t tx="ekr.20071201085751.119">class IPythonLineDemo(IPythonDemo,LineDemo):
    """Variant of the LineDemo class whose input is processed by IPython."""
    pass
</t>
<t tx="ekr.20071201085751.120"># -*- coding: utf-8 -*-
"""DPyGetOpt -- Demiurge Python GetOptions Module

 $Id$

This module is modeled after perl's Getopt::Long module-- which
is, in turn, modeled after GNU's extended getopt() function.

Upon instantiation, the option specification should be a sequence
(list) of option definitions.

Options that take no arguments should simply contain the name of
the option.  If a ! is post-pended, the option can be negated by
prepending 'no';  ie 'debug!' specifies that -debug and -nodebug
should be accepted.

Mandatory arguments to options are specified using a postpended
'=' + a type specifier.  '=s' specifies a mandatory string
argument, '=i' specifies a mandatory integer argument, and '=f'
specifies a mandatory real number.  In all cases, the '=' can be
substituted with ':' to specify that the argument is optional.

Dashes '-' in option names are allowed.

If an option has the character '@' postpended (after the
argumentation specification), it can appear multiple times within
each argument list that is processed. The results will be stored
in a list.

The option name can actually be a list of names separated by '|'
characters;  ie-- 'foo|bar|baz=f@' specifies that all -foo, -bar,
and -baz options that appear on within the parsed argument list
must have a real number argument and that the accumulated list
of values will be available under the name 'foo'

$Id$"""

#*****************************************************************************
#
# Copyright (c) 2001 Bill Bumgarner &lt;bbum@friday.com&gt;
#
#
# Published under the terms of the MIT license, hereby reproduced:
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
#*****************************************************************************

__author__  = 'Bill Bumgarner &lt;bbum@friday.com&gt;'
__license__ = 'MIT'
__version__ = '1.2'

# Modified to use re instead of regex and regsub modules.
# 2001/5/7, Jonathan Hogg &lt;jonathan@onegoodidea.com&gt;

import re
import string
import sys
import types

arg_error  = 'DPyGetOpt Argument Error'
spec_error = 'DPyGetOpt Specification Error'
term_error = 'DPyGetOpt Termination Error'

specificationExpr = re.compile('(?P&lt;required&gt;.)(?P&lt;type&gt;.)(?P&lt;multi&gt;@?)')

ArgRequired     = 'Requires an Argument'
ArgOptional     = 'Argument Optional'

# The types modules is not used for these identifiers because there
# is no identifier for 'boolean' or 'generic'
StringArgType   = 'String Argument Type'
IntegerArgType  = 'Integer Argument Type'
RealArgType             = 'Real Argument Type'
BooleanArgType  = 'Boolean Argument Type'
GenericArgType  = 'Generic Argument Type'

# dictionary of conversion functions-- boolean and generic options
# do not accept arguments and do not need conversion functions;
# the identity function is used purely for convenience.
ConversionFunctions = {
        StringArgType : lambda x: x,
        IntegerArgType : string.atoi,
        RealArgType : string.atof,
        BooleanArgType : lambda x: x,
        GenericArgType : lambda x: x,
        }

</t>
<t tx="ekr.20071201085751.121">class DPyGetOpt:
    @others
</t>
<t tx="ekr.20071201085751.122">
def __init__(self, spec = None, terminators = ['--']):
    """
    Declare and intialize instance variables

    Yes, declaration is not necessary... but one of the things
    I sorely miss from C/Obj-C is the concept of having an
    interface definition that clearly declares all instance
    variables and methods without providing any implementation
     details.   it is a useful reference!

    all instance variables are initialized to 0/Null/None of
    the appropriate type-- not even the default value...
    """

#               sys.stderr.write(string.join(spec) + "\n")

    self.allowAbbreviations = 1  # boolean, 1 if abbreviations will
                                                                              # be expanded
    self.freeValues         = [] # list, contains free values
    self.ignoreCase         = 0  # boolean, YES if ignoring case
    self.needsParse         = 0  # boolean, YES if need to reparse parameter spec
    self.optionNames        = {} # dict, all option names-- value is index of tuple
    self.optionStartExpr    = None # regexp defining the start of an option (ie; '-', '--')
    self.optionTuples       = [] # list o' tuples containing defn of options AND aliases
    self.optionValues       = {} # dict, option names (after alias expansion) -&gt; option value(s)
    self.orderMixed         = 0  # boolean, YES if options can be mixed with args
    self.posixCompliance    = 0  # boolean, YES indicates posix like behaviour
    self.spec               = [] # list, raw specs (in case it must be reparsed)
    self.terminators        = terminators # list, strings that terminate argument processing
    self.termValues         = [] # list, values after terminator
    self.terminator         = None # full name of terminator that ended
                                           # option processing

    # set up defaults
    self.setPosixCompliance()
    self.setIgnoreCase()
    self.setAllowAbbreviations()

    # parse spec-- if present
    if spec:
        self.parseConfiguration(spec)

</t>
<t tx="ekr.20071201085751.123">def setPosixCompliance(self, aFlag = 0):
    """
    Enables and disables posix compliance.

    When enabled, '+' can be used as an option prefix and free
    values can be mixed with options.
    """
    self.posixCompliance = aFlag
    self.needsParse = 1

    if self.posixCompliance:
        self.optionStartExpr = re.compile('(--|-)(?P&lt;option&gt;[A-Za-z0-9_-]+)(?P&lt;arg&gt;=.*)?')
        self.orderMixed = 0
    else:
        self.optionStartExpr = re.compile('(--|-|\+)(?P&lt;option&gt;[A-Za-z0-9_-]+)(?P&lt;arg&gt;=.*)?')
        self.orderMixed = 1

</t>
<t tx="ekr.20071201085751.124">def isPosixCompliant(self):
    """
    Returns the value of the posix compliance flag.
    """
    return self.posixCompliance

</t>
<t tx="ekr.20071201085751.125">def setIgnoreCase(self, aFlag = 1):
    """
    Enables and disables ignoring case during option processing.
    """
    self.needsParse = 1
    self.ignoreCase = aFlag

</t>
<t tx="ekr.20071201085751.126">def ignoreCase(self):
    """
    Returns 1 if the option processor will ignore case when
    processing options.
    """
    return self.ignoreCase

</t>
<t tx="ekr.20071201085751.127">def setAllowAbbreviations(self, aFlag = 1):
    """
    Enables and disables the expansion of abbreviations during
    option processing.
    """
    self.allowAbbreviations = aFlag

</t>
<t tx="ekr.20071201085751.128">def willAllowAbbreviations(self):
    """
    Returns 1 if abbreviated options will be automatically
    expanded to the non-abbreviated form (instead of causing an
    unrecognized option error).
    """
    return self.allowAbbreviations

</t>
<t tx="ekr.20071201085751.129">def addTerminator(self, newTerm):
    """
    Adds newTerm as terminator of option processing.

    Whenever the option processor encounters one of the terminators
    during option processing, the processing of options terminates
    immediately, all remaining options are stored in the termValues
    instance variable and the full name of the terminator is stored
    in the terminator instance variable.
    """
    self.terminators = self.terminators + [newTerm]

</t>
<t tx="ekr.20071201085751.130">def _addOption(self, oTuple):
    """
    Adds the option described by oTuple (name, (type, mode,
    default), alias) to optionTuples.  Adds index keyed under name
    to optionNames.  Raises spec_error if name already in
    optionNames
    """
    (name, (type, mode, default, multi), realName) = oTuple

    # verify name and add to option names dictionary
    if self.optionNames.has_key(name):
        if realName:
            raise spec_error, 'Alias \'' + name + '\' for \'' + realName + \
                            '\' already used for another option or alias.'
        else:
            raise spec_error, 'Option named \'' + name + \
                            '\' specified more than once. Specification: ' + option

    # validated. add to optionNames
    self.optionNames[name] = self.tupleIndex
    self.tupleIndex = self.tupleIndex + 1

    # add to optionTuples
    self.optionTuples = self.optionTuples + [oTuple]

    # if type is boolean, add negation
    if type == BooleanArgType:
        alias            = 'no' + name
        specTuple = (type, mode, 0, multi)
        oTuple = (alias, specTuple, name)

        # verify name and add to option names dictionary
        if self.optionNames.has_key(alias):
            if realName:
                raise spec_error, 'Negated alias \'' + name + '\' for \'' + realName + \
                                '\' already used for another option or alias.'
            else:
                raise spec_error, 'Negated option named \'' + name + \
                                '\' specified more than once. Specification: ' + option

        # validated. add to optionNames
        self.optionNames[alias] = self.tupleIndex
        self.tupleIndex = self.tupleIndex + 1

        # add to optionTuples
        self.optionTuples = self.optionTuples + [oTuple]

</t>
<t tx="ekr.20071201085751.131">def addOptionConfigurationTuple(self, oTuple):
    (name, argSpec, realName) = oTuple
    if self.ignoreCase:
        name = string.lower(name)
        if realName:
            realName = string.lower(realName)
        else:
            realName = name

        oTuple = (name, argSpec, realName)

    # add option
    self._addOption(oTuple)

</t>
<t tx="ekr.20071201085751.132">def addOptionConfigurationTuples(self, oTuple):
    if type(oTuple) is ListType:
        for t in oTuple:
            self.addOptionConfigurationTuple(t)
    else:
        self.addOptionConfigurationTuple(oTuple)

</t>
<t tx="ekr.20071201085751.133">def parseConfiguration(self, spec):
    # destroy previous stored information + store raw spec
    self.spec                       = spec
    self.optionTuples       = []
    self.optionNames  = {}
    self.tupleIndex   = 0

    tupleIndex = 0

    # create some regex's for parsing each spec
    splitExpr = \
                             re.compile('(?P&lt;names&gt;\w+[-A-Za-z0-9|]*)?(?P&lt;spec&gt;!|[=:][infs]@?)?')
    for option in spec:
# push to lower case (does not negatively affect
# specification)
        if self.ignoreCase:
            option = string.lower(option)

        # break into names, specification
        match = splitExpr.match(option)
        if match is None:
            raise spec_error, 'Invalid specification {' + option + '}'

        names                     = match.group('names')
        specification = match.group('spec')

        # break name into name, aliases
        nlist = string.split(names, '|')

        # get name
        name      = nlist[0]
        aliases = nlist[1:]

        # specificationExpr = regex.symcomp('\(&lt;required&gt;.\)\(&lt;type&gt;.\)\(&lt;multi&gt;@?\)')
        if not specification:
            #spec tuple is ('type', 'arg mode', 'default value', 'multiple')
            argType         = GenericArgType
            argMode         = None
            argDefault      = 1
            argMultiple     = 0
        elif specification == '!':
            argType         = BooleanArgType
            argMode         = None
            argDefault      = 1
            argMultiple     = 0
        else:
            # parse
            match = specificationExpr.match(specification)
            if match is None:
                # failed to parse, die
                raise spec_error, 'Invalid configuration for option \'' + option + '\''

            # determine mode
            required = match.group('required')
            if required == '=':
                argMode = ArgRequired
            elif required == ':':
                argMode = ArgOptional
            else:
                raise spec_error, 'Unknown requirement configuration \'' + required + '\''

            # determine type
            type = match.group('type')
            if type == 's':
                argType   = StringArgType
                argDefault = ''
            elif type == 'i':
                argType   = IntegerArgType
                argDefault = 1
            elif type == 'f' or type == 'n':
                argType   = RealArgType
                argDefault = 1
            else:
                raise spec_error, 'Unknown type specifier \'' + type + '\''

            # determine quantity
            if match.group('multi') == '@':
                argMultiple = 1
            else:
                argMultiple = 0
        ## end else (of not specification)

        # construct specification tuple
        specTuple = (argType, argMode, argDefault, argMultiple)

        # add the option-- option tuple is (name, specTuple, real name)
        oTuple = (name, specTuple, name)
        self._addOption(oTuple)

        for alias in aliases:
            # drop to all lower (if configured to do so)
            if self.ignoreCase:
                alias = string.lower(alias)
            # create configuration tuple
            oTuple = (alias, specTuple, name)
            # add
            self._addOption(oTuple)

    # successfully parsed....
    self.needsParse = 0

</t>
<t tx="ekr.20071201085751.134">def _getArgTuple(self, argName):
    """
    Returns a list containing all the specification tuples that
    match argName.  If none match, None is returned.  If one
    matches, a list with one tuple is returned.  If more than one
    match, a list containing all the tuples that matched is
    returned.

    In other words, this function does not pass judgement upon the
    validity of multiple matches.
    """
    # is it in the optionNames dict?

    try:
#                       sys.stderr.write(argName + string.join(self.optionNames.keys()) + "\n")

        # yes, get index
        tupleIndex = self.optionNames[argName]
        # and return tuple as element of list
        return [self.optionTuples[tupleIndex]]
    except KeyError:
        # are abbreviations allowed?
        if not self.allowAbbreviations:
            # No! terefore, this cannot be valid argument-- nothing found
            return None

    # argName might be an abbreviation (and, abbreviations must
    # be allowed... or this would not have been reached!)

    # create regex for argName
    argExpr = re.compile('^' + argName)

    tuples = filter(lambda x, argExpr=argExpr: argExpr.search(x[0]) is not None,
                                              self.optionTuples)

    if not len(tuples):
        return None
    else:
        return tuples

</t>
<t tx="ekr.20071201085751.135">def _isTerminator(self, optionName):
    """
    Returns the full name of the terminator if optionName is a valid
    terminator.  If it is, sets self.terminator to the full name of
    the terminator.

    If more than one terminator matched, raises a term_error with a
    string describing the ambiguity.
    """

#               sys.stderr.write(optionName + "\n")
#               sys.stderr.write(repr(self.terminators))

    if optionName in self.terminators:
        self.terminator = optionName
    elif not self.allowAbbreviations:
        return None

# regex thing in bogus
#               termExpr = regex.compile('^' + optionName)

    terms = filter(lambda x, on=optionName: string.find(x,on) == 0, self.terminators)

    if not len(terms):
        return None
    elif len(terms) &gt; 1:
        raise term_error, 'Ambiguous terminator \'' + optionName + \
                        '\' matches ' + repr(terms)

    self.terminator = terms[0]
    return self.terminator

</t>
<t tx="ekr.20071201085751.136">def processArguments(self, args = None):
    """
    Processes args, a list of arguments (including options).

    If args is the same as sys.argv, automatically trims the first
    argument (the executable name/path).

    If an exception is not raised, the argument list was parsed
    correctly.

    Upon successful completion, the freeValues instance variable
    will contain all the arguments that were not associated with an
    option in the order they were encountered.  optionValues is a
    dictionary containing the value of each option-- the method
    valueForOption() can be used to query this dictionary.
    terminator will contain the argument encountered that terminated
    option processing (or None, if a terminator was never
    encountered) and termValues will contain all of the options that
    appeared after the Terminator (or an empty list).
    """

    if hasattr(sys, "argv") and args == sys.argv:
        args = sys.argv[1:]

    max             = len(args) # maximum index + 1
    self.freeValues = []        # array to hold return values
    self.optionValues= {}
    index           = 0         # initial index
    self.terminator = None
    self.termValues  = []

    while index &lt; max:
        # obtain argument
        arg = args[index]
        # increment index -- REMEMBER; it is NOW incremented
        index = index + 1

        # terminate immediately if option terminator encountered
        if self._isTerminator(arg):
            self.freeValues = self.freeValues + args[index:]
            self.termValues = args[index:]
            return

        # is this possibly an option?
        match = self.optionStartExpr.match(arg)
        if match is None:
            # not an option-- add to freeValues
            self.freeValues = self.freeValues + [arg]
            if not self.orderMixed:
                # mixing not allowed;  add rest of args as freeValues
                self.freeValues = self.freeValues + args[index:]
                # return to caller
                return
            else:
                continue

        # grab name
        optName = match.group('option')

        # obtain next argument-- index has already been incremented
        nextArg = match.group('arg')
        if nextArg:
            nextArg = nextArg[1:]
            index = index - 1 # put it back
        else:
            try:
                nextArg = args[index]
            except:
                nextArg = None

        # transpose to lower case, if necessary
        if self.ignoreCase:
            optName = string.lower(optName)

        # obtain defining tuple
        tuples = self._getArgTuple(optName)

        if tuples == None:
            raise arg_error, 'Illegal option \'' + arg + '\''
        elif len(tuples) &gt; 1:
            raise arg_error, 'Ambiguous option \'' + arg + '\';  matches ' + \
                            repr(map(lambda x: x[0], tuples))
        else:
            config = tuples[0]

        # config is now set to the configuration tuple for the
        # argument
        (fullName, spec, realName) = config
        (optType, optMode, optDefault, optMultiple) = spec

        # if opt mode required, but nextArg is none, raise an error
        if (optMode == ArgRequired):
            if (not nextArg) or self._isTerminator(nextArg):
#                                       print nextArg
                raise arg_error, 'Option \'' + arg + \
                                '\' requires an argument of type ' + optType

        if (not optMode == None) and nextArg and (not self._isTerminator(nextArg)):
            # nextArg defined, option configured to possibly consume arg
            try:
                # grab conversion function-- the try is more for internal diagnostics
                func = ConversionFunctions[optType]
                try:
                    optionValue = func(nextArg)
                    index = index + 1
                except:
                    # only raise conversion error if REQUIRED to consume argument
                    if optMode == ArgRequired:
                        raise arg_error, 'Invalid argument to option \'' + arg + \
                                        '\';  should be \'' + optType + '\''
                    else:
                        optionValue = optDefault
            except arg_error:
                raise arg_error, sys.exc_value
            except:
                raise arg_error, '(' + arg + \
                                ') Conversion function for \'' + optType + '\' not found.'
        else:
            optionValue = optDefault

        # add value to options dictionary
        if optMultiple:
            # can be multiple values
            try:
                # try to append element
                self.optionValues[realName] = self.optionValues[realName] + [optionValue]
            except:
                # failed-- must not exist;  add it
                self.optionValues[realName] = [optionValue]
        else:
            # only one value per
            if self.isPosixCompliant and self.optionValues.has_key(realName):
                raise arg_error, 'Argument \'' + arg + '\' occurs multiple times.'

            self.optionValues[realName] = optionValue

</t>
<t tx="ekr.20071201085751.137">def valueForOption(self, optionName, defaultValue = None):
    """
    Return the value associated with optionName.  If optionName was
    not encountered during parsing of the arguments, returns the
    defaultValue (which defaults to None).
    """
    try:
        optionValue = self.optionValues[optionName]
    except:
        optionValue = defaultValue

    return optionValue

</t>
<t tx="ekr.20071201085751.138">##
## test/example section
##
test_error = 'Test Run Amok!'
def _test():
    """
    A relatively complete test suite.
    """
    try:
        DPyGetOpt(['foo', 'bar=s', 'foo'])
    except:
        print 'EXCEPTION (should be \'foo\' already used..): ' + sys.exc_value

    try:
        DPyGetOpt(['foo|bar|apple=s@', 'baz|apple!'])
    except:
        print 'EXCEPTION (should be duplicate alias/name error): ' + sys.exc_value

    x = DPyGetOpt(['apple|atlas=i@', 'application|executable=f@'])
    try:
        x.processArguments(['-app', '29.3'])
    except:
        print 'EXCEPTION (should be ambiguous argument): ' +    sys.exc_value

    x = DPyGetOpt(['foo'], ['antigravity', 'antithesis'])
    try:
        x.processArguments(['-foo', 'anti'])
    except:
        print 'EXCEPTION (should be ambiguous terminator): ' + sys.exc_value

    profile = ['plain-option',
                              'boolean-option!',
                              'list-of-integers=i@',
                              'list-real-option|list-real-alias|list-real-pseudonym=f@',
                              'optional-string-option:s',
                              'abbreviated-string-list=s@']

    terminators = ['terminator']

    args = ['-plain-option',
                      '+noboolean-option',
                      '--list-of-integers', '1',
                      '+list-of-integers', '2',
                      '-list-of-integers', '3',
                      'freeargone',
                      '-list-real-option', '1.1',
                      '+list-real-alias', '1.2',
                      '--list-real-pseudonym', '1.3',
                      'freeargtwo',
                      '-abbreviated-string-list', 'String1',
                      '--abbreviated-s', 'String2',
                      '-abbrev', 'String3',
                      '-a', 'String4',
                      '-optional-string-option',
                      'term',
                      'next option should look like an invalid arg',
                      '-a']


    print 'Using profile: ' + repr(profile)
    print 'With terminator: ' + repr(terminators)
    print 'Processing arguments: ' + repr(args)

    go = DPyGetOpt(profile, terminators)
    go.processArguments(args)

    print 'Options (and values): ' + repr(go.optionValues)
    print 'free args: ' + repr(go.freeValues)
    print 'term args: ' + repr(go.termValues)
</t>
<t tx="ekr.20071201085751.139"># -*- coding: utf-8 -*-
"""
Color schemes for exception handling code in IPython.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2005-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license
__version__ = Release.version

#****************************************************************************
# Required modules
from IPython.ColorANSI import ColorSchemeTable, TermColors, ColorScheme

ExceptionColors = ColorSchemeTable()

# Populate it with color schemes
C = TermColors # shorthand and local lookup
ExceptionColors.add_scheme(ColorScheme(
    'NoColor',
    # The color to be used for the top line
    topline = C.NoColor,

    # The colors to be used in the traceback
    filename = C.NoColor,
    lineno = C.NoColor,
    name = C.NoColor,
    vName = C.NoColor,
    val = C.NoColor,
    em = C.NoColor,
    
    # Emphasized colors for the last frame of the traceback
    normalEm = C.NoColor,
    filenameEm = C.NoColor,
    linenoEm = C.NoColor,
    nameEm = C.NoColor,
    valEm = C.NoColor,
    
    # Colors for printing the exception
    excName = C.NoColor,
    line = C.NoColor,
    caret = C.NoColor,
    Normal = C.NoColor
    ))

# make some schemes as instances so we can copy them for modification easily
ExceptionColors.add_scheme(ColorScheme(
    'Linux',
    # The color to be used for the top line
    topline = C.LightRed,

    # The colors to be used in the traceback
    filename = C.Green,
    lineno = C.Green,
    name = C.Purple,
    vName = C.Cyan,
    val = C.Green,
    em = C.LightCyan,

    # Emphasized colors for the last frame of the traceback
    normalEm = C.LightCyan,
    filenameEm = C.LightGreen,
    linenoEm = C.LightGreen,
    nameEm = C.LightPurple,
    valEm = C.LightBlue,

    # Colors for printing the exception
    excName = C.LightRed,
    line = C.Yellow,
    caret = C.White,
    Normal = C.Normal
    ))

# For light backgrounds, swap dark/light colors
ExceptionColors.add_scheme(ColorScheme(
    'LightBG',
    # The color to be used for the top line
    topline = C.Red,
    
    # The colors to be used in the traceback
    filename = C.LightGreen,
    lineno = C.LightGreen,
    name = C.LightPurple,
    vName = C.Cyan,
    val = C.LightGreen,
    em = C.Cyan,

    # Emphasized colors for the last frame of the traceback
    normalEm = C.Cyan,
    filenameEm = C.Green,
    linenoEm = C.Green,
    nameEm = C.Purple,
    valEm = C.Blue,

    # Colors for printing the exception
    excName = C.Red,
    #line = C.Brown,  # brown often is displayed as yellow
    line = C.Red,
    caret = C.Normal,
    Normal = C.Normal
    ))
</t>
<t tx="ekr.20071201085751.140"># -*- coding: utf-8 -*-
"""
Class which mimics a module.

Needed to allow pickle to correctly resolve namespaces during IPython
sessions.

$Id$"""

</t>
<t tx="ekr.20071201085751.141">#*****************************************************************************
#       Copyright (C) 2002-2004 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

class FakeModule:
    """Simple class with attribute access to fake a module.

    This is not meant to replace a module, but to allow inserting a fake
    module in sys.modules so that systems which rely on run-time module
    importing (like shelve and pickle) work correctly in interactive IPython
    sessions.

    Do NOT use this code for anything other than this IPython private hack."""
    @others
</t>
<t tx="ekr.20071201085751.142">
def __init__(self,adict):

    # It seems pydoc (and perhaps others) needs any module instance to
    # implement a __nonzero__ method, so we add it if missing:
    if '__nonzero__' not in adict:
        def __nonzero__():
            return 1
        adict['__nonzero__'] = __nonzero__

        self.__dict__ = adict

    # modules should have a __file__ attribute
    adict['__file__'] = __file__

</t>
<t tx="ekr.20071201085751.143">def __getattr__(self,key):
    try:
        return self.__dict__[key]
    except KeyError, e:
        raise AttributeError("FakeModule object has no attribute %s" % e)

</t>
<t tx="ekr.20071201085751.144">def __str__(self):
    return "&lt;IPython.FakeModule instance&gt;"

</t>
<t tx="ekr.20071201085751.145">def __repr__(self):
    return str(self)
</t>
<t tx="ekr.20071201085751.146"># -*- coding: utf-8 -*-
"""
General purpose utilities.

This is a grab-bag of stuff I find useful in most programs I write. Some of
these things are also convenient when working at the command line.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

#****************************************************************************
# required modules from the Python standard library
import __main__
import commands
import os
import re
import shlex
import shutil
import sys
import tempfile
import time
import types
import warnings

# Other IPython utilities
from IPython.Itpl import Itpl,itpl,printpl
from IPython import DPyGetOpt
from path import path
if os.name == "nt":
    from IPython.winconsole import get_console_size

</t>
<t tx="ekr.20071201085751.147">#****************************************************************************
# Exceptions
class Error(Exception):
    """Base class for exceptions in this module."""
    pass

</t>
<t tx="ekr.20071201085751.148">#----------------------------------------------------------------------------
class IOStream:
    @others
</t>
<t tx="ekr.20071201085751.149">def __init__(self,stream,fallback):
    if not hasattr(stream,'write') or not hasattr(stream,'flush'):
        stream = fallback
    self.stream = stream
    self._swrite = stream.write
    self.flush = stream.flush

</t>
<t tx="ekr.20071201085751.150">def write(self,data):
    try:
        self._swrite(data)
    except:
        try:
            # print handles some unicode issues which may trip a plain
            # write() call.  Attempt to emulate write() by using a
            # trailing comma
            print &gt;&gt; self.stream, data,
        except:
            # if we get here, something is seriously broken.
            print &gt;&gt; sys.stderr, \
                  'ERROR - failed to write data to stream:', self.stream
    
</t>
<t tx="ekr.20071201085751.151">class IOTerm:
    """ Term holds the file or file-like objects for handling I/O operations.

    These are normally just sys.stdin, sys.stdout and sys.stderr but for
    Windows they can can replaced to allow editing the strings before they are
    displayed."""
    @others
</t>
<t tx="ekr.20071201085751.152">
# In the future, having IPython channel all its I/O operations through
# this class will make it easier to embed it into other environments which
# are not a normal terminal (such as a GUI-based shell)
def __init__(self,cin=None,cout=None,cerr=None):
    self.cin  = IOStream(cin,sys.stdin)
    self.cout = IOStream(cout,sys.stdout)
    self.cerr = IOStream(cerr,sys.stderr)
    
</t>
<t tx="ekr.20071201085751.153"># Global variable to be used for all I/O
Term = IOTerm()

import IPython.rlineimpl as readline
# Remake Term to use the readline i/o facilities
if sys.platform == 'win32' and readline.have_readline:
    
    Term = IOTerm(cout=readline._outputfile,cerr=readline._outputfile)
    

#****************************************************************************
# Generic warning/error printer, used by everything else
def warn(msg,level=2,exit_val=1):
    """Standard warning printer. Gives formatting consistency.

    Output is sent to Term.cerr (sys.stderr by default).
    
    Options:
    
    -level(2): allows finer control:
      0 -&gt; Do nothing, dummy function.
      1 -&gt; Print message.
      2 -&gt; Print 'WARNING:' + message. (Default level).
      3 -&gt; Print 'ERROR:' + message.
      4 -&gt; Print 'FATAL ERROR:' + message and trigger a sys.exit(exit_val).

    -exit_val (1): exit value returned by sys.exit() for a level 4
    warning. Ignored for all other levels."""
    
    if level&gt;0:
        header = ['','','WARNING: ','ERROR: ','FATAL ERROR: ']
        print &gt;&gt; Term.cerr, '%s%s' % (header[level],msg)
        if level == 4:
            print &gt;&gt; Term.cerr,'Exiting.\n'
            sys.exit(exit_val)

</t>
<t tx="ekr.20071201085751.154">def info(msg):
    """Equivalent to warn(msg,level=1)."""

    warn(msg,level=1)

</t>
<t tx="ekr.20071201085751.155">def error(msg):
    """Equivalent to warn(msg,level=3)."""

    warn(msg,level=3)

</t>
<t tx="ekr.20071201085751.156">def fatal(msg,exit_val=1):
    """Equivalent to warn(msg,exit_val=exit_val,level=4)."""

    warn(msg,exit_val=exit_val,level=4)

</t>
<t tx="ekr.20071201085751.157">#---------------------------------------------------------------------------
# Debugging routines
# 
def debugx(expr,pre_msg=''):
    """Print the value of an expression from the caller's frame.
    
    Takes an expression, evaluates it in the caller's frame and prints both
    the given expression and the resulting value (as well as a debug mark
    indicating the name of the calling function.  The input must be of a form
    suitable for eval().

    An optional message can be passed, which will be prepended to the printed
    expr-&gt;value pair."""
    
    cf = sys._getframe(1)
    print '[DBG:%s] %s%s -&gt; %r' % (cf.f_code.co_name,pre_msg,expr,
                                   eval(expr,cf.f_globals,cf.f_locals))

</t>
<t tx="ekr.20071201085751.158"># deactivate it by uncommenting the following line, which makes it a no-op
#def debugx(expr,pre_msg=''): pass

#----------------------------------------------------------------------------
StringTypes = types.StringTypes

# Basic timing functionality

# If possible (Unix), use the resource module instead of time.clock()
try:
    import resource
    def clock():
        """clock() -&gt; floating point number

        Return the CPU time in seconds (user time only, system time is
        ignored) since the start of the process.  This is done via a call to
        resource.getrusage, so it avoids the wraparound problems in
        time.clock()."""
        
        return resource.getrusage(resource.RUSAGE_SELF)[0]
    
    def clock2():
        """clock2() -&gt; (t_user,t_system)

        Similar to clock(), but return a tuple of user/system times."""
        return resource.getrusage(resource.RUSAGE_SELF)[:2]

except ImportError:
    clock = time.clock
    def clock2():
        """Under windows, system CPU time can't be measured.

        This just returns clock() and zero."""
        return time.clock(),0.0

def timings_out(reps,func,*args,**kw):
    """timings_out(reps,func,*args,**kw) -&gt; (t_total,t_per_call,output)

    Execute a function reps times, return a tuple with the elapsed total
    CPU time in seconds, the time per call and the function's output.

    Under Unix, the return value is the sum of user+system time consumed by
    the process, computed via the resource module.  This prevents problems
    related to the wraparound effect which the time.clock() function has.
    
    Under Windows the return value is in wall clock seconds. See the
    documentation for the time module for more details."""

    reps = int(reps)
    assert reps &gt;=1, 'reps must be &gt;= 1'
    if reps==1:
        start = clock()
        out = func(*args,**kw)
        tot_time = clock()-start
    else:
        rng = xrange(reps-1) # the last time is executed separately to store output
        start = clock()
        for dummy in rng: func(*args,**kw)
        out = func(*args,**kw)  # one last time
        tot_time = clock()-start
    av_time = tot_time / reps
    return tot_time,av_time,out

</t>
<t tx="ekr.20071201085751.159">def timings(reps,func,*args,**kw):
    """timings(reps,func,*args,**kw) -&gt; (t_total,t_per_call)

    Execute a function reps times, return a tuple with the elapsed total CPU
    time in seconds and the time per call. These are just the first two values
    in timings_out()."""

    return timings_out(reps,func,*args,**kw)[0:2]

</t>
<t tx="ekr.20071201085751.160">def timing(func,*args,**kw):
    """timing(func,*args,**kw) -&gt; t_total

    Execute a function once, return the elapsed total CPU time in
    seconds. This is just the first value in timings_out()."""

    return timings_out(1,func,*args,**kw)[0]

</t>
<t tx="ekr.20071201085751.161">#****************************************************************************
# file and system

def arg_split(s,posix=False):
    """Split a command line's arguments in a shell-like manner.

    This is a modified version of the standard library's shlex.split()
    function, but with a default of posix=False for splitting, so that quotes
    in inputs are respected."""
    
    lex = shlex.shlex(s, posix=posix)
    lex.whitespace_split = True
    return list(lex)

</t>
<t tx="ekr.20071201085751.162">def system(cmd,verbose=0,debug=0,header=''):
    """Execute a system command, return its exit status.

    Options:

    - verbose (0): print the command to be executed.
    
    - debug (0): only print, do not actually execute.

    - header (''): Header to print on screen prior to the executed command (it
    is only prepended to the command, no newlines are added).

    Note: a stateful version of this function is available through the
    SystemExec class."""

    stat = 0
    if verbose or debug: print header+cmd
    sys.stdout.flush()
    if not debug: stat = os.system(cmd)
    return stat

</t>
<t tx="ekr.20071201085751.163"># This function is used by ipython in a lot of places to make system calls.
# We need it to be slightly different under win32, due to the vagaries of
# 'network shares'.  A win32 override is below.

def shell(cmd,verbose=0,debug=0,header=''):
    """Execute a command in the system shell, always return None.

    Options:

    - verbose (0): print the command to be executed.
    
    - debug (0): only print, do not actually execute.

    - header (''): Header to print on screen prior to the executed command (it
    is only prepended to the command, no newlines are added).

    Note: this is similar to genutils.system(), but it returns None so it can
    be conveniently used in interactive loops without getting the return value
    (typically 0) printed many times."""

    stat = 0
    if verbose or debug: print header+cmd
    # flush stdout so we don't mangle python's buffering
    sys.stdout.flush()
    if not debug:
        os.system(cmd)

</t>
<t tx="ekr.20071201085751.164"># override shell() for win32 to deal with network shares
if os.name in ('nt','dos'):

    shell_ori = shell

    def shell(cmd,verbose=0,debug=0,header=''):
        if os.getcwd().startswith(r"\\"):
            path = os.getcwd()
            # change to c drive (cannot be on UNC-share when issuing os.system,
            # as cmd.exe cannot handle UNC addresses)
            os.chdir("c:")
            # issue pushd to the UNC-share and then run the command
            try:
                shell_ori('"pushd %s&amp;&amp;"'%path+cmd,verbose,debug,header)
            finally:
                os.chdir(path)
        else:
            shell_ori(cmd,verbose,debug,header)

    shell.__doc__ = shell_ori.__doc__

def getoutput(cmd,verbose=0,debug=0,header='',split=0):
    """Dummy substitute for perl's backquotes.

    Executes a command and returns the output.

    Accepts the same arguments as system(), plus:

    - split(0): if true, the output is returned as a list split on newlines.

    Note: a stateful version of this function is available through the
    SystemExec class.
    
    This is pretty much deprecated and rarely used, 
    genutils.getoutputerror may be what you need.
    
    """

    if verbose or debug: print header+cmd
    if not debug:
        output = os.popen(cmd).read()
        # stipping last \n is here for backwards compat.
        if output.endswith('\n'):
            output = output[:-1]
        if split:
            return output.split('\n')
        else:
            return output

</t>
<t tx="ekr.20071201085751.165">def getoutputerror(cmd,verbose=0,debug=0,header='',split=0):
    """Return (standard output,standard error) of executing cmd in a shell.

    Accepts the same arguments as system(), plus:

    - split(0): if true, each of stdout/err is returned as a list split on
    newlines.

    Note: a stateful version of this function is available through the
    SystemExec class."""

    if verbose or debug: print header+cmd
    if not cmd:
        if split:
            return [],[]
        else:
            return '',''
    if not debug:
        pin,pout,perr = os.popen3(cmd)
        tout = pout.read().rstrip()
        terr = perr.read().rstrip()
        pin.close()
        pout.close()
        perr.close()
        if split:
            return tout.split('\n'),terr.split('\n')
        else:
            return tout,terr

</t>
<t tx="ekr.20071201085751.166"># for compatibility with older naming conventions
xsys = system
bq = getoutput

class SystemExec:
    """Access the system and getoutput functions through a stateful interface.

    Note: here we refer to the system and getoutput functions from this
    library, not the ones from the standard python library.
    
    This class offers the system and getoutput functions as methods, but the
    verbose, debug and header parameters can be set for the instance (at
    creation time or later) so that they don't need to be specified on each
    call.

    For efficiency reasons, there's no way to override the parameters on a
    per-call basis other than by setting instance attributes. If you need
    local overrides, it's best to directly call system() or getoutput().

    The following names are provided as alternate options:
     - xsys: alias to system
     - bq: alias to getoutput

    An instance can then be created as:
     &gt;&gt;&gt; sysexec = SystemExec(verbose=1,debug=0,header='Calling: ')

    And used as:
     &gt;&gt;&gt; sysexec.xsys('pwd')
     &gt;&gt;&gt; dirlist = sysexec.bq('ls -l')
    """
    @others
    bq = getoutput  # alias

</t>
<t tx="ekr.20071201085751.167">
def __init__(self,verbose=0,debug=0,header='',split=0):
    """Specify the instance's values for verbose, debug and header."""
    setattr_list(self,'verbose debug header split')

</t>
<t tx="ekr.20071201085751.168">def system(self,cmd):
    """Stateful interface to system(), with the same keyword parameters."""

    system(cmd,self.verbose,self.debug,self.header)

</t>
<t tx="ekr.20071201085751.169">def shell(self,cmd):
    """Stateful interface to shell(), with the same keyword parameters."""

    shell(cmd,self.verbose,self.debug,self.header)

</t>
<t tx="ekr.20071201085751.170">xsys = system  # alias

def getoutput(self,cmd):
    """Stateful interface to getoutput()."""

    return getoutput(cmd,self.verbose,self.debug,self.header,self.split)

</t>
<t tx="ekr.20071201085751.171">def getoutputerror(self,cmd):
    """Stateful interface to getoutputerror()."""

    return getoutputerror(cmd,self.verbose,self.debug,self.header,self.split)

</t>
<t tx="ekr.20071201085751.172">#-----------------------------------------------------------------------------
def mutex_opts(dict,ex_op):
    """Check for presence of mutually exclusive keys in a dict.

    Call: mutex_opts(dict,[[op1a,op1b],[op2a,op2b]...]"""
    for op1,op2 in ex_op:
        if op1 in dict and op2 in dict:
            raise ValueError,'\n*** ERROR in Arguments *** '\
                  'Options '+op1+' and '+op2+' are mutually exclusive.'

</t>
<t tx="ekr.20071201085751.173">#-----------------------------------------------------------------------------
def get_py_filename(name):
    """Return a valid python filename in the current directory.

    If the given name is not a file, it adds '.py' and searches again.
    Raises IOError with an informative message if the file isn't found."""

    name = os.path.expanduser(name)
    if not os.path.isfile(name) and not name.endswith('.py'):
        name += '.py'
    if os.path.isfile(name):
        return name
    else:
        raise IOError,'File `%s` not found.' % name

</t>
<t tx="ekr.20071201085751.174">#-----------------------------------------------------------------------------
def filefind(fname,alt_dirs = None):
    """Return the given filename either in the current directory, if it
    exists, or in a specified list of directories.

    ~ expansion is done on all file and directory names.

    Upon an unsuccessful search, raise an IOError exception."""

    if alt_dirs is None:
        try:
            alt_dirs = get_home_dir()
        except HomeDirError:
            alt_dirs = os.getcwd()
    search = [fname] + list_strings(alt_dirs)
    search = map(os.path.expanduser,search)
    #print 'search list for',fname,'list:',search  # dbg
    fname = search[0]
    if os.path.isfile(fname):
        return fname
    for direc in search[1:]:
        testname = os.path.join(direc,fname)
        #print 'testname',testname  # dbg
        if os.path.isfile(testname):
            return testname
    raise IOError,'File' + `fname` + \
          ' not found in current or supplied directories:' + `alt_dirs`

</t>
<t tx="ekr.20071201085751.175">#----------------------------------------------------------------------------
def file_read(filename):
    """Read a file and close it.  Returns the file source."""
    fobj = open(filename,'r');
    source = fobj.read();
    fobj.close()
    return source

</t>
<t tx="ekr.20071201085751.176">def file_readlines(filename):
    """Read a file and close it.  Returns the file source using readlines()."""
    fobj = open(filename,'r');
    lines = fobj.readlines();
    fobj.close()
    return lines

</t>
<t tx="ekr.20071201085751.177">#----------------------------------------------------------------------------
def target_outdated(target,deps):
    """Determine whether a target is out of date.

    target_outdated(target,deps) -&gt; 1/0

    deps: list of filenames which MUST exist.
    target: single filename which may or may not exist.

    If target doesn't exist or is older than any file listed in deps, return
    true, otherwise return false.
    """
    try:
        target_time = os.path.getmtime(target)
    except os.error:
        return 1
    for dep in deps:
        dep_time = os.path.getmtime(dep)
        if dep_time &gt; target_time:
            #print "For target",target,"Dep failed:",dep # dbg
            #print "times (dep,tar):",dep_time,target_time # dbg
            return 1
    return 0

</t>
<t tx="ekr.20071201085751.178">#-----------------------------------------------------------------------------
def target_update(target,deps,cmd):
    """Update a target with a given command given a list of dependencies.

    target_update(target,deps,cmd) -&gt; runs cmd if target is outdated.

    This is just a wrapper around target_outdated() which calls the given
    command if target is outdated."""

    if target_outdated(target,deps):
        xsys(cmd)

</t>
<t tx="ekr.20071201085751.179">#----------------------------------------------------------------------------
def unquote_ends(istr):
    """Remove a single pair of quotes from the endpoints of a string."""

    if not istr:
        return istr
    if (istr[0]=="'" and istr[-1]=="'") or \
       (istr[0]=='"' and istr[-1]=='"'):
        return istr[1:-1]
    else:
        return istr

</t>
<t tx="ekr.20071201085751.180">#----------------------------------------------------------------------------
def process_cmdline(argv,names=[],defaults={},usage=''):
    """ Process command-line options and arguments.

    Arguments:

    - argv: list of arguments, typically sys.argv.
    
    - names: list of option names. See DPyGetOpt docs for details on options
    syntax.

    - defaults: dict of default values.

    - usage: optional usage notice to print if a wrong argument is passed.

    Return a dict of options and a list of free arguments."""

    getopt = DPyGetOpt.DPyGetOpt()
    getopt.setIgnoreCase(0)
    getopt.parseConfiguration(names)

    try:
        getopt.processArguments(argv)
    except:
        print usage
        warn(`sys.exc_value`,level=4)

    defaults.update(getopt.optionValues)
    args = getopt.freeValues
    
    return defaults,args

</t>
<t tx="ekr.20071201085751.181">#----------------------------------------------------------------------------
def optstr2types(ostr):
    """Convert a string of option names to a dict of type mappings.

    optstr2types(str) -&gt; {None:'string_opts',int:'int_opts',float:'float_opts'}

    This is used to get the types of all the options in a string formatted
    with the conventions of DPyGetOpt. The 'type' None is used for options
    which are strings (they need no further conversion). This function's main
    use is to get a typemap for use with read_dict().
    """

    typeconv = {None:'',int:'',float:''}
    typemap = {'s':None,'i':int,'f':float}
    opt_re = re.compile(r'([\w]*)([^:=]*:?=?)([sif]?)')

    for w in ostr.split():
        oname,alias,otype = opt_re.match(w).groups()
        if otype == '' or alias == '!':   # simple switches are integers too
            otype = 'i'
        typeconv[typemap[otype]] += oname + ' '
    return typeconv

</t>
<t tx="ekr.20071201085751.182">#----------------------------------------------------------------------------
def read_dict(filename,type_conv=None,**opt):

    """Read a dictionary of key=value pairs from an input file, optionally
    performing conversions on the resulting values.

    read_dict(filename,type_conv,**opt) -&gt; dict

    Only one value per line is accepted, the format should be
     # optional comments are ignored
     key value\n

    Args:

      - type_conv: A dictionary specifying which keys need to be converted to
      which types. By default all keys are read as strings. This dictionary
      should have as its keys valid conversion functions for strings
      (int,long,float,complex, or your own).  The value for each key
      (converter) should be a whitespace separated string containing the names
      of all the entries in the file to be converted using that function. For
      keys to be left alone, use None as the conversion function (only needed
      with purge=1, see below).

      - opt: dictionary with extra options as below (default in parens)

        purge(0): if set to 1, all keys *not* listed in type_conv are purged out
        of the dictionary to be returned. If purge is going to be used, the
        set of keys to be left as strings also has to be explicitly specified
        using the (non-existent) conversion function None.

        fs(None): field separator. This is the key/value separator to be used
        when parsing the file. The None default means any whitespace [behavior
        of string.split()].

        strip(0): if 1, strip string values of leading/trailinig whitespace.

        warn(1): warning level if requested keys are not found in file.
          - 0: silently ignore.
          - 1: inform but proceed.
          - 2: raise KeyError exception.

        no_empty(0): if 1, remove keys with whitespace strings as a value.

        unique([]): list of keys (or space separated string) which can't be
        repeated. If one such key is found in the file, each new instance
        overwrites the previous one. For keys not listed here, the behavior is
        to make a list of all appearances.

    Example:
    If the input file test.ini has:
      i 3
      x 4.5
      y 5.5
      s hi ho
    Then:

    &gt;&gt;&gt; type_conv={int:'i',float:'x',None:'s'}
    &gt;&gt;&gt; read_dict('test.ini')
    {'i': '3', 's': 'hi ho', 'x': '4.5', 'y': '5.5'}
    &gt;&gt;&gt; read_dict('test.ini',type_conv)
    {'i': 3, 's': 'hi ho', 'x': 4.5, 'y': '5.5'}
    &gt;&gt;&gt; read_dict('test.ini',type_conv,purge=1)
    {'i': 3, 's': 'hi ho', 'x': 4.5}
    """

    # starting config
    opt.setdefault('purge',0)
    opt.setdefault('fs',None)  # field sep defaults to any whitespace
    opt.setdefault('strip',0)
    opt.setdefault('warn',1)
    opt.setdefault('no_empty',0)
    opt.setdefault('unique','')
    if type(opt['unique']) in StringTypes:
        unique_keys = qw(opt['unique'])
    elif type(opt['unique']) in (types.TupleType,types.ListType):
        unique_keys = opt['unique']
    else:
        raise ValueError, 'Unique keys must be given as a string, List or Tuple'

    dict = {}
    # first read in table of values as strings
    file = open(filename,'r')
    for line in file.readlines():
        line = line.strip()
        if len(line) and line[0]=='#': continue
        if len(line)&gt;0:
            lsplit = line.split(opt['fs'],1)
            try:
                key,val = lsplit
            except ValueError:
                key,val = lsplit[0],''
            key = key.strip()
            if opt['strip']: val = val.strip()
            if val == "''" or val == '""': val = ''
            if opt['no_empty'] and (val=='' or val.isspace()):
                continue
            # if a key is found more than once in the file, build a list
            # unless it's in the 'unique' list. In that case, last found in file
            # takes precedence. User beware.
            try:
                if dict[key] and key in unique_keys:
                    dict[key] = val
                elif type(dict[key]) is types.ListType:
                    dict[key].append(val)
                else:
                    dict[key] = [dict[key],val]
            except KeyError:
                dict[key] = val
    # purge if requested
    if opt['purge']:
        accepted_keys = qwflat(type_conv.values())
        for key in dict.keys():
            if key in accepted_keys: continue
            del(dict[key])
    # now convert if requested
    if type_conv==None: return dict
    conversions = type_conv.keys()
    try: conversions.remove(None)
    except: pass
    for convert in conversions:
        for val in qw(type_conv[convert]):
            try:
                dict[val] = convert(dict[val])
            except KeyError,e:
                if opt['warn'] == 0:
                    pass
                elif opt['warn'] == 1:
                    print &gt;&gt;sys.stderr, 'Warning: key',val,\
                          'not found in file',filename
                elif opt['warn'] == 2:
                    raise KeyError,e
                else:
                    raise ValueError,'Warning level must be 0,1 or 2'

    return dict

</t>
<t tx="ekr.20071201085751.183">#----------------------------------------------------------------------------
def flag_calls(func):
    """Wrap a function to detect and flag when it gets called.

    This is a decorator which takes a function and wraps it in a function with
    a 'called' attribute. wrapper.called is initialized to False.

    The wrapper.called attribute is set to False right before each call to the
    wrapped function, so if the call fails it remains False.  After the call
    completes, wrapper.called is set to True and the output is returned.

    Testing for truth in wrapper.called allows you to determine if a call to
    func() was attempted and succeeded."""
    
    def wrapper(*args,**kw):
        wrapper.called = False
        out = func(*args,**kw)
        wrapper.called = True
        return out

    wrapper.called = False
    wrapper.__doc__ = func.__doc__
    return wrapper

</t>
<t tx="ekr.20071201085751.184">#----------------------------------------------------------------------------
class HomeDirError(Error):
    pass

</t>
<t tx="ekr.20071201085751.185">def get_home_dir():
    """Return the closest possible equivalent to a 'home' directory.

    We first try $HOME.  Absent that, on NT it's $HOMEDRIVE\$HOMEPATH.

    Currently only Posix and NT are implemented, a HomeDirError exception is
    raised for all other OSes. """

    isdir = os.path.isdir
    env = os.environ
    try:
        homedir = env['HOME']
        if not isdir(homedir):
            # in case a user stuck some string which does NOT resolve to a
            # valid path, it's as good as if we hadn't foud it
            raise KeyError
        return homedir
    except KeyError:
        if os.name == 'posix':
            raise HomeDirError,'undefined $HOME, IPython can not proceed.'
        elif os.name == 'nt':
            # For some strange reason, win9x returns 'nt' for os.name.
            try:
                homedir = os.path.join(env['HOMEDRIVE'],env['HOMEPATH'])
                if not isdir(homedir):
                    homedir = os.path.join(env['USERPROFILE'])
                    if not isdir(homedir):
                        raise HomeDirError
                return homedir
            except:
                try:
                    # Use the registry to get the 'My Documents' folder.
                    import _winreg as wreg
                    key = wreg.OpenKey(wreg.HKEY_CURRENT_USER,
                                       "Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders")
                    homedir = wreg.QueryValueEx(key,'Personal')[0]
                    key.Close()
                    if not isdir(homedir):
                        e = ('Invalid "Personal" folder registry key '
                             'typically "My Documents".\n'
                             'Value: %s\n'
                             'This is not a valid directory on your system.' %
                             homedir)
                        raise HomeDirError(e)
                    return homedir
                except HomeDirError:
                    raise
                except:
                    return 'C:\\'
        elif os.name == 'dos':
            # Desperate, may do absurd things in classic MacOS. May work under DOS.
            return 'C:\\'
        else:
            raise HomeDirError,'support for your operating system not implemented.'

</t>
<t tx="ekr.20071201085751.186">#****************************************************************************
# strings and text

class LSString(str):
    """String derivative with a special access attributes.

    These are normal strings, but with the special attributes:

        .l (or .list) : value as list (split on newlines).
        .n (or .nlstr): original value (the string itself).
        .s (or .spstr): value as whitespace-separated string.
        
    Any values which require transformations are computed only once and
    cached.

    Such strings are very useful to efficiently interact with the shell, which
    typically only understands whitespace-separated options for commands."""
    @others
    p = paths = property(get_paths)


</t>
<t tx="ekr.20071201085751.187">
def get_list(self):
    try:
        return self.__list
    except AttributeError:
        self.__list = self.split('\n')
        return self.__list

</t>
<t tx="ekr.20071201085751.188">l = list = property(get_list)

def get_spstr(self):
    try:
        return self.__spstr
    except AttributeError:
        self.__spstr = self.replace('\n',' ')
        return self.__spstr

</t>
<t tx="ekr.20071201085751.189">s = spstr = property(get_spstr)

def get_nlstr(self):
    return self

</t>
<t tx="ekr.20071201085751.190">n = nlstr = property(get_nlstr)

def get_paths(self):
    try:
        return self.__paths
    except AttributeError:
        self.__paths = [path(p) for p in self.split('\n') if os.path.exists(p)]
        return self.__paths

</t>
<t tx="ekr.20071201085751.191">#----------------------------------------------------------------------------
class SList(list):
    """List derivative with a special access attributes.

    These are normal lists, but with the special attributes:

        .l (or .list) : value as list (the list itself).
        .n (or .nlstr): value as a string, joined on newlines.
        .s (or .spstr): value as a string, joined on spaces.

    Any values which require transformations are computed only once and
    cached."""
    @others
    p = paths = property(get_paths)

</t>
<t tx="ekr.20071201085751.192">
def get_list(self):
    return self

</t>
<t tx="ekr.20071201085751.193">l = list = property(get_list)

def get_spstr(self):
    try:
        return self.__spstr
    except AttributeError:
        self.__spstr = ' '.join(self)
        return self.__spstr

</t>
<t tx="ekr.20071201085751.194">s = spstr = property(get_spstr)

def get_nlstr(self):
    try:
        return self.__nlstr
    except AttributeError:
        self.__nlstr = '\n'.join(self)
        return self.__nlstr

</t>
<t tx="ekr.20071201085751.195">n = nlstr = property(get_nlstr)

def get_paths(self):
    try:
        return self.__paths
    except AttributeError:
        self.__paths = [path(p) for p in self if os.path.exists(p)]
        return self.__paths

</t>
<t tx="ekr.20071201085751.196">#----------------------------------------------------------------------------
def esc_quotes(strng):
    """Return the input string with single and double quotes escaped out"""

    return strng.replace('"','\\"').replace("'","\\'")

</t>
<t tx="ekr.20071201085751.197">#----------------------------------------------------------------------------
def make_quoted_expr(s):
    """Return string s in appropriate quotes, using raw string if possible.
    
    Effectively this turns string: cd \ao\ao\
    to: r"cd \ao\ao\_"[:-1]
    
    Note the use of raw string and padding at the end to allow trailing backslash.
    
    """
    
    tail = ''
    tailpadding = ''
    raw  = ''
    if "\\" in s:
        raw = 'r'
        if s.endswith('\\'):
            tail = '[:-1]'
            tailpadding = '_'
    if '"' not in s:
        quote = '"'
    elif "'" not in s:
        quote = "'"
    elif '"""' not in s and not s.endswith('"'):
        quote = '"""'
    elif "'''" not in s and not s.endswith("'"):
        quote = "'''"
    else:
        # give up, backslash-escaped string will do
        return '"%s"' % esc_quotes(s)
    res = itpl("$raw$quote$s$tailpadding$quote$tail")
    return res


</t>
<t tx="ekr.20071201085751.198">#----------------------------------------------------------------------------
def raw_input_multi(header='', ps1='==&gt; ', ps2='..&gt; ',terminate_str = '.'):
    """Take multiple lines of input.

    A list with each line of input as a separate element is returned when a
    termination string is entered (defaults to a single '.'). Input can also
    terminate via EOF (^D in Unix, ^Z-RET in Windows).

    Lines of input which end in \\ are joined into single entries (and a
    secondary continuation prompt is issued as long as the user terminates
    lines with \\). This allows entering very long strings which are still
    meant to be treated as single entities.
    """

    try:
        if header:
            header += '\n'
        lines = [raw_input(header + ps1)]
    except EOFError:
        return []
    terminate = [terminate_str]
    try:
        while lines[-1:] != terminate:
            new_line = raw_input(ps1)
            while new_line.endswith('\\'):
                new_line = new_line[:-1] + raw_input(ps2)
            lines.append(new_line)
                
        return lines[:-1]  # don't return the termination command
    except EOFError:
        print
        return lines

</t>
<t tx="ekr.20071201085751.199">#----------------------------------------------------------------------------
def raw_input_ext(prompt='',  ps2='... '):
    """Similar to raw_input(), but accepts extended lines if input ends with \\."""

    line = raw_input(prompt)
    while line.endswith('\\'):
        line = line[:-1] + raw_input(ps2)
    return line

</t>
<t tx="ekr.20071201085751.200">#----------------------------------------------------------------------------
def ask_yes_no(prompt,default=None):
    """Asks a question and returns an integer 1/0 (y/n) answer.

    If default is given (one of 'y','n'), it is used if the user input is
    empty. Otherwise the question is repeated until an answer is given.

    An EOF is treated as the default answer.  If there is no default, an
    exception is raised to prevent infinite loops.

    Valid answers are: y/yes/n/no (match is not case sensitive)."""

    answers = {'y':True,'n':False,'yes':True,'no':False}
    ans = None
    while ans not in answers.keys():
        try:
            ans = raw_input(prompt+' ').lower()
            if not ans:  # response was an empty string
                ans = default
        except KeyboardInterrupt:
            pass
        except EOFError:
            if default in answers.keys():
                ans = default
                print
            else:
                raise
            
    return answers[ans]

</t>
<t tx="ekr.20071201085751.201">#----------------------------------------------------------------------------
def marquee(txt='',width=78,mark='*'):
    """Return the input string centered in a 'marquee'."""
    if not txt:
        return (mark*width)[:width]
    nmark = (width-len(txt)-2)/len(mark)/2
    if nmark &lt; 0: nmark =0
    marks = mark*nmark
    return '%s %s %s' % (marks,txt,marks)

</t>
<t tx="ekr.20071201085751.202">#----------------------------------------------------------------------------
class EvalDict:
    """
    Emulate a dict which evaluates its contents in the caller's frame.

    Usage:
    &gt;&gt;&gt;number = 19
    &gt;&gt;&gt;text = "python"
    &gt;&gt;&gt;print "%(text.capitalize())s %(number/9.0).1f rules!" % EvalDict()
    """
    @others
</t>
<t tx="ekr.20071201085751.203">
# This version is due to sismex01@hebmex.com on c.l.py, and is basically a
# modified (shorter) version of:
# http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66018 by
# Skip Montanaro (skip@pobox.com).

def __getitem__(self, name):
    frame = sys._getframe(1)
    return eval(name, frame.f_globals, frame.f_locals)

</t>
<t tx="ekr.20071201085751.204">EvalString = EvalDict  # for backwards compatibility
#----------------------------------------------------------------------------
def qw(words,flat=0,sep=None,maxsplit=-1):
    """Similar to Perl's qw() operator, but with some more options.

    qw(words,flat=0,sep=' ',maxsplit=-1) -&gt; words.split(sep,maxsplit)

    words can also be a list itself, and with flat=1, the output will be
    recursively flattened. Examples:

    &gt;&gt;&gt; qw('1 2')
    ['1', '2']
    &gt;&gt;&gt; qw(['a b','1 2',['m n','p q']])
    [['a', 'b'], ['1', '2'], [['m', 'n'], ['p', 'q']]]
    &gt;&gt;&gt; qw(['a b','1 2',['m n','p q']],flat=1)
    ['a', 'b', '1', '2', 'm', 'n', 'p', 'q']    """

    if type(words) in StringTypes:
        return [word.strip() for word in words.split(sep,maxsplit)
                if word and not word.isspace() ]
    if flat:
        return flatten(map(qw,words,[1]*len(words)))
    return map(qw,words)

</t>
<t tx="ekr.20071201085751.205">#----------------------------------------------------------------------------
def qwflat(words,sep=None,maxsplit=-1):
    """Calls qw(words) in flat mode. It's just a convenient shorthand."""
    return qw(words,1,sep,maxsplit)

</t>
<t tx="ekr.20071201085751.206">#----------------------------------------------------------------------------
def qw_lol(indata):
    """qw_lol('a b') -&gt; [['a','b']],
    otherwise it's just a call to qw().

    We need this to make sure the modules_some keys *always* end up as a
    list of lists."""

    if type(indata) in StringTypes:
        return [qw(indata)]
    else:
        return qw(indata)

</t>
<t tx="ekr.20071201085751.207">#-----------------------------------------------------------------------------
def list_strings(arg):
    """Always return a list of strings, given a string or list of strings
    as input."""

    if type(arg) in StringTypes: return [arg]
    else: return arg

</t>
<t tx="ekr.20071201085751.208">#----------------------------------------------------------------------------
def grep(pat,list,case=1):
    """Simple minded grep-like function.
    grep(pat,list) returns occurrences of pat in list, None on failure.

    It only does simple string matching, with no support for regexps. Use the
    option case=0 for case-insensitive matching."""

    # This is pretty crude. At least it should implement copying only references
    # to the original data in case it's big. Now it copies the data for output.
    out=[]
    if case:
        for term in list:
            if term.find(pat)&gt;-1: out.append(term)
    else:
        lpat=pat.lower()
        for term in list:
            if term.lower().find(lpat)&gt;-1: out.append(term)

    if len(out): return out
    else: return None

</t>
<t tx="ekr.20071201085751.209">#----------------------------------------------------------------------------
def dgrep(pat,*opts):
    """Return grep() on dir()+dir(__builtins__).

    A very common use of grep() when working interactively."""

    return grep(pat,dir(__main__)+dir(__main__.__builtins__),*opts)

</t>
<t tx="ekr.20071201085751.210">#----------------------------------------------------------------------------
def idgrep(pat):
    """Case-insensitive dgrep()"""

    return dgrep(pat,0)

</t>
<t tx="ekr.20071201085751.211">#----------------------------------------------------------------------------
def igrep(pat,list):
    """Synonym for case-insensitive grep."""

    return grep(pat,list,case=0)

</t>
<t tx="ekr.20071201085751.212">#----------------------------------------------------------------------------
def indent(str,nspaces=4,ntabs=0):
    """Indent a string a given number of spaces or tabstops.
    
    indent(str,nspaces=4,ntabs=0) -&gt; indent str by ntabs+nspaces.
    """
    if str is None:
        return
    ind = '\t'*ntabs+' '*nspaces
    outstr = '%s%s' % (ind,str.replace(os.linesep,os.linesep+ind))
    if outstr.endswith(os.linesep+ind):
        return outstr[:-len(ind)]
    else:
        return outstr
    
</t>
<t tx="ekr.20071201085751.213">#-----------------------------------------------------------------------------
def native_line_ends(filename,backup=1):
    """Convert (in-place) a file to line-ends native to the current OS.

    If the optional backup argument is given as false, no backup of the
    original file is left.  """

    backup_suffixes = {'posix':'~','dos':'.bak','nt':'.bak','mac':'.bak'}

    bak_filename = filename + backup_suffixes[os.name]

    original = open(filename).read()
    shutil.copy2(filename,bak_filename)
    try:
        new = open(filename,'wb')
        new.write(os.linesep.join(original.splitlines()))
        new.write(os.linesep) # ALWAYS put an eol at the end of the file
        new.close()
    except:
        os.rename(bak_filename,filename)
    if not backup:
        try:
            os.remove(bak_filename)
        except:
            pass
    
</t>
<t tx="ekr.20071201085751.214">#----------------------------------------------------------------------------
def get_pager_cmd(pager_cmd = None):
    """Return a pager command.

    Makes some attempts at finding an OS-correct one."""
    
    if os.name == 'posix':
        default_pager_cmd = 'less -r'  # -r for color control sequences
    elif os.name in ['nt','dos']:
        default_pager_cmd = 'type'

    if pager_cmd is None:
        try:
            pager_cmd = os.environ['PAGER']
        except:
            pager_cmd = default_pager_cmd
    return pager_cmd

</t>
<t tx="ekr.20071201085751.215">#-----------------------------------------------------------------------------
def get_pager_start(pager,start):
    """Return the string for paging files with an offset.

    This is the '+N' argument which less and more (under Unix) accept.
    """

    if pager in ['less','more']:
        if start:
            start_string = '+' + str(start)
        else:
            start_string = ''
    else:
        start_string = ''
    return start_string

</t>
<t tx="ekr.20071201085751.216">#----------------------------------------------------------------------------
if os.name == "nt":
    import msvcrt
    def page_more():
        """ Smart pausing between pages

        @return:    True if need print more lines, False if quit
        """
        Term.cout.write('---Return to continue, q to quit--- ')
        ans = msvcrt.getch()
        if ans in ("q", "Q"):
            result = False
        else:
            result = True
        Term.cout.write("\b"*37 + " "*37 + "\b"*37)
        return result
else:
    def page_more():
        ans = raw_input('---Return to continue, q to quit--- ')
        if ans.lower().startswith('q'):
            return False
        else:
            return True

esc_re = re.compile(r"(\x1b[^m]+m)")

def page_dumb(strng,start=0,screen_lines=25):
    """Very dumb 'pager' in Python, for when nothing else works.

    Only moves forward, same interface as page(), except for pager_cmd and
    mode."""

    out_ln  = strng.splitlines()[start:]
    screens = chop(out_ln,screen_lines-1)
    if len(screens) == 1:
        print &gt;&gt;Term.cout, os.linesep.join(screens[0])
    else:
        last_escape = ""
        for scr in screens[0:-1]:
            hunk = os.linesep.join(scr)
            print &gt;&gt;Term.cout, last_escape + hunk
            if not page_more():
                return
            esc_list = esc_re.findall(hunk)
            if len(esc_list) &gt; 0:
                last_escape = esc_list[-1]
        print &gt;&gt;Term.cout, last_escape + os.linesep.join(screens[-1])

</t>
<t tx="ekr.20071201085751.217">#----------------------------------------------------------------------------
def page(strng,start=0,screen_lines=0,pager_cmd = None):
    """Print a string, piping through a pager after a certain length.

    The screen_lines parameter specifies the number of *usable* lines of your
    terminal screen (total lines minus lines you need to reserve to show other
    information).

    If you set screen_lines to a number &lt;=0, page() will try to auto-determine
    your screen size and will only use up to (screen_size+screen_lines) for
    printing, paging after that. That is, if you want auto-detection but need
    to reserve the bottom 3 lines of the screen, use screen_lines = -3, and for
    auto-detection without any lines reserved simply use screen_lines = 0.

    If a string won't fit in the allowed lines, it is sent through the
    specified pager command. If none given, look for PAGER in the environment,
    and ultimately default to less.

    If no system pager works, the string is sent through a 'dumb pager'
    written in python, very simplistic.
    """
    
    # Ugly kludge, but calling curses.initscr() flat out crashes in emacs
    TERM = os.environ.get('TERM','dumb')
    if TERM in ['dumb','emacs'] and os.name != 'nt':
        print strng
        return
    # chop off the topmost part of the string we don't want to see
    str_lines = strng.split(os.linesep)[start:]
    str_toprint = os.linesep.join(str_lines)
    num_newlines = len(str_lines)
    len_str = len(str_toprint)
    
    # Dumb heuristics to guesstimate number of on-screen lines the string
    # takes.  Very basic, but good enough for docstrings in reasonable
    # terminals. If someone later feels like refining it, it's not hard.
    numlines = max(num_newlines,int(len_str/80)+1)

    if os.name == "nt":
        screen_lines_def = get_console_size(defaulty=25)[1]
    else:
        screen_lines_def = 25 # default value if we can't auto-determine

    # auto-determine screen size
    if screen_lines &lt;= 0:
        if TERM=='xterm':
            try:
                import curses
                if hasattr(curses,'initscr'):
                    use_curses = 1
                else:
                    use_curses = 0
            except ImportError:
                use_curses = 0
        else:
            # curses causes problems on many terminals other than xterm.
            use_curses = 0
        if use_curses:
                scr = curses.initscr()
                screen_lines_real,screen_cols = scr.getmaxyx()
                curses.endwin()
                screen_lines += screen_lines_real
                #print '***Screen size:',screen_lines_real,'lines x',\
                #screen_cols,'columns.' # dbg
        else:
                screen_lines += screen_lines_def

    #print 'numlines',numlines,'screenlines',screen_lines  # dbg
    if numlines &lt;= screen_lines :
        #print '*** normal print'  # dbg
        print &gt;&gt;Term.cout, str_toprint
    else:
        # Try to open pager and default to internal one if that fails.
        # All failure modes are tagged as 'retval=1', to match the return
        # value of a failed system command.  If any intermediate attempt
        # sets retval to 1, at the end we resort to our own page_dumb() pager.
        pager_cmd = get_pager_cmd(pager_cmd)
        pager_cmd += ' ' + get_pager_start(pager_cmd,start)
        if os.name == 'nt':
            if pager_cmd.startswith('type'):
                # The default WinXP 'type' command is failing on complex strings.
                retval = 1
            else:
                tmpname = tempfile.mktemp('.txt')
                tmpfile = file(tmpname,'wt')
                tmpfile.write(strng)
                tmpfile.close()
                cmd = "%s &lt; %s" % (pager_cmd,tmpname)
                if os.system(cmd):
                  retval = 1
                else:
                  retval = None
                os.remove(tmpname)
        else:
            try:
                retval = None
                # if I use popen4, things hang. No idea why.
                #pager,shell_out = os.popen4(pager_cmd)
                pager = os.popen(pager_cmd,'w')
                pager.write(strng)
                pager.close()
                retval = pager.close()  # success returns None
            except IOError,msg:  # broken pipe when user quits
                if msg.args == (32,'Broken pipe'):
                    retval = None
                else:
                    retval = 1
            except OSError:
                # Other strange problems, sometimes seen in Win2k/cygwin
                retval = 1
        if retval is not None:
            page_dumb(strng,screen_lines=screen_lines)

</t>
<t tx="ekr.20071201085751.218">#----------------------------------------------------------------------------
def page_file(fname,start = 0, pager_cmd = None):
    """Page a file, using an optional pager command and starting line.
    """

    pager_cmd = get_pager_cmd(pager_cmd)
    pager_cmd += ' ' + get_pager_start(pager_cmd,start)

    try:
        if os.environ['TERM'] in ['emacs','dumb']:
            raise EnvironmentError
        xsys(pager_cmd + ' ' + fname)
    except:
        try:
            if start &gt; 0:
                start -= 1
            page(open(fname).read(),start)
        except:
            print 'Unable to show file',`fname`

</t>
<t tx="ekr.20071201085751.219">#----------------------------------------------------------------------------
def snip_print(str,width = 75,print_full = 0,header = ''):
    """Print a string snipping the midsection to fit in width.

    print_full: mode control:
      - 0: only snip long strings
      - 1: send to page() directly.
      - 2: snip long strings and ask for full length viewing with page()
    Return 1 if snipping was necessary, 0 otherwise."""

    if print_full == 1:
        page(header+str)
        return 0

    print header,
    if len(str) &lt; width:
        print str
        snip = 0
    else:
        whalf = int((width -5)/2)
        print str[:whalf] + ' &lt;...&gt; ' + str[-whalf:]
        snip = 1
    if snip and print_full == 2:
        if raw_input(header+' Snipped. View (y/n)? [N]').lower() == 'y':
            page(str)
    return snip

</t>
<t tx="ekr.20071201085751.220">#****************************************************************************
# lists, dicts and structures

def belong(candidates,checklist):
    """Check whether a list of items appear in a given list of options.

    Returns a list of 1 and 0, one for each candidate given."""

    return [x in checklist for x in candidates]

</t>
<t tx="ekr.20071201085751.221">#----------------------------------------------------------------------------
def uniq_stable(elems):
    """uniq_stable(elems) -&gt; list

    Return from an iterable, a list of all the unique elements in the input,
    but maintaining the order in which they first appear.

    A naive solution to this problem which just makes a dictionary with the
    elements as keys fails to respect the stability condition, since
    dictionaries are unsorted by nature.

    Note: All elements in the input must be valid dictionary keys for this
    routine to work, as it internally uses a dictionary for efficiency
    reasons."""
    
    unique = []
    unique_dict = {}
    for nn in elems:
        if nn not in unique_dict:
            unique.append(nn)
            unique_dict[nn] = None
    return unique

</t>
<t tx="ekr.20071201085751.222">#----------------------------------------------------------------------------
class NLprinter:
    """Print an arbitrarily nested list, indicating index numbers.

    An instance of this class called nlprint is available and callable as a
    function.
    
    nlprint(list,indent=' ',sep=': ') -&gt; prints indenting each level by 'indent'
    and using 'sep' to separate the index from the value. """
    @others
</t>
<t tx="ekr.20071201085751.223">
def __init__(self):
    self.depth = 0

</t>
<t tx="ekr.20071201085751.224">def __call__(self,lst,pos='',**kw):
    """Prints the nested list numbering levels."""
    kw.setdefault('indent',' ')
    kw.setdefault('sep',': ')
    kw.setdefault('start',0)
    kw.setdefault('stop',len(lst))
    # we need to remove start and stop from kw so they don't propagate
    # into a recursive call for a nested list.
    start = kw['start']; del kw['start']
    stop = kw['stop']; del kw['stop']
    if self.depth == 0 and 'header' in kw.keys():
        print kw['header']
        
    for idx in range(start,stop):
        elem = lst[idx]
        if type(elem)==type([]):
            self.depth += 1
            self.__call__(elem,itpl('$pos$idx,'),**kw)
            self.depth -= 1
        else:
            printpl(kw['indent']*self.depth+'$pos$idx$kw["sep"]$elem')

</t>
<t tx="ekr.20071201085751.225">nlprint = NLprinter()
#----------------------------------------------------------------------------
def all_belong(candidates,checklist):
    """Check whether a list of items ALL appear in a given list of options.

    Returns a single 1 or 0 value."""

    return 1-(0 in [x in checklist for x in candidates])

</t>
<t tx="ekr.20071201085751.226">#----------------------------------------------------------------------------
def sort_compare(lst1,lst2,inplace = 1):
    """Sort and compare two lists.

    By default it does it in place, thus modifying the lists. Use inplace = 0
    to avoid that (at the cost of temporary copy creation)."""
    if not inplace:
        lst1 = lst1[:]
        lst2 = lst2[:]
    lst1.sort(); lst2.sort()
    return lst1 == lst2

</t>
<t tx="ekr.20071201085751.227">#----------------------------------------------------------------------------
def mkdict(**kwargs):
    """Return a dict from a keyword list.

    It's just syntactic sugar for making ditcionary creation more convenient:
    # the standard way
    &gt;&gt;&gt;data = { 'red' : 1, 'green' : 2, 'blue' : 3 }
    # a cleaner way
    &gt;&gt;&gt;data = dict(red=1, green=2, blue=3)

    If you need more than this, look at the Struct() class."""

    return kwargs

</t>
<t tx="ekr.20071201085751.228">#----------------------------------------------------------------------------
def list2dict(lst):
    """Takes a list of (key,value) pairs and turns it into a dict."""

    dic = {}
    for k,v in lst: dic[k] = v
    return dic

</t>
<t tx="ekr.20071201085751.229">#----------------------------------------------------------------------------
def list2dict2(lst,default=''):
    """Takes a list and turns it into a dict.
    Much slower than list2dict, but more versatile. This version can take
    lists with sublists of arbitrary length (including sclars)."""

    dic = {}
    for elem in lst:
        if type(elem) in (types.ListType,types.TupleType):
            size = len(elem)
            if  size == 0:
                pass
            elif size == 1:
                dic[elem] = default
            else:
                k,v = elem[0], elem[1:]
                if len(v) == 1: v = v[0]
                dic[k] = v
        else:
            dic[elem] = default
    return dic

</t>
<t tx="ekr.20071201085751.230">#----------------------------------------------------------------------------
def flatten(seq):
    """Flatten a list of lists (NOT recursive, only works for 2d lists)."""

    return [x for subseq in seq for x in subseq]

</t>
<t tx="ekr.20071201085751.231">#----------------------------------------------------------------------------
def get_slice(seq,start=0,stop=None,step=1):
    """Get a slice of a sequence with variable step. Specify start,stop,step."""
    if stop == None:
        stop = len(seq)
    item = lambda i: seq[i]
    return map(item,xrange(start,stop,step))

</t>
<t tx="ekr.20071201085751.232">#----------------------------------------------------------------------------
def chop(seq,size):
    """Chop a sequence into chunks of the given size."""
    chunk = lambda i: seq[i:i+size]
    return map(chunk,xrange(0,len(seq),size))

</t>
<t tx="ekr.20071201085751.233">#----------------------------------------------------------------------------
# with is a keyword as of python 2.5, so this function is renamed to withobj
# from its old 'with' name.
def with_obj(object, **args):
    """Set multiple attributes for an object, similar to Pascal's with.

    Example:
    with_obj(jim,
             born = 1960,
             haircolour = 'Brown',
             eyecolour = 'Green')

    Credit: Greg Ewing, in
    http://mail.python.org/pipermail/python-list/2001-May/040703.html.

    NOTE: up until IPython 0.7.2, this was called simply 'with', but 'with'
    has become a keyword for Python 2.5, so we had to rename it."""

    object.__dict__.update(args)

</t>
<t tx="ekr.20071201085751.234">#----------------------------------------------------------------------------
def setattr_list(obj,alist,nspace = None):
    """Set a list of attributes for an object taken from a namespace.

    setattr_list(obj,alist,nspace) -&gt; sets in obj all the attributes listed in
    alist with their values taken from nspace, which must be a dict (something
    like locals() will often do) If nspace isn't given, locals() of the
    *caller* is used, so in most cases you can omit it.

    Note that alist can be given as a string, which will be automatically
    split into a list on whitespace. If given as a list, it must be a list of
    *strings* (the variable names themselves), not of variables."""

    # this grabs the local variables from the *previous* call frame -- that is
    # the locals from the function that called setattr_list().
    # - snipped from weave.inline()
    if nspace is None:
        call_frame = sys._getframe().f_back
        nspace = call_frame.f_locals

    if type(alist) in StringTypes:
        alist = alist.split()
    for attr in alist:
        val = eval(attr,nspace)
        setattr(obj,attr,val)

</t>
<t tx="ekr.20071201085751.235">#----------------------------------------------------------------------------
def getattr_list(obj,alist,*args):
    """getattr_list(obj,alist[, default]) -&gt; attribute list.

    Get a list of named attributes for an object. When a default argument is
    given, it is returned when the attribute doesn't exist; without it, an
    exception is raised in that case.

    Note that alist can be given as a string, which will be automatically
    split into a list on whitespace. If given as a list, it must be a list of
    *strings* (the variable names themselves), not of variables."""

    if type(alist) in StringTypes:
        alist = alist.split()
    if args:
        if len(args)==1:
            default = args[0]
            return map(lambda attr: getattr(obj,attr,default),alist)
        else:
            raise ValueError,'getattr_list() takes only one optional argument'
    else:
        return map(lambda attr: getattr(obj,attr),alist)
    
</t>
<t tx="ekr.20071201085751.236">#----------------------------------------------------------------------------
def map_method(method,object_list,*argseq,**kw):
    """map_method(method,object_list,*args,**kw) -&gt; list

    Return a list of the results of applying the methods to the items of the
    argument sequence(s).  If more than one sequence is given, the method is
    called with an argument list consisting of the corresponding item of each
    sequence. All sequences must be of the same length.

    Keyword arguments are passed verbatim to all objects called.

    This is Python code, so it's not nearly as fast as the builtin map()."""

    out_list = []
    idx = 0
    for object in object_list:
        try:
            handler = getattr(object, method)
        except AttributeError:
            out_list.append(None)
        else:
            if argseq:
                args = map(lambda lst:lst[idx],argseq)
                #print 'ob',object,'hand',handler,'ar',args # dbg
                out_list.append(handler(args,**kw))
            else:
                out_list.append(handler(**kw))
        idx += 1
    return out_list

</t>
<t tx="ekr.20071201085751.237">#----------------------------------------------------------------------------
def import_fail_info(mod_name,fns=None):
    """Inform load failure for a module."""

    if fns == None:
        warn("Loading of %s failed.\n" % (mod_name,))
    else:
        warn("Loading of %s from %s failed.\n" % (fns,mod_name))

</t>
<t tx="ekr.20071201085751.238">#----------------------------------------------------------------------------
# Proposed popitem() extension, written as a method


class NotGiven: pass

</t>
<t tx="ekr.20071201085751.239">def popkey(dct,key,default=NotGiven):
    """Return dct[key] and delete dct[key].

    If default is given, return it if dct[key] doesn't exist, otherwise raise
    KeyError.  """

    try:
        val = dct[key]
    except KeyError:
        if default is NotGiven:
            raise
        else:
            return default
    else:
        del dct[key]
        return val

</t>
<t tx="ekr.20071201085751.240">def wrap_deprecated(func, suggest = '&lt;nothing&gt;'):
    def newFunc(*args, **kwargs):
        warnings.warn("Call to deprecated function %s, use %s instead" % 
                      ( func.__name__, suggest),
                      category=DeprecationWarning,
                      stacklevel = 2)
        return func(*args, **kwargs)
    return newFunc
    
</t>
<t tx="ekr.20071201085751.241"># -*- coding: utf-8 -*-
"""Improved replacement for the Gnuplot.Gnuplot class.

This module imports Gnuplot and replaces some of its functionality with
improved versions. They add better handling of arrays for plotting and more
convenient PostScript generation, plus some fixes for hardcopy().

It also adds a convenient plot2 method for plotting dictionaries and
lists/tuples of arrays.

This module is meant to be used as a drop-in replacement to the original
Gnuplot, so it should be safe to do:

import IPython.Gnuplot2 as Gnuplot

$Id$"""

import cStringIO
import os
import string
import sys
import tempfile
import time
import types

import Gnuplot as Gnuplot_ori
import Numeric

from IPython.genutils import popkey,xsys

# needed by hardcopy():
gp = Gnuplot_ori.gp

# Patch for Gnuplot.py 1.6 compatibility.
# Thanks to Hayden Callow &lt;h.callow@elec.canterbury.ac.nz&gt;
try:
    OptionException = Gnuplot_ori.PlotItems.OptionException
except AttributeError:
    OptionException = Gnuplot_ori.Errors.OptionError

# exhibit a similar interface to Gnuplot so it can be somewhat drop-in
Data      = Gnuplot_ori.Data
Func      = Gnuplot_ori.Func
GridData  = Gnuplot_ori.GridData
PlotItem  = Gnuplot_ori.PlotItem
PlotItems = Gnuplot_ori.PlotItems

# Modify some of Gnuplot's functions with improved versions (or bugfixed, in
# hardcopy's case). In order to preserve the docstrings at runtime, I've
# copied them from the original code.

# After some significant changes in v 1.7 of Gnuplot.py, we need to do a bit
# of version checking.

if Gnuplot_ori.__version__ &lt;= '1.6':
    _BaseFileItem = PlotItems.File
    _BaseTempFileItem = PlotItems.TempFile

    # Fix the File class to add the 'index' option for Gnuplot versions &lt; 1.7
    class File(_BaseFileItem):

        _option_list = _BaseFileItem._option_list.copy()
        _option_list.update({
            'index' : lambda self, index: self.set_option_index(index),
            })

        # A new initializer is needed b/c we want to add a modified
        # _option_sequence list which includes 'index' in the right place.
        def __init__(self,*args,**kw):
            self._option_sequence = ['binary', 'index', 'using', 'smooth', 'axes',
                         'title', 'with']

            _BaseFileItem.__init__(self,*args,**kw)

        # Let's fix the constructor docstring
        __newdoc = \
            """Additional Keyword arguments added by IPython:

             'index=&lt;int&gt;' -- similar to the `index` keyword in Gnuplot.
                 This allows only some of the datasets in a file to be
                 plotted. Datasets within a file are assumed to be separated
                 by _pairs_ of blank lines, and the first one is numbered as
                 0 (similar to C/Python usage)."""
        __init__.__doc__ = PlotItems.File.__init__.__doc__ + __newdoc

        def set_option_index(self, index):
            if index is None:
                self.clear_option('index')
            elif type(index) in [type(''), type(1)]:
                self._options['index'] = (index, 'index %s' % index)
            elif type(index) is type(()):
                self._options['index'] = (index,'index %s' %
                                          string.join(map(repr, index), ':'))
            else:
                raise OptionException('index=%s' % (index,))

    # We need a FileClass with a different name from 'File', which is a
    # factory function in 1.7, so that our String class can subclass FileClass
    # in any version.
    _FileClass = File

elif Gnuplot_ori.__version__ =='1.7':
    _FileClass = _BaseFileItem = PlotItems._FileItem
    _BaseTempFileItem = PlotItems._TempFileItem
    File = PlotItems.File

else:  # changes in the newer version (svn as of March'06)
     _FileClass = _BaseFileItem = PlotItems._FileItem
     _BaseTempFileItem = PlotItems._NewFileItem
     File = PlotItems.File


</t>
<t tx="ekr.20071201085751.242"># Now, we can add our generic code which is version independent

# First some useful utilities
def eps_fix_bbox(fname):
    """Fix the bounding box of an eps file by running ps2eps on it.

    If its name ends in .eps, the original file is removed.

    This is particularly useful for plots made by Gnuplot with square aspect
    ratio: there is a bug in Gnuplot which makes it generate a bounding box
    which is far wider than the actual plot.

    This function assumes that ps2eps is installed in your system."""

    # note: ps2ps and eps2eps do NOT work, ONLY ps2eps works correctly. The
    # others make output with bitmapped fonts, which looks horrible.
    print 'Fixing eps file: &lt;%s&gt;' % fname
    xsys('ps2eps -f -q -l %s' % fname)
    if fname.endswith('.eps'):
        os.rename(fname+'.eps',fname)

</t>
<t tx="ekr.20071201085751.243">def is_list1d(x,containers = [types.ListType,types.TupleType]):
    """Returns true if x appears to be a 1d list/tuple/array.

    The heuristics are: identify Numeric arrays, or lists/tuples whose first
    element is not itself a list/tuple. This way zipped lists should work like
    the original Gnuplot. There's no inexpensive way to know if a list doesn't
    have a composite object after its first element, so that kind of input
    will produce an error. But it should work well in most cases.
    """
    x_type = type(x)

    return x_type == Numeric.ArrayType and len(x.shape)==1 or \
           (x_type in containers and
            type(x[0]) not in containers + [Numeric.ArrayType])

</t>
<t tx="ekr.20071201085751.244">def zip_items(items,titles=None):
    """zip together neighboring 1-d arrays, and zip standalone ones
    with their index. Leave other plot items alone."""

    class StandaloneItem(Exception): pass
    
    def get_titles(titles):
        """Return the next title and the input titles array.

        The input array may be changed to None when no titles are left to
        prevent extra unnecessary calls to this function."""
        
        try:
            title = titles[tit_ct[0]]  # tit_ct[0] is in zip_items'scope
        except IndexError:
            titles = None # so we don't enter again
            title = None
        else:
            tit_ct[0] += 1
        return title,titles

    new_items = []

    if titles:
        # Initialize counter. It was put in a list as a hack to allow the
        # nested get_titles to modify it without raising a NameError.
        tit_ct = [0]

    n = 0  # this loop needs to be done by hand
    while n &lt; len(items):
        item = items[n]
        try:
            if is_list1d(item):
                if n==len(items)-1: # last in list
                    raise StandaloneItem
                else: # check the next item and zip together if needed
                    next_item = items[n+1]
                    if next_item is None:
                        n += 1
                        raise StandaloneItem
                    elif is_list1d(next_item):
                        # this would be best done with an iterator
                        if titles:
                            title,titles = get_titles(titles)
                        else:
                            title = None
                        new_items.append(Data(zip(item,next_item),
                                              title=title))
                        n += 1  # avoid double-inclusion of next item
                    else: # can't zip with next, zip with own index list
                        raise StandaloneItem
            else:  # not 1-d array
                new_items.append(item)
        except StandaloneItem:
            if titles:
                title,titles = get_titles(titles)
            else:
                title = None
            new_items.append(Data(zip(range(len(item)),item),title=title))
        except AttributeError:
            new_items.append(item)
        n+=1

    return new_items

</t>
<t tx="ekr.20071201085751.245"># And some classes with enhanced functionality.
class String(_FileClass):
    """Make a PlotItem from data in a string with the same format as a File.

    This allows writing data directly inside python scripts using the exact
    same format and manipulation options which would be used for external
    files."""
    @others
</t>
<t tx="ekr.20071201085751.246">
def __init__(self, data_str, **keyw):
    """Construct a String object.

    &lt;data_str&gt; is a string formatted exactly like a valid Gnuplot data
    file would be. All options from the File constructor are valid here.

    Warning: when used for interactive plotting in scripts which exit
    immediately, you may get an error because the temporary file used to
    hold the string data was deleted before Gnuplot had a chance to see
    it. You can work around this problem by putting a raw_input() call at
    the end of the script.

    This problem does not appear when generating PostScript output, only
    with Gnuplot windows."""

    self.tmpfile = _BaseTempFileItem()
    tmpfile = file(self.tmpfile.filename,'w')
    tmpfile.write(data_str)
    _BaseFileItem.__init__(self,self.tmpfile,**keyw)


</t>
<t tx="ekr.20071201085751.247">class Gnuplot(Gnuplot_ori.Gnuplot):
    """Improved Gnuplot class.

    Enhancements: better plot,replot and hardcopy methods. New methods for
    quick range setting.
    """
    @others
</t>
<t tx="ekr.20071201085751.248">
def xrange(self,min='*',max='*'):
    """Set xrange. If min/max is omitted, it is set to '*' (auto).

    Note that this is different from the regular Gnuplot behavior, where
    an unspecified limit means no change. Here any unspecified limit is
    set to autoscaling, allowing these functions to be used for full
    autoscaling when called with no arguments.

    To preserve one limit's current value while changing the other, an
    explicit '' argument must be given as the limit to be kept.

    Similar functions exist for [y{2}z{2}rtuv]range."""
    
    self('set xrange [%s:%s]' % (min,max))
         
</t>
<t tx="ekr.20071201085751.249">def yrange(self,min='*',max='*'):
    self('set yrange [%s:%s]' % (min,max))
         
</t>
<t tx="ekr.20071201085751.250">def zrange(self,min='*',max='*'):
    self('set zrange [%s:%s]' % (min,max))
         
</t>
<t tx="ekr.20071201085751.251">def x2range(self,min='*',max='*'):
    self('set xrange [%s:%s]' % (min,max))
         
</t>
<t tx="ekr.20071201085751.252">def y2range(self,min='*',max='*'):
    self('set yrange [%s:%s]' % (min,max))
         
</t>
<t tx="ekr.20071201085751.253">def z2range(self,min='*',max='*'):
    self('set zrange [%s:%s]' % (min,max))
         
</t>
<t tx="ekr.20071201085751.254">def rrange(self,min='*',max='*'):
    self('set rrange [%s:%s]' % (min,max))
         
</t>
<t tx="ekr.20071201085751.255">def trange(self,min='*',max='*'):
    self('set trange [%s:%s]' % (min,max))
         
</t>
<t tx="ekr.20071201085751.256">def urange(self,min='*',max='*'):
    self('set urange [%s:%s]' % (min,max))
         
</t>
<t tx="ekr.20071201085751.257">def vrange(self,min='*',max='*'):
    self('set vrange [%s:%s]' % (min,max))

</t>
<t tx="ekr.20071201085751.258">def set_ps(self,option):
    """Set an option for the PostScript terminal and reset default term."""

    self('set terminal postscript %s ' % option)
    self('set terminal %s' % gp.GnuplotOpts.default_term)

</t>
<t tx="ekr.20071201085751.259">def __plot_ps(self, plot_method,*items, **keyw):
    """Wrapper for plot/splot/replot, with processing of hardcopy options.

    For internal use only."""

    # Filter out PostScript options which will crash the normal plot/replot
    psargs = {'filename':None,
              'mode':None,
              'eps':None,
              'enhanced':None,
              'color':None,
              'solid':None,
              'duplexing':None,
              'fontname':None,
              'fontsize':None,
              'debug':0 }

    for k in psargs.keys():
        if keyw.has_key(k):
            psargs[k] = keyw[k]
            del keyw[k]

    # Filter out other options the original plot doesn't know
    hardcopy = popkey(keyw,'hardcopy',psargs['filename'] is not None)
    titles = popkey(keyw,'titles',0)
    
    # the filename keyword should control hardcopy generation, this is an
    # override switch only which needs to be explicitly set to zero
    if hardcopy:
        if psargs['filename'] is None:
            raise ValueError, \
                  'If you request hardcopy, you must give a filename.'

        # set null output so nothing goes to screen. hardcopy() restores output
        self('set term dumb')
        # I don't know how to prevent screen output in Windows
        if os.name == 'posix':
            self('set output "/dev/null"')

    new_items = zip_items(items,titles)
    # plot_method is either plot or replot from the original Gnuplot class:
    plot_method(self,*new_items,**keyw)

    # Do hardcopy if requested
    if hardcopy:
        if psargs['filename'].endswith('.eps'):
            psargs['eps'] = 1
        self.hardcopy(**psargs)

</t>
<t tx="ekr.20071201085751.260">def plot(self, *items, **keyw):
    """Draw a new plot.

    Clear the current plot and create a new 2-d plot containing
    the specified items.  Each arguments should be of the
    following types:

    'PlotItem' (e.g., 'Data', 'File', 'Func') -- This is the most
        flexible way to call plot because the PlotItems can
        contain suboptions.  Moreover, PlotItems can be saved to
        variables so that their lifetime is longer than one plot
        command; thus they can be replotted with minimal overhead.

    'string' (e.g., 'sin(x)') -- The string is interpreted as
        'Func(string)' (a function that is computed by gnuplot).

    Anything else -- The object, which should be convertible to an
        array, is passed to the 'Data' constructor, and thus
        plotted as data.  If the conversion fails, an exception is
        raised.


    This is a modified version of plot(). Compared to the original in
    Gnuplot.py, this version has several enhancements, listed below.


    Modifications to the input arguments
    ------------------------------------

    (1-d array means Numeric array, list or tuple):

    (i) Any 1-d array which is NOT followed by another 1-d array, is
    automatically zipped with range(len(array_1d)). Typing g.plot(y) will
    plot y against its indices.

    (ii) If two 1-d arrays are contiguous in the argument list, they are
    automatically zipped together. So g.plot(x,y) plots y vs. x, and
    g.plot(x1,y1,x2,y2) plots y1 vs. x1 and y2 vs. x2.

    (iii) Any 1-d array which is followed by None is automatically zipped
    with range(len(array_1d)). In this form, typing g.plot(y1,None,y2)
    will plot both y1 and y2 against their respective indices (and NOT
    versus one another). The None prevents zipping y1 and y2 together, and
    since y2 is unpaired it is automatically zipped to its indices by (i)

    (iv) Any other arguments which don't match these cases are left alone and
    passed to the code below.

    For lists or tuples, the heuristics used to determine whether they are
    in fact 1-d is fairly simplistic: their first element is checked, and
    if it is not a list or tuple itself, it is assumed that the whole
    object is one-dimensional.

    An additional optional keyword 'titles' has been added: it must be a
    list of strings to be used as labels for the individual plots which
    are NOT PlotItem objects (since those objects carry their own labels
    within).


    PostScript generation
    ---------------------

    This version of plot() also handles automatically the production of
    PostScript output. The main options are (given as keyword arguments):

    - filename: a string, typically ending in .eps. If given, the plot is
    sent to this file in PostScript format.
    
    - hardcopy: this can be set to 0 to override 'filename'. It does not
    need to be given to produce PostScript, its purpose is to allow
    switching PostScript output off globally in scripts without having to
    manually change 'filename' values in multiple calls.

    All other keywords accepted by Gnuplot.hardcopy() are transparently
    passed, and safely ignored if output is sent to the screen instead of
    PostScript.

    For example:
    
    In [1]: x=frange(0,2*pi,npts=100)

    Generate a plot in file 'sin.eps':

    In [2]: plot(x,sin(x),filename = 'sin.eps')

    Plot to screen instead, without having to change the filename:

    In [3]: plot(x,sin(x),filename = 'sin.eps',hardcopy=0)

    Pass the 'color=0' option to hardcopy for monochrome output:

    In [4]: plot(x,sin(x),filename = 'sin.eps',color=0)

    PostScript generation through plot() is useful mainly for scripting
    uses where you are not interested in interactive plotting. For
    interactive use, the hardcopy() function is typically more convenient:
    
    In [5]: plot(x,sin(x))

    In [6]: hardcopy('sin.eps')  """
    
    self.__plot_ps(Gnuplot_ori.Gnuplot.plot,*items,**keyw)
    
</t>
<t tx="ekr.20071201085751.261">def plot2(self,arg,**kw):
    """Plot the entries of a dictionary or a list/tuple of arrays.        
    
    This simple utility calls plot() with a list of Gnuplot.Data objects
    constructed either from the values of the input dictionary, or the entries
    in it if it is a tuple or list.  Each item gets labeled with the key/index
    in the Gnuplot legend.

    Each item is plotted by zipping it with a list of its indices.

    Any keywords are passed directly to plot()."""

    if hasattr(arg,'keys'):
        keys = arg.keys()
        keys.sort()
    else:
        keys = range(len(arg))

    pitems = [Data(zip(range(len(arg[k])),arg[k]),title=`k`) for k in keys]
    self.plot(*pitems,**kw)

</t>
<t tx="ekr.20071201085751.262">def splot(self, *items, **keyw):
    """Draw a new three-dimensional plot.

    Clear the current plot and create a new 3-d plot containing
    the specified items.  Arguments can be of the following types:

    'PlotItem' (e.g., 'Data', 'File', 'Func', 'GridData' ) -- This
        is the most flexible way to call plot because the
        PlotItems can contain suboptions.  Moreover, PlotItems can
        be saved to variables so that their lifetime is longer
        than one plot command--thus they can be replotted with
        minimal overhead.

    'string' (e.g., 'sin(x*y)') -- The string is interpreted as a
        'Func()' (a function that is computed by gnuplot).

    Anything else -- The object is converted to a Data() item, and
        thus plotted as data.  Note that each data point should
        normally have at least three values associated with it
        (i.e., x, y, and z).  If the conversion fails, an
        exception is raised.

    This is a modified version of splot(). Compared to the original in
    Gnuplot.py, this version has several enhancements, listed in the
    plot() documentation.
    """
    
    self.__plot_ps(Gnuplot_ori.Gnuplot.splot,*items,**keyw)

</t>
<t tx="ekr.20071201085751.263">def replot(self, *items, **keyw):
    """Replot the data, possibly adding new 'PlotItem's.

    Replot the existing graph, using the items in the current
    itemlist.  If arguments are specified, they are interpreted as
    additional items to be plotted alongside the existing items on
    the same graph.  See 'plot' for details.

    If you want to replot to a postscript file, you MUST give the
    'filename' keyword argument in each call to replot. The Gnuplot python
    interface has no way of knowing that your previous call to
    Gnuplot.plot() was meant for PostScript output."""
    
    self.__plot_ps(Gnuplot_ori.Gnuplot.replot,*items,**keyw)

</t>
<t tx="ekr.20071201085751.264"># The original hardcopy has a bug. See fix at the end. The rest of the code
# was lifted verbatim from the original, so that people using IPython get the
# benefits without having to manually patch Gnuplot.py
def hardcopy(self, filename=None,
             mode=None,
             eps=None,
             enhanced=None,
             color=None,
             solid=None,
             duplexing=None,
             fontname=None,
             fontsize=None,
             debug = 0,
             ):
    """Create a hardcopy of the current plot.

    Create a postscript hardcopy of the current plot to the
    default printer (if configured) or to the specified filename.

    Note that gnuplot remembers the postscript suboptions across
    terminal changes.  Therefore if you set, for example, color=1
    for one hardcopy then the next hardcopy will also be color
    unless you explicitly choose color=0.  Alternately you can
    force all of the options to their defaults by setting
    mode='default'.  I consider this to be a bug in gnuplot.

    Keyword arguments:

      'filename=&lt;string&gt;' -- if a filename is specified, save the
          output in that file; otherwise print it immediately
          using the 'default_lpr' configuration option.  If the
          filename ends in '.eps', EPS mode is automatically
          selected (like manually specifying eps=1 or mode='eps').

      'mode=&lt;string&gt;' -- set the postscript submode ('landscape',
          'portrait', 'eps', or 'default').  The default is
          to leave this option unspecified.

      'eps=&lt;bool&gt;' -- shorthand for 'mode="eps"'; asks gnuplot to
          generate encapsulated postscript.

      'enhanced=&lt;bool&gt;' -- if set (the default), then generate
          enhanced postscript, which allows extra features like
          font-switching, superscripts, and subscripts in axis
          labels.  (Some old gnuplot versions do not support
          enhanced postscript; if this is the case set
          gp.GnuplotOpts.prefer_enhanced_postscript=None.)

      'color=&lt;bool&gt;' -- if set, create a plot with color.  Default
          is to leave this option unchanged.

      'solid=&lt;bool&gt;' -- if set, force lines to be solid (i.e., not
          dashed).

      'duplexing=&lt;string&gt;' -- set duplexing option ('defaultplex',
          'simplex', or 'duplex').  Only request double-sided
          printing if your printer can handle it.  Actually this
          option is probably meaningless since hardcopy() can only
          print a single plot at a time.

      'fontname=&lt;string&gt;' -- set the default font to &lt;string&gt;,
          which must be a valid postscript font.  The default is
          to leave this option unspecified.

      'fontsize=&lt;double&gt;' -- set the default font size, in
          postscript points.

      'debug=&lt;bool&gt;' -- print extra debugging information (useful if
          your PostScript files are misteriously not being created).
    """

    if filename is None:
        assert gp.GnuplotOpts.default_lpr is not None, \
               OptionException('default_lpr is not set, so you can only '
                               'print to a file.')
        filename = gp.GnuplotOpts.default_lpr
        lpr_output = 1
    else:
        if filename.endswith('.eps'):
            eps = 1
        lpr_output = 0

    # Be careful processing the options.  If the user didn't
    # request an option explicitly, do not specify it on the 'set
    # terminal' line (don't even specify the default value for the
    # option).  This is to avoid confusing older versions of
    # gnuplot that do not support all of these options.  The
    # exception is 'enhanced', which is just too useful to have to
    # specify each time!

    setterm = ['set', 'terminal', 'postscript']
    if eps:
        assert mode is None or mode=='eps', \
               OptionException('eps option and mode are incompatible')
        setterm.append('eps')
    else:
        if mode is not None:
            assert mode in ['landscape', 'portrait', 'eps', 'default'], \
                   OptionException('illegal mode "%s"' % mode)
            setterm.append(mode)
    if enhanced is None:
        enhanced = gp.GnuplotOpts.prefer_enhanced_postscript
    if enhanced is not None:
        if enhanced: setterm.append('enhanced')
        else: setterm.append('noenhanced')
    if color is not None:
        if color: setterm.append('color')
        else: setterm.append('monochrome')
    if solid is not None:
        if solid: setterm.append('solid')
        else: setterm.append('dashed')
    if duplexing is not None:
        assert duplexing in ['defaultplex', 'simplex', 'duplex'], \
               OptionException('illegal duplexing mode "%s"' % duplexing)
        setterm.append(duplexing)
    if fontname is not None:
        setterm.append('"%s"' % fontname)
    if fontsize is not None:
        setterm.append('%s' % fontsize)

    self(string.join(setterm))
    self.set_string('output', filename)
    # replot the current figure (to the printer):
    self.refresh()

    # fperez. Ugly kludge: often for some reason the file is NOT created
    # and we must reissue the creation commands. I have no idea why!
    if not lpr_output:
        #print 'Hardcopy &lt;%s&gt;' % filename  # dbg
        maxtries = 20
        delay = 0.1  # delay (in seconds) between print attempts
        for i in range(maxtries):
            time.sleep(0.05)  # safety, very small delay
            if os.path.isfile(filename):
                if debug:
                    print 'Hardcopy to file &lt;%s&gt; success at attempt #%s.' \
                    % (filename,i+1)
                break
            time.sleep(delay)
            # try again, issue all commands just in case
            self(string.join(setterm))
            self.set_string('output', filename)
            self.refresh()
        if not os.path.isfile(filename):
            print &gt;&gt; sys.stderr,'ERROR: Tried %s times and failed to '\
            'create hardcopy file `%s`' % (maxtries,filename)

    # reset the terminal to its `default' setting:
    self('set terminal %s' % gp.GnuplotOpts.default_term)
    self.set_string('output')

</t>
<t tx="ekr.20071201085751.265"># -*- coding: utf-8 -*-
"""Interactive functions and magic functions for Gnuplot usage.

This requires the Gnuplot.py module for interfacing python with Gnuplot, which
can be downloaded from:

http://gnuplot-py.sourceforge.net/

See gphelp() below for details on the services offered by this module.

Inspired by a suggestion/request from Arnd Baecker.

$Id$"""

__all__ = ['Gnuplot','gp','gp_new','plot','plot2','splot','replot',
           'hardcopy','gpdata','gpfile','gpstring','gpfunc','gpgrid',
           'gphelp']

import IPython.GnuplotRuntime as GRun
from IPython.genutils import page,warn

# Set global names for interactive use
Gnuplot  = GRun.Gnuplot
gp_new   = GRun.gp_new
gp       = GRun.gp
plot     = gp.plot
plot2    = gp.plot2
splot    = gp.splot
replot   = gp.replot
hardcopy = gp.hardcopy

# Accessors for the main plot object constructors:
gpdata   = Gnuplot.Data
gpfile   = Gnuplot.File
gpstring = Gnuplot.String
gpfunc   = Gnuplot.Func
gpgrid   = Gnuplot.GridData

</t>
<t tx="ekr.20071201085751.266">def gphelp():
    """Print information about the Gnuplot facilities in IPython."""

    page("""
IPython provides an interface to access the Gnuplot scientific plotting
system, in an environment similar to that of Mathematica or Matlab.

New top-level global objects
----------------------------

Please see their respective docstrings for further details.

- gp: a running Gnuplot instance. You can access its methods as
gp.&lt;method&gt;. gp(`a string`) will execute the given string as if it had been
typed in an interactive gnuplot window.

- plot, splot, replot and hardcopy: aliases to the methods of the same name in
the global running Gnuplot instance gp. These allow you to simply type:

In [1]: plot(x,sin(x),title='Sin(x)')  # assuming x is a Numeric array

and obtain a plot of sin(x) vs x with the title 'Sin(x)'.

- gp_new: a function which returns a new Gnuplot instance. This can be used to
have multiple Gnuplot instances running in your session to compare different
plots, each in a separate window.

- Gnuplot: alias to the Gnuplot2 module, an improved drop-in replacement for
the original Gnuplot.py. Gnuplot2 needs Gnuplot but redefines several of its
functions with improved versions (Gnuplot2 comes with IPython).

- gpdata, gpfile, gpstring, gpfunc, gpgrid: aliases to Gnuplot.Data,
Gnuplot.File, Gnuplot.String, Gnuplot.Func and Gnuplot.GridData
respectively. These functions create objects which can then be passed to the
plotting commands. See the Gnuplot.py documentation for details.

Keep in mind that all commands passed to a Gnuplot instance are executed in
the Gnuplot namespace, where no Python variables exist. For example, for
plotting sin(x) vs x as above, typing

In [2]: gp('plot x,sin(x)')

would not work. Instead, you would get the plot of BOTH the functions 'x' and
'sin(x)', since Gnuplot doesn't know about the 'x' Python array. The plot()
method lives in python and does know about these variables.


New magic functions
-------------------

%gpc: pass one command to Gnuplot and execute it or open a Gnuplot shell where
each line of input is executed.

%gp_set_default: reset the value of IPython's global Gnuplot instance.""")
    
</t>
<t tx="ekr.20071201085751.267"># Code below is all for IPython use
# Define the magic functions for communicating with the above gnuplot instance.
def magic_gpc(self,parameter_s=''):
    """Execute a gnuplot command or open a gnuplot shell.

    Usage (omit the % if automagic is on). There are two ways to use it:

      1) %gpc 'command' -&gt; passes 'command' directly to the gnuplot instance.

      2) %gpc -&gt; will open up a prompt (gnuplot&gt;&gt;&gt;) which takes input like the
      standard gnuplot interactive prompt. If you need to type a multi-line
      command, use \\ at the end of each intermediate line.

      Upon exiting of the gnuplot sub-shell, you return to your IPython
      session (the gnuplot sub-shell can be invoked as many times as needed).
      """

    if parameter_s.strip():
        self.shell.gnuplot(parameter_s)
    else:
        self.shell.gnuplot.interact()

</t>
<t tx="ekr.20071201085751.268">def magic_gp_set_default(self,parameter_s=''):
    """Set the default gnuplot instance accessed by the %gp magic function.

    %gp_set_default name

    Call with the name of the new instance at the command line. If you want to
    set this instance in your own code (using an embedded IPython, for
    example), simply set the variable __IPYTHON__.gnuplot to your own gnuplot
    instance object."""

    gname = parameter_s.strip()
    G = eval(gname,self.shell.user_ns)
    self.shell.gnuplot = G
    self.shell.user_ns.update({'plot':G.plot,'splot':G.splot,'plot2':G.plot2,
                               'replot':G.replot,'hardcopy':G.hardcopy})

</t>
<t tx="ekr.20071201085751.269"># -*- coding: utf-8 -*-
"""Basic Gnuplot functionality for inclusion in other code.

This module creates a running Gnuplot instance called 'gp' and builds other
convenient globals for quick use in running scripts. It is intended to allow
you to script plotting tasks in Python with a minimum of effort. A typical
usage would be:

import IPython.GnuplotRuntime as GP  # or some other short name
GP.gp.plot(GP.File('your_data.dat'))


This module exposes the following objects:

- gp: a running Gnuplot instance. You can access its methods as
gp.&lt;method&gt;. gp(`a string`) will execute the given string as if it had been
typed in an interactive gnuplot window.

- gp_new: a function which returns a new Gnuplot instance. This can be used to
have multiple Gnuplot instances running in your session to compare different
plots.

- Gnuplot: alias to the Gnuplot2 module, an improved drop-in replacement for
the original Gnuplot.py. Gnuplot2 needs Gnuplot but redefines several of its
functions with improved versions (Gnuplot2 comes with IPython).

- Data: alias to Gnuplot.Data, makes a PlotItem from array data.

- File: alias to Gnuplot.File, makes a PlotItem from a file.

- String: alias to Gnuplot.String, makes a PlotItem from a string formatted
exactly like a file for Gnuplot.File would be.

- Func: alias to Gnuplot.Func, makes a PlotItem from a function string.

- GridData: alias to Gnuplot.GridData, makes a PlotItem from grid data.

- pm3d_config: a string with Gnuplot commands to set up the pm3d mode for
surface plotting. You can activate it simply by calling gp(pm3d_config).

- eps_fix_bbox: A Unix-only function to fix eps files with bad bounding boxes
(which Gnuplot generates when the plot size is set to square).

This requires the Gnuplot.py module for interfacing Python with Gnuplot, which
can be downloaded from:

http://gnuplot-py.sourceforge.net/

Inspired by a suggestion/request from Arnd Baecker.

$Id$"""

__all__ = ['Gnuplot','gp','gp_new','Data','File','Func','GridData',
           'pm3d_config','eps_fix_bbox']

import os,tempfile,sys
from IPython.genutils import getoutput

#---------------------------------------------------------------------------
# Notes on mouse support for Gnuplot.py

# If you do not have a mouse-enabled gnuplot, set gnuplot_mouse to 0. If you
# use gnuplot, you should really grab a recent, mouse enabled copy. It is an
# extremely useful feature.  Mouse support is official as of gnuplot 4.0,
# released in April 2004.

# For the mouse features to work correctly, you MUST set your Gnuplot.py
# module to use temporary files instead of 'inline data' for data
# communication. Note that this is the default, so unless you've manually
# fiddled with it you should be ok. If you need to make changes, in the
# Gnuplot module directory, loook for the gp_unix.py file and make sure the
# prefer_inline_data variable is set to 0. If you set it to 1 Gnuplot.py will
# try to pass the data to gnuplot via standard input, which completely
# confuses the mouse control system (even though it may be a bit faster than
# using temp files).

# As of Gnuplot.py v1.7, a new option was added to use FIFOs (pipes).  This
# mechanism, while fast, also breaks the mouse system.  You must therefore set
# the variable prefer_fifo_data to 0 in gp_unix.py.

tmpname = tempfile.mktemp()
open(tmpname,'w').write('set mouse')
gnu_out = getoutput('gnuplot '+ tmpname)
os.unlink(tmpname)
if gnu_out:  # Gnuplot won't print anything if it has mouse support
    print "*** Your version of Gnuplot appears not to have mouse support."
    gnuplot_mouse = 0
else:
    gnuplot_mouse = 1
del tmpname,gnu_out

# Default state for persistence of new gnuplot instances
if os.name in ['nt','dos'] or sys.platform == 'cygwin':
    gnuplot_persist = 0
else:
    gnuplot_persist = 1

import IPython.Gnuplot2 as Gnuplot

</t>
<t tx="ekr.20071201085751.270">class NotGiven: pass

</t>
<t tx="ekr.20071201085751.271">def gp_new(mouse=NotGiven,persist=NotGiven):
    """Return a new Gnuplot instance.

    The instance returned uses the improved methods defined in Gnuplot2.

    Options (boolean):

    - mouse: if unspecified, the module global gnuplot_mouse is used.

    - persist: if unspecified, the module global gnuplot_persist is used."""
    
    if mouse is NotGiven:
        mouse = gnuplot_mouse
    if persist is NotGiven:
        persist = gnuplot_persist
    g = Gnuplot.Gnuplot(persist=persist)
    if mouse:
        g('set mouse')
    return g

</t>
<t tx="ekr.20071201085751.272">"""hooks for IPython.

In Python, it is possible to overwrite any method of any object if you really
want to.  But IPython exposes a few 'hooks', methods which are _designed_ to
be overwritten by users for customization purposes.  This module defines the
default versions of all such hooks, which get used by IPython if not
overridden by the user.

hooks are simple functions, but they should be declared with 'self' as their
first argument, because when activated they are registered into IPython as
instance methods.  The self argument will be the IPython running instance
itself, so hooks have full access to the entire IPython object.

If you wish to define a new hook and activate it, you need to put the
necessary code into a python file which can be either imported or execfile()'d
from within your ipythonrc configuration.

For example, suppose that you have a module called 'myiphooks' in your
PYTHONPATH, which contains the following definition:

import os
import IPython.ipapi
ip = IPython.ipapi.get()

def calljed(self,filename, linenum):
    "My editor hook calls the jed editor directly."
    print "Calling my own editor, jed ..."
    os.system('jed +%d %s' % (linenum,filename))

ip.set_hook('editor', calljed)

You can then enable the functionality by doing 'import myiphooks'
somewhere in your configuration files or ipython command line.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2005 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
from IPython import ipapi
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license
__version__ = Release.version

import os,bisect
from genutils import Term
from pprint import PrettyPrinter

# List here all the default hooks.  For now it's just the editor functions
# but over time we'll move here all the public API for user-accessible things.
__all__ = ['editor', 'fix_error_editor', 'result_display',
           'input_prefilter', 'shutdown_hook', 'late_startup_hook',
           'generate_prompt', 'generate_output_prompt' ]

pformat = PrettyPrinter().pformat

</t>
<t tx="ekr.20071201085751.273">def editor(self,filename, linenum=None):
    """Open the default editor at the given filename and linenumber.

    This is IPython's default editor hook, you can use it as an example to
    write your own modified one.  To set your own editor function as the
    new editor hook, call ip.set_hook('editor',yourfunc)."""

    # IPython configures a default editor at startup by reading $EDITOR from
    # the environment, and falling back on vi (unix) or notepad (win32).
    editor = self.rc.editor
    
    # marker for at which line to open the file (for existing objects)
    if linenum is None or editor=='notepad':
        linemark = ''
    else:
        linemark = '+%d' % int(linenum)
    
    # Enclose in quotes if necessary and legal
    if ' ' in editor and os.path.isfile(editor) and editor[0] != '"':
        editor = '"%s"' % editor
        
    # Call the actual editor
    os.system('%s %s %s' % (editor,linemark,filename))

</t>
<t tx="ekr.20071201085751.274">import tempfile
def fix_error_editor(self,filename,linenum,column,msg):
    """Open the editor at the given filename, linenumber, column and 
    show an error message. This is used for correcting syntax errors.
    The current implementation only has special support for the VIM editor,
    and falls back on the 'editor' hook if VIM is not used.

    Call ip.set_hook('fix_error_editor',youfunc) to use your own function,
    """
    def vim_quickfix_file():
        t = tempfile.NamedTemporaryFile()
        t.write('%s:%d:%d:%s\n' % (filename,linenum,column,msg))
        t.flush()
        return t
    if os.path.basename(self.rc.editor) != 'vim':
        self.hooks.editor(filename,linenum)
        return
    t = vim_quickfix_file()
    try:
        os.system('vim --cmd "set errorformat=%f:%l:%c:%m" -q ' + t.name)
    finally:
        t.close()


</t>
<t tx="ekr.20071201085751.275">class CommandChainDispatcher:
    """ Dispatch calls to a chain of commands until some func can handle it
    
    Usage: instantiate, execute "add" to add commands (with optional
    priority), execute normally via f() calling mechanism.
    
    """
    @others
</t>
<t tx="ekr.20071201085751.276">def __init__(self,commands=None):
    if commands is None:
        self.chain = []
    else:
        self.chain = commands
        
        
</t>
<t tx="ekr.20071201085751.277">def __call__(self,*args, **kw):
    """ Command chain is called just like normal func. 
    
    This will call all funcs in chain with the same args as were given to this
    function, and return the result of first func that didn't raise
    TryNext """
    
    for prio,cmd in self.chain:
        #print "prio",prio,"cmd",cmd #dbg
        try:
            ret = cmd(*args, **kw)
            return ret
        except ipapi.TryNext, exc:
            if exc.args or exc.kwargs:
                args = exc.args
                kw = exc.kwargs
            
</t>
<t tx="ekr.20071201085751.278">def __str__(self):
    return str(self.chain)

</t>
<t tx="ekr.20071201085751.279">def add(self, func, priority=0):
    """ Add a func to the cmd chain with given priority """
    bisect.insort(self.chain,(priority,func))

</t>
<t tx="ekr.20071201085751.280">def __iter__(self):
    """ Return all objects in chain.
    
    Handy if the objects are not callable.
    """
    return iter(self.chain)

</t>
<t tx="ekr.20071201085751.281">def result_display(self,arg):
    """ Default display hook.
    
    Called for displaying the result to the user.
    """
    
    if self.rc.pprint:
        out = pformat(arg)
        if '\n' in out:
            # So that multi-line strings line up with the left column of
            # the screen, instead of having the output prompt mess up
            # their first line.                
            Term.cout.write('\n')
        print &gt;&gt;Term.cout, out
    else:
        # By default, the interactive prompt uses repr() to display results,
        # so we should honor this.  Users who'd rather use a different
        # mechanism can easily override this hook.
        print &gt;&gt;Term.cout, repr(arg)
    # the default display hook doesn't manipulate the value to put in history
    return None 

</t>
<t tx="ekr.20071201085751.282">def input_prefilter(self,line):     
    """ Default input prefilter
    
    This returns the line as unchanged, so that the interpreter
    knows that nothing was done and proceeds with "classic" prefiltering
    (%magics, !shell commands etc.). 
    
    Note that leading whitespace is not passed to this hook. Prefilter
    can't alter indentation.
    
    """
    #print "attempt to rewrite",line #dbg
    return line

</t>
<t tx="ekr.20071201085751.283">def shutdown_hook(self):
    """ default shutdown hook
    
    Typically, shotdown hooks should raise TryNext so all shutdown ops are done
    """
    
    #print "default shutdown hook ok" # dbg
    return

</t>
<t tx="ekr.20071201085751.284">def late_startup_hook(self):
    """ Executed after ipython has been constructed and configured 
    
    """
    #print "default startup hook ok" # dbg

</t>
<t tx="ekr.20071201085751.285">def generate_prompt(self, is_continuation):
    """ calculate and return a string with the prompt to display """
    ip = self.api
    if is_continuation:
        return str(ip.IP.outputcache.prompt2)
    return str(ip.IP.outputcache.prompt1)

</t>
<t tx="ekr.20071201085751.286">def generate_output_prompt(self):
    ip = self.api
    return str(ip.IP.outputcache.prompt_out)
        
   </t>
<t tx="ekr.20071201085751.287">''' IPython customization API

Your one-stop module for configuring &amp; extending ipython

The API will probably break when ipython 1.0 is released, but so 
will the other configuration method (rc files).

All names prefixed by underscores are for internal use, not part 
of the public api.

Below is an example that you can just put to a module and import from ipython. 

A good practice is to install the config script below as e.g. 

~/.ipython/my_private_conf.py

And do 

import_mod my_private_conf 

in ~/.ipython/ipythonrc

That way the module is imported at startup and you can have all your
personal configuration (as opposed to boilerplate ipythonrc-PROFILENAME 
stuff) in there. 

-----------------------------------------------
import IPython.ipapi
ip = IPython.ipapi.get()

def ankka_f(self, arg):
    print "Ankka",self,"says uppercase:",arg.upper()

ip.expose_magic("ankka",ankka_f)

ip.magic('alias sayhi echo "Testing, hi ok"')
ip.magic('alias helloworld echo "Hello world"')
ip.system('pwd')

ip.ex('import re')
ip.ex("""
def funcci(a,b):
    print a+b
print funcci(3,4)
""")
ip.ex("funcci(348,9)")

def jed_editor(self,filename, linenum=None):
    print "Calling my own editor, jed ... via hook!"
    import os
    if linenum is None: linenum = 0
    os.system('jed +%d %s' % (linenum, filename))
    print "exiting jed"

ip.set_hook('editor',jed_editor)

o = ip.options
o.autocall = 2  # FULL autocall mode

print "done!"
'''

# stdlib imports
import __builtin__
import sys

# our own
from IPython.genutils import warn,error
 
</t>
<t tx="ekr.20071201085751.288">class TryNext(Exception):
    """Try next hook exception.
     
    Raise this in your hook function to indicate that the next hook handler
    should be used to handle the operation.  If you pass arguments to the
    constructor those arguments will be used by the next hook instead of the
    original ones.
    """
    @others
</t>
<t tx="ekr.20071201085751.289">
def __init__(self, *args, **kwargs):
    self.args = args
    self.kwargs = kwargs

</t>
<t tx="ekr.20071201085751.290"># contains the most recently instantiated IPApi

class IPythonNotRunning:
    """Dummy do-nothing class.

    Instances of this class return a dummy attribute on all accesses, which
    can be called and warns.  This makes it easier to write scripts which use
    the ipapi.get() object for informational purposes to operate both with and
    without ipython.  Obviously code which uses the ipython object for
    computations will not work, but this allows a wider range of code to
    transparently work whether ipython is being used or not."""
    @others
</t>
<t tx="ekr.20071201085751.291">
def __str__(self):
    return "&lt;IPythonNotRunning&gt;"

</t>
<t tx="ekr.20071201085751.292">__repr__ = __str__

def __getattr__(self,name):
    return self.dummy

</t>
<t tx="ekr.20071201085751.293">def dummy(self,*args,**kw):
    """Dummy function, which doesn't do anything but warn."""
    warn("IPython is not running, this is a dummy no-op function")

</t>
<t tx="ekr.20071201085751.294">_recent = None


def get(allow_dummy=False):
    """Get an IPApi object.

    If allow_dummy is true, returns an instance of IPythonNotRunning 
    instead of None if not running under IPython.

    Running this should be the first thing you do when writing extensions that
    can be imported as normal modules. You can then direct all the
    configuration operations against the returned object.
    """
    global _recent
    if allow_dummy and not _recent:
        _recent = IPythonNotRunning()
    return _recent

</t>
<t tx="ekr.20071201085751.295">class IPApi:
    """ The actual API class for configuring IPython 
    
    You should do all of the IPython configuration by getting an IPApi object
    with IPython.ipapi.get() and using the attributes and methods of the
    returned object."""
    @others
</t>
<t tx="ekr.20071201085751.296">
def __init__(self,ip):
    
    # All attributes exposed here are considered to be the public API of
    # IPython.  As needs dictate, some of these may be wrapped as
    # properties.

    self.magic = ip.ipmagic
    
    self.system = ip.ipsystem
    
    self.set_hook = ip.set_hook
    
    self.set_custom_exc = ip.set_custom_exc

    self.user_ns = ip.user_ns

    self.set_crash_handler = ip.set_crash_handler

    # Session-specific data store, which can be used to store
    # data that should persist through the ipython session.
    self.meta =  ip.meta

    # The ipython instance provided
    self.IP = ip

    global _recent
    _recent = self

</t>
<t tx="ekr.20071201085751.297"># Use a property for some things which are added to the instance very
# late.  I don't have time right now to disentangle the initialization
# order issues, so a property lets us delay item extraction while
# providing a normal attribute API.
def get_db(self):
    """A handle to persistent dict-like database (a PickleShareDB object)"""
    return self.IP.db

</t>
<t tx="ekr.20071201085751.298">db = property(get_db,None,None,get_db.__doc__)

def get_options(self):
    """All configurable variables."""
    
    # catch typos by disabling new attribute creation. If new attr creation
    # is in fact wanted (e.g. when exposing new options), do allow_new_attr(True) 
    # for the received rc struct.
    
    self.IP.rc.allow_new_attr(False)
    return self.IP.rc

</t>
<t tx="ekr.20071201085751.299">options = property(get_options,None,None,get_options.__doc__)

def expose_magic(self,magicname, func):
    ''' Expose own function as magic function for ipython 

    def foo_impl(self,parameter_s=''):
        """My very own magic!. (Use docstrings, IPython reads them)."""
        print 'Magic function. Passed parameter is between &lt; &gt;: &lt;'+parameter_s+'&gt;'
        print 'The self object is:',self

    ipapi.expose_magic("foo",foo_impl)
    '''
            
    import new
    im = new.instancemethod(func,self.IP, self.IP.__class__)
    setattr(self.IP, "magic_" + magicname, im)

</t>
<t tx="ekr.20071201085751.300">def ex(self,cmd):
    """ Execute a normal python statement in user namespace """
    exec cmd in self.user_ns

</t>
<t tx="ekr.20071201085751.301">def ev(self,expr):
    """ Evaluate python expression expr in user namespace 
    
    Returns the result of evaluation"""
    return eval(expr,self.user_ns)

</t>
<t tx="ekr.20071201085751.302">def runlines(self,lines):
    """ Run the specified lines in interpreter, honoring ipython directives.
    
    This allows %magic and !shell escape notations.
    
    Takes either all lines in one string or list of lines.
    """
    if isinstance(lines,basestring):
        self.IP.runlines(lines)
    else:
        self.IP.runlines('\n'.join(lines))

</t>
<t tx="ekr.20071201085751.303">def to_user_ns(self,vars):
    """Inject a group of variables into the IPython user namespace.

    Inputs:

     - vars: string with variable names separated by whitespace

    This utility routine is meant to ease interactive debugging work,
    where you want to easily propagate some internal variable in your code
    up to the interactive namespace for further exploration.

    When you run code via %run, globals in your script become visible at
    the interactive prompt, but this doesn't happen for locals inside your
    own functions and methods.  Yet when debugging, it is common to want
    to explore some internal variables further at the interactive propmt.

    Examples:

    To use this, you first must obtain a handle on the ipython object as
    indicated above, via:

    import IPython.ipapi
    ip = IPython.ipapi.get()

    Once this is done, inside a routine foo() where you want to expose
    variables x and y, you do the following:

    def foo():
        ...
        x = your_computation()
        y = something_else()
        
        # This pushes x and y to the interactive prompt immediately, even
        # if this routine crashes on the next line after:
        ip.to_user_ns('x y')
        ...
        # return           
    
    If you need to rename variables, just use ip.user_ns with dict
    and update:
    
    # exposes variables 'foo' as 'x' and 'bar' as 'y' in IPython 
    # user namespace
    ip.user_ns.update(dict(x=foo,y=bar))    
    """

    # print 'vars given:',vars # dbg
    # Get the caller's frame to evaluate the given names in
    cf = sys._getframe(1)
    
    user_ns = self.user_ns
    
    for name in vars.split():
        try:
            user_ns[name] = eval(name,cf.f_globals,cf.f_locals)
        except:
            error('could not get var. %s from %s' %
            (name,cf.f_code.co_name))

</t>
<t tx="ekr.20071201085751.304">def launch_new_instance(user_ns = None):
    """ Make and start a new ipython instance.
    
    This can be called even without having an already initialized 
    ipython session running.
    
    This is also used as the egg entry point for the 'ipython' script.
    
    """
    ses = make_session(user_ns)
    ses.mainloop()


</t>
<t tx="ekr.20071201085751.305">def make_user_ns(user_ns = None):
    """Return a valid user interactive namespace.

    This builds a dict with the minimal information needed to operate as a
    valid IPython user namespace, which you can pass to the various embedding
    classes in ipython.
    """

    if user_ns is None:
        # Set __name__ to __main__ to better match the behavior of the
        # normal interpreter.
        user_ns = {'__name__'     :'__main__',
                   '__builtins__' : __builtin__,
                   }
    else:
        user_ns.setdefault('__name__','__main__')
        user_ns.setdefault('__builtins__',__builtin__)

    return user_ns


</t>
<t tx="ekr.20071201085751.306">def make_user_global_ns(ns = None):
    """Return a valid user global namespace.

    Similar to make_user_ns(), but global namespaces are really only needed in
    embedded applications, where there is a distinction between the user's
    interactive namespace and the global one where ipython is running."""

    if ns is None: ns = {}
    return ns


</t>
<t tx="ekr.20071201085751.307">def make_session(user_ns = None):
    """Makes, but does not launch an IPython session.
    
    Later on you can call obj.mainloop() on the returned object.

    Inputs:

      - user_ns(None): a dict to be used as the user's namespace with initial
      data.
    
    WARNING: This should *not* be run when a session exists already."""

    import IPython
    return IPython.Shell.start(user_ns)
</t>
<t tx="ekr.20071201085751.308"># -*- coding: utf-8 -*-
"""
IPython -- An enhanced Interactive Python

Requires Python 2.3 or newer.

This file contains all the classes and helper functions specific to IPython.

$Id$
"""

#*****************************************************************************
#       Copyright (C) 2001 Janko Hauser &lt;jhauser@zscout.de&gt; and
#       Copyright (C) 2001-2006 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#
# Note: this code originally subclassed code.InteractiveConsole from the
# Python standard library.  Over time, all of that class has been copied
# verbatim here for modifications which could not be accomplished by
# subclassing.  At this point, there are no dependencies at all on the code
# module anymore (it is not even imported).  The Python License (sec. 2)
# allows for this, but it's always nice to acknowledge credit where credit is
# due.
#*****************************************************************************

#****************************************************************************
# Modules and globals

from IPython import Release
__author__  = '%s &lt;%s&gt;\n%s &lt;%s&gt;' % \
              ( Release.authors['Janko'] + Release.authors['Fernando'] )
__license__ = Release.license
__version__ = Release.version

# Python standard modules
import __main__
import __builtin__
import StringIO
import bdb
import cPickle as pickle
import codeop
import exceptions
import glob
import inspect
import keyword
import new
import os
import pydoc
import re
import shutil
import string
import sys
import tempfile
import traceback
import types
import pickleshare
from sets import Set
from pprint import pprint, pformat

# IPython's own modules
import IPython
from IPython import OInspect,PyColorize,ultraTB
from IPython.ColorANSI import ColorScheme,ColorSchemeTable  # too long names
from IPython.FakeModule import FakeModule
from IPython.Itpl import Itpl,itpl,printpl,ItplNS,itplns
from IPython.Logger import Logger
from IPython.Magic import Magic
from IPython.Prompts import CachedOutput
from IPython.ipstruct import Struct
from IPython.background_jobs import BackgroundJobManager
from IPython.usage import cmd_line_usage,interactive_usage
from IPython.genutils import *
from IPython.strdispatch import StrDispatch
import IPython.ipapi

# Globals

# store the builtin raw_input globally, and use this always, in case user code
# overwrites it (like wx.py.PyShell does)
raw_input_original = raw_input

# compiled regexps for autoindent management
dedent_re = re.compile(r'^\s+raise|^\s+return|^\s+pass')


#****************************************************************************
# Some utility function definitions

ini_spaces_re = re.compile(r'^(\s+)')

</t>
<t tx="ekr.20071201085751.309">def num_ini_spaces(strng):
    """Return the number of initial spaces in a string"""

    ini_spaces = ini_spaces_re.match(strng)
    if ini_spaces:
        return ini_spaces.end()
    else:
        return 0

</t>
<t tx="ekr.20071201085751.310">def softspace(file, newvalue):
    """Copied from code.py, to remove the dependency"""

    oldvalue = 0
    try:
        oldvalue = file.softspace
    except AttributeError:
        pass
    try:
        file.softspace = newvalue
    except (AttributeError, TypeError):
        # "attribute-less object" or "read-only attributes"
        pass
    return oldvalue


</t>
<t tx="ekr.20071201085751.311">#****************************************************************************
# Local use exceptions
class SpaceInInput(exceptions.Exception): pass


</t>
<t tx="ekr.20071201085751.312">#****************************************************************************
# Local use classes
class Bunch: pass

</t>
<t tx="ekr.20071201085751.313">class Undefined: pass

</t>
<t tx="ekr.20071201085751.314">class Quitter(object):
    """Simple class to handle exit, similar to Python 2.5's.

    It handles exiting in an ipython-safe manner, which the one in Python 2.5
    doesn't do (obviously, since it doesn't know about ipython)."""
    @others
</t>
<t tx="ekr.20071201085751.315">
def __init__(self,shell,name):
    self.shell = shell
    self.name = name
    
</t>
<t tx="ekr.20071201085751.316">def __repr__(self):
    return 'Type %s() to exit.' % self.name
</t>
<t tx="ekr.20071201085751.317">__str__ = __repr__

def __call__(self):
    self.shell.exit()

</t>
<t tx="ekr.20071201085751.318">class InputList(list):
    """Class to store user input.

    It's basically a list, but slices return a string instead of a list, thus
    allowing things like (assuming 'In' is an instance):

    exec In[4:7]

    or

    exec In[5:9] + In[14] + In[21:25]"""
    @others
</t>
<t tx="ekr.20071201085751.319">
def __getslice__(self,i,j):
    return ''.join(list.__getslice__(self,i,j))

</t>
<t tx="ekr.20071201085751.320">class SyntaxTB(ultraTB.ListTB):
    """Extension which holds some state: the last exception value"""
    @others
</t>
<t tx="ekr.20071201085751.321">
def __init__(self,color_scheme = 'NoColor'):
    ultraTB.ListTB.__init__(self,color_scheme)
    self.last_syntax_error = None

</t>
<t tx="ekr.20071201085751.322">def __call__(self, etype, value, elist):
    self.last_syntax_error = value
    ultraTB.ListTB.__call__(self,etype,value,elist)

</t>
<t tx="ekr.20071201085751.323">def clear_err_state(self):
    """Return the current error state and clear it"""
    e = self.last_syntax_error
    self.last_syntax_error = None
    return e

</t>
<t tx="ekr.20071201085751.324">#****************************************************************************
# Main IPython class

# FIXME: the Magic class is a mixin for now, and will unfortunately remain so
# until a full rewrite is made.  I've cleaned all cross-class uses of
# attributes and methods, but too much user code out there relies on the
# equlity %foo == __IP.magic_foo, so I can't actually remove the mixin usage.
#
# But at least now, all the pieces have been separated and we could, in
# principle, stop using the mixin.  This will ease the transition to the
# chainsaw branch.

# For reference, the following is the list of 'self.foo' uses in the Magic
# class as of 2005-12-28.  These are names we CAN'T use in the main ipython
# class, to prevent clashes.

# ['self.__class__', 'self.__dict__', 'self._inspect', 'self._ofind',
#  'self.arg_err', 'self.extract_input', 'self.format_', 'self.lsmagic',
#  'self.magic_', 'self.options_table', 'self.parse', 'self.shell',
#  'self.value']

class InteractiveShell(object,Magic):
    """An enhanced console for Python."""

    # class attribute to indicate whether the class supports threads or not.
    # Subclasses with thread support should override this as needed.
    isthreaded = False

    @others
</t>
<t tx="ekr.20071201085751.325">def __init__(self,name,usage=None,rc=Struct(opts=None,args=None),
             user_ns = None,user_global_ns=None,banner2='',
             custom_exceptions=((),None),embedded=False):

    # log system
    self.logger = Logger(self,logfname='ipython_log.py',logmode='rotate')

    # some minimal strict typechecks.  For some core data structures, I
    # want actual basic python types, not just anything that looks like
    # one.  This is especially true for namespaces.
    for ns in (user_ns,user_global_ns):
        if ns is not None and type(ns) != types.DictType:
            raise TypeError,'namespace must be a dictionary'

    # Job manager (for jobs run as background threads)
    self.jobs = BackgroundJobManager()

    # Store the actual shell's name
    self.name = name

    # We need to know whether the instance is meant for embedding, since
    # global/local namespaces need to be handled differently in that case
    self.embedded = embedded

    # command compiler
    self.compile = codeop.CommandCompiler()

    # User input buffer
    self.buffer = []

    # Default name given in compilation of code
    self.filename = '&lt;ipython console&gt;'

    # Install our own quitter instead of the builtins.  For python2.3-2.4,
    # this brings in behavior like 2.5, and for 2.5 it's identical.
    __builtin__.exit = Quitter(self,'exit')
    __builtin__.quit = Quitter(self,'quit')
    
    # Make an empty namespace, which extension writers can rely on both
    # existing and NEVER being used by ipython itself.  This gives them a
    # convenient location for storing additional information and state
    # their extensions may require, without fear of collisions with other
    # ipython names that may develop later.
    self.meta = Struct()

    # Create the namespace where the user will operate.  user_ns is
    # normally the only one used, and it is passed to the exec calls as
    # the locals argument.  But we do carry a user_global_ns namespace
    # given as the exec 'globals' argument,  This is useful in embedding
    # situations where the ipython shell opens in a context where the
    # distinction between locals and globals is meaningful.

    # FIXME. For some strange reason, __builtins__ is showing up at user
    # level as a dict instead of a module. This is a manual fix, but I
    # should really track down where the problem is coming from. Alex
    # Schmolck reported this problem first.

    # A useful post by Alex Martelli on this topic:
    # Re: inconsistent value from __builtins__
    # Von: Alex Martelli &lt;aleaxit@yahoo.com&gt;
    # Datum: Freitag 01 Oktober 2004 04:45:34 nachmittags/abends
    # Gruppen: comp.lang.python

    # Michael Hohn &lt;hohn@hooknose.lbl.gov&gt; wrote:
    # &gt; &gt;&gt;&gt; print type(builtin_check.get_global_binding('__builtins__'))
    # &gt; &lt;type 'dict'&gt;
    # &gt; &gt;&gt;&gt; print type(__builtins__)
    # &gt; &lt;type 'module'&gt;
    # &gt; Is this difference in return value intentional?

    # Well, it's documented that '__builtins__' can be either a dictionary
    # or a module, and it's been that way for a long time. Whether it's
    # intentional (or sensible), I don't know. In any case, the idea is
    # that if you need to access the built-in namespace directly, you
    # should start with "import __builtin__" (note, no 's') which will
    # definitely give you a module. Yeah, it's somewhat confusing:-(.

    # These routines return properly built dicts as needed by the rest of
    # the code, and can also be used by extension writers to generate
    # properly initialized namespaces.
    user_ns = IPython.ipapi.make_user_ns(user_ns)
    user_global_ns = IPython.ipapi.make_user_global_ns(user_global_ns)
        
    # Assign namespaces
    # This is the namespace where all normal user variables live
    self.user_ns = user_ns
    # Embedded instances require a separate namespace for globals.
    # Normally this one is unused by non-embedded instances.
    self.user_global_ns = user_global_ns
    # A namespace to keep track of internal data structures to prevent
    # them from cluttering user-visible stuff.  Will be updated later
    self.internal_ns = {}

    # Namespace of system aliases.  Each entry in the alias
    # table must be a 2-tuple of the form (N,name), where N is the number
    # of positional arguments of the alias.
    self.alias_table = {}

    # A table holding all the namespaces IPython deals with, so that
    # introspection facilities can search easily.
    self.ns_table = {'user':user_ns,
                     'user_global':user_global_ns,
                     'alias':self.alias_table,
                     'internal':self.internal_ns,
                     'builtin':__builtin__.__dict__
                     }

    # The user namespace MUST have a pointer to the shell itself.
    self.user_ns[name] = self

    # We need to insert into sys.modules something that looks like a
    # module but which accesses the IPython namespace, for shelve and
    # pickle to work interactively. Normally they rely on getting
    # everything out of __main__, but for embedding purposes each IPython
    # instance has its own private namespace, so we can't go shoving
    # everything into __main__.

    # note, however, that we should only do this for non-embedded
    # ipythons, which really mimic the __main__.__dict__ with their own
    # namespace.  Embedded instances, on the other hand, should not do
    # this because they need to manage the user local/global namespaces
    # only, but they live within a 'normal' __main__ (meaning, they
    # shouldn't overtake the execution environment of the script they're
    # embedded in).

    if not embedded:
        try:
            main_name = self.user_ns['__name__']
        except KeyError:
            raise KeyError,'user_ns dictionary MUST have a "__name__" key'
        else:
            #print "pickle hack in place"  # dbg
            #print 'main_name:',main_name # dbg
            sys.modules[main_name] = FakeModule(self.user_ns)

    # List of input with multi-line handling.
    # Fill its zero entry, user counter starts at 1
    self.input_hist = InputList(['\n'])
    # This one will hold the 'raw' input history, without any
    # pre-processing.  This will allow users to retrieve the input just as
    # it was exactly typed in by the user, with %hist -r.
    self.input_hist_raw = InputList(['\n'])

    # list of visited directories
    try:
        self.dir_hist = [os.getcwd()]
    except IOError, e:
        self.dir_hist = []

    # dict of output history
    self.output_hist = {}

    # dict of things NOT to alias (keywords, builtins and some magics)
    no_alias = {}
    no_alias_magics = ['cd','popd','pushd','dhist','alias','unalias']
    for key in keyword.kwlist + no_alias_magics:
        no_alias[key] = 1
    no_alias.update(__builtin__.__dict__)
    self.no_alias = no_alias
            
    # make global variables for user access to these
    self.user_ns['_ih'] = self.input_hist
    self.user_ns['_oh'] = self.output_hist
    self.user_ns['_dh'] = self.dir_hist

    # user aliases to input and output histories
    self.user_ns['In']  = self.input_hist
    self.user_ns['Out'] = self.output_hist

    # Object variable to store code object waiting execution.  This is
    # used mainly by the multithreaded shells, but it can come in handy in
    # other situations.  No need to use a Queue here, since it's a single
    # item which gets cleared once run.
    self.code_to_run = None
    
    # escapes for automatic behavior on the command line
    self.ESC_SHELL  = '!'
    self.ESC_HELP   = '?'
    self.ESC_MAGIC  = '%'
    self.ESC_QUOTE  = ','
    self.ESC_QUOTE2 = ';'
    self.ESC_PAREN  = '/'

    # And their associated handlers
    self.esc_handlers = {self.ESC_PAREN  : self.handle_auto,
                         self.ESC_QUOTE  : self.handle_auto,
                         self.ESC_QUOTE2 : self.handle_auto,
                         self.ESC_MAGIC  : self.handle_magic,
                         self.ESC_HELP   : self.handle_help,
                         self.ESC_SHELL  : self.handle_shell_escape,
                         }

    # class initializations
    Magic.__init__(self,self)

    # Python source parser/formatter for syntax highlighting
    pyformat = PyColorize.Parser().format
    self.pycolorize = lambda src: pyformat(src,'str',self.rc['colors'])

    # hooks holds pointers used for user-side customizations
    self.hooks = Struct()
    
    self.strdispatchers = {}
    
    # Set all default hooks, defined in the IPython.hooks module.
    hooks = IPython.hooks
    for hook_name in hooks.__all__:
        # default hooks have priority 100, i.e. low; user hooks should have 0-100 priority
        self.set_hook(hook_name,getattr(hooks,hook_name), 100)
        #print "bound hook",hook_name

    # Flag to mark unconditional exit
    self.exit_now = False

    self.usage_min =  """\
    An enhanced console for Python.
    Some of its features are:
    - Readline support if the readline library is present.
    - Tab completion in the local namespace.
    - Logging of input, see command-line options.
    - System shell escape via ! , eg !ls.
    - Magic commands, starting with a % (like %ls, %pwd, %cd, etc.)
    - Keeps track of locally defined variables via %who, %whos.
    - Show object information with a ? eg ?x or x? (use ?? for more info).
    """
    if usage: self.usage = usage
    else: self.usage = self.usage_min

    # Storage
    self.rc = rc   # This will hold all configuration information
    self.pager = 'less'
    # temporary files used for various purposes.  Deleted at exit.
    self.tempfiles = []

    # Keep track of readline usage (later set by init_readline)
    self.has_readline = False

    # template for logfile headers.  It gets resolved at runtime by the
    # logstart method.
    self.loghead_tpl = \
</t>
<t tx="ekr.20071201085751.326"># -*- coding: utf-8 -*-
"""
IPython -- An enhanced Interactive Python

Requires Python 2.1 or better.

This file contains the main make_IPython() starter function.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license
__version__ = Release.version

credits._Printer__data = """
Python: %s

IPython: Fernando Perez, Janko Hauser, Nathan Gray, and many users.
See http://ipython.scipy.org for more information.""" \
% credits._Printer__data

copyright._Printer__data += """

Copyright (c) 2001-2004 Fernando Perez, Janko Hauser, Nathan Gray.
All Rights Reserved."""

#****************************************************************************
# Required modules

# From the standard library
import __main__
import __builtin__
import os
import re
import sys
import types
from pprint import pprint,pformat

# Our own
from IPython import DPyGetOpt
from IPython.ipstruct import Struct
from IPython.OutputTrap import OutputTrap
from IPython.ConfigLoader import ConfigLoader
from IPython.iplib import InteractiveShell
from IPython.usage import cmd_line_usage,interactive_usage
from IPython.genutils import *

</t>
<t tx="ekr.20071201085751.327">#-----------------------------------------------------------------------------
def make_IPython(argv=None,user_ns=None,user_global_ns=None,debug=1,
                 rc_override=None,shell_class=InteractiveShell,
                 embedded=False,**kw):
    """This is a dump of IPython into a single function.

    Later it will have to be broken up in a sensible manner.

    Arguments:

    - argv: a list similar to sys.argv[1:].  It should NOT contain the desired
    script name, b/c DPyGetOpt strips the first argument only for the real
    sys.argv.

    - user_ns: a dict to be used as the user's namespace."""

    #----------------------------------------------------------------------
    # Defaults and initialization
    
    # For developer debugging, deactivates crash handler and uses pdb.
    DEVDEBUG = False

    if argv is None:
        argv = sys.argv

    # __IP is the main global that lives throughout and represents the whole
    # application. If the user redefines it, all bets are off as to what
    # happens.

    # __IP is the name of he global which the caller will have accessible as
    # __IP.name. We set its name via the first parameter passed to
    # InteractiveShell:

    IP = shell_class('__IP',user_ns=user_ns,user_global_ns=user_global_ns,
                     embedded=embedded,**kw)

    # Put 'help' in the user namespace
    from site import _Helper
    IP.user_ns['help'] = _Helper()


    if DEVDEBUG:
        # For developer debugging only (global flag)
        from IPython import ultraTB
        sys.excepthook = ultraTB.VerboseTB(call_pdb=1)

    IP.BANNER_PARTS = ['Python %s\n'
                         'Type "copyright", "credits" or "license" '
                         'for more information.\n'
                         % (sys.version.split('\n')[0],),
                         "IPython %s -- An enhanced Interactive Python."
                         % (__version__,),
"""?       -&gt; Introduction to IPython's features.
%magic  -&gt; Information about IPython's 'magic' % functions.
help    -&gt; Python's own help system.
object? -&gt; Details about 'object'. ?object also works, ?? prints more.
""" ]

    IP.usage = interactive_usage

    # Platform-dependent suffix and directory names.  We use _ipython instead
    # of .ipython under win32 b/c there's software that breaks with .named
    # directories on that platform.
    if os.name == 'posix':
        rc_suffix = ''
        ipdir_def = '.ipython'
    else:
        rc_suffix = '.ini'
        ipdir_def = '_ipython'

    # default directory for configuration
    ipythondir_def = os.path.abspath(os.environ.get('IPYTHONDIR',
                                 os.path.join(IP.home_dir,ipdir_def)))

    sys.path.insert(0, '') # add . to sys.path. Fix from Prabhu Ramachandran

    # we need the directory where IPython itself is installed
    import IPython
    IPython_dir = os.path.dirname(IPython.__file__)
    del IPython
    
    #-------------------------------------------------------------------------
    # Command line handling

    # Valid command line options (uses DPyGetOpt syntax, like Perl's
    # GetOpt::Long)

    # Any key not listed here gets deleted even if in the file (like session
    # or profile). That's deliberate, to maintain the rc namespace clean.

    # Each set of options appears twice: under _conv only the names are
    # listed, indicating which type they must be converted to when reading the
    # ipythonrc file. And under DPyGetOpt they are listed with the regular
    # DPyGetOpt syntax (=s,=i,:f,etc).

    # Make sure there's a space before each end of line (they get auto-joined!)
    cmdline_opts = ('autocall=i autoindent! automagic! banner! cache_size|cs=i '
                    'c=s classic|cl color_info! colors=s confirm_exit! '
                    'debug! deep_reload! editor=s log|l messages! nosep '
                    'object_info_string_level=i pdb! '
                    'pprint! prompt_in1|pi1=s prompt_in2|pi2=s prompt_out|po=s '
                    'quick screen_length|sl=i prompts_pad_left=i '
                    'logfile|lf=s logplay|lp=s profile|p=s '
                    'readline! readline_merge_completions! '
                    'readline_omit__names! '
                    'rcfile=s separate_in|si=s separate_out|so=s '
                    'separate_out2|so2=s xmode=s wildcards_case_sensitive! '
                    'magic_docstrings system_verbose! '
                    'multi_line_specials! '
                    'wxversion=s '
                    'autoedit_syntax!')

    # Options that can *only* appear at the cmd line (not in rcfiles).
    
    # The "ignore" option is a kludge so that Emacs buffers don't crash, since
    # the 'C-c !' command in emacs automatically appends a -i option at the end.
    cmdline_only = ('help ignore|i ipythondir=s Version upgrade '
                    'gthread! qthread! q4thread! wthread! pylab! tk!')

    # Build the actual name list to be used by DPyGetOpt
    opts_names = qw(cmdline_opts) + qw(cmdline_only)

    # Set sensible command line defaults.
    # This should have everything from  cmdline_opts and cmdline_only
    opts_def = Struct(autocall = 1,
                      autoedit_syntax = 0,
                      autoindent = 0,
                      automagic = 1,
                      banner = 1,
                      cache_size = 1000,
                      c = '',
                      classic = 0,
                      colors = 'NoColor',
                      color_info = 0,
                      confirm_exit = 1,
                      debug = 0,
                      deep_reload = 0,
                      editor = '0',
                      help = 0,
                      ignore = 0,
                      ipythondir = ipythondir_def,
                      log = 0,
                      logfile = '',
                      logplay = '',
                      multi_line_specials = 1,
                      messages = 1,
                      object_info_string_level = 0,
                      nosep = 0,
                      pdb = 0,
                      pprint = 0,
                      profile = '',
                      prompt_in1 = 'In [\\#]: ',
                      prompt_in2 = '   .\\D.: ',
                      prompt_out = 'Out[\\#]: ',
                      prompts_pad_left = 1,
                      quiet = 0,
                      quick = 0,
                      readline = 1,
                      readline_merge_completions = 1,
                      readline_omit__names = 0,
                      rcfile = 'ipythonrc' + rc_suffix,
                      screen_length = 0,
                      separate_in = '\n',
                      separate_out = '\n',
                      separate_out2 = '',
                      system_header = 'IPython system call: ',
                      system_verbose = 0,
                      gthread = 0,
                      qthread = 0,
                      q4thread = 0,
                      wthread = 0,
                      pylab = 0,
                      tk = 0,
                      upgrade = 0,
                      Version = 0,
                      xmode = 'Verbose',
                      wildcards_case_sensitive = 1,
                      wxversion = '0',
                      magic_docstrings = 0,  # undocumented, for doc generation
                      )
    
    # Things that will *only* appear in rcfiles (not at the command line).
    # Make sure there's a space before each end of line (they get auto-joined!)
    rcfile_opts = { qwflat: 'include import_mod import_all execfile ',
                    qw_lol: 'import_some ',
                    # for things with embedded whitespace:
                    list_strings:'execute alias readline_parse_and_bind ',
                    # Regular strings need no conversion:
                    None:'readline_remove_delims ',
                    }
    # Default values for these
    rc_def = Struct(include = [],
                    import_mod = [], 
                    import_all = [],
                    import_some = [[]],
                    execute = [],
                    execfile = [],
                    alias = [],
                    readline_parse_and_bind = [],
                    readline_remove_delims = '',
                    )

    # Build the type conversion dictionary from the above tables:
    typeconv = rcfile_opts.copy()
    typeconv.update(optstr2types(cmdline_opts))

    # FIXME: the None key appears in both, put that back together by hand. Ugly!
    typeconv[None] += ' ' + rcfile_opts[None]

    # Remove quotes at ends of all strings (used to protect spaces)
    typeconv[unquote_ends] = typeconv[None]
    del typeconv[None]

    # Build the list we'll use to make all config decisions with defaults:
    opts_all = opts_def.copy()
    opts_all.update(rc_def)

    # Build conflict resolver for recursive loading of config files:
    # - preserve means the outermost file maintains the value, it is not
    # overwritten if an included file has the same key.
    # - add_flip applies + to the two values, so it better make sense to add
    # those types of keys. But it flips them first so that things loaded
    # deeper in the inclusion chain have lower precedence.
    conflict = {'preserve': ' '.join([ typeconv[int],
                                       typeconv[unquote_ends] ]),
                'add_flip': ' '.join([ typeconv[qwflat],
                                       typeconv[qw_lol],
                                       typeconv[list_strings] ])
                }

    # Now actually process the command line
    getopt = DPyGetOpt.DPyGetOpt()
    getopt.setIgnoreCase(0)

    getopt.parseConfiguration(opts_names)

    try:
        getopt.processArguments(argv)
    except:
        print cmd_line_usage
        warn('\nError in Arguments: ' + `sys.exc_value`)
        sys.exit(1)

    # convert the options dict to a struct for much lighter syntax later
    opts = Struct(getopt.optionValues)
    args = getopt.freeValues

    # this is the struct (which has default values at this point) with which
    # we make all decisions:
    opts_all.update(opts)

    # Options that force an immediate exit
    if opts_all.help:
        page(cmd_line_usage)
        sys.exit()

    if opts_all.Version:
        print __version__
        sys.exit()

    if opts_all.magic_docstrings:
        IP.magic_magic('-latex')
        sys.exit()

    # add personal ipythondir to sys.path so that users can put things in
    # there for customization
    sys.path.append(os.path.abspath(opts_all.ipythondir))

    # Create user config directory if it doesn't exist. This must be done
    # *after* getting the cmd line options.
    if not os.path.isdir(opts_all.ipythondir):
        IP.user_setup(opts_all.ipythondir,rc_suffix,'install')

    # upgrade user config files while preserving a copy of the originals
    if opts_all.upgrade:
        IP.user_setup(opts_all.ipythondir,rc_suffix,'upgrade')

    # check mutually exclusive options in the *original* command line
    mutex_opts(opts,[qw('log logfile'),qw('rcfile profile'),
                     qw('classic profile'),qw('classic rcfile')])

    #---------------------------------------------------------------------------
    # Log replay
    
    # if -logplay, we need to 'become' the other session. That basically means
    # replacing the current command line environment with that of the old
    # session and moving on.

    # this is needed so that later we know we're in session reload mode, as
    # opts_all will get overwritten:
    load_logplay = 0

    if opts_all.logplay:
        load_logplay = opts_all.logplay 
        opts_debug_save = opts_all.debug
        try:
            logplay = open(opts_all.logplay)
        except IOError:
            if opts_all.debug: IP.InteractiveTB()
            warn('Could not open logplay file '+`opts_all.logplay`)
            # restore state as if nothing had happened and move on, but make
            # sure that later we don't try to actually load the session file
            logplay = None
            load_logplay = 0
            del opts_all.logplay
        else:
            try: 
                logplay.readline()
                logplay.readline();
                # this reloads that session's command line
                cmd = logplay.readline()[6:] 
                exec cmd
                # restore the true debug flag given so that the process of
                # session loading itself can be monitored.
                opts.debug = opts_debug_save
                # save the logplay flag so later we don't overwrite the log
                opts.logplay = load_logplay
                # now we must update our own structure with defaults
                opts_all.update(opts)
                # now load args
                cmd = logplay.readline()[6:] 
                exec cmd
                logplay.close()
            except:
                logplay.close()
                if opts_all.debug: IP.InteractiveTB()
                warn("Logplay file lacking full configuration information.\n"
                     "I'll try to read it, but some things may not work.")

    #-------------------------------------------------------------------------
    # set up output traps: catch all output from files, being run, modules
    # loaded, etc. Then give it to the user in a clean form at the end.
    
    msg_out = 'Output messages. '
    msg_err = 'Error messages. '
    msg_sep = '\n'
    msg = Struct(config    = OutputTrap('Configuration Loader',msg_out,
                                        msg_err,msg_sep,debug,
                                        quiet_out=1),
                 user_exec = OutputTrap('User File Execution',msg_out,
                                        msg_err,msg_sep,debug),
                 logplay   = OutputTrap('Log Loader',msg_out,
                                        msg_err,msg_sep,debug),
                 summary = ''
                 )

    #-------------------------------------------------------------------------
    # Process user ipythonrc-type configuration files

    # turn on output trapping and log to msg.config
    # remember that with debug on, trapping is actually disabled
    msg.config.trap_all()

    # look for rcfile in current or default directory
    try:
        opts_all.rcfile = filefind(opts_all.rcfile,opts_all.ipythondir)
    except IOError:
        if opts_all.debug:  IP.InteractiveTB()
        warn('Configuration file %s not found. Ignoring request.'
             % (opts_all.rcfile) )

    # 'profiles' are a shorthand notation for config filenames
    if opts_all.profile:
            
        try:
            opts_all.rcfile = filefind('ipythonrc-' + opts_all.profile
                                       + rc_suffix,
                                       opts_all.ipythondir)
        except IOError:
           if opts_all.debug:  IP.InteractiveTB()
           opts.profile = ''  # remove profile from options if invalid
           # We won't warn anymore, primary method is ipy_profile_PROFNAME
           # which does trigger a warning.

    # load the config file
    rcfiledata = None
    if opts_all.quick:
        print 'Launching IPython in quick mode. No config file read.'
    elif opts_all.classic:
        print 'Launching IPython in classic mode. No config file read.'
    elif opts_all.rcfile:
        try:
            cfg_loader = ConfigLoader(conflict)
            rcfiledata = cfg_loader.load(opts_all.rcfile,typeconv,
                                         'include',opts_all.ipythondir,
                                         purge = 1,
                                         unique = conflict['preserve'])
        except:
            IP.InteractiveTB()
            warn('Problems loading configuration file '+
                 `opts_all.rcfile`+
                 '\nStarting with default -bare bones- configuration.')
    else:
        warn('No valid configuration file found in either currrent directory\n'+
             'or in the IPython config. directory: '+`opts_all.ipythondir`+
             '\nProceeding with internal defaults.')

    #------------------------------------------------------------------------
    # Set exception handlers in mode requested by user.
    otrap = OutputTrap(trap_out=1)  # trap messages from magic_xmode
    IP.magic_xmode(opts_all.xmode)
    otrap.release_out()

    #------------------------------------------------------------------------
    # Execute user config

    # Create a valid config structure with the right precedence order:
    # defaults &lt; rcfile &lt; command line.  This needs to be in the instance, so
    # that method calls below that rely on it find it.
    IP.rc = rc_def.copy()

    # Work with a local alias inside this routine to avoid unnecessary
    # attribute lookups.
    IP_rc = IP.rc
    
    IP_rc.update(opts_def)
    if rcfiledata:
        # now we can update 
        IP_rc.update(rcfiledata)
    IP_rc.update(opts)
    IP_rc.update(rc_override)

    # Store the original cmd line for reference:
    IP_rc.opts = opts
    IP_rc.args = args

    # create a *runtime* Struct like rc for holding parameters which may be
    # created and/or modified by runtime user extensions.
    IP.runtime_rc = Struct()

    # from this point on, all config should be handled through IP_rc,
    # opts* shouldn't be used anymore.

    
    # update IP_rc with some special things that need manual
    # tweaks. Basically options which affect other options. I guess this
    # should just be written so that options are fully orthogonal and we
    # wouldn't worry about this stuff!

    if IP_rc.classic:
        IP_rc.quick = 1
        IP_rc.cache_size = 0
        IP_rc.pprint = 0
        IP_rc.prompt_in1 = '&gt;&gt;&gt; '
        IP_rc.prompt_in2 = '... '
        IP_rc.prompt_out = ''
        IP_rc.separate_in = IP_rc.separate_out = IP_rc.separate_out2 = '0'
        IP_rc.colors = 'NoColor'
        IP_rc.xmode = 'Plain'

    IP.pre_config_initialization()
    # configure readline
    # Define the history file for saving commands in between sessions
    if IP_rc.profile:
        histfname = 'history-%s' % IP_rc.profile
    else:
        histfname = 'history'
    IP.histfile = os.path.join(opts_all.ipythondir,histfname)

    # update exception handlers with rc file status
    otrap.trap_out()  # I don't want these messages ever.
    IP.magic_xmode(IP_rc.xmode)
    otrap.release_out()

    # activate logging if requested and not reloading a log
    if IP_rc.logplay:
        IP.magic_logstart(IP_rc.logplay + ' append')
    elif  IP_rc.logfile:
        IP.magic_logstart(IP_rc.logfile)
    elif IP_rc.log:
        IP.magic_logstart()

    # find user editor so that it we don't have to look it up constantly
    if IP_rc.editor.strip()=='0':
        try:
            ed = os.environ['EDITOR']
        except KeyError:
            if os.name == 'posix':
                ed = 'vi'  # the only one guaranteed to be there!
            else:
                ed = 'notepad' # same in Windows!
        IP_rc.editor = ed

    # Keep track of whether this is an embedded instance or not (useful for
    # post-mortems).
    IP_rc.embedded = IP.embedded

    # Recursive reload
    try:
        from IPython import deep_reload
        if IP_rc.deep_reload:
            __builtin__.reload = deep_reload.reload
        else:
            __builtin__.dreload = deep_reload.reload
        del deep_reload
    except ImportError:
        pass

    # Save the current state of our namespace so that the interactive shell
    # can later know which variables have been created by us from config files
    # and loading. This way, loading a file (in any way) is treated just like
    # defining things on the command line, and %who works as expected.

    # DON'T do anything that affects the namespace beyond this point!
    IP.internal_ns.update(__main__.__dict__)

    #IP.internal_ns.update(locals()) # so our stuff doesn't show up in %who

    # Now run through the different sections of the users's config
    if IP_rc.debug:    
        print 'Trying to execute the following configuration structure:'
        print '(Things listed first are deeper in the inclusion tree and get'
        print 'loaded first).\n'
        pprint(IP_rc.__dict__)
        
    for mod in IP_rc.import_mod:
        try:
            exec 'import '+mod in IP.user_ns
        except :
            IP.InteractiveTB()
            import_fail_info(mod)

    for mod_fn in IP_rc.import_some:
        if not mod_fn == []: 
            mod,fn = mod_fn[0],','.join(mod_fn[1:])
            try:
                exec 'from '+mod+' import '+fn in IP.user_ns
            except :
                IP.InteractiveTB()
                import_fail_info(mod,fn)

    for mod in IP_rc.import_all:
        try:
            exec 'from '+mod+' import *' in IP.user_ns
        except :
            IP.InteractiveTB()
            import_fail_info(mod)

    for code in IP_rc.execute:
        try:
            exec code in IP.user_ns
        except:
            IP.InteractiveTB()
            warn('Failure executing code: ' + `code`)

    # Execute the files the user wants in ipythonrc
    for file in IP_rc.execfile:
        try:
            file = filefind(file,sys.path+[IPython_dir])
        except IOError:
            warn(itpl('File $file not found. Skipping it.'))
        else:
            IP.safe_execfile(os.path.expanduser(file),IP.user_ns)

    # finally, try importing ipy_*_conf for final configuration
    try:
        import ipy_system_conf
    except ImportError:
        if opts_all.debug:  IP.InteractiveTB()
        warn("Could not import 'ipy_system_conf'")        
    except:
        IP.InteractiveTB()
        import_fail_info('ipy_system_conf')
        
    if opts_all.profile:
        profmodname = 'ipy_profile_' + opts_all.profile
        try:
            __import__(profmodname)
        except ImportError:
            # only warn if ipythonrc-PROFNAME didn't exist
            if opts.profile =='':
                warn("Could not start with profile '%s'!\n"
                     "('%s/%s.py' does not exist? run '%%upgrade')" %
                     (opts_all.profile, opts_all.ipythondir, profmodname) )
        except:
            print "Error importing",profmodname
            IP.InteractiveTB()
            import_fail_info(profmodname)
                      
    try:    
        import ipy_user_conf
    except ImportError:
        if opts_all.debug:  IP.InteractiveTB()
        warn("Could not import user config!\n "
             "('%s/ipy_user_conf.py' does not exist? Please run '%%upgrade')\n"
             % opts_all.ipythondir)
    except:
        print "Error importing ipy_user_conf"
        IP.InteractiveTB()
        import_fail_info("ipy_user_conf")
    
    # release stdout and stderr and save config log into a global summary
    msg.config.release_all()
    if IP_rc.messages:
        msg.summary += msg.config.summary_all()

    #------------------------------------------------------------------------
    # Setup interactive session

    # Now we should be fully configured. We can then execute files or load
    # things only needed for interactive use. Then we'll open the shell.

    # Take a snapshot of the user namespace before opening the shell. That way
    # we'll be able to identify which things were interactively defined and
    # which were defined through config files.
    IP.user_config_ns = IP.user_ns.copy()

    # Force reading a file as if it were a session log. Slower but safer.
    if load_logplay:
        print 'Replaying log...'
        try:
            if IP_rc.debug:
                logplay_quiet = 0
            else:
                 logplay_quiet = 1

            msg.logplay.trap_all()
            IP.safe_execfile(load_logplay,IP.user_ns,
                             islog = 1, quiet = logplay_quiet)
            msg.logplay.release_all()
            if IP_rc.messages:
                msg.summary += msg.logplay.summary_all()
        except:
            warn('Problems replaying logfile %s.' % load_logplay)
            IP.InteractiveTB()

    # Load remaining files in command line
    msg.user_exec.trap_all()

    # Do NOT execute files named in the command line as scripts to be loaded
    # by embedded instances.  Doing so has the potential for an infinite
    # recursion if there are exceptions thrown in the process.

    # XXX FIXME: the execution of user files should be moved out to after
    # ipython is fully initialized, just as if they were run via %run at the
    # ipython prompt.  This would also give them the benefit of ipython's
    # nice tracebacks.

    if (not embedded and IP_rc.args and 
        not IP_rc.args[0].lower().endswith('.ipy')):
        name_save = IP.user_ns['__name__']
        IP.user_ns['__name__'] = '__main__'
        # Set our own excepthook in case the user code tries to call it
        # directly. This prevents triggering the IPython crash handler.
        old_excepthook,sys.excepthook = sys.excepthook, IP.excepthook

        save_argv = sys.argv[1:] # save it for later restoring
        
        sys.argv = args
        
        try:
            IP.safe_execfile(args[0], IP.user_ns)
        finally:
            # Reset our crash handler in place
            sys.excepthook = old_excepthook
            sys.argv[:] = save_argv
            IP.user_ns['__name__'] = name_save
        
    msg.user_exec.release_all()

    if IP_rc.messages:
        msg.summary += msg.user_exec.summary_all()

    # since we can't specify a null string on the cmd line, 0 is the equivalent:
    if IP_rc.nosep:
        IP_rc.separate_in = IP_rc.separate_out = IP_rc.separate_out2 = '0'
    if IP_rc.separate_in == '0': IP_rc.separate_in = ''
    if IP_rc.separate_out == '0': IP_rc.separate_out = ''
    if IP_rc.separate_out2 == '0': IP_rc.separate_out2 = ''
    IP_rc.separate_in = IP_rc.separate_in.replace('\\n','\n')
    IP_rc.separate_out = IP_rc.separate_out.replace('\\n','\n')
    IP_rc.separate_out2 = IP_rc.separate_out2.replace('\\n','\n')

    # Determine how many lines at the bottom of the screen are needed for
    # showing prompts, so we can know wheter long strings are to be printed or
    # paged:
    num_lines_bot = IP_rc.separate_in.count('\n')+1
    IP_rc.screen_length = IP_rc.screen_length - num_lines_bot

    # configure startup banner
    if IP_rc.c:  # regular python doesn't print the banner with -c
        IP_rc.banner = 0
    if IP_rc.banner:
        BANN_P = IP.BANNER_PARTS
    else:
        BANN_P = []

    if IP_rc.profile: BANN_P.append('IPython profile: %s\n' % IP_rc.profile)

    # add message log (possibly empty)
    if msg.summary: BANN_P.append(msg.summary)
    # Final banner is a string
    IP.BANNER = '\n'.join(BANN_P)

    # Finalize the IPython instance.  This assumes the rc structure is fully
    # in place.
    IP.post_config_initialization()

    return IP
</t>
<t tx="ekr.20071201085751.328"># -*- coding: utf-8 -*-
"""Mimic C structs with lots of extra functionality.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

__all__ = ['Struct']

import types
import pprint

from IPython.genutils import list2dict2

</t>
<t tx="ekr.20071201085751.329">class Struct:
    """Class to mimic C structs but also provide convenient dictionary-like
    functionality.

    Instances can be initialized with a dictionary, a list of key=value pairs
    or both. If both are present, the dictionary must come first.

    Because Python classes provide direct assignment to their members, it's
    easy to overwrite normal methods (S.copy = 1 would destroy access to
    S.copy()). For this reason, all builtin method names are protected and
    can't be assigned to. An attempt to do s.copy=1 or s['copy']=1 will raise
    a KeyError exception. If you really want to, you can bypass this
    protection by directly assigning to __dict__: s.__dict__['copy']=1 will
    still work. Doing this will break functionality, though. As in most of
    Python, namespace protection is weakly enforced, so feel free to shoot
    yourself if you really want to.

    Note that this class uses more memory and is *much* slower than a regular
    dictionary, so be careful in situations where memory or performance are
    critical. But for day to day use it should behave fine. It is particularly
    convenient for storing configuration data in programs.

    +,+=,- and -= are implemented. +/+= do merges (non-destructive updates),
    -/-= remove keys from the original. See the method descripitions.

    This class allows a quick access syntax: both s.key and s['key'] are
    valid.  This syntax has a limitation: each 'key' has to be explicitly
    accessed by its original name. The normal s.key syntax doesn't provide
    access to the keys via variables whose values evaluate to the desired
    keys. An example should clarify this:

    Define a dictionary and initialize both with dict and k=v pairs:
    &gt;&gt;&gt; d={'a':1,'b':2}
    &gt;&gt;&gt; s=Struct(d,hi=10,ho=20)
    The return of __repr__ can be used to create a new instance:
    &gt;&gt;&gt; s
    Struct({'ho': 20, 'b': 2, 'hi': 10, 'a': 1})
    __str__ (called by print) shows it's not quite a regular dictionary:
    &gt;&gt;&gt; print s
    Struct {a: 1, b: 2, hi: 10, ho: 20}
    Access by explicitly named key with dot notation:
    &gt;&gt;&gt; s.a
    1
    Or like a dictionary:
    &gt;&gt;&gt; s['a']
    1
    If you want a variable to hold the key value, only dictionary access works:
    &gt;&gt;&gt; key='hi'
    &gt;&gt;&gt; s.key
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in ?
    AttributeError: Struct instance has no attribute 'key'
    &gt;&gt;&gt; s[key]
    10

    Another limitation of the s.key syntax (and Struct(key=val)
    initialization): keys can't be numbers. But numeric keys can be used and
    accessed using the dictionary syntax. Again, an example:

    This doesn't work:
    &gt;&gt;&gt; s=Struct(4='hi')
    SyntaxError: keyword can't be an expression
    But this does:
    &gt;&gt;&gt; s=Struct()
    &gt;&gt;&gt; s[4]='hi'
    &gt;&gt;&gt; s
    Struct({4: 'hi'})
    &gt;&gt;&gt; s[4]
    'hi'
    """

    # Attributes to which __setitem__ and __setattr__ will block access.
    # Note: much of this will be moot in Python 2.2 and will be done in a much
    # cleaner way.
    __protected = ('copy dict dictcopy get has_attr has_key items keys '
                   'merge popitem setdefault update values '
                   '__make_dict __dict_invert ').split()

    @others
</t>
<t tx="ekr.20071201085751.330">def __init__(self,dict=None,**kw):
    """Initialize with a dictionary, another Struct, or by giving
    explicitly the list of attributes.

    Both can be used, but the dictionary must come first:
    Struct(dict), Struct(k1=v1,k2=v2) or Struct(dict,k1=v1,k2=v2).
    """
    self.__dict__['__allownew'] = True
    if dict is None:
        dict = {}
    if isinstance(dict,Struct):
        dict = dict.dict()
    elif dict and  type(dict) is not types.DictType:
        raise TypeError,\
              'Initialize with a dictionary or key=val pairs.'
    dict.update(kw)
    # do the updating by hand to guarantee that we go through the
    # safety-checked __setitem__
    for k,v in dict.items():
        self[k] = v
    

</t>
<t tx="ekr.20071201085751.331">def __setitem__(self,key,value):
    """Used when struct[key] = val calls are made."""
    if key in Struct.__protected:
        raise KeyError,'Key '+`key`+' is a protected key of class Struct.'
    if not self['__allownew'] and key not in self.__dict__:
        raise KeyError(
        "Can't create unknown attribute %s - Check for typos, or use allow_new_attr to create new attributes!" %
        key)
        
    self.__dict__[key] = value

</t>
<t tx="ekr.20071201085751.332">def __setattr__(self, key, value):
    """Used when struct.key = val calls are made."""
    self.__setitem__(key,value)

</t>
<t tx="ekr.20071201085751.333">def __str__(self):
    """Gets called by print."""
    
    return 'Struct('+ pprint.pformat(self.__dict__)+')'

</t>
<t tx="ekr.20071201085751.334">def __repr__(self):
    """Gets called by repr.
    
    A Struct can be recreated with S_new=eval(repr(S_old))."""
    return self.__str__()

</t>
<t tx="ekr.20071201085751.335">def __getitem__(self,key):
    """Allows struct[key] access."""
    return self.__dict__[key]

</t>
<t tx="ekr.20071201085751.336">def __contains__(self,key):
    """Allows use of the 'in' operator."""
    return self.__dict__.has_key(key)

</t>
<t tx="ekr.20071201085751.337">def __iadd__(self,other):
    """S += S2 is a shorthand for S.merge(S2)."""
    self.merge(other)
    return self

</t>
<t tx="ekr.20071201085751.338">def __add__(self,other):
    """S + S2 -&gt; New Struct made form S and S.merge(S2)"""
    Sout = self.copy()
    Sout.merge(other)
    return Sout

</t>
<t tx="ekr.20071201085751.339">def __sub__(self,other):
    """Return S1-S2, where all keys in S2 have been deleted (if present)
    from S1."""
    Sout = self.copy()
    Sout -= other
    return Sout

</t>
<t tx="ekr.20071201085751.340">def __isub__(self,other):
    """Do in place S = S - S2, meaning all keys in S2 have been deleted
    (if present) from S1."""

    for k in other.keys():
        if self.has_key(k):
            del self.__dict__[k]

</t>
<t tx="ekr.20071201085751.341">def __make_dict(self,__loc_data__,**kw):
    "Helper function for update and merge. Return a dict from data."

    if __loc_data__ == None:
        dict = {}
    elif type(__loc_data__) is types.DictType:
        dict = __loc_data__
    elif isinstance(__loc_data__,Struct):
        dict = __loc_data__.__dict__
    else:
        raise TypeError, 'Update with a dict, a Struct or key=val pairs.'
    if kw:
        dict.update(kw)
    return dict

</t>
<t tx="ekr.20071201085751.342">def __dict_invert(self,dict):
    """Helper function for merge. Takes a dictionary whose values are
    lists and returns a dict. with the elements of each list as keys and
    the original keys as values."""

    outdict = {}
    for k,lst in dict.items():
        if type(lst) is types.StringType:
            lst = lst.split()
        for entry in lst:
            outdict[entry] = k
    return outdict

</t>
<t tx="ekr.20071201085751.343">def clear(self):
    """Clear all attributes."""
    self.__dict__.clear()

</t>
<t tx="ekr.20071201085751.344">def copy(self):
    """Return a (shallow) copy of a Struct."""
    return Struct(self.__dict__.copy())

</t>
<t tx="ekr.20071201085751.345">def dict(self):
    """Return the Struct's dictionary."""
    return self.__dict__

</t>
<t tx="ekr.20071201085751.346">def dictcopy(self):
    """Return a (shallow) copy of the Struct's dictionary."""
    return self.__dict__.copy()

</t>
<t tx="ekr.20071201085751.347">def popitem(self):
    """S.popitem() -&gt; (k, v), remove and return some (key, value) pair as
    a 2-tuple; but raise KeyError if S is empty."""
    return self.__dict__.popitem()

</t>
<t tx="ekr.20071201085751.348">def update(self,__loc_data__=None,**kw):
    """Update (merge) with data from another Struct or from a dictionary.
    Optionally, one or more key=value pairs can be given at the end for
    direct update."""

    # The funny name __loc_data__ is to prevent a common variable name which
    # could be a fieled of a Struct to collide with this parameter. The problem
    # would arise if the function is called with a keyword with this same name
    # that a user means to add as a Struct field.
    newdict = Struct.__make_dict(self,__loc_data__,**kw)
    for k,v in newdict.items():
        self[k] = v

</t>
<t tx="ekr.20071201085751.349">def merge(self,__loc_data__=None,__conflict_solve=None,**kw):
    """S.merge(data,conflict,k=v1,k=v2,...) -&gt; merge data and k=v into S.

    This is similar to update(), but much more flexible.  First, a dict is
    made from data+key=value pairs. When merging this dict with the Struct
    S, the optional dictionary 'conflict' is used to decide what to do.

    If conflict is not given, the default behavior is to preserve any keys
    with their current value (the opposite of the update method's
    behavior).

    conflict is a dictionary of binary functions which will be used to
    solve key conflicts. It must have the following structure:

      conflict == { fn1 : [Skey1,Skey2,...], fn2 : [Skey3], etc }

    Values must be lists or whitespace separated strings which are
    automatically converted to lists of strings by calling string.split().

    Each key of conflict is a function which defines a policy for
    resolving conflicts when merging with the input data. Each fn must be
    a binary function which returns the desired outcome for a key
    conflict. These functions will be called as fn(old,new).

    An example is probably in order. Suppose you are merging the struct S
    with a dict D and the following conflict policy dict:

        S.merge(D,{fn1:['a','b',4], fn2:'key_c key_d'})

    If the key 'a' is found in both S and D, the merge method will call:

        S['a'] = fn1(S['a'],D['a'])

    As a convenience, merge() provides five (the most commonly needed)
    pre-defined policies: preserve, update, add, add_flip and add_s. The
    easiest explanation is their implementation:

      preserve = lambda old,new: old
      update   = lambda old,new: new
      add      = lambda old,new: old + new
      add_flip = lambda old,new: new + old  # note change of order!
      add_s    = lambda old,new: old + ' ' + new  # only works for strings!

    You can use those four words (as strings) as keys in conflict instead
    of defining them as functions, and the merge method will substitute
    the appropriate functions for you. That is, the call

      S.merge(D,{'preserve':'a b c','add':[4,5,'d'],my_function:[6]})

    will automatically substitute the functions preserve and add for the
    names 'preserve' and 'add' before making any function calls.

    For more complicated conflict resolution policies, you still need to
    construct your own functions. """

    data_dict = Struct.__make_dict(self,__loc_data__,**kw)

    # policies for conflict resolution: two argument functions which return
    # the value that will go in the new struct
    preserve = lambda old,new: old
    update   = lambda old,new: new
    add      = lambda old,new: old + new
    add_flip = lambda old,new: new + old  # note change of order!
    add_s    = lambda old,new: old + ' ' + new

    # default policy is to keep current keys when there's a conflict
    conflict_solve = list2dict2(self.keys(),default = preserve)

    # the conflict_solve dictionary is given by the user 'inverted': we
    # need a name-function mapping, it comes as a function -&gt; names
    # dict. Make a local copy (b/c we'll make changes), replace user
    # strings for the three builtin policies and invert it.
    if __conflict_solve:
        inv_conflict_solve_user = __conflict_solve.copy()
        for name, func in [('preserve',preserve), ('update',update),
                           ('add',add), ('add_flip',add_flip), ('add_s',add_s)]:
            if name in inv_conflict_solve_user.keys():
                inv_conflict_solve_user[func] = inv_conflict_solve_user[name]
                del inv_conflict_solve_user[name]
        conflict_solve.update(Struct.__dict_invert(self,inv_conflict_solve_user))
    #print 'merge. conflict_solve: '; pprint(conflict_solve) # dbg
    #print '*'*50,'in merger. conflict_solver:';  pprint(conflict_solve)
    for key in data_dict:
        if key not in self:
            self[key] = data_dict[key]
        else:
            self[key] = conflict_solve[key](self[key],data_dict[key])

</t>
<t tx="ekr.20071201085751.350">def has_key(self,key):
    """Like has_key() dictionary method."""
    return self.__dict__.has_key(key)

</t>
<t tx="ekr.20071201085751.351">def hasattr(self,key):
    """hasattr function available as a method.

    Implemented like has_key, to make sure that all available keys in the
    internal dictionary of the Struct appear also as attributes (even
    numeric keys)."""
    return self.__dict__.has_key(key)

</t>
<t tx="ekr.20071201085751.352">def items(self):
    """Return the items in the Struct's dictionary, in the same format
    as a call to {}.items()."""
    return self.__dict__.items()

</t>
<t tx="ekr.20071201085751.353">def keys(self):
    """Return the keys in the Struct's dictionary, in the same format
    as a call to {}.keys()."""
    return self.__dict__.keys()

</t>
<t tx="ekr.20071201085751.354">def values(self,keys=None):
    """Return the values in the Struct's dictionary, in the same format
    as a call to {}.values().

    Can be called with an optional argument keys, which must be a list or
    tuple of keys. In this case it returns only the values corresponding
    to those keys (allowing a form of 'slicing' for Structs)."""
    if not keys:
        return self.__dict__.values()
    else:
        ret=[]
        for k in keys:
            ret.append(self[k])
        return ret

</t>
<t tx="ekr.20071201085751.355">def get(self,attr,val=None):
    """S.get(k[,d]) -&gt; S[k] if S.has_key(k), else d.  d defaults to None."""
    try:
        return self[attr]
    except KeyError:
        return val

</t>
<t tx="ekr.20071201085751.356">def setdefault(self,attr,val=None):
    """S.setdefault(k[,d]) -&gt; S.get(k,d), also set S[k]=d if not S.has_key(k)"""
    if not self.has_key(attr):
        self[attr] = val
    return self.get(attr,val)

</t>
<t tx="ekr.20071201085751.357">def allow_new_attr(self, allow = True):
    """ Set whether new attributes can be created inside struct
    
    This can be used to catch typos by verifying that the attribute user tries to 
    change already exists in this Struct.
    """
    self['__allownew'] = allow
    
    
</t>
<t tx="ekr.20071201085751.358"># -*- coding: utf-8 -*-
"""String interpolation for Python (by Ka-Ping Yee, 14 Feb 2000).

This module lets you quickly and conveniently interpolate values into
strings (in the flavour of Perl or Tcl, but with less extraneous
punctuation).  You get a bit more power than in the other languages,
because this module allows subscripting, slicing, function calls,
attribute lookup, or arbitrary expressions.  Variables and expressions
are evaluated in the namespace of the caller.

The itpl() function returns the result of interpolating a string, and
printpl() prints out an interpolated string.  Here are some examples:

    from Itpl import printpl
    printpl("Here is a $string.")
    printpl("Here is a $module.member.")
    printpl("Here is an $object.member.")
    printpl("Here is a $functioncall(with, arguments).")
    printpl("Here is an ${arbitrary + expression}.")
    printpl("Here is an $array[3] member.")
    printpl("Here is a $dictionary['member'].")

The filter() function filters a file object so that output through it
is interpolated.  This lets you produce the illusion that Python knows
how to do interpolation:

    import Itpl
    sys.stdout = Itpl.filter()
    f = "fancy"
    print "Isn't this $f?"
    print "Standard output has been replaced with a $sys.stdout object."
    sys.stdout = Itpl.unfilter()
    print "Okay, back $to $normal."

Under the hood, the Itpl class represents a string that knows how to
interpolate values.  An instance of the class parses the string once
upon initialization; the evaluation and substitution can then be done
each time the instance is evaluated with str(instance).  For example:

    from Itpl import Itpl
    s = Itpl("Here is $foo.")
    foo = 5
    print str(s)
    foo = "bar"
    print str(s)

$Id$
"""                   # ' -&gt; close an open quote for stupid emacs

#*****************************************************************************
#
# Copyright (c) 2001 Ka-Ping Yee &lt;ping@lfw.org&gt;
#
#
# Published under the terms of the MIT license, hereby reproduced:
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
#*****************************************************************************

__author__  = 'Ka-Ping Yee &lt;ping@lfw.org&gt;'
__license__ = 'MIT'

import string
import sys
from tokenize import tokenprog
from types import StringType

</t>
<t tx="ekr.20071201085751.359">class ItplError(ValueError):
    @others
</t>
<t tx="ekr.20071201085751.360">def __init__(self, text, pos):
    self.text = text
    self.pos = pos
</t>
<t tx="ekr.20071201085751.361">def __str__(self):
    return "unfinished expression in %s at char %d" % (
        repr(self.text), self.pos)

</t>
<t tx="ekr.20071201085751.362">def matchorfail(text, pos):
    match = tokenprog.match(text, pos)
    if match is None:
        raise ItplError(text, pos)
    return match, match.end()

</t>
<t tx="ekr.20071201085751.363">class Itpl:
    """Class representing a string with interpolation abilities.
    
    Upon creation, an instance works out what parts of the format
    string are literal and what parts need to be evaluated.  The
    evaluation and substitution happens in the namespace of the
    caller when str(instance) is called."""
    @others
</t>
<t tx="ekr.20071201085751.364">
def __init__(self, format,codec='utf_8',encoding_errors='backslashreplace'):
    """The single mandatory argument to this constructor is a format
    string.

    The format string is parsed according to the following rules:

    1.  A dollar sign and a name, possibly followed by any of: 
          - an open-paren, and anything up to the matching paren 
          - an open-bracket, and anything up to the matching bracket 
          - a period and a name 
        any number of times, is evaluated as a Python expression.

    2.  A dollar sign immediately followed by an open-brace, and
        anything up to the matching close-brace, is evaluated as
        a Python expression.

    3.  Outside of the expressions described in the above two rules,
        two dollar signs in a row give you one literal dollar sign.

    Optional arguments:

    - codec('utf_8'): a string containing the name of a valid Python
    codec.

    - encoding_errors('backslashreplace'): a string with a valid error handling
    policy.  See the codecs module documentation for details.

    These are used to encode the format string if a call to str() fails on
    the expanded result."""

    if not isinstance(format,basestring):
        raise TypeError, "needs string initializer"
    self.format = format
    self.codec = codec
    self.encoding_errors = encoding_errors
    
    namechars = "abcdefghijklmnopqrstuvwxyz" \
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";
    chunks = []
    pos = 0

    while 1:
        dollar = string.find(format, "$", pos)
        if dollar &lt; 0: break
        nextchar = format[dollar+1]

        if nextchar == "{":
            chunks.append((0, format[pos:dollar]))
            pos, level = dollar+2, 1
            while level:
                match, pos = matchorfail(format, pos)
                tstart, tend = match.regs[3]
                token = format[tstart:tend]
                if token == "{": level = level+1
                elif token == "}": level = level-1
            chunks.append((1, format[dollar+2:pos-1]))

        elif nextchar in namechars:
            chunks.append((0, format[pos:dollar]))
            match, pos = matchorfail(format, dollar+1)
            while pos &lt; len(format):
                if format[pos] == "." and \
                    pos+1 &lt; len(format) and format[pos+1] in namechars:
                    match, pos = matchorfail(format, pos+1)
                elif format[pos] in "([":
                    pos, level = pos+1, 1
                    while level:
                        match, pos = matchorfail(format, pos)
                        tstart, tend = match.regs[3]
                        token = format[tstart:tend]
                        if token[0] in "([": level = level+1
                        elif token[0] in ")]": level = level-1
                else: break
            chunks.append((1, format[dollar+1:pos]))

        else:
            chunks.append((0, format[pos:dollar+1]))
            pos = dollar + 1 + (nextchar == "$")

    if pos &lt; len(format): chunks.append((0, format[pos:]))
    self.chunks = chunks

</t>
<t tx="ekr.20071201085751.365">def __repr__(self):
    return "&lt;Itpl %s &gt;" % repr(self.format)

</t>
<t tx="ekr.20071201085751.366">def _str(self,glob,loc):
    """Evaluate to a string in the given globals/locals.

    The final output is built by calling str(), but if this fails, the
    result is encoded with the instance's codec and error handling policy,
    via a call to out.encode(self.codec,self.encoding_errors)"""
    result = []
    app = result.append
    for live, chunk in self.chunks:
        if live: app(str(eval(chunk,glob,loc)))
        else: app(chunk)
    out = ''.join(result)
    try:
        return str(out)
    except UnicodeError:
        return out.encode(self.codec,self.encoding_errors)

</t>
<t tx="ekr.20071201085751.367">def __str__(self):
    """Evaluate and substitute the appropriate parts of the string."""

    # We need to skip enough frames to get to the actual caller outside of
    # Itpl.
    frame = sys._getframe(1)
    while frame.f_globals["__name__"] == __name__: frame = frame.f_back
    loc, glob = frame.f_locals, frame.f_globals

    return self._str(glob,loc)

</t>
<t tx="ekr.20071201085751.368">class ItplNS(Itpl):
    """Class representing a string with interpolation abilities.

    This inherits from Itpl, but at creation time a namespace is provided
    where the evaluation will occur.  The interpolation becomes a bit more
    efficient, as no traceback needs to be extracte.  It also allows the
    caller to supply a different namespace for the interpolation to occur than
    its own."""
    @others
</t>
<t tx="ekr.20071201085751.369">
def __init__(self, format,globals,locals=None,
             codec='utf_8',encoding_errors='backslashreplace'):
    """ItplNS(format,globals[,locals]) -&gt; interpolating string instance.

    This constructor, besides a format string, takes a globals dictionary
    and optionally a locals (which defaults to globals if not provided).

    For further details, see the Itpl constructor."""

    if locals is None:
        locals = globals
    self.globals = globals
    self.locals = locals
    Itpl.__init__(self,format,codec,encoding_errors)
    
</t>
<t tx="ekr.20071201085751.370">def __str__(self):
    """Evaluate and substitute the appropriate parts of the string."""
    return self._str(self.globals,self.locals)

</t>
<t tx="ekr.20071201085751.371">def __repr__(self):
    return "&lt;ItplNS %s &gt;" % repr(self.format)

</t>
<t tx="ekr.20071201085751.372"># utilities for fast printing
def itpl(text): return str(Itpl(text))
</t>
<t tx="ekr.20071201085751.373">def printpl(text): print itpl(text)
</t>
<t tx="ekr.20071201085751.374"># versions with namespace
def itplns(text,globals,locals=None): return str(ItplNS(text,globals,locals))
</t>
<t tx="ekr.20071201085751.375">def printplns(text,globals,locals=None): print itplns(text,globals,locals)

</t>
<t tx="ekr.20071201085751.376">class ItplFile:
    """A file object that filters each write() through an interpolator."""
    @others
</t>
<t tx="ekr.20071201085751.377">def __init__(self, file): self.file = file
</t>
<t tx="ekr.20071201085751.378">def __repr__(self): return "&lt;interpolated " + repr(self.file) + "&gt;"
</t>
<t tx="ekr.20071201085751.379">def __getattr__(self, attr): return getattr(self.file, attr)
</t>
<t tx="ekr.20071201085751.380">def write(self, text): self.file.write(str(Itpl(text)))

</t>
<t tx="ekr.20071201085751.381">def filter(file=sys.stdout):
    """Return an ItplFile that filters writes to the given file object.
    
    'file = filter(file)' replaces 'file' with a filtered object that
    has a write() method.  When called with no argument, this creates
    a filter to sys.stdout."""
    return ItplFile(file)

</t>
<t tx="ekr.20071201085751.382">def unfilter(ifile=None):
    """Return the original file that corresponds to the given ItplFile.
    
    'file = unfilter(file)' undoes the effect of 'file = filter(file)'.
    'sys.stdout = unfilter()' undoes the effect of 'sys.stdout = filter()'."""
    return ifile and ifile.file or sys.stdout.file
</t>
<t tx="ekr.20071201085751.383">"""Support for interactive macros in IPython"""

</t>
<t tx="ekr.20071201085751.384">#*****************************************************************************
#       Copyright (C) 2001-2005 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

class Macro:
    """Simple class to store the value of macros as strings.

    This allows us to later exec them by checking when something is an
    instance of this class."""
    @others
</t>
<t tx="ekr.20071201085751.385">
def __init__(self,data):

    # store the macro value, as a single string which can be evaluated by
    # runlines()
    self.value = ''.join(data).rstrip()+'\n'

</t>
<t tx="ekr.20071201085751.386">def __str__(self):
    return self.value

</t>
<t tx="ekr.20071201085751.387">def __repr__(self):
    return 'IPython.macro.Macro(%s)' % repr(self.value)
</t>
<t tx="ekr.20071201085751.388"># -*- coding: utf-8 -*-
"""
A set of convenient utilities for numerical work.

Most of this module requires Numerical Python or is meant to be used with it.
See http://www.pfdubois.com/numpy for details.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2005 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

__all__ = ['sum_flat','mean_flat','rms_flat','base_repr','binary_repr',
           'amin','amax','amap','zeros_like','empty_like',
           'frange','diagonal_matrix','identity',
           'fromfunction_kw','log2','ispower2',
           'norm','l1norm','l2norm','exp_safe',
           'inf','infty','Infinity',
           'Numeric']

#****************************************************************************
# required modules
import __main__
import math
import operator
import sys

import Numeric
from Numeric import *

#*****************************************************************************
# Globals

# useful for testing infinities in results of array divisions (which don't
# raise an exception)
# Python, LaTeX and Mathematica names.
inf = infty = Infinity = (array([1])/0.0)[0]

#****************************************************************************
# function definitions        
exp_safe_MIN = math.log(2.2250738585072014e-308)
exp_safe_MAX = 1.7976931348623157e+308

</t>
<t tx="ekr.20071201085751.389">def exp_safe(x):
    """Compute exponentials which safely underflow to zero.

    Slow but convenient to use. Note that NumArray will introduce proper
    floating point exception handling with access to the underlying
    hardware."""

    if type(x) is ArrayType:
        return exp(clip(x,exp_safe_MIN,exp_safe_MAX))
    else:
        return math.exp(x)

</t>
<t tx="ekr.20071201085751.390">def amap(fn,*args):
    """amap(function, sequence[, sequence, ...]) -&gt; array.

    Works like map(), but it returns an array.  This is just a convenient
    shorthand for Numeric.array(map(...))"""
    return array(map(fn,*args))

</t>
<t tx="ekr.20071201085751.391">def amin(m,axis=0):
    """amin(m,axis=0) returns the minimum of m along dimension axis.
    """
    return minimum.reduce(asarray(m),axis)

</t>
<t tx="ekr.20071201085751.392">def amax(m,axis=0):
    """amax(m,axis=0) returns the maximum of m along dimension axis.
    """
    return maximum.reduce(asarray(m),axis)

</t>
<t tx="ekr.20071201085751.393">def zeros_like(a):
    """Return an array of zeros of the shape and typecode of a.

    If you don't explicitly need the array to be zeroed, you should instead
    use empty_like(), which is faster as it only allocates memory."""

    return zeros(a.shape,a.typecode())

</t>
<t tx="ekr.20071201085751.394">def empty_like(a):
    """Return an empty (uninitialized) array of the shape and typecode of a.

    Note that this does NOT initialize the returned array.  If you require
    your array to be initialized, you should use zeros_like().

    This requires Numeric.empty(), which appeared in Numeric 23.7."""

    return empty(a.shape,a.typecode())

</t>
<t tx="ekr.20071201085751.395">def sum_flat(a):
    """Return the sum of all the elements of a, flattened out.

    It uses a.flat, and if a is not contiguous, a call to ravel(a) is made."""

    if a.iscontiguous():
        return Numeric.sum(a.flat)
    else:
        return Numeric.sum(ravel(a))

</t>
<t tx="ekr.20071201085751.396">def mean_flat(a):
    """Return the mean of all the elements of a, flattened out."""

    return sum_flat(a)/float(size(a))

</t>
<t tx="ekr.20071201085751.397">def rms_flat(a):
    """Return the root mean square of all the elements of a, flattened out."""

    return math.sqrt(sum_flat(absolute(a)**2)/float(size(a)))

</t>
<t tx="ekr.20071201085751.398">def l1norm(a):
    """Return the l1 norm of a, flattened out.

    Implemented as a separate function (not a call to norm() for speed).

    Ref: http://mathworld.wolfram.com/L1-Norm.html"""

    return sum_flat(absolute(a))

</t>
<t tx="ekr.20071201085751.399">def l2norm(a):
    """Return the l2 norm of a, flattened out.

    Implemented as a separate function (not a call to norm() for speed).

    Ref: http://mathworld.wolfram.com/L2-Norm.html"""

    return math.sqrt(sum_flat(absolute(a)**2))

</t>
<t tx="ekr.20071201085751.400">def norm(a,p=2):
    """norm(a,p=2) -&gt; l-p norm of a.flat

    Return the l-p norm of a, considered as a flat array.  This is NOT a true
    matrix norm, since arrays of arbitrary rank are always flattened.

    p can be a number or one of the strings ('inf','Infinity') to get the
    L-infinity norm.

    Ref: http://mathworld.wolfram.com/VectorNorm.html
         http://mathworld.wolfram.com/L-Infinity-Norm.html"""
    
    if p in ('inf','Infinity'):
        return max(absolute(a).flat)
    else:
        return (sum_flat(absolute(a)**p))**(1.0/p)    
    
</t>
<t tx="ekr.20071201085751.401">def frange(xini,xfin=None,delta=None,**kw):
    """frange([start,] stop[, step, keywords]) -&gt; array of floats

    Return a Numeric array() containing a progression of floats. Similar to
    arange(), but defaults to a closed interval.

    frange(x0, x1) returns [x0, x0+1, x0+2, ..., x1]; start defaults to 0, and
    the endpoint *is included*. This behavior is different from that of
    range() and arange(). This is deliberate, since frange will probably be
    more useful for generating lists of points for function evaluation, and
    endpoints are often desired in this use. The usual behavior of range() can
    be obtained by setting the keyword 'closed=0', in this case frange()
    basically becomes arange().

    When step is given, it specifies the increment (or decrement). All
    arguments can be floating point numbers.

    frange(x0,x1,d) returns [x0,x0+d,x0+2d,...,xfin] where xfin&lt;=x1.

    frange can also be called with the keyword 'npts'. This sets the number of
    points the list should contain (and overrides the value 'step' might have
    been given). arange() doesn't offer this option.

    Examples:
    &gt;&gt;&gt; frange(3)
    array([ 0.,  1.,  2.,  3.])
    &gt;&gt;&gt; frange(3,closed=0)
    array([ 0.,  1.,  2.])
    &gt;&gt;&gt; frange(1,6,2)
    array([1, 3, 5])
    &gt;&gt;&gt; frange(1,6.5,npts=5)
    array([ 1.   ,  2.375,  3.75 ,  5.125,  6.5  ])
    """

    #defaults
    kw.setdefault('closed',1)
    endpoint = kw['closed'] != 0
        
    # funny logic to allow the *first* argument to be optional (like range())
    # This was modified with a simpler version from a similar frange() found
    # at http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66472
    if xfin == None:
        xfin = xini + 0.0
        xini = 0.0
        
    if delta == None:
        delta = 1.0

    # compute # of points, spacing and return final list
    try:
        npts=kw['npts']
        delta=(xfin-xini)/float(npts-endpoint)
    except KeyError:
        # round() gets npts right even with the vagaries of floating point.
        npts=int(round((xfin-xini)/delta+endpoint))

    return arange(npts)*delta+xini

</t>
<t tx="ekr.20071201085751.402">def diagonal_matrix(diag):
    """Return square diagonal matrix whose non-zero elements are given by the
    input array."""

    return diag*identity(len(diag))

</t>
<t tx="ekr.20071201085751.403">def identity(n,rank=2,typecode='l'):
    """identity(n,r) returns the identity matrix of shape (n,n,...,n) (rank r).

    For ranks higher than 2, this object is simply a multi-index Kronecker
    delta:
                        /  1  if i0=i1=...=iR,
    id[i0,i1,...,iR] = -|
                        \  0  otherwise.

    Optionally a typecode may be given (it defaults to 'l').

    Since rank defaults to 2, this function behaves in the default case (when
    only n is given) like the Numeric identity function."""
    
    iden = zeros((n,)*rank,typecode=typecode)
    for i in range(n):
        idx = (i,)*rank
        iden[idx] = 1
    return iden

</t>
<t tx="ekr.20071201085751.404">def base_repr (number, base = 2, padding = 0):
    """Return the representation of a number in any given base."""
    chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    if number &lt; base: \
       return (padding - 1) * chars [0] + chars [int (number)]
    max_exponent = int (math.log (number)/math.log (base))
    max_power = long (base) ** max_exponent
    lead_digit = int (number/max_power)
    return chars [lead_digit] + \
           base_repr (number - max_power * lead_digit, base, \
                      max (padding - 1, max_exponent))

</t>
<t tx="ekr.20071201085751.405">def binary_repr(number, max_length = 1025):
    """Return the binary representation of the input number as a string.

    This is more efficient than using base_repr with base 2.

    Increase the value of max_length for very large numbers. Note that on
    32-bit machines, 2**1023 is the largest integer power of 2 which can be
    converted to a Python float."""
    
    assert number &lt; 2L &lt;&lt; max_length
    shifts = map (operator.rshift, max_length * [number], \
                  range (max_length - 1, -1, -1))
    digits = map (operator.mod, shifts, max_length * [2])
    if not digits.count (1): return 0
    digits = digits [digits.index (1):]
    return ''.join (map (repr, digits)).replace('L','')

</t>
<t tx="ekr.20071201085751.406">def log2(x,ln2 = math.log(2.0)):
    """Return the log(x) in base 2.
    
    This is a _slow_ function but which is guaranteed to return the correct
    integer value if the input is an ineger exact power of 2."""

    try:
        bin_n = binary_repr(x)[1:]
    except (AssertionError,TypeError):
        return math.log(x)/ln2
    else:
        if '1' in bin_n:
            return math.log(x)/ln2
        else:
            return len(bin_n)

</t>
<t tx="ekr.20071201085751.407">def ispower2(n):
    """Returns the log base 2 of n if n is a power of 2, zero otherwise.

    Note the potential ambiguity if n==1: 2**0==1, interpret accordingly."""

    bin_n = binary_repr(n)[1:]
    if '1' in bin_n:
        return 0
    else:
        return len(bin_n)

</t>
<t tx="ekr.20071201085751.408">def fromfunction_kw(function, dimensions, **kwargs):
    """Drop-in replacement for fromfunction() from Numerical Python.
 
    Allows passing keyword arguments to the desired function.

    Call it as (keywords are optional):
    fromfunction_kw(MyFunction, dimensions, keywords)

    The function MyFunction() is responsible for handling the dictionary of
    keywords it will recieve."""

    return function(tuple(indices(dimensions)),**kwargs)

</t>
<t tx="ekr.20071201085751.409"># -*- coding: utf-8 -*-
"""Tools for inspecting Python objects.

Uses syntax highlighting for presenting the various information elements.

Similar in spirit to the inspect module, but all calls take a name argument to
reference the name under which an object is being read.

$Id$
"""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

__all__ = ['Inspector','InspectColors']

# stdlib modules
import __builtin__
import inspect
import linecache
import string
import StringIO
import types
import os
import sys
# IPython's own
from IPython import PyColorize
from IPython.genutils import page,indent,Term,mkdict
from IPython.Itpl import itpl
from IPython.wildcard import list_namespace
from IPython.ColorANSI import *

#****************************************************************************
# HACK!!! This is a crude fix for bugs in python 2.3's inspect module.  We
# simply monkeypatch inspect with code copied from python 2.4.
if sys.version_info[:2] == (2,3):
    from inspect import ismodule, getabsfile, modulesbyfile
    def getmodule(object):
        """Return the module an object was defined in, or None if not found."""
        if ismodule(object):
            return object
        if hasattr(object, '__module__'):
            return sys.modules.get(object.__module__)
        try:
            file = getabsfile(object)
        except TypeError:
            return None
        if file in modulesbyfile:
            return sys.modules.get(modulesbyfile[file])
        for module in sys.modules.values():
            if hasattr(module, '__file__'):
                modulesbyfile[
                    os.path.realpath(
                            getabsfile(module))] = module.__name__
        if file in modulesbyfile:
            return sys.modules.get(modulesbyfile[file])
        main = sys.modules['__main__']
        if not hasattr(object, '__name__'):
            return None
        if hasattr(main, object.__name__):
            mainobject = getattr(main, object.__name__)
            if mainobject is object:
                return main
        builtin = sys.modules['__builtin__']
        if hasattr(builtin, object.__name__):
            builtinobject = getattr(builtin, object.__name__)
            if builtinobject is object:
                return builtin

    inspect.getmodule = getmodule

#****************************************************************************
# Builtin color schemes

Colors = TermColors  # just a shorthand

# Build a few color schemes
NoColor = ColorScheme(
    'NoColor',{
    'header' : Colors.NoColor,
    'normal' : Colors.NoColor  # color off (usu. Colors.Normal)
    }  )

LinuxColors = ColorScheme(
    'Linux',{
    'header' : Colors.LightRed,
    'normal' : Colors.Normal  # color off (usu. Colors.Normal)
    } )

LightBGColors = ColorScheme(
    'LightBG',{
    'header' : Colors.Red,
    'normal' : Colors.Normal  # color off (usu. Colors.Normal)
    }  )

# Build table of color schemes (needed by the parser)
InspectColors = ColorSchemeTable([NoColor,LinuxColors,LightBGColors],
                                 'Linux')

</t>
<t tx="ekr.20071201085751.410">#****************************************************************************
# Auxiliary functions
def getdoc(obj):
    """Stable wrapper around inspect.getdoc.

    This can't crash because of attribute problems.

    It also attempts to call a getdoc() method on the given object.  This
    allows objects which provide their docstrings via non-standard mechanisms
    (like Pyro proxies) to still be inspected by ipython's ? system."""

    ds = None  # default return value
    try:
        ds = inspect.getdoc(obj)
    except:
        # Harden against an inspect failure, which can occur with
        # SWIG-wrapped extensions.
        pass
    # Allow objects to offer customized documentation via a getdoc method:
    try:
        ds2 = obj.getdoc()
    except:
        pass
    else:
        # if we get extra info, we add it to the normal docstring.
        if ds is None:
            ds = ds2
        else:
            ds = '%s\n%s' % (ds,ds2)
    return ds

</t>
<t tx="ekr.20071201085751.411">def getsource(obj,is_binary=False):
    """Wrapper around inspect.getsource.

    This can be modified by other projects to provide customized source
    extraction.

    Inputs:

    - obj: an object whose source code we will attempt to extract.

    Optional inputs:

    - is_binary: whether the object is known to come from a binary source.
    This implementation will skip returning any output for binary objects, but
    custom extractors may know how to meaninfully process them."""
    
    if is_binary:
        return None
    else:
        return inspect.getsource(obj)

</t>
<t tx="ekr.20071201085751.412">#****************************************************************************
# Class definitions

class myStringIO(StringIO.StringIO):
    """Adds a writeln method to normal StringIO."""
    @others
</t>
<t tx="ekr.20071201085751.413">def writeln(self,*arg,**kw):
    """Does a write() and then a write('\n')"""
    self.write(*arg,**kw)
    self.write('\n')

</t>
<t tx="ekr.20071201085751.414">class Inspector:
    @others
</t>
<t tx="ekr.20071201085751.415">def __init__(self,color_table,code_color_table,scheme,
             str_detail_level=0):
    self.color_table = color_table
    self.parser = PyColorize.Parser(code_color_table,out='str')
    self.format = self.parser.format
    self.str_detail_level = str_detail_level
    self.set_active_scheme(scheme)

</t>
<t tx="ekr.20071201085751.416">def __getargspec(self,obj):
    """Get the names and default values of a function's arguments.

    A tuple of four things is returned: (args, varargs, varkw, defaults).
    'args' is a list of the argument names (it may contain nested lists).
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'defaults' is an n-tuple of the default values of the last n arguments.

    Modified version of inspect.getargspec from the Python Standard
    Library."""

    if inspect.isfunction(obj):
        func_obj = obj
    elif inspect.ismethod(obj):
        func_obj = obj.im_func
    else:
        raise TypeError, 'arg is not a Python function'
    args, varargs, varkw = inspect.getargs(func_obj.func_code)
    return args, varargs, varkw, func_obj.func_defaults

</t>
<t tx="ekr.20071201085751.417">def __getdef(self,obj,oname=''):
    """Return the definition header for any callable object.

    If any exception is generated, None is returned instead and the
    exception is suppressed."""
    
    try:
        return oname + inspect.formatargspec(*self.__getargspec(obj))
    except:
        return None

</t>
<t tx="ekr.20071201085751.418">def __head(self,h):
    """Return a header string with proper colors."""
    return '%s%s%s' % (self.color_table.active_colors.header,h,
                       self.color_table.active_colors.normal)

</t>
<t tx="ekr.20071201085751.419">def set_active_scheme(self,scheme):
    self.color_table.set_active_scheme(scheme)
    self.parser.color_table.set_active_scheme(scheme)

</t>
<t tx="ekr.20071201085751.420">def noinfo(self,msg,oname):
    """Generic message when no information is found."""
    print 'No %s found' % msg,
    if oname:
        print 'for %s' % oname
    else:
        print
        
</t>
<t tx="ekr.20071201085751.421">def pdef(self,obj,oname=''):
    """Print the definition header for any callable object.

    If the object is a class, print the constructor information."""

    if not callable(obj):
        print 'Object is not callable.'
        return

    header = ''
    if type(obj) is types.ClassType:
        header = self.__head('Class constructor information:\n')
        obj = obj.__init__
    elif type(obj) is types.InstanceType:
        obj = obj.__call__

    output = self.__getdef(obj,oname)
    if output is None:
        self.noinfo('definition header',oname)
    else:
        print &gt;&gt;Term.cout, header,self.format(output),

</t>
<t tx="ekr.20071201085751.422">def pdoc(self,obj,oname='',formatter = None):
    """Print the docstring for any object.

    Optional:
    -formatter: a function to run the docstring through for specially
    formatted docstrings."""
    
    head = self.__head  # so that itpl can find it even if private
    ds = getdoc(obj)
    if formatter:
        ds = formatter(ds)
    if type(obj) is types.ClassType:
        init_ds = getdoc(obj.__init__)
        output = itpl('$head("Class Docstring:")\n'
                      '$indent(ds)\n'
                      '$head("Constructor Docstring"):\n'
                      '$indent(init_ds)')
    elif type(obj) is types.InstanceType and hasattr(obj,'__call__'):
        call_ds = getdoc(obj.__call__)
        if call_ds:
            output = itpl('$head("Class Docstring:")\n$indent(ds)\n'
                          '$head("Calling Docstring:")\n$indent(call_ds)')
        else:
            output = ds
    else:
        output = ds
    if output is None:
        self.noinfo('documentation',oname)
        return
    page(output)

</t>
<t tx="ekr.20071201085751.423">def psource(self,obj,oname=''):
    """Print the source code for an object."""

    # Flush the source cache because inspect can return out-of-date source
    linecache.checkcache()
    try:
        src = getsource(obj) 
    except:
        self.noinfo('source',oname)
    else:
        page(self.format(src))

</t>
<t tx="ekr.20071201085751.424">def pfile(self,obj,oname=''):
    """Show the whole file where an object was defined."""
    try:
        sourcelines,lineno = inspect.getsourcelines(obj)
    except:
        self.noinfo('file',oname)
    else:
        # run contents of file through pager starting at line
        # where the object is defined
        ofile = inspect.getabsfile(obj)
        
        if (ofile.endswith('.so') or ofile.endswith('.dll')):
            print 'File %r is binary, not printing.' % ofile
        elif not os.path.isfile(ofile):
            print 'File %r does not exist, not printing.' % ofile
        else:
            # Print only text files, not extension binaries.
            page(self.format(open(ofile).read()),lineno)
        #page(self.format(open(inspect.getabsfile(obj)).read()),lineno)

</t>
<t tx="ekr.20071201085751.425">def pinfo(self,obj,oname='',formatter=None,info=None,detail_level=0):
    """Show detailed information about an object.

    Optional arguments:
    
    - oname: name of the variable pointing to the object.

    - formatter: special formatter for docstrings (see pdoc)

    - info: a structure with some information fields which may have been
    precomputed already.

    - detail_level: if set to 1, more information is given.
    """

    obj_type = type(obj)

    header = self.__head
    if info is None:
        ismagic = 0
        isalias = 0
        ospace = ''
    else:
        ismagic = info.ismagic
        isalias = info.isalias
        ospace = info.namespace
    # Get docstring, special-casing aliases:
    if isalias:
        ds = "Alias to the system command:\n  %s" % obj[1]
    else:
        ds = getdoc(obj)
        if ds is None:
            ds = '&lt;no docstring&gt;'
    if formatter is not None:
        ds = formatter(ds)

    # store output in a list which gets joined with \n at the end.
    out = myStringIO()
    
    string_max = 200 # max size of strings to show (snipped if longer)
    shalf = int((string_max -5)/2)

    if ismagic:
        obj_type_name = 'Magic function'
    elif isalias:
        obj_type_name = 'System alias'
    else:
        obj_type_name = obj_type.__name__
    out.writeln(header('Type:\t\t')+obj_type_name)

    try:
        bclass = obj.__class__
        out.writeln(header('Base Class:\t')+str(bclass))
    except: pass

    # String form, but snip if too long in ? form (full in ??)
    if detail_level &gt;= self.str_detail_level:
        try:
            ostr = str(obj)
            str_head = 'String Form:'
            if not detail_level and len(ostr)&gt;string_max:
                ostr = ostr[:shalf] + ' &lt;...&gt; ' + ostr[-shalf:]
                ostr = ("\n" + " " * len(str_head.expandtabs())).\
                       join(map(string.strip,ostr.split("\n")))
            if ostr.find('\n') &gt; -1:
                # Print multi-line strings starting at the next line.
                str_sep = '\n'
            else:
                str_sep = '\t'
            out.writeln("%s%s%s" % (header(str_head),str_sep,ostr))
        except:
            pass

    if ospace:
        out.writeln(header('Namespace:\t')+ospace)

    # Length (for strings and lists)
    try:
        length = str(len(obj))
        out.writeln(header('Length:\t\t')+length)
    except: pass

    # Filename where object was defined
    binary_file = False
    try:
        fname = inspect.getabsfile(obj)
        if fname.endswith('&lt;string&gt;'):
            fname = 'Dynamically generated function. No source code available.'
        if (fname.endswith('.so') or fname.endswith('.dll') or 
            not os.path.isfile(fname)):
            binary_file = True
        out.writeln(header('File:\t\t')+fname)
    except:
        # if anything goes wrong, we don't want to show source, so it's as
        # if the file was binary
        binary_file = True

    # reconstruct the function definition and print it:
    defln = self.__getdef(obj,oname)
    if defln:
        out.write(header('Definition:\t')+self.format(defln))

    # Docstrings only in detail 0 mode, since source contains them (we
    # avoid repetitions).  If source fails, we add them back, see below.
    if ds and detail_level == 0:
            out.writeln(header('Docstring:\n') + indent(ds))

            
    # Original source code for any callable
    if detail_level:
        # Flush the source cache because inspect can return out-of-date source
        linecache.checkcache()
        source_success = False
        try:
            source = self.format(getsource(obj,binary_file))
            if source:
                out.write(header('Source:\n')+source.rstrip())
                source_success = True
        except Exception, msg:
            pass
        
        if ds and not source_success:
            out.writeln(header('Docstring [source file open failed]:\n')
                        + indent(ds))

    # Constructor docstring for classes
    if obj_type is types.ClassType:
        # reconstruct the function definition and print it:
        try:
            obj_init =  obj.__init__
        except AttributeError:
            init_def = init_ds = None
        else:
            init_def = self.__getdef(obj_init,oname)
            init_ds  = getdoc(obj_init)

        if init_def or init_ds:
            out.writeln(header('\nConstructor information:'))
            if init_def:
                out.write(header('Definition:\t')+ self.format(init_def))
            if init_ds:
                out.writeln(header('Docstring:\n') + indent(init_ds))
    # and class docstring for instances:
    elif obj_type is types.InstanceType:

        # First, check whether the instance docstring is identical to the
        # class one, and print it separately if they don't coincide.  In
        # most cases they will, but it's nice to print all the info for
        # objects which use instance-customized docstrings.
        if ds:
            class_ds = getdoc(obj.__class__)
            if class_ds and ds != class_ds:
                out.writeln(header('Class Docstring:\n') +
                            indent(class_ds))

        # Next, try to show constructor docstrings
        try:
            init_ds = getdoc(obj.__init__)
        except AttributeError:
            init_ds = None
        if init_ds:
            out.writeln(header('Constructor Docstring:\n') +
                        indent(init_ds))

        # Call form docstring for callable instances
        if hasattr(obj,'__call__'):
            out.writeln(header('Callable:\t')+'Yes')
            call_def = self.__getdef(obj.__call__,oname)
            if call_def is None:
                out.write(header('Call def:\t')+
                          'Calling definition not available.')
            else:
                out.write(header('Call def:\t')+self.format(call_def))
            call_ds = getdoc(obj.__call__)
            if call_ds:
                out.writeln(header('Call docstring:\n') + indent(call_ds))

    # Finally send to printer/pager
    output = out.getvalue()
    if output:
        page(output)
    # end pinfo

</t>
<t tx="ekr.20071201085751.426">def psearch(self,pattern,ns_table,ns_search=[],
            ignore_case=False,show_all=False):
    """Search namespaces with wildcards for objects.

    Arguments:

    - pattern: string containing shell-like wildcards to use in namespace
    searches and optionally a type specification to narrow the search to
    objects of that type.

    - ns_table: dict of name-&gt;namespaces for search.

    Optional arguments:
    
      - ns_search: list of namespace names to include in search.

      - ignore_case(False): make the search case-insensitive.

      - show_all(False): show all names, including those starting with
      underscores.
    """
    # defaults
    type_pattern = 'all'
    filter = ''

    cmds = pattern.split()
    len_cmds  =  len(cmds)
    if len_cmds == 1:
        # Only filter pattern given
        filter = cmds[0]
    elif len_cmds == 2:
        # Both filter and type specified
        filter,type_pattern = cmds
    else:
        raise ValueError('invalid argument string for psearch: &lt;%s&gt;' %
                         pattern)

    # filter search namespaces
    for name in ns_search:
        if name not in ns_table:
            raise ValueError('invalid namespace &lt;%s&gt;. Valid names: %s' %
                             (name,ns_table.keys()))

    #print 'type_pattern:',type_pattern # dbg
    search_result = []
    for ns_name in ns_search:
        ns = ns_table[ns_name]
        tmp_res = list(list_namespace(ns,type_pattern,filter,
                                      ignore_case=ignore_case,
                                      show_all=show_all))
        search_result.extend(tmp_res)
    search_result.sort()

    page('\n'.join(search_result))
</t>
<t tx="ekr.20071201085751.427"># -*- coding: utf-8 -*-
"""Class to trap stdout and stderr and log them separately.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

import exceptions
import sys
from cStringIO import StringIO

</t>
<t tx="ekr.20071201085751.428">class OutputTrapError(exceptions.Exception):
    """Exception for OutputTrap class."""
    @others
</t>
<t tx="ekr.20071201085751.429">
def __init__(self,args=None):
    exceptions.Exception.__init__(self)
    self.args = args

</t>
<t tx="ekr.20071201085751.430">class OutputTrap:

    """Class to trap standard output and standard error. They get logged in
    StringIO objects which are available as &lt;instance&gt;.out and
    &lt;instance&gt;.err. The class also offers summary methods which format this
    data a bit.

    A word of caution: because it blocks messages, using this class can make
    debugging very tricky. If you are having bizarre problems silently, try
    turning your output traps off for a while. You can call the constructor
    with the parameter debug=1 for these cases. This turns actual trapping
    off, but you can keep the rest of your code unchanged (this has already
    been a life saver).

    Example:

    # config: trapper with a line of dots as log separator (final '\\n' needed)
    config = OutputTrap('Config','Out ','Err ','.'*80+'\\n')

    # start trapping output
    config.trap_all()

    # now all output is logged ...
    # do stuff...

    # output back to normal:
    config.release_all()

    # print all that got logged:
    print config.summary()

    # print individual raw data:
    print config.out.getvalue()
    print config.err.getvalue()
    """
    @others
    # a few shorthands
    trap = trap_all
    release = release_all
    summary = summary_all
    flush = flush_all
</t>
<t tx="ekr.20071201085751.431">
def __init__(self,name='Generic Output Trap',
             out_head='Standard Output. ',err_head='Standard Error. ',
             sum_sep='\n',debug=0,trap_out=0,trap_err=0,
             quiet_out=0,quiet_err=0):
    self.name = name
    self.out_head = out_head
    self.err_head = err_head
    self.sum_sep = sum_sep
    self.out = StringIO()
    self.err = StringIO()
    self.out_save = None
    self.err_save = None
    self.debug = debug
    self.quiet_out = quiet_out
    self.quiet_err = quiet_err
    if trap_out:
        self.trap_out()
    if trap_err:
        self.trap_err()

</t>
<t tx="ekr.20071201085751.432">def trap_out(self):
    """Trap and log stdout."""
    if sys.stdout is self.out:
        raise OutputTrapError,'You are already trapping stdout.'
    if not self.debug:
        self._out_save = sys.stdout
        sys.stdout = self.out

</t>
<t tx="ekr.20071201085751.433">def release_out(self):
    """Release stdout."""
    if not self.debug:
        if not sys.stdout is self.out:
            raise OutputTrapError,'You are not trapping stdout.'
        sys.stdout = self._out_save
        self.out_save = None

</t>
<t tx="ekr.20071201085751.434">def summary_out(self):
    """Return as a string the log from stdout."""
    out = self.out.getvalue()
    if out:
        if self.quiet_out:
            return out
        else:
            return self.out_head + 'Log by '+ self.name + ':\n' + out
    else:
        return ''

</t>
<t tx="ekr.20071201085751.435">def flush_out(self):
    """Flush the stdout log. All data held in the log is lost."""

    self.out.close()
    self.out = StringIO()

</t>
<t tx="ekr.20071201085751.436">def trap_err(self):
    """Trap and log stderr."""
    if sys.stderr is self.err:
        raise OutputTrapError,'You are already trapping stderr.'
    if not self.debug:
        self._err_save = sys.stderr
        sys.stderr = self.err

</t>
<t tx="ekr.20071201085751.437">def release_err(self):
    """Release stderr."""
    if not self.debug:
        if not sys.stderr is self.err:
            raise OutputTrapError,'You are not trapping stderr.'
        sys.stderr = self._err_save
        self.err_save = None

</t>
<t tx="ekr.20071201085751.438">def summary_err(self):
    """Return as a string the log from stderr."""
    err = self.err.getvalue()
    if err:
        if self.quiet_err:
            return err
        else:
            return self.err_head + 'Log by '+ self.name + ':\n' + err
    else:
        return ''

</t>
<t tx="ekr.20071201085751.439">def flush_err(self):
    """Flush the stdout log. All data held in the log is lost."""

    self.err.close()
    self.err = StringIO()

</t>
<t tx="ekr.20071201085751.440">def trap_all(self):
    """Trap and log both stdout and stderr.

    Cacthes and discards OutputTrapError exceptions raised."""
    try:
        self.trap_out()
    except OutputTrapError:
        pass
    try:
        self.trap_err()
    except OutputTrapError:
        pass

</t>
<t tx="ekr.20071201085751.441">def release_all(self):
    """Release both stdout and stderr.

    Cacthes and discards OutputTrapError exceptions raised."""
    try:
        self.release_out()
    except OutputTrapError:
        pass
    try:
        self.release_err()
    except OutputTrapError:
        pass
    
</t>
<t tx="ekr.20071201085751.442">def summary_all(self):
    """Return as a string the log from stdout and stderr, prepending a separator
    to each (defined in __init__ as sum_sep)."""
    sum = ''
    sout = self.summary_out()
    if sout:
        sum += self.sum_sep + sout
    serr = self.summary_err()
    if serr:
        sum += '\n'+self.sum_sep + serr
    return sum

</t>
<t tx="ekr.20071201085751.443">def flush_all(self):
    """Flush stdout and stderr"""
    self.flush_out()
    self.flush_err()

</t>
<t tx="ekr.20071201085751.444"># end OutputTrap


#****************************************************************************
# Module testing. Incomplete, I'm lazy...

def _test_all():

    """Module testing functions, activated when the module is called as a
    script (not imported)."""

    # Put tests for this module in here.
    # Define them as nested functions so they don't clobber the
    # pydoc-generated docs

    def _test_():
        name = ''
        print '#'*50+'\nRunning test for ' + name
        # ...
        print 'Finished test for '+ name +'\n'+'#'*50

    def _test_OutputTrap():
        trap = OutputTrap(name = 'Test Trap', sum_sep = '.'*50+'\n',
                          out_head = 'SOut. ', err_head = 'SErr. ')

        name = 'OutputTrap class'
        print '#'*50+'\nRunning test for ' + name
        print 'Trapping out'
        trap.trap_out()
        print &gt;&gt;sys.stdout, '&gt;&gt;stdout. stdout is trapped.'
        print &gt;&gt;sys.stderr, '&gt;&gt;stderr. stdout is trapped.'
        trap.release_out()
        print trap.summary_out()

        print 'Trapping err'
        trap.trap_err()
        print &gt;&gt;sys.stdout, '&gt;&gt;stdout. stderr is trapped.'
        print &gt;&gt;sys.stderr, '&gt;&gt;stderr. stderr is trapped.'
        trap.release_err()
        print trap.summary_err()

        print 'Trapping all (no flushing)'
        trap.trap_all()
        print &gt;&gt;sys.stdout, '&gt;&gt;stdout. stdout/err is trapped.'
        print &gt;&gt;sys.stderr, '&gt;&gt;stderr. stdout/err is trapped.'
        trap.release_all()
        print trap.summary_all()

        print 'Trapping all (flushing first)'
        trap.flush()
        trap.trap_all()
        print &gt;&gt;sys.stdout, '&gt;&gt;stdout. stdout/err is trapped.'
        print &gt;&gt;sys.stderr, '&gt;&gt;stderr. stdout/err is trapped.'
        trap.release_all()
        print trap.summary_all()
        print 'Finished test for '+ name +'\n'+'#'*50

    # call the actual tests here:
    _test_OutputTrap()


</t>
<t tx="ekr.20071201085751.445"># -*- coding: utf-8 -*-
""" Proxy module for accessing platform specific utility functions. 

Importing this module should give you the implementations that are correct 
for your operation system, from platutils_PLATFORMNAME module.

$Id$


"""


#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Ville']
__license__ = Release.license

import os,sys

if os.name == 'posix':
    from platutils_posix import *
elif sys.platform == 'win32':
    from platutils_win32 import *
else:
    from platutils_dummy import *
    import warnings
    warnings.warn("Platutils not available for platform '%s', some features may be missing" %
        os.name)
    del warnings
</t>
<t tx="ekr.20071201085751.446"># -*- coding: utf-8 -*-
""" Platform specific utility functions, dummy version 

This has empty implementation of the platutils functions, used for 
unsupported operating systems.

$Id$


"""


#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Ville']
__license__ = Release.license


</t>
<t tx="ekr.20071201085751.447">def _dummy(*args,**kw):
    pass

</t>
<t tx="ekr.20071201085751.448"># -*- coding: utf-8 -*-
""" Platform specific utility functions, posix version 

Importing this module directly is not portable - rather, import platutils 
to use these functions in platform agnostic fashion.

$Id$

"""


#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Ville']
__license__ = Release.license

import sys
import os


</t>
<t tx="ekr.20071201085751.449">def _dummy_op(*a, **b):
    """ A no-op function """

</t>
<t tx="ekr.20071201085751.450">def _set_term_title_xterm(title):
    """ Change virtual terminal title in xterm-workalikes """
    sys.stdout.write('\033]%d;%s\007' % (0,title))


</t>
<t tx="ekr.20071201085751.451"># -*- coding: utf-8 -*-
""" Platform specific utility functions, win32 version

Importing this module directly is not portable - rather, import platutils 
to use these functions in platform agnostic fashion.

$Id$

"""


#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Ville']
__license__ = Release.license


</t>
<t tx="ekr.20071201085751.452">def set_term_title(title):
    """ TBD """
</t>
<t tx="ekr.20071201085751.453"># -*- coding: utf-8 -*-
"""
Classes for handling input/output prompts.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license
__version__ = Release.version

#****************************************************************************
# Required modules
import __builtin__
import os
import socket
import sys
import time

# IPython's own
from IPython import ColorANSI
from IPython.Itpl import ItplNS
from IPython.ipstruct import Struct
from IPython.macro import Macro
from IPython.genutils import *

#****************************************************************************
#Color schemes for Prompts.

PromptColors = ColorANSI.ColorSchemeTable()
InputColors = ColorANSI.InputTermColors  # just a shorthand
Colors = ColorANSI.TermColors  # just a shorthand

PromptColors.add_scheme(ColorANSI.ColorScheme(
    'NoColor',
    in_prompt  = InputColors.NoColor,  # Input prompt
    in_number  = InputColors.NoColor,  # Input prompt number
    in_prompt2 = InputColors.NoColor, # Continuation prompt
    in_normal  = InputColors.NoColor,  # color off (usu. Colors.Normal)
    
    out_prompt = Colors.NoColor, # Output prompt
    out_number = Colors.NoColor, # Output prompt number

    normal = Colors.NoColor  # color off (usu. Colors.Normal)
    ))

# make some schemes as instances so we can copy them for modification easily:
__PColLinux =  ColorANSI.ColorScheme(
    'Linux',
    in_prompt  = InputColors.Green,
    in_number  = InputColors.LightGreen,
    in_prompt2 = InputColors.Green,
    in_normal  = InputColors.Normal,  # color off (usu. Colors.Normal)

    out_prompt = Colors.Red,
    out_number = Colors.LightRed,

    normal = Colors.Normal
    )
# Don't forget to enter it into the table!
PromptColors.add_scheme(__PColLinux)

# Slightly modified Linux for light backgrounds
__PColLightBG  = __PColLinux.copy('LightBG')

__PColLightBG.colors.update(
    in_prompt  = InputColors.Blue,
    in_number  = InputColors.LightBlue,
    in_prompt2 = InputColors.Blue
)
PromptColors.add_scheme(__PColLightBG)

del Colors,InputColors

</t>
<t tx="ekr.20071201085751.454">#-----------------------------------------------------------------------------
def multiple_replace(dict, text):
    """ Replace in 'text' all occurences of any key in the given
    dictionary by its corresponding value.  Returns the new string."""

    # Function by Xavier Defrang, originally found at:
    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/81330

    # Create a regular expression  from the dictionary keys
    regex = re.compile("(%s)" % "|".join(map(re.escape, dict.keys())))
    # For each match, look-up corresponding value in dictionary
    return regex.sub(lambda mo: dict[mo.string[mo.start():mo.end()]], text)

</t>
<t tx="ekr.20071201085751.455">#-----------------------------------------------------------------------------
# Special characters that can be used in prompt templates, mainly bash-like

# If $HOME isn't defined (Windows), make it an absurd string so that it can
# never be expanded out into '~'.  Basically anything which can never be a
# reasonable directory name will do, we just want the $HOME -&gt; '~' operation
# to become a no-op.  We pre-compute $HOME here so it's not done on every
# prompt call.

# FIXME:

# - This should be turned into a class which does proper namespace management,
# since the prompt specials need to be evaluated in a certain namespace.
# Currently it's just globals, which need to be managed manually by code
# below.

# - I also need to split up the color schemes from the prompt specials
# somehow.  I don't have a clean design for that quite yet.

HOME = os.environ.get("HOME","//////:::::ZZZZZ,,,~~~")

# We precompute a few more strings here for the prompt_specials, which are
# fixed once ipython starts.  This reduces the runtime overhead of computing
# prompt strings.
USER           = os.environ.get("USER")
HOSTNAME       = socket.gethostname()
HOSTNAME_SHORT = HOSTNAME.split(".")[0]
ROOT_SYMBOL    = "$#"[os.name=='nt' or os.getuid()==0]

prompt_specials_color = {
    # Prompt/history count
    '%n' : '${self.col_num}' '${self.cache.prompt_count}' '${self.col_p}',
    '\\#': '${self.col_num}' '${self.cache.prompt_count}' '${self.col_p}',
    # Prompt/history count, with the actual digits replaced by dots.  Used
    # mainly in continuation prompts (prompt_in2)
    '\\D': '${"."*len(str(self.cache.prompt_count))}',
    # Current working directory
    '\\w': '${os.getcwd()}',
    # Current time
    '\\t' : '${time.strftime("%H:%M:%S")}',
    # Basename of current working directory.
    # (use os.sep to make this portable across OSes)
    '\\W' : '${os.getcwd().split("%s")[-1]}' % os.sep,
    # These X&lt;N&gt; are an extension to the normal bash prompts.  They return
    # N terms of the path, after replacing $HOME with '~'
    '\\X0': '${os.getcwd().replace("%s","~")}' % HOME,
    '\\X1': '${self.cwd_filt(1)}',
    '\\X2': '${self.cwd_filt(2)}',
    '\\X3': '${self.cwd_filt(3)}',
    '\\X4': '${self.cwd_filt(4)}',
    '\\X5': '${self.cwd_filt(5)}',
    # Y&lt;N&gt; are similar to X&lt;N&gt;, but they show '~' if it's the directory
    # N+1 in the list.  Somewhat like %cN in tcsh.
    '\\Y0': '${self.cwd_filt2(0)}',
    '\\Y1': '${self.cwd_filt2(1)}',
    '\\Y2': '${self.cwd_filt2(2)}',
    '\\Y3': '${self.cwd_filt2(3)}',
    '\\Y4': '${self.cwd_filt2(4)}',
    '\\Y5': '${self.cwd_filt2(5)}',
    # Hostname up to first .
    '\\h': HOSTNAME_SHORT,
    # Full hostname
    '\\H': HOSTNAME,
    # Username of current user
    '\\u': USER,
    # Escaped '\'
    '\\\\': '\\',
    # Newline
    '\\n': '\n',
    # Carriage return
    '\\r': '\r',
    # Release version
    '\\v': __version__,
    # Root symbol ($ or #)
    '\\$': ROOT_SYMBOL,
    }

# A copy of the prompt_specials dictionary but with all color escapes removed,
# so we can correctly compute the prompt length for the auto_rewrite method.
prompt_specials_nocolor = prompt_specials_color.copy()
prompt_specials_nocolor['%n'] = '${self.cache.prompt_count}'
prompt_specials_nocolor['\\#'] = '${self.cache.prompt_count}'

# Add in all the InputTermColors color escapes as valid prompt characters.
# They all get added as \\C_COLORNAME, so that we don't have any conflicts
# with a color name which may begin with a letter used by any other of the
# allowed specials.  This of course means that \\C will never be allowed for
# anything else.
input_colors = ColorANSI.InputTermColors
for _color in dir(input_colors):
    if _color[0] != '_':
        c_name = '\\C_'+_color
        prompt_specials_color[c_name] = getattr(input_colors,_color)
        prompt_specials_nocolor[c_name] = ''

# we default to no color for safety.  Note that prompt_specials is a global
# variable used by all prompt objects.
prompt_specials = prompt_specials_nocolor

#-----------------------------------------------------------------------------
def str_safe(arg):
    """Convert to a string, without ever raising an exception.

    If str(arg) fails, &lt;ERROR: ... &gt; is returned, where ... is the exception
    error message."""

    try:
        out = str(arg)
    except UnicodeError:
        try:
            out = arg.encode('utf_8','replace')
        except Exception,msg:
            # let's keep this little duplication here, so that the most common
            # case doesn't suffer from a double try wrapping.
            out = '&lt;ERROR: %s&gt;' % msg
    except Exception,msg:
        out = '&lt;ERROR: %s&gt;' % msg
    return out

</t>
<t tx="ekr.20071201085751.456">class BasePrompt:
    """Interactive prompt similar to Mathematica's."""
    @others
</t>
<t tx="ekr.20071201085751.457">def __init__(self,cache,sep,prompt,pad_left=False):

    # Hack: we access information about the primary prompt through the
    # cache argument.  We need this, because we want the secondary prompt
    # to be aligned with the primary one.  Color table info is also shared
    # by all prompt classes through the cache.  Nice OO spaghetti code!
    self.cache = cache
    self.sep = sep
    
    # regexp to count the number of spaces at the end of a prompt
    # expression, useful for prompt auto-rewriting
    self.rspace = re.compile(r'(\s*)$')
    # Flag to left-pad prompt strings to match the length of the primary
    # prompt
    self.pad_left = pad_left
    # Set template to create each actual prompt (where numbers change)
    self.p_template = prompt
    self.set_p_str()

</t>
<t tx="ekr.20071201085751.458">def set_p_str(self):
    """ Set the interpolating prompt strings.

    This must be called every time the color settings change, because the
    prompt_specials global may have changed."""

    import os,time  # needed in locals for prompt string handling
    loc = locals()
    self.p_str = ItplNS('%s%s%s' %
                        ('${self.sep}${self.col_p}',
                         multiple_replace(prompt_specials, self.p_template),
                         '${self.col_norm}'),self.cache.user_ns,loc)

    self.p_str_nocolor = ItplNS(multiple_replace(prompt_specials_nocolor,
                                                 self.p_template),
                                self.cache.user_ns,loc)

</t>
<t tx="ekr.20071201085751.459">def write(self,msg):  # dbg
    sys.stdout.write(msg)
    return ''

</t>
<t tx="ekr.20071201085751.460">def __str__(self):
    """Return a string form of the prompt.

    This for is useful for continuation and output prompts, since it is
    left-padded to match lengths with the primary one (if the
    self.pad_left attribute is set)."""

    out_str = str_safe(self.p_str)
    if self.pad_left:
        # We must find the amount of padding required to match lengths,
        # taking the color escapes (which are invisible on-screen) into
        # account.
        esc_pad = len(out_str) - len(str_safe(self.p_str_nocolor))
        format = '%%%ss' % (len(str(self.cache.last_prompt))+esc_pad)
        return format % out_str
    else:
        return out_str

</t>
<t tx="ekr.20071201085751.461"># these path filters are put in as methods so that we can control the
# namespace where the prompt strings get evaluated
def cwd_filt(self,depth):
    """Return the last depth elements of the current working directory.

    $HOME is always replaced with '~'.
    If depth==0, the full path is returned."""

    cwd = os.getcwd().replace(HOME,"~")
    out = os.sep.join(cwd.split(os.sep)[-depth:])
    if out:
        return out
    else:
        return os.sep

</t>
<t tx="ekr.20071201085751.462">def cwd_filt2(self,depth):
    """Return the last depth elements of the current working directory.

    $HOME is always replaced with '~'.
    If depth==0, the full path is returned."""

    cwd = os.getcwd().replace(HOME,"~").split(os.sep)
    if '~' in cwd and len(cwd) == depth+1:
        depth += 1
    out = os.sep.join(cwd[-depth:])
    if out:
        return out
    else:
        return os.sep

</t>
<t tx="ekr.20071201085751.463">class Prompt1(BasePrompt):
    """Input interactive prompt similar to Mathematica's."""
    @others
</t>
<t tx="ekr.20071201085751.464">
def __init__(self,cache,sep='\n',prompt='In [\\#]: ',pad_left=True):
    BasePrompt.__init__(self,cache,sep,prompt,pad_left)

</t>
<t tx="ekr.20071201085751.465">def set_colors(self):
    self.set_p_str()
    Colors = self.cache.color_table.active_colors # shorthand
    self.col_p = Colors.in_prompt
    self.col_num = Colors.in_number
    self.col_norm = Colors.in_normal
    # We need a non-input version of these escapes for the '---&gt;'
    # auto-call prompts used in the auto_rewrite() method.
    self.col_p_ni = self.col_p.replace('\001','').replace('\002','') 
    self.col_norm_ni = Colors.normal        
    
</t>
<t tx="ekr.20071201085751.466">def __str__(self):
    self.cache.prompt_count += 1
    self.cache.last_prompt = str_safe(self.p_str_nocolor).split('\n')[-1]
    return str_safe(self.p_str)

</t>
<t tx="ekr.20071201085751.467">def auto_rewrite(self):
    """Print a string of the form '---&gt;' which lines up with the previous
    input string. Useful for systems which re-write the user input when
    handling automatically special syntaxes."""

    curr = str(self.cache.last_prompt)
    nrspaces = len(self.rspace.search(curr).group())
    return '%s%s&gt;%s%s' % (self.col_p_ni,'-'*(len(curr)-nrspaces-1),
                          ' '*nrspaces,self.col_norm_ni)

</t>
<t tx="ekr.20071201085751.468">class PromptOut(BasePrompt):
    """Output interactive prompt similar to Mathematica's."""
    @others
</t>
<t tx="ekr.20071201085751.469">
def __init__(self,cache,sep='',prompt='Out[\\#]: ',pad_left=True):
    BasePrompt.__init__(self,cache,sep,prompt,pad_left)
    if not self.p_template:
        self.__str__ = lambda: ''

</t>
<t tx="ekr.20071201085751.470">def set_colors(self):
    self.set_p_str()
    Colors = self.cache.color_table.active_colors # shorthand
    self.col_p = Colors.out_prompt
    self.col_num = Colors.out_number
    self.col_norm = Colors.normal

</t>
<t tx="ekr.20071201085751.471">class Prompt2(BasePrompt):
    """Interactive continuation prompt."""
    @others
</t>
<t tx="ekr.20071201085751.472">
def __init__(self,cache,prompt='   .\\D.: ',pad_left=True):
    self.cache = cache
    self.p_template = prompt
    self.pad_left = pad_left
    self.set_p_str()

</t>
<t tx="ekr.20071201085751.473">def set_p_str(self):
    import os,time  # needed in locals for prompt string handling
    loc = locals()
    self.p_str = ItplNS('%s%s%s' %
                        ('${self.col_p2}',
                         multiple_replace(prompt_specials, self.p_template),
                         '$self.col_norm'),
                        self.cache.user_ns,loc)
    self.p_str_nocolor = ItplNS(multiple_replace(prompt_specials_nocolor,
                                                 self.p_template),
                                self.cache.user_ns,loc)

</t>
<t tx="ekr.20071201085751.474">def set_colors(self):
    self.set_p_str()
    Colors = self.cache.color_table.active_colors
    self.col_p2 = Colors.in_prompt2
    self.col_norm = Colors.in_normal
    # FIXME (2004-06-16) HACK: prevent crashes for users who haven't
    # updated their prompt_in2 definitions.  Remove eventually.
    self.col_p = Colors.out_prompt
    self.col_num = Colors.out_number


</t>
<t tx="ekr.20071201085751.475">#-----------------------------------------------------------------------------
class CachedOutput:
    """Class for printing output from calculations while keeping a cache of
    reults. It dynamically creates global variables prefixed with _ which
    contain these results.

    Meant to be used as a sys.displayhook replacement, providing numbered
    prompts and cache services.

    Initialize with initial and final values for cache counter (this defines
    the maximum size of the cache."""
    @others
</t>
<t tx="ekr.20071201085751.476">
def __init__(self,shell,cache_size,Pprint,
             colors='NoColor',input_sep='\n',
             output_sep='\n',output_sep2='',
             ps1 = None, ps2 = None,ps_out = None,pad_left=True):

    cache_size_min = 3
    if cache_size &lt;= 0:
        self.do_full_cache = 0
        cache_size = 0
    elif cache_size &lt; cache_size_min:
        self.do_full_cache = 0
        cache_size = 0
        warn('caching was disabled (min value for cache size is %s).' %
             cache_size_min,level=3)
    else:
        self.do_full_cache = 1

    self.cache_size = cache_size
    self.input_sep = input_sep

    # we need a reference to the user-level namespace
    self.shell = shell
    self.user_ns = shell.user_ns
    # and to the user's input
    self.input_hist = shell.input_hist
    # and to the user's logger, for logging output
    self.logger = shell.logger

    # Set input prompt strings and colors
    if cache_size == 0:
        if ps1.find('%n') &gt; -1 or ps1.find('\\#') &gt; -1: ps1 = '&gt;&gt;&gt; '
        if ps2.find('%n') &gt; -1 or ps2.find('\\#') &gt; -1: ps2 = '... '
    self.ps1_str = self._set_prompt_str(ps1,'In [\\#]: ','&gt;&gt;&gt; ')
    self.ps2_str = self._set_prompt_str(ps2,'   .\\D.: ','... ')
    self.ps_out_str = self._set_prompt_str(ps_out,'Out[\\#]: ','')

    self.color_table = PromptColors
    self.prompt1 = Prompt1(self,sep=input_sep,prompt=self.ps1_str,
                           pad_left=pad_left)
    self.prompt2 = Prompt2(self,prompt=self.ps2_str,pad_left=pad_left)
    self.prompt_out = PromptOut(self,sep='',prompt=self.ps_out_str,
                                pad_left=pad_left)
    self.set_colors(colors)

    # other more normal stuff
    # b/c each call to the In[] prompt raises it by 1, even the first.
    self.prompt_count = 0
    # Store the last prompt string each time, we need it for aligning
    # continuation and auto-rewrite prompts
    self.last_prompt = ''
    self.Pprint = Pprint
    self.output_sep = output_sep
    self.output_sep2 = output_sep2
    self._,self.__,self.___ = '','',''
    self.pprint_types = map(type,[(),[],{}])
    
    # these are deliberately global:
    to_user_ns = {'_':self._,'__':self.__,'___':self.___}
    self.user_ns.update(to_user_ns)

</t>
<t tx="ekr.20071201085751.477">def _set_prompt_str(self,p_str,cache_def,no_cache_def):
    if p_str is None:
        if self.do_full_cache:
            return cache_def
        else:
            return no_cache_def
    else:
        return p_str
            
</t>
<t tx="ekr.20071201085751.478">def set_colors(self,colors):
    """Set the active color scheme and configure colors for the three
    prompt subsystems."""

    # FIXME: the prompt_specials global should be gobbled inside this
    # class instead.  Do it when cleaning up the whole 3-prompt system.
    global prompt_specials
    if colors.lower()=='nocolor':
        prompt_specials = prompt_specials_nocolor
    else:
        prompt_specials = prompt_specials_color
    
    self.color_table.set_active_scheme(colors)
    self.prompt1.set_colors()
    self.prompt2.set_colors()
    self.prompt_out.set_colors()

</t>
<t tx="ekr.20071201085751.479">def __call__(self,arg=None):
    """Printing with history cache management.
    
    This is invoked everytime the interpreter needs to print, and is
    activated by setting the variable sys.displayhook to it."""

    # If something injected a '_' variable in __builtin__, delete
    # ipython's automatic one so we don't clobber that.  gettext() in
    # particular uses _, so we need to stay away from it.
    if '_' in __builtin__.__dict__:
        try:
            del self.user_ns['_']
        except KeyError:
            pass
    if arg is not None:
        cout_write = Term.cout.write # fast lookup
        # first handle the cache and counters

        # do not print output if input ends in ';'
        if self.input_hist[self.prompt_count].endswith(';\n'):
            return
        # don't use print, puts an extra space
        cout_write(self.output_sep)
        outprompt = self.shell.hooks.generate_output_prompt()
        if self.do_full_cache:
            cout_write(outprompt)

        if isinstance(arg,Macro):
            print 'Executing Macro...'
            # in case the macro takes a long time to execute
            Term.cout.flush()
            self.shell.runlines(arg.value)
            return None

        # and now call a possibly user-defined print mechanism
        manipulated_val = self.display(arg)
        
        # user display hooks can change the variable to be stored in
        # output history
        
        if manipulated_val is not None:
            arg = manipulated_val
            
        # avoid recursive reference when displaying _oh/Out
        if arg is not self.user_ns['_oh']:
            self.update(arg)

        if self.logger.log_output:
            self.logger.log_write(repr(arg),'output')
        cout_write(self.output_sep2)
        Term.cout.flush()

</t>
<t tx="ekr.20071201085751.480">def _display(self,arg):
    """Default printer method, uses pprint.

    Do ip.set_hook("result_display", my_displayhook) for custom result
    display, e.g. when your own objects need special formatting.
    """

    return self.shell.hooks.result_display(arg)

</t>
<t tx="ekr.20071201085751.481"># Assign the default display method:
display = _display

def update(self,arg):
    #print '***cache_count', self.cache_count # dbg
    if len(self.user_ns['_oh']) &gt;= self.cache_size and self.do_full_cache:
        warn('Output cache limit (currently '+
              `self.cache_size`+' entries) hit.\n'
             'Flushing cache and resetting history counter...\n'
             'The only history variables available will be _,__,___ and _1\n'
             'with the current result.')

        self.flush()
    # Don't overwrite '_' and friends if '_' is in __builtin__ (otherwise
    # we cause buggy behavior for things like gettext).
    if '_' not in __builtin__.__dict__:
        self.___ = self.__
        self.__ = self._
        self._ = arg
        self.user_ns.update({'_':self._,'__':self.__,'___':self.___})
        
    # hackish access to top-level  namespace to create _1,_2... dynamically
    to_main = {}
    if self.do_full_cache:
        new_result = '_'+`self.prompt_count`
        to_main[new_result] = arg
    self.user_ns.update(to_main)
    self.user_ns['_oh'][self.prompt_count] = arg

</t>
<t tx="ekr.20071201085751.482">def flush(self):
    if not self.do_full_cache:
        raise ValueError,"You shouldn't have reached the cache flush "\
              "if full caching is not enabled!"
    # delete auto-generated vars from global namespace
    
    for n in range(1,self.prompt_count + 1):
        key = '_'+`n`
        try:
            del self.user_ns[key]
        except: pass
    self.user_ns['_oh'].clear()
    
    if '_' not in __builtin__.__dict__:
        self.user_ns.update({'_':None,'__':None, '___':None})
    import gc
    gc.collect() # xxx needed?

</t>
<t tx="ekr.20071201085751.483"># -*- coding: utf-8 -*-
"""
    Class and program to colorize python source code for ANSI terminals.

    Based on an HTML code highlighter by Jurgen Hermann found at:
    http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52298

    Modifications by Fernando Perez (fperez@colorado.edu).

    Information on the original HTML highlighter follows:
    
    MoinMoin - Python Source Parser

    Title:olorize Python source using the built-in tokenizer
           
    Submitter: Jurgen Hermann
    Last Updated:2001/04/06
           
    Version no:1.2

    Description:

    This code is part of MoinMoin (http://moin.sourceforge.net/) and converts
    Python source code to HTML markup, rendering comments, keywords,
    operators, numeric and string literals in different colors.

    It shows how to use the built-in keyword, token and tokenize modules to
    scan Python source code and re-emit it with no changes to its original
    formatting (which is the hard part).

    $Id$"""

__all__ = ['ANSICodeColors','Parser']

_scheme_default = 'Linux'

# Imports
import cStringIO
import keyword
import os
import string
import sys
import token
import tokenize

from IPython.ColorANSI import *

#############################################################################
### Python Source Parser (does Hilighting)
#############################################################################

_KEYWORD = token.NT_OFFSET + 1
_TEXT    = token.NT_OFFSET + 2

#****************************************************************************
# Builtin color schemes

Colors = TermColors  # just a shorthand

# Build a few color schemes
NoColor = ColorScheme(
    'NoColor',{
    token.NUMBER     : Colors.NoColor,
    token.OP         : Colors.NoColor,
    token.STRING     : Colors.NoColor,
    tokenize.COMMENT : Colors.NoColor,
    token.NAME       : Colors.NoColor,
    token.ERRORTOKEN : Colors.NoColor,

    _KEYWORD         : Colors.NoColor,
    _TEXT            : Colors.NoColor,

    'normal'         : Colors.NoColor  # color off (usu. Colors.Normal)
    }  )

LinuxColors = ColorScheme(
    'Linux',{
    token.NUMBER     : Colors.LightCyan,
    token.OP         : Colors.Yellow,
    token.STRING     : Colors.LightBlue,
    tokenize.COMMENT : Colors.LightRed,
    token.NAME       : Colors.White,
    token.ERRORTOKEN : Colors.Red,

    _KEYWORD         : Colors.LightGreen,
    _TEXT            : Colors.Yellow,

    'normal'         : Colors.Normal  # color off (usu. Colors.Normal)
    } )

LightBGColors = ColorScheme(
    'LightBG',{
    token.NUMBER     : Colors.Cyan,
    token.OP         : Colors.Blue,
    token.STRING     : Colors.Blue,
    tokenize.COMMENT : Colors.Red,
    token.NAME       : Colors.Black,
    token.ERRORTOKEN : Colors.Red,

    _KEYWORD         : Colors.Green,
    _TEXT            : Colors.Blue,

    'normal'         : Colors.Normal  # color off (usu. Colors.Normal)
    }  )

# Build table of color schemes (needed by the parser)
ANSICodeColors = ColorSchemeTable([NoColor,LinuxColors,LightBGColors],
                                  _scheme_default)

</t>
<t tx="ekr.20071201085751.484">class Parser:
    """ Format colored Python source.
    """
    @others
</t>
<t tx="ekr.20071201085751.485">
def __init__(self, color_table=None,out = sys.stdout):
    """ Create a parser with a specified color table and output channel.

    Call format() to process code.
    """
    self.color_table = color_table and color_table or ANSICodeColors
    self.out = out

</t>
<t tx="ekr.20071201085751.486">def format(self, raw, out = None, scheme = ''):
    """ Parse and send the colored source.

    If out and scheme are not specified, the defaults (given to
    constructor) are used.

    out should be a file-type object. Optionally, out can be given as the
    string 'str' and the parser will automatically return the output in a
    string."""
    
    self.raw = string.strip(string.expandtabs(raw))
    string_output = 0
    if out == 'str' or self.out == 'str':
        out_old = self.out
        self.out = cStringIO.StringIO()
        string_output = 1
    elif out is not None:
        self.out = out
    # local shorthand
    colors = self.color_table[scheme].colors
    self.colors = colors # put in object so __call__ sees it
    # store line offsets in self.lines
    self.lines = [0, 0]
    pos = 0
    while 1:
        pos = string.find(self.raw, '\n', pos) + 1
        if not pos: break
        self.lines.append(pos)
    self.lines.append(len(self.raw))

    # parse the source and write it
    self.pos = 0
    text = cStringIO.StringIO(self.raw)
    #self.out.write('&lt;pre&gt;&lt;font face="Courier New"&gt;')
    try:
        tokenize.tokenize(text.readline, self)
    except tokenize.TokenError, ex:
        msg = ex[0]
        line = ex[1][0]
        self.out.write("%s\n\n*** ERROR: %s%s%s\n" %
                       (colors[token.ERRORTOKEN],
                        msg, self.raw[self.lines[line]:],
                        colors.normal)
                       )
    self.out.write(colors.normal+'\n')
    if string_output:
        output = self.out.getvalue()
        self.out = out_old
        return output

</t>
<t tx="ekr.20071201085751.487">def __call__(self, toktype, toktext, (srow,scol), (erow,ecol), line):
    """ Token handler, with syntax highlighting."""

    # local shorthand
    colors = self.colors

    # line separator, so this works across platforms
    linesep = os.linesep

    # calculate new positions
    oldpos = self.pos
    newpos = self.lines[srow] + scol
    self.pos = newpos + len(toktext)

    # handle newlines
    if toktype in [token.NEWLINE, tokenize.NL]:
        self.out.write(linesep)
        return

    # send the original whitespace, if needed
    if newpos &gt; oldpos:
        self.out.write(self.raw[oldpos:newpos])

    # skip indenting tokens
    if toktype in [token.INDENT, token.DEDENT]:
        self.pos = newpos
        return

    # map token type to a color group
    if token.LPAR &lt;= toktype and toktype &lt;= token.OP:
        toktype = token.OP
    elif toktype == token.NAME and keyword.iskeyword(toktext):
        toktype = _KEYWORD
    color = colors.get(toktype, colors[_TEXT])

    #print '&lt;%s&gt;' % toktext,    # dbg

    # Triple quoted strings must be handled carefully so that backtracking
    # in pagers works correctly. We need color terminators on _each_ line.
    if linesep in toktext:
        toktext = toktext.replace(linesep, '%s%s%s' %
                                  (colors.normal,linesep,color))

    # send text
    self.out.write('%s%s%s' % (color,toktext,colors.normal))
        
</t>
<t tx="ekr.20071201085751.488">def main():
    """Colorize a python file using ANSI color escapes and print to stdout.

    Usage:
      %s [-s scheme] filename

    Options:

      -s scheme: give the color scheme to use. Currently only 'Linux'
      (default) and 'LightBG' and 'NoColor' are implemented (give without
      quotes).  """  

    def usage():
        print &gt;&gt; sys.stderr, main.__doc__ % sys.argv[0]
        sys.exit(1)
        
    # FIXME: rewrite this to at least use getopt
    try:
        if sys.argv[1] == '-s':
            scheme_name = sys.argv[2]
            del sys.argv[1:3]
        else:
            scheme_name = _scheme_default
        
    except:
        usage()

    try:
        fname = sys.argv[1]
    except:
        usage()
        
    # write colorized version to stdout
    parser = Parser()
    try:
        parser.format(file(fname).read(),scheme = scheme_name)
    except IOError,msg:
        # if user reads through a pager and quits, don't print traceback
        if msg.args != (32,'Broken pipe'):
            raise

</t>
<t tx="ekr.20071201085751.489"># -*- coding: utf-8 -*-
"""Release data for the IPython project.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#       Copyright (c) 2001 Janko Hauser &lt;jhauser@zscout.de&gt; and Nathaniel Gray
#       &lt;n8gray@caltech.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

# Name of the package for release purposes.  This is the name which labels
# the tarballs and RPMs made by distutils, so it's best to lowercase it.
name = 'ipython'

# For versions with substrings (like 0.6.16.svn), use an extra . to separate
# the new substring.  We have to avoid using either dashes or underscores,
# because bdist_rpm does not accept dashes (an RPM) convention, and
# bdist_deb does not accept underscores (a Debian convention).

revision = '2007'

version = '0.7.3'

#version = '0.7.3rc2.r' + revision.rstrip('M')

description = "An enhanced interactive Python shell."

long_description = \
"""
IPython provides a replacement for the interactive Python interpreter with
extra functionality.

Main features:

 * Comprehensive object introspection.

 * Input history, persistent across sessions.

 * Caching of output results during a session with automatically generated
   references.

 * Readline based name completion.

 * Extensible system of 'magic' commands for controlling the environment and
   performing many tasks related either to IPython or the operating system.

 * Configuration system with easy switching between different setups (simpler
   than changing $PYTHONSTARTUP environment variables every time).

 * Session logging and reloading.

 * Extensible syntax processing for special purpose situations.

 * Access to the system shell with user-extensible alias system.

 * Easily embeddable in other Python programs.

 * Integrated access to the pdb debugger and the Python profiler. 

 The latest development version is always available at the IPython subversion
 repository_.

.. _repository: http://ipython.scipy.org/svn/ipython/ipython/trunk#egg=ipython-dev
 """

license = 'BSD'

authors = {'Fernando' : ('Fernando Perez','fperez@colorado.edu'),
           'Janko'    : ('Janko Hauser','jhauser@zscout.de'),
           'Nathan'   : ('Nathaniel Gray','n8gray@caltech.edu'),
           'Ville'    : ('Ville Vainio','vivainio@gmail.com')           
           }

url = 'http://ipython.scipy.org'

download_url = 'http://ipython.scipy.org/dist'

platforms = ['Linux','Mac OSX','Windows XP/2000/NT','Windows 95/98/ME']

keywords = ['Interactive','Interpreter','Shell']
</t>
<t tx="ekr.20071201085751.490"># -*- coding: utf-8 -*-
""" Imports and provides the "correct" version of readline for the platform.

Readline is used throughout IPython as "import IPython.rlineimpl as readline.

In addition to normal readline stuff, this module provides have_readline boolean 
and _outputfile variable used in genutils.

$Id$"""


import sys

have_readline = False

if sys.platform == 'win32':
    try:
        import pyreadline.rlmain
        #add config for inputrcpath here:
        #pyreadline.rlmain.config_path="c:/python/test_config.ini"
        from readline import *
        #print "Using the new pyreadline (thanks for participating in the testing!)"
        
        have_readline = True
        
        import readline as _rl
    except ImportError:
        #print "IPython team recommends the new pyreadline for Windows use, "
        #print "It's superior especially with non-US keyboard layouts."
        #print "Try installing it with 'easy_install pyreadline (ctypes is required) or"
        #print "svn co http://ipython.scipy.org/svn/ipython/pyreadline/trunk pyreadline"
        #print "Trying 'old' windows readline."
        #print "Using 'old' readline, you might want to try pyreadline:"
        #print "http://projects.scipy.org/ipython/ipython/wiki/PyReadline/Intro"
        try:
            from readline import *
            import readline as _rl
            have_readline = True
        except ImportError:
            pass

    if have_readline:
        try:
            _outputfile=_rl.GetOutputFile()
        except NameError:
            print "Failed GetOutputFile"
            have_readline = False
    
else:
    try:
        from readline import *
        have_readline = True
    except ImportError:
        pass
</t>
<t tx="ekr.20071201085751.491">from IPython.hooks import CommandChainDispatcher
import IPython.hooks

import re

</t>
<t tx="ekr.20071201085751.492">class StrDispatch(object):
    """ Dispatch (lookup) a set of strings / regexps for match """
    @others
</t>
<t tx="ekr.20071201085751.493">def __init__(self):
    self.strs = {}
    self.regexs = {}
</t>
<t tx="ekr.20071201085751.494">def add_s(self, s, obj, priority= 0 ):
    """ Adds a target 'string' for dispatching """
    
    chain = self.strs.get(s, CommandChainDispatcher())
    chain.add(obj,priority)
    self.strs[s] = chain

</t>
<t tx="ekr.20071201085751.495">def add_re(self, regex, obj, priority= 0 ):
    """ Adds a target regexp for dispatching """
    
    chain = self.regexs.get(regex, CommandChainDispatcher())
    chain.add(obj,priority)
    self.regexs[regex] = chain

</t>
<t tx="ekr.20071201085751.496">def dispatch(self, key):
    """ Get a seq of Commandchain objects that match key """
    if key in self.strs:
        yield self.strs[key]
    
    for r, obj in self.regexs.items():
        if re.match(r, key):
            yield obj
        else: 
            #print "nomatch",key
            pass
        

</t>
<t tx="ekr.20071201085751.497">def __repr__(self):
    return "&lt;Strdispatch %s, %s&gt;" % (self.strs, self.regexs)

</t>
<t tx="ekr.20071201085751.498">def s_matches(self, key):
    if key not in self.strs:
         return
    for el in self.strs[key]:
        yield el[1]
    
    
</t>
<t tx="ekr.20071201085751.499">def flat_matches(self, key):
    """ Yield all 'value' targets, without priority """
    for val in self.dispatch(key):
        for el in val:
            yield el[1] # only value, no priority
    return
     

</t>
<t tx="ekr.20071201085751.500">def test():
    d = StrDispatch()
    d.add_s('hei',34, priority = 4)
    d.add_s('hei',123, priority = 2)
    print  list(d.dispatch('hei'))
    d.add_re('h.i', 686)
    print list(d.flat_matches('hei'))

</t>
<t tx="ekr.20071201085751.501"># -*- coding: utf-8 -*-
"""
ultraTB.py -- Spice up your tracebacks!

* ColorTB
I've always found it a bit hard to visually parse tracebacks in Python.  The
ColorTB class is a solution to that problem.  It colors the different parts of a
traceback in a manner similar to what you would expect from a syntax-highlighting
text editor.

Installation instructions for ColorTB:
    import sys,ultraTB
    sys.excepthook = ultraTB.ColorTB()

* VerboseTB  
I've also included a port of Ka-Ping Yee's "cgitb.py" that produces all kinds
of useful info when a traceback occurs.  Ping originally had it spit out HTML
and intended it for CGI programmers, but why should they have all the fun?  I
altered it to spit out colored text to the terminal.  It's a bit overwhelming,
but kind of neat, and maybe useful for long-running programs that you believe
are bug-free.  If a crash *does* occur in that type of program you want details.
Give it a shot--you'll love it or you'll hate it.

Note:

  The Verbose mode prints the variables currently visible where the exception
  happened (shortening their strings if too long). This can potentially be
  very slow, if you happen to have a huge data structure whose string
  representation is complex to compute. Your computer may appear to freeze for
  a while with cpu usage at 100%. If this occurs, you can cancel the traceback
  with Ctrl-C (maybe hitting it more than once).

  If you encounter this kind of situation often, you may want to use the
  Verbose_novars mode instead of the regular Verbose, which avoids formatting
  variables (but otherwise includes the information and context given by
  Verbose).
  

Installation instructions for ColorTB:
    import sys,ultraTB
    sys.excepthook = ultraTB.VerboseTB()

Note:  Much of the code in this module was lifted verbatim from the standard
library module 'traceback.py' and Ka-Ping Yee's 'cgitb.py'.

* Color schemes
The colors are defined in the class TBTools through the use of the
ColorSchemeTable class. Currently the following exist:

  - NoColor: allows all of this module to be used in any terminal (the color
  escapes are just dummy blank strings).

  - Linux: is meant to look good in a terminal like the Linux console (black
  or very dark background).

  - LightBG: similar to Linux but swaps dark/light colors to be more readable
  in light background terminals.

You can implement other color schemes easily, the syntax is fairly
self-explanatory. Please send back new schemes you develop to the author for
possible inclusion in future releases.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001 Nathaniel Gray &lt;n8gray@caltech.edu&gt;
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;\n%s &lt;%s&gt;' % (Release.authors['Nathan']+
                                    Release.authors['Fernando'])
__license__ = Release.license

# Required modules
import inspect
import keyword
import linecache
import os
import pydoc
import string
import sys
import time
import tokenize
import traceback
import types

# IPython's own modules
# Modified pdb which doesn't damage IPython's readline handling
from IPython import Debugger
from IPython.ipstruct import Struct
from IPython.excolors import ExceptionColors
from IPython.genutils import Term,uniq_stable,error,info

# Globals
# amount of space to put line numbers before verbose tracebacks
INDENT_SIZE = 8

</t>
<t tx="ekr.20071201085751.502">#---------------------------------------------------------------------------
# Code begins

# Utility functions
def inspect_error():
    """Print a message about internal inspect errors.

    These are unfortunately quite common."""
    
    error('Internal Python error in the inspect module.\n'
          'Below is the traceback from this internal error.\n')

</t>
<t tx="ekr.20071201085751.503">def _fixed_getinnerframes(etb, context=1,tb_offset=0):
    import linecache
    LNUM_POS, LINES_POS, INDEX_POS =  2, 4, 5

    records  = inspect.getinnerframes(etb, context)

    # If the error is at the console, don't build any context, since it would
    # otherwise produce 5 blank lines printed out (there is no file at the
    # console)
    rec_check = records[tb_offset:]
    try:
        rname = rec_check[0][1]
        if rname == '&lt;ipython console&gt;' or rname.endswith('&lt;string&gt;'):
            return rec_check
    except IndexError:
        pass

    aux = traceback.extract_tb(etb)
    assert len(records) == len(aux)
    for i, (file, lnum, _, _) in zip(range(len(records)), aux):
        maybeStart = lnum-1 - context//2
        start =  max(maybeStart, 0)
        end   = start + context
        lines = linecache.getlines(file)[start:end]
        # pad with empty lines if necessary
        if maybeStart &lt; 0:
            lines = (['\n'] * -maybeStart) + lines
        if len(lines) &lt; context:
            lines += ['\n'] * (context - len(lines))
        buf = list(records[i])
        buf[LNUM_POS] = lnum
        buf[INDEX_POS] = lnum - 1 - start
        buf[LINES_POS] = lines
        records[i] = tuple(buf)
    return records[tb_offset:]

</t>
<t tx="ekr.20071201085751.504"># Helper function -- largely belongs to VerboseTB, but we need the same
# functionality to produce a pseudo verbose TB for SyntaxErrors, so that they
# can be recognized properly by ipython.el's py-traceback-line-re
# (SyntaxErrors have to be treated specially because they have no traceback)
def _formatTracebackLines(lnum, index, lines, Colors, lvals=None):
    numbers_width = INDENT_SIZE - 1
    res = []
    i = lnum - index
    for line in lines:
        if i == lnum:
            # This is the line with the error
            pad = numbers_width - len(str(i))
            if pad &gt;= 3:
                marker = '-'*(pad-3) + '-&gt; '
            elif pad == 2:
                marker = '&gt; '
            elif pad == 1:
                marker = '&gt;'
            else:
                marker = ''
            num = marker + str(i)
            line = '%s%s%s %s%s' %(Colors.linenoEm, num, 
                                   Colors.line, line, Colors.Normal)
        else:
            num = '%*s' % (numbers_width,i)
            line = '%s%s%s %s' %(Colors.lineno, num, 
                                 Colors.Normal, line)

        res.append(line)
        if lvals and i == lnum:
            res.append(lvals + '\n')
        i = i + 1
    return res

</t>
<t tx="ekr.20071201085751.505">#---------------------------------------------------------------------------
# Module classes
class TBTools:
    """Basic tools used by all traceback printer classes."""
    @others
</t>
<t tx="ekr.20071201085751.506">
def __init__(self,color_scheme = 'NoColor',call_pdb=False):
    # Whether to call the interactive pdb debugger after printing
    # tracebacks or not
    self.call_pdb = call_pdb

    # Create color table
    self.color_scheme_table = ExceptionColors 

    self.set_colors(color_scheme)
    self.old_scheme = color_scheme  # save initial value for toggles

    if call_pdb:
        self.pdb = Debugger.Pdb(self.color_scheme_table.active_scheme_name)
    else:
        self.pdb = None

</t>
<t tx="ekr.20071201085751.507">def set_colors(self,*args,**kw):
    """Shorthand access to the color table scheme selector method."""

    # Set own color table
    self.color_scheme_table.set_active_scheme(*args,**kw)
    # for convenience, set Colors to the active scheme
    self.Colors = self.color_scheme_table.active_colors
    # Also set colors of debugger
    if hasattr(self,'pdb') and self.pdb is not None:
        self.pdb.set_colors(*args,**kw)

</t>
<t tx="ekr.20071201085751.508">def color_toggle(self):
    """Toggle between the currently active color scheme and NoColor."""
    
    if self.color_scheme_table.active_scheme_name == 'NoColor':
        self.color_scheme_table.set_active_scheme(self.old_scheme)
        self.Colors = self.color_scheme_table.active_colors
    else:
        self.old_scheme = self.color_scheme_table.active_scheme_name
        self.color_scheme_table.set_active_scheme('NoColor')
        self.Colors = self.color_scheme_table.active_colors

</t>
<t tx="ekr.20071201085751.509">#---------------------------------------------------------------------------
class ListTB(TBTools):
    """Print traceback information from a traceback list, with optional color.
        
    Calling: requires 3 arguments:
      (etype, evalue, elist)
    as would be obtained by:
      etype, evalue, tb = sys.exc_info()
      if tb:
        elist = traceback.extract_tb(tb)
      else:
        elist = None

    It can thus be used by programs which need to process the traceback before
    printing (such as console replacements based on the code module from the
    standard library).

    Because they are meant to be called without a full traceback (only a
    list), instances of this class can't call the interactive pdb debugger."""
    @others
</t>
<t tx="ekr.20071201085751.510">
def __init__(self,color_scheme = 'NoColor'):
    TBTools.__init__(self,color_scheme = color_scheme,call_pdb=0)
    
</t>
<t tx="ekr.20071201085751.511">def __call__(self, etype, value, elist):
    print &gt;&gt; Term.cerr, self.text(etype,value,elist)

</t>
<t tx="ekr.20071201085751.512">def text(self,etype, value, elist,context=5):
    """Return a color formatted string with the traceback info."""

    Colors = self.Colors
    out_string = ['%s%s%s\n' % (Colors.topline,'-'*60,Colors.Normal)]
    if elist:
        out_string.append('Traceback %s(most recent call last)%s:' % \
                            (Colors.normalEm, Colors.Normal) + '\n')
        out_string.extend(self._format_list(elist))
    lines = self._format_exception_only(etype, value)
    for line in lines[:-1]:
        out_string.append(" "+line)
    out_string.append(lines[-1])
    return ''.join(out_string)

</t>
<t tx="ekr.20071201085751.513">def _format_list(self, extracted_list):
    """Format a list of traceback entry tuples for printing.

    Given a list of tuples as returned by extract_tb() or
    extract_stack(), return a list of strings ready for printing.
    Each string in the resulting list corresponds to the item with the
    same index in the argument list.  Each string ends in a newline;
    the strings may contain internal newlines as well, for those items
    whose source text line is not None.
    
    Lifted almost verbatim from traceback.py
    """

    Colors = self.Colors
    list = []
    for filename, lineno, name, line in extracted_list[:-1]:
        item = '  File %s"%s"%s, line %s%d%s, in %s%s%s\n' % \
                (Colors.filename, filename, Colors.Normal, 
                 Colors.lineno, lineno, Colors.Normal,
                 Colors.name, name, Colors.Normal)
        if line:
            item = item + '    %s\n' % line.strip()
        list.append(item)
    # Emphasize the last entry
    filename, lineno, name, line = extracted_list[-1]
    item = '%s  File %s"%s"%s, line %s%d%s, in %s%s%s%s\n' % \
            (Colors.normalEm,
             Colors.filenameEm, filename, Colors.normalEm,
             Colors.linenoEm, lineno, Colors.normalEm,
             Colors.nameEm, name, Colors.normalEm,
             Colors.Normal)
    if line:
        item = item + '%s    %s%s\n' % (Colors.line, line.strip(),
                                        Colors.Normal)
    list.append(item)
    return list
    
</t>
<t tx="ekr.20071201085751.514">def _format_exception_only(self, etype, value):
    """Format the exception part of a traceback.

    The arguments are the exception type and value such as given by
    sys.exc_info()[:2]. The return value is a list of strings, each ending
    in a newline.  Normally, the list contains a single string; however,
    for SyntaxError exceptions, it contains several lines that (when
    printed) display detailed information about where the syntax error
    occurred.  The message indicating which exception occurred is the
    always last string in the list.
    
    Also lifted nearly verbatim from traceback.py
    """
    
    Colors = self.Colors
    list = []
    if type(etype) == types.ClassType:
        stype = Colors.excName + etype.__name__ + Colors.Normal
    else:
        stype = etype  # String exceptions don't get special coloring
    if value is None:
        list.append( str(stype) + '\n')
    else:
        if etype is SyntaxError:
            try:
                msg, (filename, lineno, offset, line) = value
            except:
                pass
            else:
                #print 'filename is',filename  # dbg
                if not filename: filename = "&lt;string&gt;"
                list.append('%s  File %s"%s"%s, line %s%d%s\n' % \
                        (Colors.normalEm,
                         Colors.filenameEm, filename, Colors.normalEm,
                         Colors.linenoEm, lineno, Colors.Normal  ))
                if line is not None:
                    i = 0
                    while i &lt; len(line) and line[i].isspace():
                        i = i+1
                    list.append('%s    %s%s\n' % (Colors.line,
                                                  line.strip(), 
                                                  Colors.Normal))
                    if offset is not None:
                        s = '    '
                        for c in line[i:offset-1]:
                            if c.isspace():
                                s = s + c
                            else:
                                s = s + ' '
                        list.append('%s%s^%s\n' % (Colors.caret, s,
                                                   Colors.Normal) )
                    value = msg
        s = self._some_str(value)
        if s:
            list.append('%s%s:%s %s\n' % (str(stype), Colors.excName,
                                          Colors.Normal, s))
        else:
            list.append('%s\n' % str(stype))
    return list

</t>
<t tx="ekr.20071201085751.515">def _some_str(self, value):
    # Lifted from traceback.py
    try:
        return str(value)
    except:
        return '&lt;unprintable %s object&gt;' % type(value).__name__

</t>
<t tx="ekr.20071201085751.516">#----------------------------------------------------------------------------
class VerboseTB(TBTools):
    """A port of Ka-Ping Yee's cgitb.py module that outputs color text instead
    of HTML.  Requires inspect and pydoc.  Crazy, man.

    Modified version which optionally strips the topmost entries from the
    traceback, to be used with alternate interpreters (because their own code
    would appear in the traceback)."""
    @others
</t>
<t tx="ekr.20071201085751.517">
def __init__(self,color_scheme = 'Linux',tb_offset=0,long_header=0,
             call_pdb = 0, include_vars=1):
    """Specify traceback offset, headers and color scheme.

    Define how many frames to drop from the tracebacks. Calling it with
    tb_offset=1 allows use of this handler in interpreters which will have
    their own code at the top of the traceback (VerboseTB will first
    remove that frame before printing the traceback info)."""
    TBTools.__init__(self,color_scheme=color_scheme,call_pdb=call_pdb)
    self.tb_offset = tb_offset
    self.long_header = long_header
    self.include_vars = include_vars

</t>
<t tx="ekr.20071201085751.518">def text(self, etype, evalue, etb, context=5):
    """Return a nice text document describing the traceback."""

    # some locals
    Colors        = self.Colors   # just a shorthand + quicker name lookup
    ColorsNormal  = Colors.Normal  # used a lot
    indent        = ' '*INDENT_SIZE
    exc           = '%s%s%s' % (Colors.excName, str(etype), ColorsNormal)
    em_normal     = '%s\n%s%s' % (Colors.valEm, indent,ColorsNormal)
    undefined     = '%sundefined%s' % (Colors.em, ColorsNormal)

    # some internal-use functions
    def text_repr(value):
        """Hopefully pretty robust repr equivalent."""
        # this is pretty horrible but should always return *something*
        try:
            return pydoc.text.repr(value)
        except KeyboardInterrupt:
            raise
        except:
            try:
                return repr(value)
            except KeyboardInterrupt:
                raise
            except:
                try:
                    # all still in an except block so we catch
                    # getattr raising
                    name = getattr(value, '__name__', None)
                    if name:
                        # ick, recursion
                        return text_repr(name)
                    klass = getattr(value, '__class__', None)
                    if klass:
                        return '%s instance' % text_repr(klass)
                except KeyboardInterrupt:
                    raise
                except:
                    return 'UNRECOVERABLE REPR FAILURE'
    def eqrepr(value, repr=text_repr): return '=%s' % repr(value)
    def nullrepr(value, repr=text_repr): return ''

    # meat of the code begins
    if type(etype) is types.ClassType:
        etype = etype.__name__

    if self.long_header:
        # Header with the exception type, python version, and date
        pyver = 'Python ' + string.split(sys.version)[0] + ': ' + sys.executable
        date = time.ctime(time.time())
        
        head = '%s%s%s\n%s%s%s\n%s' % (Colors.topline, '-'*75, ColorsNormal,
                                       exc, ' '*(75-len(str(etype))-len(pyver)),
                                       pyver, string.rjust(date, 75) )
        head += "\nA problem occured executing Python code.  Here is the sequence of function"\
                "\ncalls leading up to the error, with the most recent (innermost) call last."
    else:
        # Simplified header
        head = '%s%s%s\n%s%s' % (Colors.topline, '-'*75, ColorsNormal,exc,
                                 string.rjust('Traceback (most recent call last)',
                                              75 - len(str(etype)) ) )
    frames = []
    # Flush cache before calling inspect.  This helps alleviate some of the
    # problems with python 2.3's inspect.py.
    linecache.checkcache()
    # Drop topmost frames if requested
    try:
        # Try the default getinnerframes and Alex's: Alex's fixes some
        # problems, but it generates empty tracebacks for console errors
        # (5 blanks lines) where none should be returned.
        #records = inspect.getinnerframes(etb, context)[self.tb_offset:]
        #print 'python records:', records # dbg
        records = _fixed_getinnerframes(etb, context,self.tb_offset)
        #print 'alex   records:', records # dbg
    except:

        # FIXME: I've been getting many crash reports from python 2.3
        # users, traceable to inspect.py.  If I can find a small test-case
        # to reproduce this, I should either write a better workaround or
        # file a bug report against inspect (if that's the real problem).
        # So far, I haven't been able to find an isolated example to
        # reproduce the problem.
        inspect_error()
        traceback.print_exc(file=Term.cerr)
        info('\nUnfortunately, your original traceback can not be constructed.\n')
        return ''

    # build some color string templates outside these nested loops
    tpl_link       = '%s%%s%s' % (Colors.filenameEm,ColorsNormal)
    tpl_call       = 'in %s%%s%s%%s%s' % (Colors.vName, Colors.valEm,
                                          ColorsNormal)
    tpl_call_fail  = 'in %s%%s%s(***failed resolving arguments***)%s' % \
                     (Colors.vName, Colors.valEm, ColorsNormal)
    tpl_local_var  = '%s%%s%s' % (Colors.vName, ColorsNormal)
    tpl_global_var = '%sglobal%s %s%%s%s' % (Colors.em, ColorsNormal,
                                             Colors.vName, ColorsNormal)
    tpl_name_val   = '%%s %s= %%s%s' % (Colors.valEm, ColorsNormal)
    tpl_line       = '%s%%s%s %%s' % (Colors.lineno, ColorsNormal)
    tpl_line_em    = '%s%%s%s %%s%s' % (Colors.linenoEm,Colors.line,
                                        ColorsNormal)

    # now, loop over all records printing context and info
    abspath = os.path.abspath
    for frame, file, lnum, func, lines, index in records:
        #print '*** record:',file,lnum,func,lines,index  # dbg
        try:
            file = file and abspath(file) or '?'
        except OSError:
            # if file is '&lt;console&gt;' or something not in the filesystem,
            # the abspath call will throw an OSError.  Just ignore it and
            # keep the original file string.
            pass
        link = tpl_link % file
        try:
            args, varargs, varkw, locals = inspect.getargvalues(frame)
        except:
            # This can happen due to a bug in python2.3.  We should be
            # able to remove this try/except when 2.4 becomes a
            # requirement.  Bug details at http://python.org/sf/1005466
            inspect_error()
            traceback.print_exc(file=Term.cerr)
            info("\nIPython's exception reporting continues...\n")
            
        if func == '?':
            call = ''
        else:
            # Decide whether to include variable details or not
            var_repr = self.include_vars and eqrepr or nullrepr
            try:
                call = tpl_call % (func,inspect.formatargvalues(args,
                                            varargs, varkw,
                                            locals,formatvalue=var_repr))
            except KeyError:
                # Very odd crash from inspect.formatargvalues().  The
                # scenario under which it appeared was a call to
                # view(array,scale) in NumTut.view.view(), where scale had
                # been defined as a scalar (it should be a tuple). Somehow
                # inspect messes up resolving the argument list of view()
                # and barfs out. At some point I should dig into this one
                # and file a bug report about it.
                inspect_error()
                traceback.print_exc(file=Term.cerr)
                info("\nIPython's exception reporting continues...\n")
                call = tpl_call_fail % func

        # Initialize a list of names on the current line, which the
        # tokenizer below will populate.
        names = []

        def tokeneater(token_type, token, start, end, line):
            """Stateful tokeneater which builds dotted names.

            The list of names it appends to (from the enclosing scope) can
            contain repeated composite names.  This is unavoidable, since
            there is no way to disambguate partial dotted structures until
            the full list is known.  The caller is responsible for pruning
            the final list of duplicates before using it."""
            
            # build composite names
            if token == '.':
                try:
                    names[-1] += '.'
                    # store state so the next token is added for x.y.z names
                    tokeneater.name_cont = True
                    return
                except IndexError:
                    pass
            if token_type == tokenize.NAME and token not in keyword.kwlist:
                if tokeneater.name_cont:
                    # Dotted names
                    names[-1] += token
                    tokeneater.name_cont = False
                else:
                    # Regular new names.  We append everything, the caller
                    # will be responsible for pruning the list later.  It's
                    # very tricky to try to prune as we go, b/c composite
                    # names can fool us.  The pruning at the end is easy
                    # to do (or the caller can print a list with repeated
                    # names if so desired.
                    names.append(token)
            elif token_type == tokenize.NEWLINE:
                raise IndexError
        # we need to store a bit of state in the tokenizer to build
        # dotted names
        tokeneater.name_cont = False

        def linereader(file=file, lnum=[lnum], getline=linecache.getline):
            line = getline(file, lnum[0])
            lnum[0] += 1
            return line

        # Build the list of names on this line of code where the exception
        # occurred.
        try:
            # This builds the names list in-place by capturing it from the
            # enclosing scope.
            tokenize.tokenize(linereader, tokeneater)
        except IndexError:
            # signals exit of tokenizer
            pass
        except tokenize.TokenError,msg:
            _m = ("An unexpected error occurred while tokenizing input\n"
                  "The following traceback may be corrupted or invalid\n"
                  "The error message is: %s\n" % msg)
            error(_m)
        
        # prune names list of duplicates, but keep the right order
        unique_names = uniq_stable(names)

        # Start loop over vars
        lvals = []
        if self.include_vars:
            for name_full in unique_names:
                name_base = name_full.split('.',1)[0]
                if name_base in frame.f_code.co_varnames:
                    if locals.has_key(name_base):
                        try:
                            value = repr(eval(name_full,locals))
                        except:
                            value = undefined
                    else:
                        value = undefined
                    name = tpl_local_var % name_full
                else:
                    if frame.f_globals.has_key(name_base):
                        try:
                            value = repr(eval(name_full,frame.f_globals))
                        except:
                            value = undefined
                    else:
                        value = undefined
                    name = tpl_global_var % name_full
                lvals.append(tpl_name_val % (name,value))
        if lvals:
            lvals = '%s%s' % (indent,em_normal.join(lvals))
        else:
            lvals = ''

        level = '%s %s\n' % (link,call)

        if index is None:
            frames.append(level)
        else:
            frames.append('%s%s' % (level,''.join(
                _formatTracebackLines(lnum,index,lines,self.Colors,lvals))))

    # Get (safely) a string form of the exception info
    try:
        etype_str,evalue_str = map(str,(etype,evalue))
    except:
        # User exception is improperly defined.
        etype,evalue = str,sys.exc_info()[:2]
        etype_str,evalue_str = map(str,(etype,evalue))
    # ... and format it
    exception = ['%s%s%s: %s' % (Colors.excName, etype_str,
                                 ColorsNormal, evalue_str)]
    if type(evalue) is types.InstanceType:
        try:
            names = [w for w in dir(evalue) if isinstance(w, basestring)]
        except:
            # Every now and then, an object with funny inernals blows up
            # when dir() is called on it.  We do the best we can to report
            # the problem and continue
            _m = '%sException reporting error (object with broken dir())%s:'
            exception.append(_m % (Colors.excName,ColorsNormal))
            etype_str,evalue_str = map(str,sys.exc_info()[:2])
            exception.append('%s%s%s: %s' % (Colors.excName,etype_str,
                                 ColorsNormal, evalue_str))
            names = []
        for name in names:
            value = text_repr(getattr(evalue, name))
            exception.append('\n%s%s = %s' % (indent, name, value))
    # return all our info assembled as a single string
    return '%s\n\n%s\n%s' % (head,'\n'.join(frames),''.join(exception[0]) )

</t>
<t tx="ekr.20071201085751.519">def debugger(self,force=False):
    """Call up the pdb debugger if desired, always clean up the tb
    reference.

    Keywords:

      - force(False): by default, this routine checks the instance call_pdb
      flag and does not actually invoke the debugger if the flag is false.
      The 'force' option forces the debugger to activate even if the flag
      is false.

    If the call_pdb flag is set, the pdb interactive debugger is
    invoked. In all cases, the self.tb reference to the current traceback
    is deleted to prevent lingering references which hamper memory
    management.

    Note that each call to pdb() does an 'import readline', so if your app
    requires a special setup for the readline completers, you'll have to
    fix that by hand after invoking the exception handler."""

    if force or self.call_pdb:
        if self.pdb is None:
            self.pdb = Debugger.Pdb(
                self.color_scheme_table.active_scheme_name)
        # the system displayhook may have changed, restore the original
        # for pdb
        dhook = sys.displayhook
        sys.displayhook = sys.__displayhook__
        self.pdb.reset()
        # Find the right frame so we don't pop up inside ipython itself
        if hasattr(self,'tb'):
            etb = self.tb
        else:
            etb = self.tb = sys.last_traceback
        while self.tb.tb_next is not None:
            self.tb = self.tb.tb_next
        try:
            if etb and etb.tb_next:
                etb = etb.tb_next
            self.pdb.botframe = etb.tb_frame
            self.pdb.interaction(self.tb.tb_frame, self.tb)
        finally:
            sys.displayhook = dhook
        
    if hasattr(self,'tb'):
        del self.tb

</t>
<t tx="ekr.20071201085751.520">def handler(self, info=None):
    (etype, evalue, etb) = info or sys.exc_info()
    self.tb = etb
    print &gt;&gt; Term.cerr, self.text(etype, evalue, etb)

</t>
<t tx="ekr.20071201085751.521"># Changed so an instance can just be called as VerboseTB_inst() and print
# out the right info on its own.
def __call__(self, etype=None, evalue=None, etb=None):
    """This hook can replace sys.excepthook (for Python 2.1 or higher)."""
    if etb is None:
        self.handler()
    else:
        self.handler((etype, evalue, etb))
    self.debugger()

</t>
<t tx="ekr.20071201085751.522">#----------------------------------------------------------------------------
class FormattedTB(VerboseTB,ListTB):
    """Subclass ListTB but allow calling with a traceback.

    It can thus be used as a sys.excepthook for Python &gt; 2.1.

    Also adds 'Context' and 'Verbose' modes, not available in ListTB.

    Allows a tb_offset to be specified. This is useful for situations where
    one needs to remove a number of topmost frames from the traceback (such as
    occurs with python programs that themselves execute other python code,
    like Python shells).  """
    @others
</t>
<t tx="ekr.20071201085751.523">
def __init__(self, mode = 'Plain', color_scheme='Linux',
             tb_offset = 0,long_header=0,call_pdb=0,include_vars=0):

    # NEVER change the order of this list. Put new modes at the end:
    self.valid_modes = ['Plain','Context','Verbose']
    self.verbose_modes = self.valid_modes[1:3]

    VerboseTB.__init__(self,color_scheme,tb_offset,long_header,
                       call_pdb=call_pdb,include_vars=include_vars)
    self.set_mode(mode)
    
</t>
<t tx="ekr.20071201085751.524">def _extract_tb(self,tb):
    if tb:
        return traceback.extract_tb(tb)
    else:
        return None

</t>
<t tx="ekr.20071201085751.525">def text(self, etype, value, tb,context=5,mode=None):
    """Return formatted traceback.

    If the optional mode parameter is given, it overrides the current
    mode."""

    if mode is None:
        mode = self.mode
    if mode in self.verbose_modes:
        # verbose modes need a full traceback
        return VerboseTB.text(self,etype, value, tb,context=5)
    else:
        # We must check the source cache because otherwise we can print
        # out-of-date source code.
        linecache.checkcache()
        # Now we can extract and format the exception
        elist = self._extract_tb(tb)
        if len(elist) &gt; self.tb_offset:
            del elist[:self.tb_offset]
        return ListTB.text(self,etype,value,elist)

</t>
<t tx="ekr.20071201085751.526">def set_mode(self,mode=None):
    """Switch to the desired mode.

    If mode is not specified, cycles through the available modes."""

    if not mode:
        new_idx = ( self.valid_modes.index(self.mode) + 1 ) % \
                  len(self.valid_modes)
        self.mode = self.valid_modes[new_idx]
    elif mode not in self.valid_modes:
        raise ValueError, 'Unrecognized mode in FormattedTB: &lt;'+mode+'&gt;\n'\
              'Valid modes: '+str(self.valid_modes)
    else:
        self.mode = mode
    # include variable details only in 'Verbose' mode
    self.include_vars = (self.mode == self.valid_modes[2])

</t>
<t tx="ekr.20071201085751.527"># some convenient shorcuts
def plain(self):
    self.set_mode(self.valid_modes[0])

</t>
<t tx="ekr.20071201085751.528">def context(self):
    self.set_mode(self.valid_modes[1])

</t>
<t tx="ekr.20071201085751.529">def verbose(self):
    self.set_mode(self.valid_modes[2])

</t>
<t tx="ekr.20071201085751.530">#----------------------------------------------------------------------------
class AutoFormattedTB(FormattedTB):
    """A traceback printer which can be called on the fly.

    It will find out about exceptions by itself.

    A brief example:
    
    AutoTB = AutoFormattedTB(mode = 'Verbose',color_scheme='Linux')
    try:
      ...
    except:
      AutoTB()  # or AutoTB(out=logfile) where logfile is an open file object
    """
    @others
</t>
<t tx="ekr.20071201085751.531">def __call__(self,etype=None,evalue=None,etb=None,
             out=None,tb_offset=None):
    """Print out a formatted exception traceback.

    Optional arguments:
      - out: an open file-like object to direct output to.

      - tb_offset: the number of frames to skip over in the stack, on a
      per-call basis (this overrides temporarily the instance's tb_offset
      given at initialization time.  """
    
    if out is None:
        out = Term.cerr
    if tb_offset is not None:
        tb_offset, self.tb_offset = self.tb_offset, tb_offset
        print &gt;&gt; out, self.text(etype, evalue, etb)
        self.tb_offset = tb_offset
    else:
        print &gt;&gt; out, self.text(etype, evalue, etb)
    self.debugger()

</t>
<t tx="ekr.20071201085751.532">def text(self,etype=None,value=None,tb=None,context=5,mode=None):
    if etype is None:
        etype,value,tb = sys.exc_info()
    self.tb = tb
    return FormattedTB.text(self,etype,value,tb,context=5,mode=mode)

</t>
<t tx="ekr.20071201085751.533">#---------------------------------------------------------------------------
# A simple class to preserve Nathan's original functionality.
class ColorTB(FormattedTB):
    """Shorthand to initialize a FormattedTB in Linux colors mode."""
    @others
</t>
<t tx="ekr.20071201085751.534">def __init__(self,color_scheme='Linux',call_pdb=0):
    FormattedTB.__init__(self,color_scheme=color_scheme,
                         call_pdb=call_pdb)

</t>
<t tx="ekr.20071201085751.535">#!/usr/bin/env python
""" A script/util to upgrade all files in a directory

This is rather conservative in its approach, only copying/overwriting
new and unedited files.

To be used by "upgrade" feature.
"""
try:
    from IPython.Extensions.path import path
except ImportError:
    try:
        from Extensions.path import path
    except ImportError:
        from path import path

import md5,pickle

</t>
<t tx="ekr.20071201085751.536">def showdiff(old,new):
    import difflib
    d = difflib.Differ()
    lines = d.compare(old.lines(),new.lines())
    realdiff = False
    for l in lines:
        print l,
        if not realdiff and not l[0].isspace():
            realdiff = True
    return realdiff

</t>
<t tx="ekr.20071201085751.537">def upgrade_dir(srcdir, tgtdir):
    """ Copy over all files in srcdir to tgtdir w/ native line endings

    Creates .upgrade_report in tgtdir that stores md5sums of all files
    to notice changed files b/w upgrades.
    """

    def pr(s):
        print s

    def ignorable(p):
        if p.lower().startswith('.svn') or p.startswith('ipythonrc'):
            return True
        return False


    modded = []
    files = [path(srcdir).relpathto(p) for p in path(srcdir).walkfiles()]
    #print files
    rep = tgtdir / '.upgrade_report'
    try:
        rpt = pickle.load(rep.open())
    except:
        rpt = {}

    for f in files:
        if ignorable(f):
            continue
        src = srcdir / f
        tgt = tgtdir / f
        if not tgt.isfile():
            pr("Creating %s" % str(tgt))

            tgt.write_text(src.text())
            rpt[str(tgt)] = md5.new(tgt.text()).hexdigest()
        else:
            cont = tgt.text()
            sum = rpt.get(str(tgt), None)
            #print sum
            if sum and md5.new(cont).hexdigest() == sum:
                pr("Unedited, installing new %s" % tgt)
                tgt.write_text(src.text())
                rpt[str(tgt)] = md5.new(tgt.text()).hexdigest()
            else:
                pr(' == Modified, skipping %s, diffs below == ' % tgt)
                #rpt[str(tgt)] = md5.new(tgt.bytes()).hexdigest()
                real = showdiff(tgt,src)
                pr('') # empty line
                if not real:
                    pr("(Ok, it wasn't that different at all, upgrading checksum)")
                    rpt[str(tgt)] = md5.new(tgt.text()).hexdigest()
                else:
                    modded.append(tgt)

        #print rpt
    pickle.dump(rpt, rep.open('w'))
    if modded:
        print "\n\nDelete the following files manually (and rerun %upgrade)\nif you need a full upgrade:"
        for m in modded:
            print m


</t>
<t tx="ekr.20071201085751.538"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

# $Id$

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license
__version__ = Release.version

__doc__ = """
IPython -- An enhanced Interactive Python
=========================================

A Python shell with automatic history (input and output), dynamic object
introspection, easier configuration, command completion, access to the system
shell and more.

IPython can also be embedded in running programs. See EMBEDDING below.


USAGE
       ipython [options] files

       If invoked with no options, it executes all the files listed in
       sequence and drops you into the interpreter while still acknowledging
       any options you may have set in your ipythonrc file. This behavior is
       different from standard Python, which when called as python -i will
       only execute one file and will ignore your configuration setup.

       Please note that some of the configuration options are not available at
       the command line, simply because they are not practical here. Look into
       your ipythonrc configuration file for details on those. This file
       typically installed in the $HOME/.ipython directory.

       For Windows users, $HOME resolves to C:\\Documents and
       Settings\\YourUserName in most instances, and _ipython is used instead
       of .ipython, since some Win32 programs have problems with dotted names
       in directories.

       In the rest of this text, we will refer to this directory as
       IPYTHONDIR.


SPECIAL THREADING OPTIONS
       The following special options are ONLY valid at the  beginning  of  the
       command line, and not later.  This is because they control the initial-
       ization of ipython itself, before the normal option-handling  mechanism
       is active.

       -gthread, -qthread, -wthread, -pylab

              Only ONE of these can be given, and it can only be given as the
              first option passed to IPython (it will have no effect in any
              other position).  They provide threading support for the GTK, QT
              and WXWidgets toolkits, and for the matplotlib library.

              With any of the first three options, IPython starts running a
              separate thread for the graphical toolkit's operation, so that
              you can open and control graphical elements from within an
              IPython command line, without blocking.  All three provide
              essentially the same functionality, respectively for GTK, QT and
              WXWidgets (via their Python interfaces).

              Note that with -wthread, you can additionally use the -wxversion
              option to request a specific version of wx to be used.  This
              requires that you have the 'wxversion' Python module installed,
              which is part of recent wxPython distributions.

              If -pylab is given, IPython loads special support for the mat-
              plotlib library (http://matplotlib.sourceforge.net), allowing
              interactive usage of any of its backends as defined in the
              user's .matplotlibrc file.  It automatically activates GTK, QT
              or WX threading for IPyhton if the choice of matplotlib backend
              requires it.  It also modifies the %run command to correctly
              execute (without blocking) any matplotlib-based script which
              calls show() at the end.

       -tk    The -g/q/wthread options, and -pylab (if matplotlib is
              configured to use GTK, QT or WX), will normally block Tk
              graphical interfaces.  This means that when GTK, QT or WX
              threading is active, any attempt to open a Tk GUI will result in
              a dead window, and possibly cause the Python interpreter to
              crash.  An extra option, -tk, is available to address this
              issue.  It can ONLY be given as a SECOND option after any of the
              above (-gthread, -qthread, -wthread or -pylab).

              If -tk is given, IPython will try to coordinate Tk threading
              with GTK, QT or WX.  This is however potentially unreliable, and
              you will have to test on your platform and Python configuration
              to determine whether it works for you.  Debian users have
              reported success, apparently due to the fact that Debian builds
              all of Tcl, Tk, Tkinter and Python with pthreads support.  Under
              other Linux environments (such as Fedora Core 2/3), this option
              has caused random crashes and lockups of the Python interpreter.
              Under other operating systems (Mac OSX and Windows), you'll need
              to try it to find out, since currently no user reports are
              available.

              There is unfortunately no way for IPython to determine  at  run-
              time  whether -tk will work reliably or not, so you will need to
              do some experiments before relying on it for regular work.

A WARNING ABOUT SIGNALS AND THREADS

       When any of the thread systems (GTK, QT or WX) are active, either
       directly or via -pylab with a threaded backend, it is impossible to
       interrupt long-running Python code via Ctrl-C.  IPython can not pass
       the KeyboardInterrupt exception (or the underlying SIGINT) across
       threads, so any long-running process started from IPython will run to
       completion, or will have to be killed via an external (OS-based)
       mechanism.

       To the best of my knowledge, this limitation is imposed by the Python
       interpreter itself, and it comes from the difficulty of writing
       portable signal/threaded code.  If any user is an expert on this topic
       and can suggest a better solution, I would love to hear about it.  In
       the IPython sources, look at the Shell.py module, and in particular at
       the runcode() method.

REGULAR OPTIONS
       After the above threading options have been given, regular options  can
       follow  in any order.  All options can be abbreviated to their shortest
       non-ambiguous form and are case-sensitive.  One or two  dashes  can  be
       used.   Some options have an alternate short form, indicated after a |.

       Most options can also be set from your  ipythonrc  configuration  file.
       See the provided examples for assistance.  Options given on the comman-
       dline override the values set in the ipythonrc file.

       All options with a [no] prepended can be specified in negated form
       (using -nooption instead of -option) to turn the feature off.

       -h, --help
              Show summary of options.

       -pylab This can only be given as the first option passed to IPython (it
              will have no effect in any other position). It adds special sup-
              port   for  the  matplotlib  library  (http://matplotlib.source-
              forge.net), allowing interactive usage of any of its backends as
              defined  in  the  user's  .matplotlibrc  file.  It automatically
              activates GTK or WX threading for IPyhton if the choice of  mat-
              plotlib  backend requires it.  It also modifies the @run command
              to correctly execute  (without  blocking)  any  matplotlib-based
              script which calls show() at the end.

       -autocall &lt;val&gt;
              Make IPython automatically call any callable object even if you
              didn't type explicit parentheses. For example, 'str 43' becomes
              'str(43)' automatically.  The value can be '0' to disable the
              feature, '1' for 'smart' autocall, where it is not applied if
              there are no more arguments on the line, and '2' for 'full'
              autocall, where all callable objects are automatically called
              (even if no arguments are present).  The default is '1'.

       -[no]autoindent
              Turn automatic indentation on/off.

       -[no]automagic
              Make magic commands automatic (without needing their first char-
              acter to be %).  Type %magic at  the  IPython  prompt  for  more
              information.

       -[no]autoedit_syntax
              When a syntax error occurs after editing a file, automatically
              open the file to the trouble causing line for convenient fixing.

       -[no]banner
              Print the intial information banner (default on).

       -c &lt;command&gt;
              Execute  the  given  command  string, and set sys.argv to ['c'].
              This is similar to the -c option in  the  normal  Python  inter-
              preter.

       -cache_size|cs &lt;n&gt;
              Size  of  the output cache (maximum number of entries to hold in
              memory).  The default is 1000, you can change it permanently  in
              your  config  file.   Setting  it  to  0 completely disables the
              caching system, and the minimum value accepted  is  20  (if  you
              provide  a value less than 20, it is reset to 0 and a warning is
              issued).  This limit is defined because otherwise  you'll  spend
              more time re-flushing a too small cache than working.

       -classic|cl
              Gives IPython a similar feel to the classic Python prompt.

       -colors &lt;scheme&gt;
              Color  scheme  for  prompts  and exception reporting.  Currently
              implemented: NoColor, Linux, and LightBG.

       -[no]color_info
              IPython can display information about objects via a set of func-
              tions, and optionally can use colors for this, syntax highlight-
              ing source code and various other  elements.   However,  because
              this  information  is  passed  through a pager (like 'less') and
              many pagers get confused with color codes, this option is off by
              default.   You  can  test  it and turn it on permanently in your
              ipythonrc file if it works for you.  As a reference, the  'less'
              pager  supplied  with  Mandrake 8.2 works ok, but that in RedHat
              7.2 doesn't.

              Test it and turn it on permanently if it works with your system.
              The  magic function @color_info allows you to toggle this inter-
              actively for testing.

       -[no]confirm_exit
              Set to confirm when you try to exit IPython with  an  EOF  (Con-
              trol-D in Unix, Control-Z/Enter in Windows). Note that using the
              magic functions @Exit or @Quit you  can  force  a  direct  exit,
              bypassing any confirmation.

       -[no]debug
              Show  information  about the loading process. Very useful to pin
              down problems with your configuration files or  to  get  details
              about session restores.

       -[no]deep_reload
              IPython  can use the deep_reload module which reloads changes in
              modules recursively (it replaces the reload() function,  so  you
              don't need to change anything to use it). deep_reload() forces a
              full reload of modules whose code may have  changed,  which  the
              default reload() function does not.

              When  deep_reload  is off, IPython will use the normal reload(),
              but deep_reload will still be available as dreload(). This  fea-
              ture  is  off  by default [which means that you have both normal
              reload() and dreload()].

       -editor &lt;name&gt;
              Which editor to use with the @edit command. By default,  IPython
              will  honor  your EDITOR environment variable (if not set, vi is
              the Unix default and notepad the Windows one). Since this editor
              is  invoked on the fly by IPython and is meant for editing small
              code snippets, you may want to use a small,  lightweight  editor
              here (in case your default EDITOR is something like Emacs).

       -ipythondir &lt;name&gt;
              The  name  of  your  IPython configuration directory IPYTHONDIR.
              This can also be  specified  through  the  environment  variable
              IPYTHONDIR.

       -log|l Generate  a log file of all input. The file is named
              ipython_log.py in your current directory (which prevents logs
              from multiple IPython sessions from trampling each other). You
              can use this to later restore a session by loading your logfile
              as a file to be executed with option -logplay (see below).

       -logfile|lf
              Specify the name of your logfile.

       -logplay|lp
              Replay  a previous log. For restoring a session as close as pos-
              sible to the state you left it in, use this option  (don't  just
              run the logfile). With -logplay, IPython will try to reconstruct
              the previous working environment in full, not just  execute  the
              commands in the logfile.
              When  a  session is restored, logging is automatically turned on
              again with the name of the logfile it was invoked  with  (it  is
              read  from the log header). So once you've turned logging on for
              a session, you can quit IPython and reload it as many  times  as
              you  want  and  it  will continue to log its history and restore
              from the beginning every time.

              Caveats: there are limitations in this option. The history vari-
              ables  _i*,_* and _dh don't get restored properly. In the future
              we will try to implement full  session  saving  by  writing  and
              retrieving  a failed because of inherent limitations of Python's
              Pickle module, so this may have to wait.

       -[no]messages
              Print messages which IPython collects about its startup  process
              (default on).

       -[no]pdb
              Automatically  call the pdb debugger after every uncaught excep-
              tion. If you are used to debugging  using  pdb,  this  puts  you
              automatically  inside of it after any call (either in IPython or
              in code called by it) which triggers  an  exception  which  goes
              uncaught.

       -[no]pprint
              IPython  can  optionally  use the pprint (pretty printer) module
              for displaying results. pprint tends to give a nicer display  of
              nested  data structures. If you like it, you can turn it on per-
              manently in your config file (default off).

       -profile|p &lt;name&gt;
              Assume that your config file is ipythonrc-&lt;name&gt; (looks in  cur-
              rent dir first, then in IPYTHONDIR). This is a quick way to keep
              and load multiple config files for different  tasks,  especially
              if  you  use  the include option of config files. You can keep a
              basic IPYTHONDIR/ipythonrc file and then have  other  'profiles'
              which  include  this  one  and  load extra things for particular
              tasks. For example:

              1) $HOME/.ipython/ipythonrc : load basic things you always want.
              2)  $HOME/.ipython/ipythonrc-math  :  load  (1)  and basic math-
              related modules.
              3) $HOME/.ipython/ipythonrc-numeric : load (1) and  Numeric  and
              plotting modules.

              Since  it is possible to create an endless loop by having circu-
              lar file inclusions, IPython will stop if it reaches  15  recur-
              sive inclusions.

       -prompt_in1|pi1 &lt;string&gt;
              Specify  the string used for input prompts. Note that if you are
              using numbered prompts, the number is represented with a '\#' in
              the  string.  Don't forget to quote strings with spaces embedded
              in them. Default: 'In [\#]: '.

              Most bash-like  escapes  can  be  used  to  customize  IPython's
              prompts, as well as a few additional ones which are IPython-spe-
              cific.  All valid prompt escapes are described in detail in  the
              Customization section of the IPython HTML/PDF manual.

       -prompt_in2|pi2 &lt;string&gt;
              Similar to the previous option, but used for the continuation
              prompts. The special sequence '\D' is similar to '\#', but with
              all digits replaced dots (so you can have your continuation
              prompt aligned with your input prompt).  Default: ' .\D.: '
              (note three spaces at the start for alignment with 'In [\#]').

       -prompt_out|po &lt;string&gt;
              String   used   for  output  prompts,  also  uses  numbers  like
              prompt_in1.  Default: 'Out[\#]:'.

       -quick Start in bare bones mode (no config file loaded).

       -rcfile &lt;name&gt;
              Name of your  IPython  resource  configuration  file.   normally
              IPython    loads   ipythonrc   (from   current   directory)   or
              IPYTHONDIR/ipythonrc.  If the loading of your config file fails,
              IPython  starts  with  a  bare  bones  configuration (no modules
              loaded at all).

       -[no]readline
              Use the readline library, which is needed to support  name  com-
              pletion  and  command history, among other things. It is enabled
              by default, but may cause  problems  for  users  of  X/Emacs  in
              Python comint or shell buffers.

              Note  that  emacs 'eterm' buffers (opened with M-x term) support
              IPython's readline and syntax coloring fine, only  'emacs'  (M-x
              shell and C-c !)  buffers do not.

       -screen_length|sl &lt;n&gt;
              Number  of lines of your screen.  This is used to control print-
              ing of very long strings.  Strings longer than  this  number  of
              lines  will be sent through a pager instead of directly printed.

              The default value for this is 0, which means IPython will  auto-
              detect  your  screen  size  every time it needs to print certain
              potentially long strings (this doesn't change  the  behavior  of
              the  'print'  keyword,  it's  only triggered internally). If for
              some reason this isn't working well (it needs  curses  support),
              specify it yourself. Otherwise don't change the default.

       -separate_in|si &lt;string&gt;
              Separator before input prompts.  Default '0.

       -separate_out|so &lt;string&gt;
              Separator before output prompts.  Default: 0 (nothing).

       -separate_out2|so2 &lt;string&gt;
              Separator after output prompts.  Default: 0 (nothing).

       -nosep Shorthand for '-separate_in 0 -separate_out 0 -separate_out2 0'.
              Simply removes all input/output separators.

       -upgrade
              Allows you to upgrade your  IPYTHONDIR  configuration  when  you
              install  a  new  version  of  IPython.   Since  new versions may
              include new command lines options or example files, this  copies
              updated ipythonrc-type files.  However, it backs up (with a .old
              extension) all files which it overwrites so that you  can  merge
              back any custimizations you might have in your personal files.

       -Version
              Print version information and exit.

       -wxversion &lt;string&gt;
              Select a specific version of wxPython (used in conjunction with
              -wthread). Requires the wxversion module, part of recent
              wxPython distributions.

       -xmode &lt;modename&gt;
              Mode  for  exception reporting.  The valid modes are Plain, Con-
              text, and Verbose.

              - Plain: similar to python's normal traceback printing.

              - Context: prints 5 lines of context  source  code  around  each
              line in the traceback.

              - Verbose: similar to Context, but additionally prints the vari-
              ables currently visible where the exception happened (shortening
              their  strings if too long).  This can potentially be very slow,
              if you happen to have a huge data structure whose string  repre-
              sentation  is  complex  to compute.  Your computer may appear to
              freeze for a while with cpu usage at 100%.  If this occurs,  you
              can cancel the traceback with Ctrl-C (maybe hitting it more than
              once).


EMBEDDING
       It is possible to start an IPython instance inside your own Python pro-
       grams.  In the documentation example files there are some illustrations
       on how to do this.

       This feature allows you to evalutate  dynamically  the  state  of  your
       code,  operate  with  your  variables, analyze them, etc.  Note however
       that any changes you make to values while in the shell do NOT propagate
       back  to  the running code, so it is safe to modify your values because
       you won't break your code in bizarre ways by doing so.
"""

cmd_line_usage = __doc__

#---------------------------------------------------------------------------
interactive_usage = """
IPython -- An enhanced Interactive Python
=========================================

IPython offers a combination of convenient shell features, special commands
and a history mechanism for both input (command history) and output (results
caching, similar to Mathematica). It is intended to be a fully compatible
replacement for the standard Python interpreter, while offering vastly
improved functionality and flexibility.

At your system command line, type 'ipython -help' to see the command line
options available. This document only describes interactive features.

Warning: IPython relies on the existence of a global variable called __IP which
controls the shell itself. If you redefine __IP to anything, bizarre behavior
will quickly occur.

MAIN FEATURES

* Access to the standard Python help. As of Python 2.1, a help system is
  available with access to object docstrings and the Python manuals. Simply
  type 'help' (no quotes) to access it.

* Magic commands: type %magic for information on the magic subsystem.

* System command aliases, via the %alias command or the ipythonrc config file.

* Dynamic object information:

  Typing ?word or word? prints detailed information about an object.  If
  certain strings in the object are too long (docstrings, code, etc.) they get
  snipped in the center for brevity.

  Typing ??word or word?? gives access to the full information without
  snipping long strings. Long strings are sent to the screen through the less
  pager if longer than the screen, printed otherwise.

  The ?/?? system gives access to the full source code for any object (if
  available), shows function prototypes and other useful information.

  If you just want to see an object's docstring, type '%pdoc object' (without
  quotes, and without % if you have automagic on).

  Both %pdoc and ?/?? give you access to documentation even on things which are
  not explicitely defined. Try for example typing {}.get? or after import os,
  type os.path.abspath??. The magic functions %pdef, %source and %file operate
  similarly.

* Completion in the local namespace, by typing TAB at the prompt.

  At any time, hitting tab will complete any available python commands or
  variable names, and show you a list of the possible completions if there's
  no unambiguous one. It will also complete filenames in the current directory.

  This feature requires the readline and rlcomplete modules, so it won't work
  if your Python lacks readline support (such as under Windows).

* Search previous command history in two ways (also requires readline):

  - Start typing, and then use Ctrl-p (previous,up) and Ctrl-n (next,down) to
  search through only the history items that match what you've typed so
  far. If you use Ctrl-p/Ctrl-n at a blank prompt, they just behave like
  normal arrow keys.

  - Hit Ctrl-r: opens a search prompt. Begin typing and the system searches
  your history for lines that match what you've typed so far, completing as
  much as it can.

* Persistent command history across sessions (readline required).

* Logging of input with the ability to save and restore a working session.
  
* System escape with !. Typing !ls will run 'ls' in the current directory.

* The reload command does a 'deep' reload of a module: changes made to the
  module since you imported will actually be available without having to exit.

* Verbose and colored exception traceback printouts. See the magic xmode and
  xcolor functions for details (just type %magic).

* Input caching system:

  IPython offers numbered prompts (In/Out) with input and output caching. All
  input is saved and can be retrieved as variables (besides the usual arrow
  key recall).

  The following GLOBAL variables always exist (so don't overwrite them!):
  _i: stores previous input.
  _ii: next previous.
  _iii: next-next previous.
  _ih : a list of all input _ih[n] is the input from line n.

  Additionally, global variables named _i&lt;n&gt; are dynamically created (&lt;n&gt;
  being the prompt counter), such that _i&lt;n&gt; == _ih[&lt;n&gt;]

  For example, what you typed at prompt 14 is available as _i14 and _ih[14].

  You can create macros which contain multiple input lines from this history,
  for later re-execution, with the %macro function.

  The history function %hist allows you to see any part of your input history
  by printing a range of the _i variables. Note that inputs which contain
  magic functions (%) appear in the history with a prepended comment. This is
  because they aren't really valid Python code, so you can't exec them.

* Output caching system:

  For output that is returned from actions, a system similar to the input
  cache exists but using _ instead of _i. Only actions that produce a result
  (NOT assignments, for example) are cached. If you are familiar with
  Mathematica, IPython's _ variables behave exactly like Mathematica's %
  variables.

  The following GLOBAL variables always exist (so don't overwrite them!):
  _ (one underscore): previous output.
  __ (two underscores): next previous.
  ___ (three underscores): next-next previous.

  Global variables named _&lt;n&gt; are dynamically created (&lt;n&gt; being the prompt
  counter), such that the result of output &lt;n&gt; is always available as _&lt;n&gt;.

  Finally, a global dictionary named _oh exists with entries for all lines
  which generated output.

* Directory history:

  Your history of visited directories is kept in the global list _dh, and the
  magic %cd command can be used to go to any entry in that list.

* Auto-parentheses and auto-quotes (adapted from Nathan Gray's LazyPython)

    1. Auto-parentheses
        Callable objects (i.e. functions, methods, etc) can be invoked like
        this (notice the commas between the arguments):
            &gt;&gt;&gt; callable_ob arg1, arg2, arg3
        and the input will be translated to this:
            --&gt; callable_ob(arg1, arg2, arg3)
        You can force auto-parentheses by using '/' as the first character
        of a line.  For example:
            &gt;&gt;&gt; /globals             # becomes 'globals()'
        Note that the '/' MUST be the first character on the line!  This
        won't work:
            &gt;&gt;&gt; print /globals    # syntax error
            
        In most cases the automatic algorithm should work, so you should
        rarely need to explicitly invoke /. One notable exception is if you
        are trying to call a function with a list of tuples as arguments (the
        parenthesis will confuse IPython):
            In [1]: zip (1,2,3),(4,5,6)  # won't work
        but this will work:
            In [2]: /zip (1,2,3),(4,5,6)
            ------&gt; zip ((1,2,3),(4,5,6))
            Out[2]= [(1, 4), (2, 5), (3, 6)]        

        IPython tells you that it has altered your command line by
        displaying the new command line preceded by --&gt;.  e.g.:
            In [18]: callable list
            -------&gt; callable (list) 

    2. Auto-Quoting
        You can force auto-quoting of a function's arguments by using ',' as
        the first character of a line.  For example:
            &gt;&gt;&gt; ,my_function /home/me   # becomes my_function("/home/me")

        If you use ';' instead, the whole argument is quoted as a single
        string (while ',' splits on whitespace):
            &gt;&gt;&gt; ,my_function a b c   # becomes my_function("a","b","c")
            &gt;&gt;&gt; ;my_function a b c   # becomes my_function("a b c")

        Note that the ',' MUST be the first character on the line!  This
        won't work:
            &gt;&gt;&gt; x = ,my_function /home/me    # syntax error
"""

quick_reference = r"""
IPython -- An enhanced Interactive Python - Quick Reference Card
================================================================

obj?, obj??, ?obj,??obj   : Get help, or more help for object
?os.p*           : List names in os starting with p

Example magic:
    
%alias d ls -F   : 'd' is now an alias for 'ls -F'
alias d ls -F    : Works if 'alias' not a python name
alist = %alias   : Get list of aliases to 'alist'

System commands:
    
!cp a.txt b/     : System command escape, calls os.system()
cp a.txt b/      : after %rehashx, most system commands work without !
cp ${f}.txt $bar : Variable expansion in magics and system commands
files = !ls /usr : Capture sytem command output
files.s, files.l, files.n: "a b c", ['a','b','c'], 'a\nb\nc'
cd /usr/share    : Obvious, also 'cd d:\home\_ipython' works

History:

_i, _ii, _iii    : Previous, next previous, next next previous input
_i4, _ih[2:5]    : Input history line 4, lines 2-4
exec _i81        : Execute input history line #81 again
_, __, ___       : previous, next previous, next next previous output
_dh              : Directory history
_oh              : Output history
%hist            : Command history

Autocall:

f 1,2            : f(1,2)
/f 1,2           : f(1,2) (forced autoparen)
,f 1 2           : f("1","2")
;f 1 2           : f("1 2")

"""


</t>
<t tx="ekr.20071201085751.539"># -*- coding: utf-8 -*-
"""Support for wildcard pattern matching in object inspection.

$Id$
"""

#*****************************************************************************
#       Copyright (C) 2005 JÃƒÂ¶rgen Stenarson &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = "JÃƒÂ¶rgen Stenarson &lt;jorgen.stenarson@bostream.nu&gt;"
__license__ = Release.license

import __builtin__
import exceptions
import pdb
import pprint
import re
import types

</t>
<t tx="ekr.20071201085751.540">def create_typestr2type_dicts(dont_include_in_type2type2str=["lambda"]):
    """Return dictionaries mapping lower case typename to type objects, from
    the types package, and vice versa."""
    typenamelist=[]
    for tname in dir(types):
        if tname[-4:]=="Type":
            typenamelist.append(tname)
    typestr2type={}
    type2typestr={}
    for tname in typenamelist:
        name=tname[:-4].lower()
        obj=getattr(types,tname)
        typestr2type[name]=getattr(types,tname)
        if name in dont_include_in_type2type2str:
            type2typestr[obj]=name
    return typestr2type,type2typestr

</t>
<t tx="ekr.20071201085751.541">typestr2type,type2typestr=create_typestr2type_dicts()

def is_type(obj,typestr_or_type):
    """is_type(obj,typestr_or_type) verifies if obj is of a certain type or
    group of types takes strings as parameters of the for 'tuple'&lt;-&gt;TupleType
    'all' matches all types.  TODO: Should be extended for choosing more than
    one type
    """
    if typestr_or_type=="all":
        return True
    if type(typestr_or_type)==types.TypeType:
        test_type=typestr_or_type
    else:
        test_type=typestr2type.get(typestr_or_type,False)
    if test_type:
        return isinstance(obj,test_type)
    else:
        return False

</t>
<t tx="ekr.20071201085751.542">def show_hidden(str,show_all=False):
    """Return true for strings starting with single _ if show_all is true."""
    return show_all or str.startswith("__") or not str.startswith("_")


</t>
<t tx="ekr.20071201085751.543">class NameSpace(object):
    """NameSpace holds the dictionary for a namespace and implements filtering
    on name and types"""
    @others
    #TODO: Implement dictionary like access to filtered name space?

</t>
<t tx="ekr.20071201085751.544">def __init__(self,obj,name_pattern="*",type_pattern="all",ignore_case=True,
             show_all=True):
   self.show_all = show_all #Hide names beginning with single _
   self.object = obj
   self.name_pattern = name_pattern
   self.type_pattern = type_pattern
   self.ignore_case = ignore_case

   # We should only match EXACT dicts here, so DON'T use isinstance()
   if type(obj) == types.DictType:
       self._ns = obj
   else:
       self._ns = dict([(key,getattr(obj,key)) for key in dir(obj)
                        if isinstance(key, basestring)])
   
</t>
<t tx="ekr.20071201085751.545">def get_ns(self):
    """Return name space dictionary with objects matching type and name patterns."""
    return self.filter(self.name_pattern,self.type_pattern)
</t>
<t tx="ekr.20071201085751.546">ns=property(get_ns)

def get_ns_names(self):
    """Return list of object names in namespace that match the patterns."""
    return self.ns.keys()
</t>
<t tx="ekr.20071201085751.547">ns_names=property(get_ns_names,doc="List of objects in name space that "
                  "match the type and name patterns.")

def filter(self,name_pattern,type_pattern):
    """Return dictionary of filtered namespace."""
    def glob_filter(lista,name_pattern,hidehidden,ignore_case):
        """Return list of elements in lista that match pattern."""
        pattern=name_pattern.replace("*",".*").replace("?",".")
        if ignore_case:
            reg=re.compile(pattern+"$",re.I)
        else:
            reg=re.compile(pattern+"$")
        result=[x for x in lista if reg.match(x) and show_hidden(x,hidehidden)]
        return result
    ns=self._ns
    #Filter namespace by the name_pattern
    all=[(x,ns[x]) for x in glob_filter(ns.keys(),name_pattern,
                                        self.show_all,self.ignore_case)]
    #Filter namespace by type_pattern
    all=[(key,obj) for key,obj in all if is_type(obj,type_pattern)]
    all=dict(all)
    return all

</t>
<t tx="ekr.20071201085751.548">def list_namespace(namespace,type_pattern,filter,ignore_case=False,show_all=False):
    """Return dictionary of all objects in namespace that matches type_pattern
    and filter."""
    pattern_list=filter.split(".")
    if len(pattern_list)==1:
        ns=NameSpace(namespace,name_pattern=pattern_list[0],type_pattern=type_pattern,
                     ignore_case=ignore_case,show_all=show_all)
        return ns.ns
    else:
        # This is where we can change if all objects should be searched or
        # only modules. Just change the type_pattern to module to search only
        # modules
        ns=NameSpace(namespace,name_pattern=pattern_list[0],type_pattern="all",
                     ignore_case=ignore_case,show_all=show_all)
        res={}
        nsdict=ns.ns
        for name,obj in nsdict.iteritems():
            ns=list_namespace(obj,type_pattern,".".join(pattern_list[1:]),
                              ignore_case=ignore_case,show_all=show_all)
            for inner_name,inner_obj in ns.iteritems():
                res["%s.%s"%(name,inner_name)]=inner_obj
        return res
</t>
<t tx="ekr.20071201085751.549">"""Set of functions to work with console on Windows.
"""

#*****************************************************************************
#       Copyright (C) 2005 Alexander Belchenko &lt;bialix@ukr.net&gt;
#
#                This file is placed in the public domain.
#
#*****************************************************************************

__author__  = 'Alexander Belchenko (e-mail: bialix AT ukr.net)'
__license__ = 'Public domain'

import struct

try:
    import ctypes
except ImportError:
    ctypes = None

</t>
<t tx="ekr.20071201085751.550">def get_console_size(defaultx=80, defaulty=25):
    """ Return size of current console.

    This function try to determine actual size of current working
    console window and return tuple (sizex, sizey) if success,
    or default size (defaultx, defaulty) otherwise.

    Dependencies: ctypes should be installed.
    """
    if ctypes is None:
        # no ctypes is found
        return (defaultx, defaulty)

    h = ctypes.windll.kernel32.GetStdHandle(-11)
    csbi = ctypes.create_string_buffer(22)
    res = ctypes.windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)
    
    if res:
        (bufx, bufy, curx, cury, wattr,
         left, top, right, bottom, maxx, maxy) = struct.unpack("hhhhHhhhhhh",
                                                               csbi.raw)
        sizex = right - left + 1
        sizey = bottom - top + 1
        return (sizex, sizey)
    else:
        return (defaultx, defaulty)
</t>
<t tx="ekr.20071201085751.551"># -*- coding: utf-8 -*-
"""
IPython -- An enhanced Interactive Python

One of Python's nicest features is its interactive interpreter. This allows
very fast testing of ideas without the overhead of creating test files as is
typical in most programming languages. However, the interpreter supplied with
the standard Python distribution is fairly primitive (and IDLE isn't really
much better).

IPython tries to:

  i - provide an efficient environment for interactive work in Python
  programming. It tries to address what we see as shortcomings of the standard
  Python prompt, and adds many features to make interactive work much more
  efficient.

  ii - offer a flexible framework so that it can be used as the base
  environment for other projects and problems where Python can be the
  underlying language. Specifically scientific environments like Mathematica,
  IDL and Mathcad inspired its design, but similar ideas can be useful in many
  fields. Python is a fabulous language for implementing this kind of system
  (due to its dynamic and introspective features), and with suitable libraries
  entire systems could be built leveraging Python's power.

  iii - serve as an embeddable, ready to go interpreter for your own programs.

IPython requires Python 2.3 or newer.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

# Enforce proper version requirements
import sys

if sys.version[0:3] &lt; '2.3':
    raise ImportError('Python Version 2.3 or above is required for IPython.')

# Make it easy to import extensions - they are always directly on pythonpath.
# Therefore, non-IPython modules can be added to Extensions directory
import os
sys.path.append(os.path.dirname(__file__) + "/Extensions")

# Define what gets imported with a 'from IPython import *'
__all__ = ['deep_reload','genutils','ipstruct','ultraTB','DPyGetOpt',
           'Itpl','hooks','ConfigLoader','OutputTrap','Release','Shell',
           'platutils','platutils_win32','platutils_posix','platutils_dummy',
           'ipapi','rlineimpl', 'strdispatch']

# Load __all__ in IPython namespace so that a simple 'import IPython' gives
# access to them via IPython.&lt;name&gt;
glob,loc = globals(),locals()
for name in __all__:
    __import__(name,glob,loc,[])

# Release data
from IPython import Release # do it explicitly so pydoc can see it - pydoc bug
__author__   = '%s &lt;%s&gt;\n%s &lt;%s&gt;\n%s &lt;%s&gt;' % \
               ( Release.authors['Fernando'] + Release.authors['Janko'] + \
                 Release.authors['Nathan'] )
__license__  = Release.license
__version__  = Release.version
__revision__ = Release.revision

# Namespace cleanup
del name,glob,loc
</t>
<t tx="ekr.20071201085751.552">"""
``astyle`` provides classes for adding style (foreground and background color;
bold; blink; etc.) to terminal and curses output.
"""


import sys, os

try:
    import curses
except ImportError:
    curses = None


COLOR_BLACK   = 0
COLOR_RED     = 1
COLOR_GREEN   = 2
COLOR_YELLOW  = 3
COLOR_BLUE    = 4
COLOR_MAGENTA = 5
COLOR_CYAN    = 6
COLOR_WHITE   = 7

A_BLINK     = 1&lt;&lt;0 # Blinking text
A_BOLD      = 1&lt;&lt;1 # Extra bright or bold text
A_DIM       = 1&lt;&lt;2 # Half bright text
A_REVERSE   = 1&lt;&lt;3 # Reverse-video text
A_STANDOUT  = 1&lt;&lt;4 # The best highlighting mode available
A_UNDERLINE = 1&lt;&lt;5 # Underlined text


</t>
<t tx="ekr.20071201085751.553">class Style(object):
    """
    Store foreground color, background color and attribute (bold, underlined
    etc.).
    """
    __slots__ = ("fg", "bg", "attrs")

    COLORNAMES = {
        "black": COLOR_BLACK,
        "red": COLOR_RED,
        "green": COLOR_GREEN,
        "yellow": COLOR_YELLOW,
        "blue": COLOR_BLUE,
        "magenta": COLOR_MAGENTA,
        "cyan": COLOR_CYAN,
        "white": COLOR_WHITE,
    }
    ATTRNAMES = {
        "blink": A_BLINK,
        "bold": A_BOLD,
        "dim": A_DIM,
        "reverse": A_REVERSE,
        "standout": A_STANDOUT,
        "underline": A_UNDERLINE,
    }

    @others
    fromenv = classmethod(fromenv)


</t>
<t tx="ekr.20071201085751.554">def __init__(self, fg, bg, attrs=0):
    """
    Create a ``Style`` object with ``fg`` as the foreground color,
    ``bg`` as the background color and ``attrs`` as the attributes.

    Examples:

        &gt;&gt;&gt; Style(COLOR_RED, COLOR_BLACK)
        &gt;&gt;&gt; Style(COLOR_YELLOW, COLOR_BLUE, A_BOLD|A_UNDERLINE)
    """
    self.fg = fg
    self.bg = bg
    self.attrs = attrs

</t>
<t tx="ekr.20071201085751.555">def __call__(self, *args):
    text = Text()
    for arg in args:
        if isinstance(arg, Text):
            text.extend(arg)
        else:
            text.append((self, arg))
    return text

</t>
<t tx="ekr.20071201085751.556">def __eq__(self, other):
    return self.fg == other.fg and self.bg == other.bg and self.attrs == other.attrs

</t>
<t tx="ekr.20071201085751.557">def __neq__(self, other):
    return self.fg != other.fg or self.bg != other.bg or self.attrs != other.attrs

</t>
<t tx="ekr.20071201085751.558">def __repr__(self):
    color2name = ("black", "red", "green", "yellow", "blue", "magenta", "cyan", "white")
    attrs2name = ("blink", "bold", "dim", "reverse", "standout", "underline")

    return "&lt;%s fg=%s bg=%s attrs=%s&gt;" % (
        self.__class__.__name__, color2name[self.fg], color2name[self.bg],
        "|".join([attrs2name[b] for b in xrange(6) if self.attrs&amp;(1&lt;&lt;b)]) or 0)

</t>
<t tx="ekr.20071201085751.559">def fromstr(cls, value):
    """
    Create a ``Style`` object from a string. The format looks like this:
    ``"red:black:bold|blink"``.
    """
    # defaults
    fg = COLOR_WHITE
    bg = COLOR_BLACK
    attrs = 0

    parts = value.split(":")
    if len(parts) &gt; 0:
        fg = cls.COLORNAMES[parts[0].lower()]
        if len(parts) &gt; 1:
            bg = cls.COLORNAMES[parts[1].lower()]
            if len(parts) &gt; 2:
                for strattr in parts[2].split("|"):
                    attrs |= cls.ATTRNAMES[strattr.lower()]
    return cls(fg, bg, attrs)
</t>
<t tx="ekr.20071201085751.560">fromstr = classmethod(fromstr)

def fromenv(cls, name, default):
    """
    Create a ``Style`` from an environment variable named ``name``
    (using ``default`` if the environment variable doesn't exist).
    """
    return cls.fromstr(os.environ.get(name, default))
</t>
<t tx="ekr.20071201085751.561">def switchstyle(s1, s2):
    """
    Return the ANSI escape sequence needed to switch from style ``s1`` to
    style ``s2``.
    """
    attrmask = (A_BLINK|A_BOLD|A_UNDERLINE|A_REVERSE)
    a1 = s1.attrs &amp; attrmask
    a2 = s2.attrs &amp; attrmask

    args = []
    if s1 != s2:
        # do we have to get rid of the bold/underline/blink bit?
        # (can only be done by a reset)
        # use reset when our target color is the default color
        # (this is shorter than 37;40)
        if (a1 &amp; ~a2 or s2==style_default):
            args.append("0")
            s1 = style_default
            a1 = 0

        # now we know that old and new color have the same boldness,
        # or the new color is bold and the old isn't,
        # i.e. we only might have to switch bold on, not off
        if not (a1 &amp; A_BOLD) and (a2 &amp; A_BOLD):
            args.append("1")

        # Fix underline
        if not (a1 &amp; A_UNDERLINE) and (a2 &amp; A_UNDERLINE):
            args.append("4")

        # Fix blink
        if not (a1 &amp; A_BLINK) and (a2 &amp; A_BLINK):
            args.append("5")

        # Fix reverse
        if not (a1 &amp; A_REVERSE) and (a2 &amp; A_REVERSE):
            args.append("7")

        # Fix foreground color
        if s1.fg != s2.fg:
            args.append("3%d" % s2.fg)

        # Finally fix the background color
        if s1.bg != s2.bg:
            args.append("4%d" % s2.bg)

        if args:
            return "\033[%sm" % ";".join(args)
    return ""


</t>
<t tx="ekr.20071201085751.562">class Text(list):
    """
    A colored string. A ``Text`` object is a sequence, the sequence
    items will be ``(style, string)`` tuples.
    """
    @others
</t>
<t tx="ekr.20071201085751.563">
def __init__(self, *args):
    list.__init__(self)
    self.append(*args)

</t>
<t tx="ekr.20071201085751.564">def __repr__(self):
    return "%s.%s(%s)" % (
        self.__class__.__module__, self.__class__.__name__,
        list.__repr__(self)[1:-1])

</t>
<t tx="ekr.20071201085751.565">def append(self, *args):
    for arg in args:
        if isinstance(arg, Text):
            self.extend(arg)
        elif isinstance(arg, tuple): # must be (style, string)
            list.append(self, arg)
        elif isinstance(arg, unicode):
            list.append(self, (style_default, arg))
        else:
            list.append(self, (style_default, str(arg)))

</t>
<t tx="ekr.20071201085751.566">def insert(self, index, *args):
    self[index:index] = Text(*args)

</t>
<t tx="ekr.20071201085751.567">def __add__(self, other):
    new = Text()
    new.append(self)
    new.append(other)
    return new

</t>
<t tx="ekr.20071201085751.568">def __iadd__(self, other):
    self.append(other)
    return self

</t>
<t tx="ekr.20071201085751.569">def format(self, styled=True):
    """
    This generator yields the strings that will make up the final
    colorized string.
    """
    if styled:
        oldstyle = style_default
        for (style, string) in self:
            if not isinstance(style, (int, long)):
                switch = switchstyle(oldstyle, style)
                if switch:
                    yield switch
                if string:
                    yield string
                oldstyle = style
        switch = switchstyle(oldstyle, style_default)
        if switch:
            yield switch
    else:
        for (style, string) in self:
            if not isinstance(style, (int, long)):
                yield string

</t>
<t tx="ekr.20071201085751.570">def string(self, styled=True):
    """
    Return the resulting string (with escape sequences, if ``styled``
    is true).
    """
    return "".join(self.format(styled))

</t>
<t tx="ekr.20071201085751.571">def __str__(self):
    """
    Return ``self`` as a string (without ANSI escape sequences).
    """
    return self.string(False)

</t>
<t tx="ekr.20071201085751.572">def write(self, stream, styled=True):
    """
    Write ``self`` to the output stream ``stream`` (with escape sequences,
    if ``styled`` is true).
    """
    for part in self.format(styled):
        stream.write(part)


</t>
<t tx="ekr.20071201085751.573">try:
    import ipipe
except ImportError:
    pass
else:
    def xrepr_astyle_text(self, mode="default"):
        yield (-1, True)
        for info in self:
            yield info
    try:
        ipipe.xrepr.when_type(Text)(xrepr_astyle_text)
    except Exception:
        pass


def streamstyle(stream, styled=None):
    """
    If ``styled`` is ``None``, return whether ``stream`` refers to a terminal.
    If this can't be determined (either because ``stream`` doesn't refer to a
    real OS file, or because you're on Windows) return ``False``. If ``styled``
    is not ``None`` ``styled`` will be returned unchanged.
    """
    if styled is None:
        try:
            styled = os.isatty(stream.fileno())
        except (KeyboardInterrupt, SystemExit):
            raise
        except Exception:
            styled = False
    return styled


</t>
<t tx="ekr.20071201085751.574">def write(stream, styled, *texts):
    """
    Write ``texts`` to ``stream``.
    """
    text = Text(*texts)
    text.write(stream, streamstyle(stream, styled))


</t>
<t tx="ekr.20071201085751.575">def writeln(stream, styled, *texts):
    """
    Write ``texts`` to ``stream`` and finish with a line feed.
    """
    write(stream, styled, *texts)
    stream.write("\n")


</t>
<t tx="ekr.20071201085751.576">class Stream(object):
    """
    Stream wrapper that adds color output.
    """
    @others
</t>
<t tx="ekr.20071201085751.577">def __init__(self, stream, styled=None):
    self.stream = stream
    self.styled = streamstyle(stream, styled)

</t>
<t tx="ekr.20071201085751.578">def write(self, *texts):
    write(self.stream, self.styled, *texts)

</t>
<t tx="ekr.20071201085751.579">def writeln(self, *texts):
    writeln(self.stream, self.styled, *texts)

</t>
<t tx="ekr.20071201085751.580">def __getattr__(self, name):
    return getattr(self.stream, name)


</t>
<t tx="ekr.20071201085751.581">class stdout(object):
    """
    Stream wrapper for ``sys.stdout`` that adds color output.
    """
    @others
</t>
<t tx="ekr.20071201085751.582">def write(self, *texts):
    write(sys.stdout, None, *texts)

</t>
<t tx="ekr.20071201085751.583">def writeln(self, *texts):
    writeln(sys.stdout, None, *texts)

</t>
<t tx="ekr.20071201085751.584">def __getattr__(self, name):
    return getattr(sys.stdout, name)
</t>
<t tx="ekr.20071201085751.585">stdout = stdout()


class stderr(object):
    """
    Stream wrapper for ``sys.stderr`` that adds color output.
    """
    @others
</t>
<t tx="ekr.20071201085751.586">def write(self, *texts):
    write(sys.stderr, None, *texts)

</t>
<t tx="ekr.20071201085751.587">def writeln(self, *texts):
    writeln(sys.stderr, None, *texts)

</t>
<t tx="ekr.20071201085751.588">def __getattr__(self, name):
    return getattr(sys.stdout, name)
</t>
<t tx="ekr.20071201085751.589"># -*- coding: utf-8 -*-
""" IPython extension: add %clear magic """

import IPython.ipapi
import gc
ip = IPython.ipapi.get()


</t>
<t tx="ekr.20071201085751.590">def clear_f(self,arg):
    """ Clear various data (e.g. stored history data)
    
    %clear out - clear output history
    %clear in  - clear input history
    """
    
    api = self.getapi()
    for target in arg.split():
        if target == 'out':
            print "Flushing output cache (%d entries)" % len(api.user_ns['_oh'])
            self.outputcache.flush()
        elif target == 'in':
            print "Flushing input history"
            from IPython import iplib
            del self.input_hist[:]
            del self.input_hist_raw[:]
            for n in range(1,self.outputcache.prompt_count + 1):
                key = '_i'+`n`
                try:
                    del self.user_ns[key]
                except: pass
        elif target == 'array':
            try:
                pylab=ip.IP.pylab
                for x in self.user_ns.keys():
                    if isinstance(self.user_ns[x],pylab.arraytype):
                        del self.user_ns[x]
            except AttributeError:
                print "Clear array only available in -pylab mode"
            gc.collect()                
            
            
</t>
<t tx="ekr.20071201085751.591"># -*- coding: utf-8 -*-
""" IPython extension: add %rehashdir magic

Usage:

%rehashdir c:/bin c:/tools
  - Add all executables under c:/bin and c:/tools to alias table, in 
  order to make them directly executable from any directory.
  
This also serves as an example on how to extend ipython
with new magic functions.

Unlike rest of ipython, this requires Python 2.4 (optional
extensions are allowed to do that).

To install, add

"import_mod ext_rehashdir"

To your ipythonrc or just execute "import rehash_dir" in ipython
prompt.


$Id$
"""

import IPython.ipapi
ip = IPython.ipapi.get()


import os,re,fnmatch

</t>
<t tx="ekr.20071201085751.592">def rehashdir_f(self,arg):
    """ Add executables in all specified dirs to alias table
     
    Usage:

    %rehashdir c:/bin;c:/tools
      - Add all executables under c:/bin and c:/tools to alias table, in 
      order to make them directly executable from any directory.
        
      Without arguments, add all executables in current directory.
      
    """

    # most of the code copied from Magic.magic_rehashx

    def isjunk(fname):
        junk = ['*~']
        for j in junk:
            if fnmatch.fnmatch(fname, j):
                return True
        return False
    
    if not arg:
        arg = '.'
    path = map(os.path.abspath,arg.split(';'))
    alias_table = self.shell.alias_table
        
    if os.name == 'posix':
        isexec = lambda fname:os.path.isfile(fname) and \
                 os.access(fname,os.X_OK)
    else:

        try:
            winext = os.environ['pathext'].replace(';','|').replace('.','')
        except KeyError:
            winext = 'exe|com|bat|py'
        if 'py' not in winext:
            winext += '|py'
            
        execre = re.compile(r'(.*)\.(%s)$' % winext,re.IGNORECASE)
        isexec = lambda fname:os.path.isfile(fname) and execre.match(fname)
    savedir = os.getcwd()
    try:
        # write the whole loop for posix/Windows so we don't have an if in
        # the innermost part
        if os.name == 'posix':
            for pdir in path:
                os.chdir(pdir)
                for ff in os.listdir(pdir):
                    if isexec(ff) and not isjunk(ff):
                        # each entry in the alias table must be (N,name),
                        # where N is the number of positional arguments of the
                        # alias.
                        src,tgt = os.path.splitext(ff)[0], os.path.abspath(ff)                
                        print "Aliasing:",src,"-&gt;",tgt
                        alias_table[src] = (0,tgt)
        else:
            for pdir in path:
                os.chdir(pdir)
                for ff in os.listdir(pdir):
                    if isexec(ff) and not isjunk(ff):
                        src, tgt = execre.sub(r'\1',ff), os.path.abspath(ff)
                        print "Aliasing:",src,"-&gt;",tgt
                        alias_table[src] = (0,tgt)
        # Make sure the alias table doesn't contain keywords or builtins
        self.shell.alias_table_validate()
        # Call again init_auto_alias() so we get 'rm -i' and other
        # modified aliases since %rehashx will probably clobber them
        self.shell.init_auto_alias()
    finally:
        os.chdir(savedir)
</t>
<t tx="ekr.20071201085751.593"># -*- coding: utf-8 -*-
""" IPython extension: new prefilters for output grabbing 

Provides 

var = %magic blah blah

var = !ls

$Id$

"""

import IPython.ipapi
from IPython.genutils import *

ip = IPython.ipapi.get()

import re

</t>
<t tx="ekr.20071201085751.594">def hnd_magic(line,mo):
    """ Handle a = %mymagic blah blah """
    #cmd = genutils.make_quoted_expr(mo.group('syscmd'))
    #mag = 'ipmagic
    #return "%s = %s"
    var = mo.group('varname')
    cmd = mo.group('cmd')
    expr = make_quoted_expr(cmd)
    return itpl('$var = _ip.magic($expr)')

</t>
<t tx="ekr.20071201085751.595">def hnd_syscmd(line,mo):
    """ Handle a = !ls """
    #cmd = genutils.make_quoted_expr(mo.group('syscmd'))
    #mag = 'ipmagic
    #return "%s = %s"
    var = mo.group('varname')
    cmd = mo.group('cmd')
    expr = make_quoted_expr(itpl("sc -lv =$cmd"))
    return itpl('$var = _ip.magic($expr)')

</t>
<t tx="ekr.20071201085751.596">def install_re_handler(pat, hnd):
    ip.meta.re_prefilters.append((re.compile(pat), hnd))

</t>
<t tx="ekr.20071201085751.597">def init_handlers():

    ip.meta.re_prefilters = []

    install_re_handler('(?P&lt;varname&gt;[\w\.]+)\s*=\s*%(?P&lt;cmd&gt;.*)',
                       hnd_magic
                       )
    
    install_re_handler('(?P&lt;varname&gt;[\w\.]+)\s*=\s*!(?P&lt;cmd&gt;.*)',
                       hnd_syscmd
                       )

</t>
<t tx="ekr.20071201085751.598">init_handlers()

def regex_prefilter_f(self,line):    
    for pat, handler in ip.meta.re_prefilters:
        mo = pat.match(line)
        if mo:
            return handler(line,mo)
    
    raise IPython.ipapi.TryNext

</t>
<t tx="ekr.20071201085751.599"># -*- coding: iso-8859-1 -*-

import curses, fcntl, signal, struct, tty, textwrap, inspect

import astyle, ipipe


# Python 2.3 compatibility
try:
    set
except NameError:
    import sets
    set = sets.Set

# Python 2.3 compatibility
try:
    sorted
except NameError:
    from ipipe import sorted


</t>
<t tx="ekr.20071201085751.600">class UnassignedKeyError(Exception):
    """
    Exception that is used for reporting unassigned keys.
    """


</t>
<t tx="ekr.20071201085751.601">class UnknownCommandError(Exception):
    """
    Exception that is used for reporting unknown commands (this should never
    happen).
    """


</t>
<t tx="ekr.20071201085751.602">class CommandError(Exception):
    """
    Exception that is used for reporting that a command can't be executed.
    """


</t>
<t tx="ekr.20071201085751.603">class Keymap(dict):
    """
    Stores mapping of keys to commands.
    """
    @others
</t>
<t tx="ekr.20071201085751.604">def __init__(self):
    self._keymap = {}

</t>
<t tx="ekr.20071201085751.605">def __setitem__(self, key, command):
    if isinstance(key, str):
        for c in key:
            dict.__setitem__(self, ord(c), command)
    else:
        dict.__setitem__(self, key, command)

</t>
<t tx="ekr.20071201085751.606">def __getitem__(self, key):
    if isinstance(key, str):
        key = ord(key)
    return dict.__getitem__(self, key)

</t>
<t tx="ekr.20071201085751.607">def __detitem__(self, key):
    if isinstance(key, str):
        key = ord(key)
    dict.__detitem__(self, key)

</t>
<t tx="ekr.20071201085751.608">def register(self, command, *keys):
    for key in keys:
        self[key] = command

</t>
<t tx="ekr.20071201085751.609">def get(self, key, default=None):
    if isinstance(key, str):
        key = ord(key)
    return dict.get(self, key, default)

</t>
<t tx="ekr.20071201085751.610">def findkey(self, command, default=ipipe.noitem):
    for (key, commandcandidate) in self.iteritems():
        if commandcandidate == command:
            return key
    if default is ipipe.noitem:
        raise KeyError(command)
    return default


</t>
<t tx="ekr.20071201085751.611">class _BrowserCachedItem(object):
    # This is used internally by ``ibrowse`` to store a item together with its
    # marked status.
    __slots__ = ("item", "marked")

    @others
</t>
<t tx="ekr.20071201085751.612">def __init__(self, item):
    self.item = item
    self.marked = False


</t>
<t tx="ekr.20071201085751.613">class _BrowserHelp(object):
    style_header = astyle.Style.fromstr("yellow:black:bold")
    @others
</t>
<t tx="ekr.20071201085751.614"># This is used internally by ``ibrowse`` for displaying the help screen.
def __init__(self, browser):
    self.browser = browser

</t>
<t tx="ekr.20071201085751.615">def __xrepr__(self, mode):
    yield (-1, True)
    if mode == "header" or mode == "footer":
        yield (astyle.style_default, "ibrowse help screen")
    else:
        yield (astyle.style_default, repr(self))

</t>
<t tx="ekr.20071201085751.616">def __iter__(self):
    # Get reverse key mapping
    allkeys = {}
    for (key, cmd) in self.browser.keymap.iteritems():
        allkeys.setdefault(cmd, []).append(key)

    fields = ("key", "description")

    commands = []
    for name in dir(self.browser):
        if name.startswith("cmd_"):
            command = getattr(self.browser, name)
            commands.append((inspect.getsourcelines(command)[-1], name[4:], command))
    commands.sort()
    commands = [(c[1], c[2]) for c in commands]
    for (i, (name, command)) in enumerate(commands):
        if i:
            yield ipipe.Fields(fields, key="", description="")

        description = command.__doc__
        if description is None:
            lines = []
        else:
            lines = [l.strip() for l in description.splitlines() if l.strip()]
            description = "\n".join(lines)
            lines = textwrap.wrap(description, 60)
        keys = allkeys.get(name, [])

        yield ipipe.Fields(fields, key="", description=astyle.Text((self.style_header, name)))
        for i in xrange(max(len(keys), len(lines))):
            try:
                key = self.browser.keylabel(keys[i])
            except IndexError:
                key = ""
            try:
                line = lines[i]
            except IndexError:
                line = ""
            yield ipipe.Fields(fields, key=key, description=line)


</t>
<t tx="ekr.20071201085751.617">class _BrowserLevel(object):
    @others
</t>
<t tx="ekr.20071201085751.618"># This is used internally to store the state (iterator, fetch items,
# position of cursor and screen, etc.) of one browser level
# An ``ibrowse`` object keeps multiple ``_BrowserLevel`` objects in
# a stack.
def __init__(self, browser, input,mainsizey, *attrs):
    self.browser = browser
    self.input = input
    self.header = [x for x in ipipe.xrepr(input, "header") if not isinstance(x[0], int)]
    # iterator for the input
    self.iterator = ipipe.xiter(input)

    # is the iterator exhausted?
    self.exhausted = False

    # attributes to be display (autodetected if empty)
    self.attrs = attrs

    # fetched items (+ marked flag)
    self.items = ipipe.deque()

    # Number of marked objects
    self.marked = 0

    # Vertical cursor position
    self.cury = 0

    # Horizontal cursor position
    self.curx = 0

    # Index of first data column
    self.datastartx = 0

    # Index of first data line
    self.datastarty = 0

    # height of the data display area
    self.mainsizey = mainsizey

    # width of the data display area (changes when scrolling)
    self.mainsizex = 0

    # Size of row number (changes when scrolling)
    self.numbersizex = 0

    # Attributes to display (in this order)
    self.displayattrs = []

    # index and attribute under the cursor
    self.displayattr = (None, ipipe.noitem)

    # Maps attributes to column widths
    self.colwidths = {}

    # Set of hidden attributes
    self.hiddenattrs = set()

    # This takes care of all the caches etc.
    self.moveto(0, 0, refresh=True)

</t>
<t tx="ekr.20071201085751.619">def fetch(self, count):
    # Try to fill ``self.items`` with at least ``count`` objects.
    have = len(self.items)
    while not self.exhausted and have &lt; count:
        try:
            item = self.iterator.next()
        except StopIteration:
            self.exhausted = True
            break
        except (KeyboardInterrupt, SystemExit):
            raise
        except Exception, exc:
            have += 1
            self.items.append(_BrowserCachedItem(exc))
            self.exhausted = True
            break
        else:
            have += 1
            self.items.append(_BrowserCachedItem(item))

</t>
<t tx="ekr.20071201085751.620">def calcdisplayattrs(self):
    # Calculate which attributes are available from the objects that are
    # currently visible on screen (and store it in ``self.displayattrs``)

    attrs = set()
    self.displayattrs = []
    if self.attrs:
        # If the browser object specifies a fixed list of attributes,
        # simply use it (removing hidden attributes).
        for attr in self.attrs:
            attr = ipipe.upgradexattr(attr)
            if attr not in attrs and attr not in self.hiddenattrs:
                self.displayattrs.append(attr)
                attrs.add(attr)
    else:
        endy = min(self.datastarty+self.mainsizey, len(self.items))
        for i in xrange(self.datastarty, endy):
            for attr in ipipe.xattrs(self.items[i].item, "default"):
                if attr not in attrs and attr not in self.hiddenattrs:
                    self.displayattrs.append(attr)
                    attrs.add(attr)

</t>
<t tx="ekr.20071201085751.621">def getrow(self, i):
    # Return a dictionary with the attributes for the object
    # ``self.items[i]``. Attribute names are taken from
    # ``self.displayattrs`` so ``calcdisplayattrs()`` must have been
    # called before.
    row = {}
    item = self.items[i].item
    for attr in self.displayattrs:
        try:
            value = attr.value(item)
        except (KeyboardInterrupt, SystemExit):
            raise
        except Exception, exc:
            value = exc
        # only store attribute if it exists (or we got an exception)
        if value is not ipipe.noitem:
            # remember alignment, length and colored text
            row[attr] = ipipe.xformat(value, "cell", self.browser.maxattrlength)
    return row

</t>
<t tx="ekr.20071201085751.622">def calcwidths(self):
    # Recalculate the displayed fields and their widths.
    # ``calcdisplayattrs()'' must have been called and the cache
    # for attributes of the objects on screen (``self.displayrows``)
    # must have been filled. This sets ``self.colwidths`` which maps
    # attribute descriptors to widths.
    self.colwidths = {}
    for row in self.displayrows:
        for attr in self.displayattrs:
            try:
                length = row[attr][1]
            except KeyError:
                length = 0
            # always add attribute to colwidths, even if it doesn't exist
            if attr not in self.colwidths:
                self.colwidths[attr] = len(attr.name())
            newwidth = max(self.colwidths[attr], length)
            self.colwidths[attr] = newwidth

    # How many characters do we need to paint the largest item number?
    self.numbersizex = len(str(self.datastarty+self.mainsizey-1))
    # How must space have we got to display data?
    self.mainsizex = self.browser.scrsizex-self.numbersizex-3
    # width of all columns
    self.datasizex = sum(self.colwidths.itervalues()) + len(self.colwidths)

</t>
<t tx="ekr.20071201085751.623">def calcdisplayattr(self):
    # Find out which attribute the cursor is on and store this
    # information in ``self.displayattr``.
    pos = 0
    for (i, attr) in enumerate(self.displayattrs):
        if pos+self.colwidths[attr] &gt;= self.curx:
            self.displayattr = (i, attr)
            break
        pos += self.colwidths[attr]+1
    else:
        self.displayattr = (None, ipipe.noitem)

</t>
<t tx="ekr.20071201085751.624">def moveto(self, x, y, refresh=False):
    # Move the cursor to the position ``(x,y)`` (in data coordinates,
    # not in screen coordinates). If ``refresh`` is true, all cached
    # values will be recalculated (e.g. because the list has been
    # resorted, so screen positions etc. are no longer valid).
    olddatastarty = self.datastarty
    oldx = self.curx
    oldy = self.cury
    x = int(x+0.5)
    y = int(y+0.5)
    newx = x # remember where we wanted to move
    newy = y # remember where we wanted to move

    scrollbordery = min(self.browser.scrollbordery, self.mainsizey//2)
    scrollborderx = min(self.browser.scrollborderx, self.mainsizex//2)

    # Make sure that the cursor didn't leave the main area vertically
    if y &lt; 0:
        y = 0
    # try to get enough items to fill the screen
    self.fetch(max(y+scrollbordery+1, self.mainsizey))
    if y &gt;= len(self.items):
        y = max(0, len(self.items)-1)

    # Make sure that the cursor stays on screen vertically
    if y &lt; self.datastarty+scrollbordery:
        self.datastarty = max(0, y-scrollbordery)
    elif y &gt;= self.datastarty+self.mainsizey-scrollbordery:
        self.datastarty = max(0, min(y-self.mainsizey+scrollbordery+1,
                                     len(self.items)-self.mainsizey))

    if refresh: # Do we need to refresh the complete display?
        self.calcdisplayattrs()
        endy = min(self.datastarty+self.mainsizey, len(self.items))
        self.displayrows = map(self.getrow, xrange(self.datastarty, endy))
        self.calcwidths()
    # Did we scroll vertically =&gt; update displayrows
    # and various other attributes
    elif self.datastarty != olddatastarty:
        # Recalculate which attributes we have to display
        olddisplayattrs = self.displayattrs
        self.calcdisplayattrs()
        # If there are new attributes, recreate the cache
        if self.displayattrs != olddisplayattrs:
            endy = min(self.datastarty+self.mainsizey, len(self.items))
            self.displayrows = map(self.getrow, xrange(self.datastarty, endy))
        elif self.datastarty&lt;olddatastarty: # we did scroll up
            # drop rows from the end
            del self.displayrows[self.datastarty-olddatastarty:]
            # fetch new items
            for i in xrange(min(olddatastarty, self.datastarty+self.mainsizey)-1,
                            self.datastarty-1, -1):
                try:
                    row = self.getrow(i)
                except IndexError:
                    # we didn't have enough objects to fill the screen
                    break
                self.displayrows.insert(0, row)
        else: # we did scroll down
            # drop rows from the start
            del self.displayrows[:self.datastarty-olddatastarty]
            # fetch new items
            for i in xrange(max(olddatastarty+self.mainsizey, self.datastarty),
                            self.datastarty+self.mainsizey):
                try:
                    row = self.getrow(i)
                except IndexError:
                    # we didn't have enough objects to fill the screen
                    break
                self.displayrows.append(row)
        self.calcwidths()

    # Make sure that the cursor didn't leave the data area horizontally
    if x &lt; 0:
        x = 0
    elif x &gt;= self.datasizex:
        x = max(0, self.datasizex-1)

    # Make sure that the cursor stays on screen horizontally
    if x &lt; self.datastartx+scrollborderx:
        self.datastartx = max(0, x-scrollborderx)
    elif x &gt;= self.datastartx+self.mainsizex-scrollborderx:
        self.datastartx = max(0, min(x-self.mainsizex+scrollborderx+1,
                                     self.datasizex-self.mainsizex))

    if x == oldx and y == oldy and (x != newx or y != newy): # couldn't move
        self.browser.beep()
    else:
        self.curx = x
        self.cury = y
        self.calcdisplayattr()

</t>
<t tx="ekr.20071201085751.625">def sort(self, key, reverse=False):
    """
    Sort the currently list of items using the key function ``key``. If
    ``reverse`` is true the sort order is reversed.
    """
    curitem = self.items[self.cury] # Remember where the cursor is now

    # Sort items
    def realkey(item):
        return key(item.item)
    self.items = ipipe.deque(sorted(self.items, key=realkey, reverse=reverse))

    # Find out where the object under the cursor went
    cury = self.cury
    for (i, item) in enumerate(self.items):
        if item is curitem:
            cury = i
            break

    self.moveto(self.curx, cury, refresh=True)

</t>
<t tx="ekr.20071201085751.626">def refresh(self):
    """
    Restart iterating the input.
    """
    self.iterator = ipipe.xiter(self.input)
    self.items.clear()
    self.exhausted = False
    self.datastartx = self.datastarty = 0
    self.moveto(0, 0, refresh=True)

</t>
<t tx="ekr.20071201085751.627">def refreshfind(self):
    """
    Restart iterating the input and go back to the same object as before
    (if it can be found in the new iterator).
    """
    try:
        oldobject = self.items[self.cury].item
    except IndexError:
        oldobject = ipipe.noitem
    self.iterator = ipipe.xiter(self.input)
    self.items.clear()
    self.exhausted = False
    while True:
        self.fetch(len(self.items)+1)
        if self.exhausted:
            curses.beep()
            self.datastartx = self.datastarty = 0
            self.moveto(self.curx, 0, refresh=True)
            break
        if self.items[-1].item == oldobject:
            self.datastartx = self.datastarty = 0
            self.moveto(self.curx, len(self.items)-1, refresh=True)
            break


</t>
<t tx="ekr.20071201085751.628">class _CommandInput(object):
    keymap = Keymap()
    keymap.register("left", curses.KEY_LEFT)
    keymap.register("right", curses.KEY_RIGHT)
    keymap.register("home", curses.KEY_HOME, "\x01") # Ctrl-A
    keymap.register("end", curses.KEY_END, "\x05") # Ctrl-E
    # FIXME: What's happening here?
    keymap.register("backspace", curses.KEY_BACKSPACE, "\x08\x7f")
    keymap.register("delete", curses.KEY_DC)
    keymap.register("delend", 0x0b) # Ctrl-K
    keymap.register("execute", "\r\n")
    keymap.register("up", curses.KEY_UP)
    keymap.register("down", curses.KEY_DOWN)
    keymap.register("incsearchup", curses.KEY_PPAGE)
    keymap.register("incsearchdown", curses.KEY_NPAGE)
    keymap.register("exit", "\x18"), # Ctrl-X

    @others
</t>
<t tx="ekr.20071201085751.629">def __init__(self, prompt):
    self.prompt = prompt
    self.history = []
    self.maxhistory = 100
    self.input = ""
    self.curx = 0
    self.cury = -1 # blank line

</t>
<t tx="ekr.20071201085751.630">def start(self):
    self.input = ""
    self.curx = 0
    self.cury = -1 # blank line

</t>
<t tx="ekr.20071201085751.631">def handlekey(self, browser, key):
    cmdname = self.keymap.get(key, None)
    if cmdname is not None:
        cmdfunc = getattr(self, "cmd_%s" % cmdname, None)
        if cmdfunc is not None:
            return cmdfunc(browser)
        curses.beep()
    elif key != -1:
        try:
            char = chr(key)
        except ValueError:
            curses.beep()
        else:
            return self.handlechar(browser, char)

</t>
<t tx="ekr.20071201085751.632">def handlechar(self, browser, char):
    self.input = self.input[:self.curx] + char + self.input[self.curx:]
    self.curx += 1
    return True

</t>
<t tx="ekr.20071201085751.633">def dohistory(self):
    self.history.insert(0, self.input)
    del self.history[:-self.maxhistory]

</t>
<t tx="ekr.20071201085751.634">def cmd_backspace(self, browser):
    if self.curx:
        self.input = self.input[:self.curx-1] + self.input[self.curx:]
        self.curx -= 1
        return True
    else:
        curses.beep()

</t>
<t tx="ekr.20071201085751.635">def cmd_delete(self, browser):
    if self.curx&lt;len(self.input):
        self.input = self.input[:self.curx] + self.input[self.curx+1:]
        return True
    else:
        curses.beep()

</t>
<t tx="ekr.20071201085751.636">def cmd_delend(self, browser):
    if self.curx&lt;len(self.input):
        self.input = self.input[:self.curx]
        return True

</t>
<t tx="ekr.20071201085751.637">def cmd_left(self, browser):
    if self.curx:
        self.curx -= 1
        return True
    else:
        curses.beep()

</t>
<t tx="ekr.20071201085751.638">def cmd_right(self, browser):
    if self.curx &lt; len(self.input):
        self.curx += 1
        return True
    else:
        curses.beep()

</t>
<t tx="ekr.20071201085751.639">def cmd_home(self, browser):
    if self.curx:
        self.curx = 0
        return True
    else:
        curses.beep()

</t>
<t tx="ekr.20071201085751.640">def cmd_end(self, browser):
    if self.curx &lt; len(self.input):
        self.curx = len(self.input)
        return True
    else:
        curses.beep()

</t>
<t tx="ekr.20071201085751.641">def cmd_up(self, browser):
    if self.cury &lt; len(self.history)-1:
        self.cury += 1
        self.input = self.history[self.cury]
        self.curx = len(self.input)
        return True
    else:
        curses.beep()

</t>
<t tx="ekr.20071201085751.642">def cmd_down(self, browser):
    if self.cury &gt;= 0:
        self.cury -= 1
        if self.cury&gt;=0:
            self.input = self.history[self.cury]
        else:
            self.input = ""
        self.curx = len(self.input)
        return True
    else:
        curses.beep()

</t>
<t tx="ekr.20071201085751.643">def cmd_incsearchup(self, browser):
    prefix = self.input[:self.curx]
    cury = self.cury
    while True:
        cury += 1
        if cury &gt;= len(self.history):
            break
        if self.history[cury].startswith(prefix):
            self.input = self.history[cury]
            self.cury = cury
            return True
    curses.beep()

</t>
<t tx="ekr.20071201085751.644">def cmd_incsearchdown(self, browser):
    prefix = self.input[:self.curx]
    cury = self.cury
    while True:
        cury -= 1
        if cury &lt;= 0:
            break
        if self.history[cury].startswith(prefix):
            self.input = self.history[self.cury]
            self.cury = cury
            return True
    curses.beep()

</t>
<t tx="ekr.20071201085751.645">def cmd_exit(self, browser):
    browser.mode = "default"
    return True

</t>
<t tx="ekr.20071201085751.646">def cmd_execute(self, browser):
    raise NotImplementedError


</t>
<t tx="ekr.20071201085751.647">class _CommandGoto(_CommandInput):
    @others
</t>
<t tx="ekr.20071201085751.648">def __init__(self):
    _CommandInput.__init__(self, "goto object #")

</t>
<t tx="ekr.20071201085751.649">def handlechar(self, browser, char):
    # Only accept digits
    if not "0" &lt;= char &lt;= "9":
        curses.beep()
    else:
        return _CommandInput.handlechar(self, browser, char)

</t>
<t tx="ekr.20071201085751.650">def cmd_execute(self, browser):
    level = browser.levels[-1]
    if self.input:
        self.dohistory()
        level.moveto(level.curx, int(self.input))
    browser.mode = "default"
    return True


</t>
<t tx="ekr.20071201085751.651">class _CommandFind(_CommandInput):
    @others
</t>
<t tx="ekr.20071201085751.652">def __init__(self):
    _CommandInput.__init__(self, "find expression")

</t>
<t tx="ekr.20071201085751.653">def cmd_execute(self, browser):
    level = browser.levels[-1]
    if self.input:
        self.dohistory()
        while True:
            cury = level.cury
            level.moveto(level.curx, cury+1)
            if cury == level.cury:
                curses.beep()
                break # hit end
            item = level.items[level.cury].item
            try:
                globals = ipipe.getglobals(None)
                if eval(self.input, globals, ipipe.AttrNamespace(item)):
                    break # found something
            except (KeyboardInterrupt, SystemExit):
                raise
            except Exception, exc:
                browser.report(exc)
                curses.beep()
                break  # break on error
    browser.mode = "default"
    return True


</t>
<t tx="ekr.20071201085751.654">class _CommandFindBackwards(_CommandInput):
    @others
</t>
<t tx="ekr.20071201085751.655">def __init__(self):
    _CommandInput.__init__(self, "find backwards expression")

</t>
<t tx="ekr.20071201085751.656">def cmd_execute(self, browser):
    level = browser.levels[-1]
    if self.input:
        self.dohistory()
        while level.cury:
            level.moveto(level.curx, level.cury-1)
            item = level.items[level.cury].item
            try:
                globals = ipipe.getglobals(None)
                if eval(self.input, globals, ipipe.AttrNamespace(item)):
                    break # found something
            except (KeyboardInterrupt, SystemExit):
                raise
            except Exception, exc:
                browser.report(exc)
                curses.beep()
                break # break on error
        else:
            curses.beep()
    browser.mode = "default"
    return True


</t>
<t tx="ekr.20071201085751.657">class ibrowse(ipipe.Display):
    # Show this many lines from the previous screen when paging horizontally
    pageoverlapx = 1

    # Show this many lines from the previous screen when paging vertically
    pageoverlapy = 1

    # Start scrolling when the cursor is less than this number of columns
    # away from the left or right screen edge
    scrollborderx = 10

    # Start scrolling when the cursor is less than this number of lines
    # away from the top or bottom screen edge
    scrollbordery = 5

    # Accelerate by this factor when scrolling horizontally
    acceleratex = 1.05

    # Accelerate by this factor when scrolling vertically
    acceleratey = 1.05

    # The maximum horizontal scroll speed
    # (as a factor of the screen width (i.e. 0.5 == half a screen width)
    maxspeedx = 0.5

    # The maximum vertical scroll speed
    # (as a factor of the screen height (i.e. 0.5 == half a screen height)
    maxspeedy = 0.5

    # The maximum number of header lines for browser level
    # if the nesting is deeper, only the innermost levels are displayed
    maxheaders = 5

    # The approximate maximum length of a column entry
    maxattrlength = 200

    # Styles for various parts of the GUI
    style_objheadertext = astyle.Style.fromstr("white:black:bold|reverse")
    style_objheadernumber = astyle.Style.fromstr("white:blue:bold|reverse")
    style_objheaderobject = astyle.Style.fromstr("white:black:reverse")
    style_colheader = astyle.Style.fromstr("blue:white:reverse")
    style_colheaderhere = astyle.Style.fromstr("green:black:bold|reverse")
    style_colheadersep = astyle.Style.fromstr("blue:black:reverse")
    style_number = astyle.Style.fromstr("blue:white:reverse")
    style_numberhere = astyle.Style.fromstr("green:black:bold|reverse")
    style_sep = astyle.Style.fromstr("blue:black")
    style_data = astyle.Style.fromstr("white:black")
    style_datapad = astyle.Style.fromstr("blue:black:bold")
    style_footer = astyle.Style.fromstr("black:white")
    style_report = astyle.Style.fromstr("white:black")

    # Column separator in header
    headersepchar = "|"

    # Character for padding data cell entries
    datapadchar = "."

    # Column separator in data area
    datasepchar = "|"

    # Character to use for "empty" cell (i.e. for non-existing attributes)
    nodatachar = "-"

    # Prompts for modes that require keyboard input
    prompts = {
        "goto": _CommandGoto(),
        "find": _CommandFind(),
        "findbackwards": _CommandFindBackwards()
    }

    # Maps curses key codes to "function" names
    keymap = Keymap()
    keymap.register("quit", "q")
    keymap.register("up", curses.KEY_UP)
    keymap.register("down", curses.KEY_DOWN)
    keymap.register("pageup", curses.KEY_PPAGE)
    keymap.register("pagedown", curses.KEY_NPAGE)
    keymap.register("left", curses.KEY_LEFT)
    keymap.register("right", curses.KEY_RIGHT)
    keymap.register("home", curses.KEY_HOME, "\x01")
    keymap.register("end", curses.KEY_END, "\x05")
    keymap.register("prevattr", "&lt;\x1b")
    keymap.register("nextattr", "&gt;\t")
    keymap.register("pick", "p")
    keymap.register("pickattr", "P")
    keymap.register("pickallattrs", "C")
    keymap.register("pickmarked", "m")
    keymap.register("pickmarkedattr", "M")
    keymap.register("hideattr", "h")
    keymap.register("unhideattrs", "H")
    keymap.register("help", "?")
    keymap.register("enter", "\r\n")
    keymap.register("enterattr", "E")
    # FIXME: What's happening here?
    keymap.register("leave", curses.KEY_BACKSPACE, "x\x08\x7f")
    keymap.register("detail", "d")
    keymap.register("detailattr", "D")
    keymap.register("tooglemark", " ")
    keymap.register("markrange", "%")
    keymap.register("sortattrasc", "v")
    keymap.register("sortattrdesc", "V")
    keymap.register("goto", "g")
    keymap.register("find", "f")
    keymap.register("findbackwards", "b")
    keymap.register("refresh", "r")
    keymap.register("refreshfind", "R")

    @others
</t>
<t tx="ekr.20071201085751.658">def __init__(self, *attrs):
    """
    Create a new browser. If ``attrs`` is not empty, it is the list
    of attributes that will be displayed in the browser, otherwise
    these will be determined by the objects on screen.
    """
    self.attrs = attrs

    # Stack of browser levels
    self.levels = []
    # how many colums to scroll (Changes when accelerating)
    self.stepx = 1.

    # how many rows to scroll (Changes when accelerating)
    self.stepy = 1.

    # Beep on the edges of the data area? (Will be set to ``False``
    # once the cursor hits the edge of the screen, so we don't get
    # multiple beeps).
    self._dobeep = True

    # Cache for registered ``curses`` colors and styles.
    self._styles = {}
    self._colors = {}
    self._maxcolor = 1

    # How many header lines do we want to paint (the numbers of levels
    # we have, but with an upper bound)
    self._headerlines = 1

    # Index of first header line
    self._firstheaderline = 0

    # curses window
    self.scr = None
    # report in the footer line (error, executed command etc.)
    self._report = None

    # value to be returned to the caller (set by commands)
    self.returnvalue = None

    # The mode the browser is in
    # e.g. normal browsing or entering an argument for a command
    self.mode = "default"

    # set by the SIGWINCH signal handler
    self.resized = False

</t>
<t tx="ekr.20071201085751.659">def nextstepx(self, step):
    """
    Accelerate horizontally.
    """
    return max(1., min(step*self.acceleratex,
                       self.maxspeedx*self.levels[-1].mainsizex))

</t>
<t tx="ekr.20071201085751.660">def nextstepy(self, step):
    """
    Accelerate vertically.
    """
    return max(1., min(step*self.acceleratey,
                       self.maxspeedy*self.levels[-1].mainsizey))

</t>
<t tx="ekr.20071201085751.661">def getstyle(self, style):
    """
    Register the ``style`` with ``curses`` or get it from the cache,
    if it has been registered before.
    """
    try:
        return self._styles[style.fg, style.bg, style.attrs]
    except KeyError:
        attrs = 0
        for b in astyle.A2CURSES:
            if style.attrs &amp; b:
                attrs |= astyle.A2CURSES[b]
        try:
            color = self._colors[style.fg, style.bg]
        except KeyError:
            curses.init_pair(
                self._maxcolor,
                astyle.COLOR2CURSES[style.fg],
                astyle.COLOR2CURSES[style.bg]
            )
            color = curses.color_pair(self._maxcolor)
            self._colors[style.fg, style.bg] = color
            self._maxcolor += 1
        c = color | attrs
        self._styles[style.fg, style.bg, style.attrs] = c
        return c

</t>
<t tx="ekr.20071201085751.662">def addstr(self, y, x, begx, endx, text, style):
    """
    A version of ``curses.addstr()`` that can handle ``x`` coordinates
    that are outside the screen.
    """
    text2 = text[max(0, begx-x):max(0, endx-x)]
    if text2:
        self.scr.addstr(y, max(x, begx), text2, self.getstyle(style))
    return len(text)

</t>
<t tx="ekr.20071201085751.663">def addchr(self, y, x, begx, endx, c, l, style):
    x0 = max(x, begx)
    x1 = min(x+l, endx)
    if x1&gt;x0:
        self.scr.addstr(y, x0, c*(x1-x0), self.getstyle(style))
    return l

</t>
<t tx="ekr.20071201085751.664">def _calcheaderlines(self, levels):
    # Calculate how many headerlines do we have to display, if we have
    # ``levels`` browser levels
    if levels is None:
        levels = len(self.levels)
    self._headerlines = min(self.maxheaders, levels)
    self._firstheaderline = levels-self._headerlines

</t>
<t tx="ekr.20071201085751.665">def getstylehere(self, style):
    """
    Return a style for displaying the original style ``style``
    in the row the cursor is on.
    """
    return astyle.Style(style.fg, astyle.COLOR_BLUE, style.attrs | astyle.A_BOLD)

</t>
<t tx="ekr.20071201085751.666">def report(self, msg):
    """
    Store the message ``msg`` for display below the footer line. This
    will be displayed as soon as the screen is redrawn.
    """
    self._report = msg

</t>
<t tx="ekr.20071201085751.667">def enter(self, item, *attrs):
    """
    Enter the object ``item``. If ``attrs`` is specified, it will be used
    as a fixed list of attributes to display.
    """
    oldlevels = len(self.levels)
    self._calcheaderlines(oldlevels+1)
    try:
        level = _BrowserLevel(
            self,
            item,
            self.scrsizey-1-self._headerlines-2,
            *attrs
        )
    except (KeyboardInterrupt, SystemExit):
        raise
    except Exception, exc:
        self._calcheaderlines(oldlevels)
        curses.beep()
        self.report(exc)
    else:
        self.levels.append(level)

</t>
<t tx="ekr.20071201085751.668">def startkeyboardinput(self, mode):
    """
    Enter mode ``mode``, which requires keyboard input.
    """
    self.mode = mode
    self.prompts[mode].start()

</t>
<t tx="ekr.20071201085751.669">def keylabel(self, keycode):
    """
    Return a pretty name for the ``curses`` key ``keycode`` (used in the
    help screen and in reports about unassigned keys).
    """
    if keycode &lt;= 0xff:
        specialsnames = {
            ord("\n"): "RETURN",
            ord(" "): "SPACE",
            ord("\t"): "TAB",
            ord("\x7f"): "DELETE",
            ord("\x08"): "BACKSPACE",
        }
        if keycode in specialsnames:
            return specialsnames[keycode]
        elif 0x00 &lt; keycode &lt; 0x20:
            return "CTRL-%s" % chr(keycode + 64)
        return repr(chr(keycode))
    for name in dir(curses):
        if name.startswith("KEY_") and getattr(curses, name) == keycode:
            return name
    return str(keycode)

</t>
<t tx="ekr.20071201085751.670">def beep(self, force=False):
    if force or self._dobeep:
        curses.beep()
        # don't beep again (as long as the same key is pressed)
        self._dobeep = False

</t>
<t tx="ekr.20071201085751.671">def cmd_up(self):
    """
    Move the cursor to the previous row.
    """
    level = self.levels[-1]
    self.report("up")
    level.moveto(level.curx, level.cury-self.stepy)

</t>
<t tx="ekr.20071201085751.672">def cmd_down(self):
    """
    Move the cursor to the next row.
    """
    level = self.levels[-1]
    self.report("down")
    level.moveto(level.curx, level.cury+self.stepy)

</t>
<t tx="ekr.20071201085751.673">def cmd_pageup(self):
    """
    Move the cursor up one page.
    """
    level = self.levels[-1]
    self.report("page up")
    level.moveto(level.curx, level.cury-level.mainsizey+self.pageoverlapy)

</t>
<t tx="ekr.20071201085751.674">def cmd_pagedown(self):
    """
    Move the cursor down one page.
    """
    level = self.levels[-1]
    self.report("page down")
    level.moveto(level.curx, level.cury+level.mainsizey-self.pageoverlapy)

</t>
<t tx="ekr.20071201085751.675">def cmd_left(self):
    """
    Move the cursor left.
    """
    level = self.levels[-1]
    self.report("left")
    level.moveto(level.curx-self.stepx, level.cury)

</t>
<t tx="ekr.20071201085751.676">def cmd_right(self):
    """
    Move the cursor right.
    """
    level = self.levels[-1]
    self.report("right")
    level.moveto(level.curx+self.stepx, level.cury)

</t>
<t tx="ekr.20071201085751.677">def cmd_home(self):
    """
    Move the cursor to the first column.
    """
    level = self.levels[-1]
    self.report("home")
    level.moveto(0, level.cury)

</t>
<t tx="ekr.20071201085751.678">def cmd_end(self):
    """
    Move the cursor to the last column.
    """
    level = self.levels[-1]
    self.report("end")
    level.moveto(level.datasizex+level.mainsizey-self.pageoverlapx, level.cury)

</t>
<t tx="ekr.20071201085751.679">def cmd_prevattr(self):
    """
    Move the cursor one attribute column to the left.
    """
    level = self.levels[-1]
    if level.displayattr[0] is None or level.displayattr[0] == 0:
        self.beep()
    else:
        self.report("prevattr")
        pos = 0
        for (i, attrname) in enumerate(level.displayattrs):
            if i == level.displayattr[0]-1:
                break
            pos += level.colwidths[attrname] + 1
        level.moveto(pos, level.cury)

</t>
<t tx="ekr.20071201085751.680">def cmd_nextattr(self):
    """
    Move the cursor one attribute column to the right.
    """
    level = self.levels[-1]
    if level.displayattr[0] is None or level.displayattr[0] == len(level.displayattrs)-1:
        self.beep()
    else:
        self.report("nextattr")
        pos = 0
        for (i, attrname) in enumerate(level.displayattrs):
            if i == level.displayattr[0]+1:
                break
            pos += level.colwidths[attrname] + 1
        level.moveto(pos, level.cury)

</t>
<t tx="ekr.20071201085751.681">def cmd_pick(self):
    """
    'Pick' the object under the cursor (i.e. the row the cursor is on).
    This leaves the browser and returns the picked object to the caller.
    (In IPython this object will be available as the ``_`` variable.)
    """
    level = self.levels[-1]
    self.returnvalue = level.items[level.cury].item
    return True

</t>
<t tx="ekr.20071201085751.682">def cmd_pickattr(self):
    """
    'Pick' the attribute under the cursor (i.e. the row/column the
    cursor is on).
    """
    level = self.levels[-1]
    attr = level.displayattr[1]
    if attr is ipipe.noitem:
        curses.beep()
        self.report(CommandError("no column under cursor"))
        return
    value = attr.value(level.items[level.cury].item)
    if value is ipipe.noitem:
        curses.beep()
        self.report(AttributeError(attr.name()))
    else:
        self.returnvalue = value
        return True

</t>
<t tx="ekr.20071201085751.683">def cmd_pickallattrs(self):
    """
    Pick' the complete column under the cursor (i.e. the attribute under
    the cursor) from all currently fetched objects. These attributes
    will be returned as a list.
    """
    level = self.levels[-1]
    attr = level.displayattr[1]
    if attr is ipipe.noitem:
        curses.beep()
        self.report(CommandError("no column under cursor"))
        return
    result = []
    for cache in level.items:
        value = attr.value(cache.item)
        if value is not ipipe.noitem:
            result.append(value)
    self.returnvalue = result
    return True

</t>
<t tx="ekr.20071201085751.684">def cmd_pickmarked(self):
    """
    'Pick' marked objects. Marked objects will be returned as a list.
    """
    level = self.levels[-1]
    self.returnvalue = [cache.item for cache in level.items if cache.marked]
    return True

</t>
<t tx="ekr.20071201085751.685">def cmd_pickmarkedattr(self):
    """
    'Pick' the attribute under the cursor from all marked objects
    (This returns a list).
    """

    level = self.levels[-1]
    attr = level.displayattr[1]
    if attr is ipipe.noitem:
        curses.beep()
        self.report(CommandError("no column under cursor"))
        return
    result = []
    for cache in level.items:
        if cache.marked:
            value = attr.value(cache.item)
            if value is not ipipe.noitem:
                result.append(value)
    self.returnvalue = result
    return True

</t>
<t tx="ekr.20071201085751.686">def cmd_markrange(self):
    """
    Mark all objects from the last marked object before the current cursor
    position to the cursor position.
    """
    level = self.levels[-1]
    self.report("markrange")
    start = None
    if level.items:
        for i in xrange(level.cury, -1, -1):
            if level.items[i].marked:
                start = i
                break
    if start is None:
        self.report(CommandError("no mark before cursor"))
        curses.beep()
    else:
        for i in xrange(start, level.cury+1):
            cache = level.items[i]
            if not cache.marked:
                cache.marked = True
                level.marked += 1

</t>
<t tx="ekr.20071201085751.687">def cmd_enter(self):
    """
    Enter the object under the cursor. (what this mean depends on the object
    itself (i.e. how it implements iteration). This opens a new browser 'level'.
    """
    level = self.levels[-1]
    try:
        item = level.items[level.cury].item
    except IndexError:
        self.report(CommandError("No object"))
        curses.beep()
    else:
        self.report("entering object...")
        self.enter(item)

</t>
<t tx="ekr.20071201085751.688">def cmd_leave(self):
    """
    Leave the current browser level and go back to the previous one.
    """
    self.report("leave")
    if len(self.levels) &gt; 1:
        self._calcheaderlines(len(self.levels)-1)
        self.levels.pop(-1)
    else:
        self.report(CommandError("This is the last level"))
        curses.beep()

</t>
<t tx="ekr.20071201085751.689">def cmd_enterattr(self):
    """
    Enter the attribute under the cursor.
    """
    level = self.levels[-1]
    attr = level.displayattr[1]
    if attr is ipipe.noitem:
        curses.beep()
        self.report(CommandError("no column under cursor"))
        return
    try:
        item = level.items[level.cury].item
    except IndexError:
        self.report(CommandError("No object"))
        curses.beep()
    else:
        value = attr.value(item)
        name = attr.name()
        if value is ipipe.noitem:
            self.report(AttributeError(name))
        else:
            self.report("entering object attribute %s..." % name)
            self.enter(value)

</t>
<t tx="ekr.20071201085751.690">def cmd_detail(self):
    """
    Show a detail view of the object under the cursor. This shows the
    name, type, doc string and value of the object attributes (and it
    might show more attributes than in the list view, depending on
    the object).
    """
    level = self.levels[-1]
    try:
        item = level.items[level.cury].item
    except IndexError:
        self.report(CommandError("No object"))
        curses.beep()
    else:
        self.report("entering detail view for object...")
        attrs = [ipipe.AttributeDetail(item, attr) for attr in ipipe.xattrs(item, "detail")]
        self.enter(attrs)

</t>
<t tx="ekr.20071201085751.691">def cmd_detailattr(self):
    """
    Show a detail view of the attribute under the cursor.
    """
    level = self.levels[-1]
    attr = level.displayattr[1]
    if attr is ipipe.noitem:
        curses.beep()
        self.report(CommandError("no attribute"))
        return
    try:
        item = level.items[level.cury].item
    except IndexError:
        self.report(CommandError("No object"))
        curses.beep()
    else:
        try:
            item = attr.value(item)
        except (KeyboardInterrupt, SystemExit):
            raise
        except Exception, exc:
            self.report(exc)
        else:
            self.report("entering detail view for attribute %s..." % attr.name())
            attrs = [ipipe.AttributeDetail(item, attr) for attr in ipipe.xattrs(item, "detail")]
            self.enter(attrs)

</t>
<t tx="ekr.20071201085751.692">def cmd_tooglemark(self):
    """
    Mark/unmark the object under the cursor. Marked objects have a '!'
    after the row number).
    """
    level = self.levels[-1]
    self.report("toggle mark")
    try:
        item = level.items[level.cury]
    except IndexError: # no items?
        pass
    else:
        if item.marked:
            item.marked = False
            level.marked -= 1
        else:
            item.marked = True
            level.marked += 1

</t>
<t tx="ekr.20071201085751.693">def cmd_sortattrasc(self):
    """
    Sort the objects (in ascending order) using the attribute under
    the cursor as the sort key.
    """
    level = self.levels[-1]
    attr = level.displayattr[1]
    if attr is ipipe.noitem:
        curses.beep()
        self.report(CommandError("no column under cursor"))
        return
    self.report("sort by %s (ascending)" % attr.name())
    def key(item):
        try:
            return attr.value(item)
        except (KeyboardInterrupt, SystemExit):
            raise
        except Exception:
            return None
    level.sort(key)

</t>
<t tx="ekr.20071201085751.694">def cmd_sortattrdesc(self):
    """
    Sort the objects (in descending order) using the attribute under
    the cursor as the sort key.
    """
    level = self.levels[-1]
    attr = level.displayattr[1]
    if attr is ipipe.noitem:
        curses.beep()
        self.report(CommandError("no column under cursor"))
        return
    self.report("sort by %s (descending)" % attr.name())
    def key(item):
        try:
            return attr.value(item)
        except (KeyboardInterrupt, SystemExit):
            raise
        except Exception:
            return None
    level.sort(key, reverse=True)

</t>
<t tx="ekr.20071201085751.695">def cmd_hideattr(self):
    """
    Hide the attribute under the cursor.
    """
    level = self.levels[-1]
    if level.displayattr[0] is None:
        self.beep()
    else:
        self.report("hideattr")
        level.hiddenattrs.add(level.displayattr[1])
        level.moveto(level.curx, level.cury, refresh=True)

</t>
<t tx="ekr.20071201085751.696">def cmd_unhideattrs(self):
    """
    Make all attributes visible again.
    """
    level = self.levels[-1]
    self.report("unhideattrs")
    level.hiddenattrs.clear()
    level.moveto(level.curx, level.cury, refresh=True)

</t>
<t tx="ekr.20071201085751.697">def cmd_goto(self):
    """
    Jump to a row. The row number can be entered at the
    bottom of the screen.
    """
    self.startkeyboardinput("goto")

</t>
<t tx="ekr.20071201085751.698">def cmd_find(self):
    """
    Search forward for a row. The search condition can be entered at the
    bottom of the screen.
    """
    self.startkeyboardinput("find")

</t>
<t tx="ekr.20071201085751.699">def cmd_findbackwards(self):
    """
    Search backward for a row. The search condition can be entered at the
    bottom of the screen.
    """
    self.startkeyboardinput("findbackwards")

</t>
<t tx="ekr.20071201085751.700">def cmd_refresh(self):
    """
    Refreshes the display by restarting the iterator.
    """
    level = self.levels[-1]
    self.report("refresh")
    level.refresh()

</t>
<t tx="ekr.20071201085751.701">def cmd_refreshfind(self):
    """
    Refreshes the display by restarting the iterator and goes back to the
    same object the cursor was on before restarting (if this object can't be
    found the cursor jumps back to the first object).
    """
    level = self.levels[-1]
    self.report("refreshfind")
    level.refreshfind()

</t>
<t tx="ekr.20071201085751.702">def cmd_help(self):
    """
    Opens the help screen as a new browser level, describing keyboard
    shortcuts.
    """
    for level in self.levels:
        if isinstance(level.input, _BrowserHelp):
            curses.beep()
            self.report(CommandError("help already active"))
            return

    self.enter(_BrowserHelp(self))

</t>
<t tx="ekr.20071201085751.703">def cmd_quit(self):
    """
    Quit the browser and return to the IPython prompt.
    """
    self.returnvalue = None
    return True

</t>
<t tx="ekr.20071201085751.704">def sigwinchhandler(self, signal, frame):
    self.resized = True

</t>
<t tx="ekr.20071201085751.705">def _dodisplay(self, scr):
    """
    This method is the workhorse of the browser. It handles screen
    drawing and the keyboard.
    """
    self.scr = scr
    curses.halfdelay(1)
    footery = 2

    keys = []
    for cmd in ("quit", "help"):
        key = self.keymap.findkey(cmd, None)
        if key is not None:
            keys.append("%s=%s" % (self.keylabel(key), cmd))
    helpmsg = " | %s" % " ".join(keys)

    scr.clear()
    msg = "Fetching first batch of objects..."
    (self.scrsizey, self.scrsizex) = scr.getmaxyx()
    scr.addstr(self.scrsizey//2, (self.scrsizex-len(msg))//2, msg)
    scr.refresh()

    lastc = -1

    self.levels = []
    # enter the first level
    self.enter(self.input, *self.attrs)

    self._calcheaderlines(None)

    while True:
        level = self.levels[-1]
        (self.scrsizey, self.scrsizex) = scr.getmaxyx()
        level.mainsizey = self.scrsizey-1-self._headerlines-footery

        # Paint object header
        for i in xrange(self._firstheaderline, self._firstheaderline+self._headerlines):
            lv = self.levels[i]
            posx = 0
            posy = i-self._firstheaderline
            endx = self.scrsizex
            if i: # not the first level
                msg = " (%d/%d" % (self.levels[i-1].cury, len(self.levels[i-1].items))
                if not self.levels[i-1].exhausted:
                    msg += "+"
                msg += ") "
                endx -= len(msg)+1
            posx += self.addstr(posy, posx, 0, endx, " ibrowse #%d: " % i, self.style_objheadertext)
            for (style, text) in lv.header:
                posx += self.addstr(posy, posx, 0, endx, text, self.style_objheaderobject)
                if posx &gt;= endx:
                    break
            if i:
                posx += self.addstr(posy, posx, 0, self.scrsizex, msg, self.style_objheadernumber)
            posx += self.addchr(posy, posx, 0, self.scrsizex, " ", self.scrsizex-posx, self.style_objheadernumber)

        if not level.items:
            self.addchr(self._headerlines, 0, 0, self.scrsizex, " ", self.scrsizex, self.style_colheader)
            self.addstr(self._headerlines+1, 0, 0, self.scrsizex, " &lt;empty&gt;", astyle.style_error)
            scr.clrtobot()
        else:
            # Paint column headers
            scr.move(self._headerlines, 0)
            scr.addstr(" %*s " % (level.numbersizex, "#"), self.getstyle(self.style_colheader))
            scr.addstr(self.headersepchar, self.getstyle(self.style_colheadersep))
            begx = level.numbersizex+3
            posx = begx-level.datastartx
            for attr in level.displayattrs:
                attrname = attr.name()
                cwidth = level.colwidths[attr]
                header = attrname.ljust(cwidth)
                if attr is level.displayattr[1]:
                    style = self.style_colheaderhere
                else:
                    style = self.style_colheader
                posx += self.addstr(self._headerlines, posx, begx, self.scrsizex, header, style)
                posx += self.addstr(self._headerlines, posx, begx, self.scrsizex, self.headersepchar, self.style_colheadersep)
                if posx &gt;= self.scrsizex:
                    break
            else:
                scr.addstr(" "*(self.scrsizex-posx), self.getstyle(self.style_colheader))

            # Paint rows
            posy = self._headerlines+1+level.datastarty
            for i in xrange(level.datastarty, min(level.datastarty+level.mainsizey, len(level.items))):
                cache = level.items[i]
                if i == level.cury:
                    style = self.style_numberhere
                else:
                    style = self.style_number

                posy = self._headerlines+1+i-level.datastarty
                posx = begx-level.datastartx

                scr.move(posy, 0)
                scr.addstr(" %*d%s" % (level.numbersizex, i, " !"[cache.marked]), self.getstyle(style))
                scr.addstr(self.headersepchar, self.getstyle(self.style_sep))

                for attrname in level.displayattrs:
                    cwidth = level.colwidths[attrname]
                    try:
                        (align, length, parts) = level.displayrows[i-level.datastarty][attrname]
                    except KeyError:
                        align = 2
                        style = astyle.style_nodata
                        if i == level.cury:
                            style = self.getstylehere(style)
                    padstyle = self.style_datapad
                    sepstyle = self.style_sep
                    if i == level.cury:
                        padstyle = self.getstylehere(padstyle)
                        sepstyle = self.getstylehere(sepstyle)
                    if align == 2:
                        posx += self.addchr(posy, posx, begx, self.scrsizex, self.nodatachar, cwidth, style)
                    else:
                        if align == 1:
                            posx += self.addchr(posy, posx, begx, self.scrsizex, self.datapadchar, cwidth-length, padstyle)
                        elif align == 0:
                            pad1 = (cwidth-length)//2
                            pad2 = cwidth-length-len(pad1)
                            posx += self.addchr(posy, posx, begx, self.scrsizex, self.datapadchar, pad1, padstyle)
                        for (style, text) in parts:
                            if i == level.cury:
                                style = self.getstylehere(style)
                            posx += self.addstr(posy, posx, begx, self.scrsizex, text, style)
                            if posx &gt;= self.scrsizex:
                                break
                        if align == -1:
                            posx += self.addchr(posy, posx, begx, self.scrsizex, self.datapadchar, cwidth-length, padstyle)
                        elif align == 0:
                            posx += self.addchr(posy, posx, begx, self.scrsizex, self.datapadchar, pad2, padstyle)
                    posx += self.addstr(posy, posx, begx, self.scrsizex, self.datasepchar, sepstyle)
                else:
                    scr.clrtoeol()

            # Add blank row headers for the rest of the screen
            for posy in xrange(posy+1, self.scrsizey-2):
                scr.addstr(posy, 0, " " * (level.numbersizex+2), self.getstyle(self.style_colheader))
                scr.clrtoeol()

        posy = self.scrsizey-footery
        # Display footer
        scr.addstr(posy, 0, " "*self.scrsizex, self.getstyle(self.style_footer))

        if level.exhausted:
            flag = ""
        else:
            flag = "+"

        endx = self.scrsizex-len(helpmsg)-1
        scr.addstr(posy, endx, helpmsg, self.getstyle(self.style_footer))

        posx = 0
        msg = " %d%s objects (%d marked): " % (len(level.items), flag, level.marked)
        posx += self.addstr(posy, posx, 0, endx, msg, self.style_footer)
        try:
            item = level.items[level.cury].item
        except IndexError: # empty
            pass
        else:
            for (nostyle, text) in ipipe.xrepr(item, "footer"):
                if not isinstance(nostyle, int):
                    posx += self.addstr(posy, posx, 0, endx, text, self.style_footer)
                    if posx &gt;= endx:
                        break

            attrstyle = [(astyle.style_default, "no attribute")]
            attr = level.displayattr[1]
            if attr is not ipipe.noitem and not isinstance(attr, ipipe.SelfDescriptor):
                posx += self.addstr(posy, posx, 0, endx, " | ", self.style_footer)
                posx += self.addstr(posy, posx, 0, endx, attr.name(), self.style_footer)
                posx += self.addstr(posy, posx, 0, endx, ": ", self.style_footer)
                try:
                    value = attr.value(item)
                except (SystemExit, KeyboardInterrupt):
                    raise
                except Exception, exc:
                    value = exc
                if value is not ipipe.noitem:
                    attrstyle = ipipe.xrepr(value, "footer")
                for (nostyle, text) in attrstyle:
                    if not isinstance(nostyle, int):
                        posx += self.addstr(posy, posx, 0, endx, text, self.style_footer)
                        if posx &gt;= endx:
                            break

        try:
            # Display input prompt
            if self.mode in self.prompts:
                history = self.prompts[self.mode]
                posx = 0
                posy = self.scrsizey-1
                posx += self.addstr(posy, posx, 0, endx, history.prompt, astyle.style_default)
                posx += self.addstr(posy, posx, 0, endx, " [", astyle.style_default)
                if history.cury==-1:
                    text = "new"
                else:
                    text = str(history.cury+1)
                posx += self.addstr(posy, posx, 0, endx, text, astyle.style_type_number)
                if history.history:
                    posx += self.addstr(posy, posx, 0, endx, "/", astyle.style_default)
                    posx += self.addstr(posy, posx, 0, endx, str(len(history.history)), astyle.style_type_number)
                posx += self.addstr(posy, posx, 0, endx, "]: ", astyle.style_default)
                inputstartx = posx
                posx += self.addstr(posy, posx, 0, endx, history.input, astyle.style_default)
            # Display report
            else:
                if self._report is not None:
                    if isinstance(self._report, Exception):
                        style = self.getstyle(astyle.style_error)
                        if self._report.__class__.__module__ == "exceptions":
                            msg = "%s: %s" % \
                                  (self._report.__class__.__name__, self._report)
                        else:
                            msg = "%s.%s: %s" % \
                                  (self._report.__class__.__module__,
                                   self._report.__class__.__name__, self._report)
                    else:
                        style = self.getstyle(self.style_report)
                        msg = self._report
                    scr.addstr(self.scrsizey-1, 0, msg[:self.scrsizex], style)
                    self._report = None
                else:
                    scr.move(self.scrsizey-1, 0)
        except curses.error:
            # Protect against errors from writing to the last line
            pass
        scr.clrtoeol()

        # Position cursor
        if self.mode in self.prompts:
            history = self.prompts[self.mode]
            scr.move(self.scrsizey-1, inputstartx+history.curx)
        else:
            scr.move(
                1+self._headerlines+level.cury-level.datastarty,
                level.numbersizex+3+level.curx-level.datastartx
            )
        scr.refresh()

        # Check keyboard
        while True:
            c = scr.getch()
            if self.resized:
                size = fcntl.ioctl(0, tty.TIOCGWINSZ, "12345678")
                size = struct.unpack("4H", size)
                oldsize = scr.getmaxyx()
                scr.erase()
                curses.resize_term(size[0], size[1])
                newsize = scr.getmaxyx()
                scr.erase()
                for l in self.levels:
                    l.mainsizey += newsize[0]-oldsize[0]
                    l.moveto(l.curx, l.cury, refresh=True)
                scr.refresh()
                self.resized = False
                break # Redisplay
            if self.mode in self.prompts:
                if self.prompts[self.mode].handlekey(self, c):
                   break # Redisplay
            else:
                # if no key is pressed slow down and beep again
                if c == -1:
                    self.stepx = 1.
                    self.stepy = 1.
                    self._dobeep = True
                else:
                    # if a different key was pressed slow down and beep too
                    if c != lastc:
                        lastc = c
                        self.stepx = 1.
                        self.stepy = 1.
                        self._dobeep = True
                    cmdname = self.keymap.get(c, None)
                    if cmdname is None:
                        self.report(
                            UnassignedKeyError("Unassigned key %s" %
                                               self.keylabel(c)))
                    else:
                        cmdfunc = getattr(self, "cmd_%s" % cmdname, None)
                        if cmdfunc is None:
                            self.report(
                                UnknownCommandError("Unknown command %r" %
                                                    (cmdname,)))
                        elif cmdfunc():
                            returnvalue = self.returnvalue
                            self.returnvalue = None
                            return returnvalue
                    self.stepx = self.nextstepx(self.stepx)
                    self.stepy = self.nextstepy(self.stepy)
                    curses.flushinp() # get rid of type ahead
                    break # Redisplay
    self.scr = None

</t>
<t tx="ekr.20071201085751.706">def display(self):
    if hasattr(curses, "resize_term"):
        oldhandler = signal.signal(signal.SIGWINCH, self.sigwinchhandler)
        try:
            return curses.wrapper(self._dodisplay)
        finally:
            signal.signal(signal.SIGWINCH, oldhandler)
    else:
        return curses.wrapper(self._dodisplay)
</t>
<t tx="ekr.20071201085751.707"># -*- coding: utf-8 -*-
"""Modified input prompt for executing files.

We define a special input line filter to allow typing lines which begin with
'~', '/' or '.'. If one of those strings is encountered, it is automatically
executed.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2004 W.J. van der Laan &lt;gnufnork@hetdigitalegat.nl&gt;
#       Copyright (C) 2004-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__ = 'W.J. van der Laan &lt;gnufnork@hetdigitalegat.nl&gt;, '\
             '%s &lt;%s&gt;' %  Release.authors['Fernando']
__license__ = Release.license

</t>
<t tx="ekr.20071201085751.708"># TODO: deprecated
def prefilter_shell(self,line,continuation):
    """Alternate prefilter, modified for shell-like functionality.

    - Execute all lines beginning with '~', '/' or '.'
    - $var=cmd &lt;=&gt; %sc var=cmd
    - $$var=cmd &lt;=&gt; %sc -l var=cmd
    """

    if line:
        l0 = line[0]
        if l0 in '~/.':
            return self._prefilter("!%s"%line,continuation)
        elif l0=='$':
            lrest = line[1:]
            if lrest.startswith('$'):
                # $$var=cmd &lt;=&gt; %sc -l var=cmd
                return self._prefilter("%ssc -l %s" % (self.ESC_MAGIC,lrest[1:]),
                                       continuation)
            else:
                # $var=cmd &lt;=&gt; %sc var=cmd
                return self._prefilter("%ssc %s" % (self.ESC_MAGIC,lrest),
                                       continuation)
        else:
            return self._prefilter(line,continuation)
    else:
        return self._prefilter(line,continuation)

</t>
<t tx="ekr.20071201085751.709"># Rebind this to be the new IPython prefilter:
from IPython.iplib import InteractiveShell
InteractiveShell.prefilter = prefilter_shell
# Clean up the namespace.
del InteractiveShell,prefilter_shell

# Provide pysh and further shell-oriented services
import os,sys,shutil
from IPython.genutils import system,shell,getoutput,getoutputerror

# Short aliases for getting shell output as a string and a list
sout = getoutput
lout = lambda cmd: getoutput(cmd,split=1)

# Empty function, meant as a docstring holder so help(pysh) works.
def pysh():
    """Pysh is a set of modules and extensions to IPython which make shell-like
    usage with Python syntax more convenient.  Keep in mind that pysh is NOT a
    full-blown shell, so don't try to make it your /etc/passwd entry!
    
    In particular, it has no job control, so if you type Ctrl-Z (under Unix),
    you'll suspend pysh itself, not the process you just started.

    Since pysh is really nothing but a customized IPython, you should
    familiarize yourself with IPython's features.  This brief help mainly
    documents areas in which pysh differs from the normal IPython.

    ALIASES
    -------
    All of your $PATH has been loaded as IPython aliases, so you should be
    able to type any normal system command and have it executed.  See %alias? 
    and %unalias? for details on the alias facilities.

    SPECIAL SYNTAX
    --------------
    Any lines which begin with '~', '/' and '.' will be executed as shell
    commands instead of as Python code. The special escapes below are also
    recognized.  !cmd is valid in single or multi-line input, all others are
    only valid in single-line input:

    !cmd      - pass 'cmd' directly to the shell
    !!cmd     - execute 'cmd' and return output as a list (split on '\\n')
    $var=cmd  - capture output of cmd into var, as a string
    $$var=cmd - capture output of cmd into var, as a list (split on '\\n')

    The $/$$ syntaxes make Python variables from system output, which you can
    later use for further scripting.  The converse is also possible: when
    executing an alias or calling to the system via !/!!, you can expand any
    python variable or expression by prepending it with $.  Full details of
    the allowed syntax can be found in Python's PEP 215.

    A few brief examples will illustrate these:

        fperez[~/test]|3&gt; !ls *s.py
        scopes.py  strings.py

    ls is an internal alias, so there's no need to use !:
        fperez[~/test]|4&gt; ls *s.py
        scopes.py*  strings.py

    !!ls will return the output into a Python variable:
        fperez[~/test]|5&gt; !!ls *s.py
                      &lt;5&gt; ['scopes.py', 'strings.py']
        fperez[~/test]|6&gt; print _5
        ['scopes.py', 'strings.py']

    $ and $$ allow direct capture to named variables:
        fperez[~/test]|7&gt; $astr = ls *s.py
        fperez[~/test]|8&gt; astr
                      &lt;8&gt; 'scopes.py\\nstrings.py'

        fperez[~/test]|9&gt; $$alist = ls *s.py
        fperez[~/test]|10&gt; alist
                      &lt;10&gt; ['scopes.py', 'strings.py']

    alist is now a normal python list you can loop over.  Using $ will expand
    back the python values when alias calls are made:
        fperez[~/test]|11&gt; for f in alist:
                      |..&gt;     print 'file',f,
                      |..&gt;     wc -l $f
                      |..&gt;
        file scopes.py     13 scopes.py
        file strings.py      4 strings.py

    Note that you may need to protect your variables with braces if you want
    to append strings to their names.  To copy all files in alist to .bak
    extensions, you must use:
        fperez[~/test]|12&gt; for f in alist:
                      |..&gt;     cp $f ${f}.bak

    If you try using $f.bak, you'll get an AttributeError exception saying
    that your string object doesn't have a .bak attribute.  This is because
    the $ expansion mechanism allows you to expand full Python expressions:
        fperez[~/test]|13&gt; echo "sys.platform is: $sys.platform"
        sys.platform is: linux2

    IPython's input history handling is still active, which allows you to
    rerun a single block of multi-line input by simply using exec:    
        fperez[~/test]|14&gt; $$alist = ls *.eps
        fperez[~/test]|15&gt; exec _i11
        file image2.eps    921 image2.eps
        file image.eps    921 image.eps

    While these are new special-case syntaxes, they are designed to allow very
    efficient use of the shell with minimal typing.  At an interactive shell
    prompt, conciseness of expression wins over readability.

    USEFUL FUNCTIONS AND MODULES
    ----------------------------
    The os, sys and shutil modules from the Python standard library are
    automatically loaded.  Some additional functions, useful for shell usage,
    are listed below.  You can request more help about them with '?'.

    shell   - execute a command in the underlying system shell    
    system  - like shell(), but return the exit status of the command
    sout    - capture the output of a command as a string
    lout    - capture the output of a command as a list (split on '\\n')
    getoutputerror - capture (output,error) of a shell command

    sout/lout are the functional equivalents of $/$$.  They are provided to
    allow you to capture system output in the middle of true python code,
    function definitions, etc (where $ and $$ are invalid).

    DIRECTORY MANAGEMENT
    --------------------
    Since each command passed by pysh to the underlying system is executed in
    a subshell which exits immediately, you can NOT use !cd to navigate the
    filesystem.

    Pysh provides its own builtin '%cd' magic command to move in the
    filesystem (the % is not required with automagic on).  It also maintains a
    list of visited directories (use %dhist to see it) and allows direct
    switching to any of them.  Type 'cd?' for more details.

    %pushd, %popd and %dirs are provided for directory stack handling.

    PROMPT CUSTOMIZATION
    --------------------
    
    The supplied ipythonrc-pysh profile comes with an example of a very
    colored and detailed prompt, mainly to serve as an illustration.  The
    valid escape sequences, besides color names, are:

        \\#  - Prompt number.
        \\D  - Dots, as many as there are digits in \\# (so they align).
        \\w  - Current working directory (cwd).
        \\W  - Basename of current working directory.
        \\XN - Where N=0..5. N terms of the cwd, with $HOME written as ~.
        \\YN - Where N=0..5. Like XN, but if ~ is term N+1 it's also shown.
        \\u  - Username.
        \\H  - Full hostname.
        \\h  - Hostname up to first '.'
        \\$  - Root symbol ($ or #).
        \\t  - Current time, in H:M:S format.
        \\v  - IPython release version.
        \\n  - Newline.
        \\r  - Carriage return.
        \\\\ - An explicitly escaped '\\'.

    You can configure your prompt colors using any ANSI color escape.  Each
    color escape sets the color for any subsequent text, until another escape
    comes in and changes things.  The valid color escapes are:

        \\C_Black
        \\C_Blue
        \\C_Brown
        \\C_Cyan
        \\C_DarkGray
        \\C_Green
        \\C_LightBlue
        \\C_LightCyan
        \\C_LightGray
        \\C_LightGreen
        \\C_LightPurple
        \\C_LightRed
        \\C_Purple
        \\C_Red
        \\C_White
        \\C_Yellow
        \\C_Normal - Stop coloring, defaults to your terminal settings.
    """
    pass

</t>
<t tx="ekr.20071201085751.710"># -*- coding: utf-8 -*-
"""Modified input prompt for entering text with &gt;&gt;&gt; or ... at the start.

We define a special input line filter to allow typing lines which begin with
'&gt;&gt;&gt; ' or '... '. These two strings, if present at the start of the input
line, are stripped. This allows for direct pasting of code from examples such
as those available in the standard Python tutorial.

Normally pasting such code is one chunk is impossible because of the
extraneous &gt;&gt;&gt; and ..., requiring one to do a line by line paste with careful
removal of those characters. This module allows pasting that kind of
multi-line examples in one pass.

Here is an 'screenshot' of a section of the tutorial pasted into IPython with
this feature enabled:

In [1]: &gt;&gt;&gt; def fib2(n): # return Fibonacci series up to n
   ...: ...     '''Return a list containing the Fibonacci series up to n.'''
   ...: ...     result = []
   ...: ...     a, b = 0, 1
   ...: ...     while b &lt; n:
   ...: ...         result.append(b)    # see below
   ...: ...         a, b = b, a+b
   ...: ...     return result
   ...:

In [2]: fib2(10)
Out[2]: [1, 1, 2, 3, 5, 8]

The &gt;&gt;&gt; and ... are stripped from the input so that the python interpreter
only sees the real part of the code.

All other input is processed normally.
"""
#*****************************************************************************
#       Copyright (C) 2001-2006 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

</t>
<t tx="ekr.20071201085751.711"># This file is an example of how to modify IPython's line-processing behavior
# without touching the internal code. We'll define an alternate pre-processing
# stage which allows a special form of input (which is invalid Python syntax)
# for certain quantities, rewrites a line of proper Python in those cases, and
# then passes it off to IPython's normal processor for further work.

# With this kind of customization, IPython can be adapted for many
# special-purpose scenarios providing alternate input syntaxes.

# This file can be imported like a regular module.

# IPython has a prefilter() function that analyzes each input line. We redefine
# it here to first pre-process certain forms of input

# The prototype of any alternate prefilter must be like this one (the name
# doesn't matter):
# - line is a string containing the user input line.
# - continuation is a parameter which tells us if we are processing a first line of
#   user input or the second or higher of a multi-line statement.

def prefilter_paste(self,line,continuation):
    """Alternate prefilter for input of pasted code from an interpreter.
    """

    from re import match

    if match(r'^&gt;&gt;&gt; |^\.\.\. ',line):
        # In the end, always call the default IPython _prefilter() function.
        # Note that self must be passed explicitly, b/c we're calling the
        # unbound class method (since this method will overwrite the instance
        # prefilter())
        return self._prefilter(line[4:],continuation)
    elif line.strip() == '...':
        return self._prefilter('',continuation)
    else:
        return self._prefilter(line,continuation)
            
</t>
<t tx="ekr.20071201085751.712"># -*- coding: iso-8859-1 -*-

"""
``ipipe`` provides classes to be used in an interactive Python session. Doing a
``from ipipe import *`` is the preferred way to do this. The name of all
objects imported this way starts with ``i`` to minimize collisions.

``ipipe`` supports "pipeline expressions", which is something resembling Unix
pipes. An example is:

    &gt;&gt;&gt; ienv | isort("key.lower()")

This gives a listing of all environment variables sorted by name.


There are three types of objects in a pipeline expression:

* ``Table``s: These objects produce items. Examples are ``ils`` (listing the
  current directory, ``ienv`` (listing environment variables), ``ipwd`` (listing
  user accounts) and ``igrp`` (listing user groups). A ``Table`` must be the
  first object in a pipe expression.

* ``Pipe``s: These objects sit in the middle of a pipe expression. They
  transform the input in some way (e.g. filtering or sorting it). Examples are:
  ``ifilter`` (which filters the input pipe), ``isort`` (which sorts the input
  pipe) and ``ieval`` (which evaluates a function or expression for each object
  in the input pipe).

* ``Display``s: These objects can be put as the last object in a pipeline
  expression. There are responsible for displaying the result of the pipeline
  expression. If a pipeline expression doesn't end in a display object a default
  display objects will be used. One example is ``ibrowse`` which is a ``curses``
  based browser.


Adding support for pipeline expressions to your own objects can be done through
three extensions points (all of them optional):

* An object that will be displayed as a row by a ``Display`` object should
  implement the method ``__xattrs__(self, mode)`` method or register an
  implementation of the generic function ``xattrs``. For more info see ``xattrs``.

* When an object ``foo`` is displayed by a ``Display`` object, the generic
  function ``xrepr`` is used.

* Objects that can be iterated by ``Pipe``s must iterable. For special cases,
  where iteration for display is different than the normal iteration a special
  implementation can be registered with the generic function ``xiter``. This makes
  it possible to use dictionaries and modules in pipeline expressions, for example:

      &gt;&gt;&gt; import sys
      &gt;&gt;&gt; sys | ifilter("isinstance(value, int)") | idump
      key        |value
      api_version|      1012
      dllhandle  | 503316480
      hexversion |  33817328
      maxint     |2147483647
      maxunicode |     65535
      &gt;&gt;&gt; sys.modules | ifilter("_.value is not None") | isort("_.key.lower()")
      ...

  Note: The expression strings passed to ``ifilter()`` and ``isort()`` can
  refer to the object to be filtered or sorted via the variable ``_`` and to any
  of the attributes of the object, i.e.:

      &gt;&gt;&gt; sys.modules | ifilter("_.value is not None") | isort("_.key.lower()")

  does the same as

      &gt;&gt;&gt; sys.modules | ifilter("value is not None") | isort("key.lower()")

  In addition to expression strings, it's possible to pass callables (taking
  the object as an argument) to ``ifilter()``, ``isort()`` and ``ieval()``:

      &gt;&gt;&gt; sys | ifilter(lambda _:isinstance(_.value, int)) \
      ...     | ieval(lambda _: (_.key, hex(_.value))) | idump
      0          |1
      api_version|0x3f4
      dllhandle  |0x1e000000
      hexversion |0x20402f0
      maxint     |0x7fffffff
      maxunicode |0xffff
"""

import sys, os, os.path, stat, glob, new, csv, datetime, types
import itertools, mimetypes

try: # Python 2.3 compatibility
    import collections
except ImportError:
    deque = list
else:
    deque = collections.deque

try: # Python 2.3 compatibility
    set
except NameError:
    import sets
    set = sets.Set

try: # Python 2.3 compatibility
    sorted
except NameError:
    def sorted(iterator, key=None, reverse=False):
        items = list(iterator)
        if key is not None:
            items.sort(lambda i1, i2: cmp(key(i1), key(i2)))
        else:
            items.sort()
        if reverse:
            items.reverse()
        return items

try:
    import pwd
except ImportError:
    pwd = None

try:
    import grp
except ImportError:
    grp = None

from IPython.external import simplegeneric

import path
try:
    from IPython import genutils, ipapi
except ImportError:
    genutils = None
    ipapi = None

import astyle


__all__ = [
    "ifile", "ils", "iglob", "iwalk", "ipwdentry", "ipwd", "igrpentry", "igrp",
    "icsv", "ix", "ichain", "isort", "ifilter", "ieval", "ienum", "ienv",
    "idump", "iless"
]


os.stat_float_times(True) # enable microseconds


</t>
<t tx="ekr.20071201085751.713">class AttrNamespace(object):
    """
    Helper class that is used for providing a namespace for evaluating
    expressions containing attribute names of an object.
    """
    @others
</t>
<t tx="ekr.20071201085751.714">def __init__(self, wrapped):
    self.wrapped = wrapped

</t>
<t tx="ekr.20071201085751.715">def __getitem__(self, name):
    if name == "_":
        return self.wrapped
    try:
        return getattr(self.wrapped, name)
    except AttributeError:
        raise KeyError(name)

</t>
<t tx="ekr.20071201085751.716"># Python 2.3 compatibility
# use eval workaround to find out which names are used in the
# eval string and put them into the locals. This works for most
# normal uses case, bizarre ones like accessing the locals()
# will fail
try:
    eval("_", None, AttrNamespace(None))
except TypeError:
    real_eval = eval
    def eval(codestring, _globals, _locals):
        """
        eval(source[, globals[, locals]]) -&gt; value

        Evaluate the source in the context of globals and locals.
        The source may be a string representing a Python expression
        or a code object as returned by compile().
        The globals must be a dictionary and locals can be any mappping.

        This function is a workaround for the shortcomings of
        Python 2.3's eval.
        """

        if isinstance(codestring, basestring):
            code = compile(codestring, "_eval", "eval")
        else:
            code = codestring
        newlocals = {}
        for name in code.co_names:
            try:
                newlocals[name] = _locals[name]
            except KeyError:
                pass
        return real_eval(code, _globals, newlocals)


noitem = object()

def item(iterator, index, default=noitem):
    """
    Return the ``index``th item from the iterator ``iterator``.
    ``index`` must be an integer (negative integers are relative to the
    end (i.e. the last items produced by the iterator)).

    If ``default`` is given, this will be the default value when
    the iterator doesn't contain an item at this position. Otherwise an
    ``IndexError`` will be raised.

    Note that using this function will partially or totally exhaust the
    iterator.
    """
    i = index
    if i&gt;=0:
        for item in iterator:
            if not i:
                return item
            i -= 1
    else:
        i = -index
        cache = deque()
        for item in iterator:
            cache.append(item)
            if len(cache)&gt;i:
                cache.popleft()
        if len(cache)==i:
            return cache.popleft()
    if default is noitem:
        raise IndexError(index)
    else:
        return default


</t>
<t tx="ekr.20071201085751.717">def getglobals(g):
    """
    Return the global namespace that is used for expression strings in
    ``ifilter`` and others. This is ``g`` or (if ``g`` is ``None``) IPython's
    user namespace.
    """
    if g is None:
        if ipapi is not None:
            api = ipapi.get()
            if api is not None:
                return api.user_ns
        return globals()
    return g


</t>
<t tx="ekr.20071201085751.718">class Descriptor(object):
    """
    A ``Descriptor`` object is used for describing the attributes of objects.
    """
    @others
</t>
<t tx="ekr.20071201085751.719">def __hash__(self):
    return hash(self.__class__) ^ hash(self.key())

</t>
<t tx="ekr.20071201085751.720">def __eq__(self, other):
    return self.__class__ is other.__class__ and self.key() == other.key()

</t>
<t tx="ekr.20071201085751.721">def __ne__(self, other):
    return self.__class__ is not other.__class__ or self.key() != other.key()

</t>
<t tx="ekr.20071201085751.722">def key(self):
    pass

</t>
<t tx="ekr.20071201085751.723">def name(self):
    """
    Return the name of this attribute for display by a ``Display`` object
    (e.g. as a column title).
    """
    key = self.key()
    if key is None:
        return "_"
    return str(key)

</t>
<t tx="ekr.20071201085751.724">def attrtype(self, obj):
    """
    Return the type of this attribute (i.e. something like "attribute" or
    "method").
    """

</t>
<t tx="ekr.20071201085751.725">def valuetype(self, obj):
    """
    Return the type of this attribute value of the object ``obj``.
    """

</t>
<t tx="ekr.20071201085751.726">def value(self, obj):
    """
    Return the value of this attribute of the object ``obj``.
    """

</t>
<t tx="ekr.20071201085751.727">def doc(self, obj):
    """
    Return the documentation for this attribute.
    """

</t>
<t tx="ekr.20071201085751.728">def shortdoc(self, obj):
    """
    Return a short documentation for this attribute (defaulting to the
    first line).
    """
    doc = self.doc(obj)
    if doc is not None:
        doc = doc.strip().splitlines()[0].strip()
    return doc

</t>
<t tx="ekr.20071201085751.729">def iter(self, obj):
    """
    Return an iterator for this attribute of the object ``obj``.
    """
    return xiter(self.value(obj))


</t>
<t tx="ekr.20071201085751.730">class SelfDescriptor(Descriptor):
    """
    A ``SelfDescriptor`` describes the object itself.
    """
    @others
</t>
<t tx="ekr.20071201085751.731">def key(self):
    return None

</t>
<t tx="ekr.20071201085751.732">def attrtype(self, obj):
    return "self"

</t>
<t tx="ekr.20071201085751.733">def valuetype(self, obj):
    return type(obj)

</t>
<t tx="ekr.20071201085751.734">def value(self, obj):
    return obj

</t>
<t tx="ekr.20071201085751.735">def __repr__(self):
    return "Self"

</t>
<t tx="ekr.20071201085751.736">selfdescriptor = SelfDescriptor() # there's no need for more than one


class AttributeDescriptor(Descriptor):
    """
    An ``AttributeDescriptor`` describes a simple attribute of an object.
    """
    __slots__ = ("_name", "_doc")

    @others
</t>
<t tx="ekr.20071201085751.737">def __init__(self, name, doc=None):
    self._name = name
    self._doc = doc

</t>
<t tx="ekr.20071201085751.738">def key(self):
    return self._name

</t>
<t tx="ekr.20071201085751.739">def doc(self, obj):
    return self._doc

</t>
<t tx="ekr.20071201085751.740">def attrtype(self, obj):
    return "attr"

</t>
<t tx="ekr.20071201085751.741">def valuetype(self, obj):
    return type(getattr(obj, self._name))

</t>
<t tx="ekr.20071201085751.742">def value(self, obj):
    return getattr(obj, self._name)

</t>
<t tx="ekr.20071201085751.743">def __repr__(self):
    if self._doc is None:
        return "Attribute(%r)" % self._name
    else:
        return "Attribute(%r, %r)" % (self._name, self._doc)


</t>
<t tx="ekr.20071201085751.744">class IndexDescriptor(Descriptor):
    """
    An ``IndexDescriptor`` describes an "attribute" of an object that is fetched
    via ``__getitem__``.
    """
    __slots__ = ("_index",)

    @others
</t>
<t tx="ekr.20071201085751.745">def __init__(self, index):
    self._index = index

</t>
<t tx="ekr.20071201085751.746">def key(self):
    return self._index

</t>
<t tx="ekr.20071201085751.747">def attrtype(self, obj):
    return "item"

</t>
<t tx="ekr.20071201085751.748">def valuetype(self, obj):
    return type(obj[self._index])

</t>
<t tx="ekr.20071201085751.749">def value(self, obj):
    return obj[self._index]

</t>
<t tx="ekr.20071201085751.750">def __repr__(self):
    return "Index(%r)" % self._index


</t>
<t tx="ekr.20071201085751.751">class MethodDescriptor(Descriptor):
    """
    A ``MethodDescriptor`` describes a method of an object that can be called
    without argument. Note that this method shouldn't change the object.
    """
    __slots__ = ("_name", "_doc")

    @others
</t>
<t tx="ekr.20071201085751.752">def __init__(self, name, doc=None):
    self._name = name
    self._doc = doc

</t>
<t tx="ekr.20071201085751.753">def key(self):
    return self._name

</t>
<t tx="ekr.20071201085751.754">def doc(self, obj):
    if self._doc is None:
        return getattr(obj, self._name).__doc__
    return self._doc

</t>
<t tx="ekr.20071201085751.755">def attrtype(self, obj):
    return "method"

</t>
<t tx="ekr.20071201085751.756">def valuetype(self, obj):
    return type(self.value(obj))

</t>
<t tx="ekr.20071201085751.757">def value(self, obj):
    return getattr(obj, self._name)()

</t>
<t tx="ekr.20071201085751.758">def __repr__(self):
    if self._doc is None:
        return "Method(%r)" % self._name
    else:
        return "Method(%r, %r)" % (self._name, self._doc)


</t>
<t tx="ekr.20071201085751.759">class IterAttributeDescriptor(Descriptor):
    """
    An ``IterAttributeDescriptor`` works like an ``AttributeDescriptor`` but
    doesn't return an attribute values (because this value might be e.g. a large
    list).
    """
    __slots__ = ("_name", "_doc")

    @others
</t>
<t tx="ekr.20071201085751.760">def __init__(self, name, doc=None):
    self._name = name
    self._doc = doc

</t>
<t tx="ekr.20071201085751.761">def key(self):
    return self._name

</t>
<t tx="ekr.20071201085751.762">def doc(self, obj):
    return self._doc

</t>
<t tx="ekr.20071201085751.763">def attrtype(self, obj):
    return "iter"

</t>
<t tx="ekr.20071201085751.764">def valuetype(self, obj):
    return noitem

</t>
<t tx="ekr.20071201085751.765">def value(self, obj):
    return noitem

</t>
<t tx="ekr.20071201085751.766">def iter(self, obj):
    return xiter(getattr(obj, self._name))

</t>
<t tx="ekr.20071201085751.767">def __repr__(self):
    if self._doc is None:
        return "IterAttribute(%r)" % self._name
    else:
        return "IterAttribute(%r, %r)" % (self._name, self._doc)


</t>
<t tx="ekr.20071201085751.768">class IterMethodDescriptor(Descriptor):
    """
    An ``IterMethodDescriptor`` works like an ``MethodDescriptor`` but doesn't
    return an attribute values (because this value might be e.g. a large list).
    """
    __slots__ = ("_name", "_doc")

    @others
</t>
<t tx="ekr.20071201085751.769">def __init__(self, name, doc=None):
    self._name = name
    self._doc = doc

</t>
<t tx="ekr.20071201085751.770">def key(self):
    return self._name

</t>
<t tx="ekr.20071201085751.771">def doc(self, obj):
    if self._doc is None:
        return getattr(obj, self._name).__doc__
    return self._doc

</t>
<t tx="ekr.20071201085751.772">def attrtype(self, obj):
    return "itermethod"

</t>
<t tx="ekr.20071201085751.773">def valuetype(self, obj):
    return noitem

</t>
<t tx="ekr.20071201085751.774">def value(self, obj):
    return noitem

</t>
<t tx="ekr.20071201085751.775">def iter(self, obj):
    return xiter(getattr(obj, self._name)())

</t>
<t tx="ekr.20071201085751.776">def __repr__(self):
    if self._doc is None:
        return "IterMethod(%r)" % self._name
    else:
        return "IterMethod(%r, %r)" % (self._name, self._doc)


</t>
<t tx="ekr.20071201085751.777">class FunctionDescriptor(Descriptor):
    """
    A ``FunctionDescriptor`` turns a function into a descriptor. The function
    will be called with the object to get the type and value of the attribute.
    """
    __slots__ = ("_function", "_name", "_doc")

    @others
</t>
<t tx="ekr.20071201085751.778">def __init__(self, function, name=None, doc=None):
    self._function = function
    self._name = name
    self._doc = doc

</t>
<t tx="ekr.20071201085751.779">def key(self):
    return self._function

</t>
<t tx="ekr.20071201085751.780">def name(self):
    if self._name is not None:
        return self._name
    return getattr(self._function, "__xname__", self._function.__name__)

</t>
<t tx="ekr.20071201085751.781">def doc(self, obj):
    if self._doc is None:
        return self._function.__doc__
    return self._doc

</t>
<t tx="ekr.20071201085751.782">def attrtype(self, obj):
    return "function"

</t>
<t tx="ekr.20071201085751.783">def valuetype(self, obj):
    return type(self._function(obj))

</t>
<t tx="ekr.20071201085751.784">def value(self, obj):
    return self._function(obj)

</t>
<t tx="ekr.20071201085751.785">def __repr__(self):
    if self._doc is None:
        return "Function(%r)" % self._name
    else:
        return "Function(%r, %r)" % (self._name, self._doc)


</t>
<t tx="ekr.20071201085751.786">class Table(object):
    """
    A ``Table`` is an object that produces items (just like a normal Python
    iterator/generator does) and can be used as the first object in a pipeline
    expression. The displayhook will open the default browser for such an object
    (instead of simply printing the ``repr()`` result).
    """
    @others
</t>
<t tx="ekr.20071201085751.787">
# We want to support ``foo`` and ``foo()`` in pipeline expression:
# So we implement the required operators (``|`` and ``+``) in the metaclass,
# instantiate the class and forward the operator to the instance
class __metaclass__(type):
    @others
</t>
<t tx="ekr.20071201085751.788">def __iter__(self):
    return iter(self())

</t>
<t tx="ekr.20071201085751.789">def __or__(self, other):
    return self() | other

</t>
<t tx="ekr.20071201085751.790">def __add__(self, other):
    return self() + other

</t>
<t tx="ekr.20071201085751.791">def __radd__(self, other):
    return other + self()

</t>
<t tx="ekr.20071201085751.792">def __getitem__(self, index):
    return self()[index]

</t>
<t tx="ekr.20071201085751.793">def __getitem__(self, index):
    return item(self, index)

</t>
<t tx="ekr.20071201085751.794">def __contains__(self, item):
    for haveitem in self:
        if item == haveitem:
            return True
    return False

</t>
<t tx="ekr.20071201085751.795">def __or__(self, other):
    # autoinstantiate right hand side
    if isinstance(other, type) and issubclass(other, (Table, Display)):
        other = other()
    # treat simple strings and functions as ``ieval`` instances
    elif not isinstance(other, Display) and not isinstance(other, Table):
        other = ieval(other)
    # forward operations to the right hand side
    return other.__ror__(self)

</t>
<t tx="ekr.20071201085751.796">def __add__(self, other):
    # autoinstantiate right hand side
    if isinstance(other, type) and issubclass(other, Table):
        other = other()
    return ichain(self, other)

</t>
<t tx="ekr.20071201085751.797">def __radd__(self, other):
    # autoinstantiate left hand side
    if isinstance(other, type) and issubclass(other, Table):
        other = other()
    return ichain(other, self)


</t>
<t tx="ekr.20071201085751.798">class Pipe(Table):
    """
    A ``Pipe`` is an object that can be used in a pipeline expression. It
    processes the objects it gets from its input ``Table``/``Pipe``. Note that
    a ``Pipe`` object can't be used as the first object in a pipeline
    expression, as it doesn't produces items itself.
    """
    @others
</t>
<t tx="ekr.20071201085751.799">class __metaclass__(Table.__metaclass__):
    @others
</t>
<t tx="ekr.20071201085751.800">def __ror__(self, input):
    return input | self()

</t>
<t tx="ekr.20071201085751.801">def __ror__(self, input):
    # autoinstantiate left hand side
    if isinstance(input, type) and issubclass(input, Table):
        input = input()
    self.input = input
    return self


</t>
<t tx="ekr.20071201085751.802">def xrepr(item, mode="default"):
    """
    Generic function that adds color output and different display modes to ``repr``.

    The result of an ``xrepr`` call is iterable and consists of ``(style, string)``
    tuples. The ``style`` in this tuple must be a ``Style`` object from the
    ``astring`` module. To reconfigure the output the first yielded tuple can be
    a ``(aligment, full)`` tuple instead of a ``(style, string)`` tuple.
    ``alignment``  can be -1 for left aligned, 0 for centered and 1 for right
    aligned (the default is left alignment). ``full`` is a boolean that specifies
    whether the complete output must be displayed or the ``Display`` object is
    allowed to stop output after enough text has been produced (e.g. a syntax
    highlighted text line would use ``True``, but for a large data structure
    (i.e. a nested list, tuple or dictionary) ``False`` would be used).
    The default is full output.

    There are four different possible values for ``mode`` depending on where
    the ``Display`` object will display ``item``:

    * ``"header"``: ``item`` will be displayed in a header line (this is used by
      ``ibrowse``).
    * ``"footer"``: ``item`` will be displayed in a footer line (this is used by
      ``ibrowse``).
    * ``"cell"``: ``item`` will be displayed in a table cell/list.
    * ``"default"``: default mode. If an ``xrepr`` implementation recursively
      outputs objects, ``"default"`` must be passed in the recursive calls to
      ``xrepr``.

    If no implementation is registered for ``item``, ``xrepr`` will try the
    ``__xrepr__`` method on ``item``. If ``item`` doesn't have an ``__xrepr__``
    method it falls back to ``repr``/``__repr__`` for all modes.
    """
    try:
        func = item.__xrepr__
    except AttributeError:
        yield (astyle.style_default, repr(item))
    else:
        try:
            for x in func(mode):
                yield x
        except (KeyboardInterrupt, SystemExit):
            raise
        except Exception:
            yield (astyle.style_default, repr(item))
</t>
<t tx="ekr.20071201085751.803">xrepr = simplegeneric.generic(xrepr)


def xrepr_none(self, mode="default"):
    yield (astyle.style_type_none, repr(self))
</t>
<t tx="ekr.20071201085751.804">xrepr.when_object(None)(xrepr_none)


def xrepr_bool(self, mode="default"):
    yield (astyle.style_type_bool, repr(self))
</t>
<t tx="ekr.20071201085751.805">xrepr.when_type(bool)(xrepr_bool)


def xrepr_str(self, mode="default"):
    if mode == "cell":
        yield (astyle.style_default, repr(self.expandtabs(tab))[1:-1])
    else:
        yield (astyle.style_default, repr(self))
</t>
<t tx="ekr.20071201085751.806">xrepr.when_type(str)(xrepr_str)


def xrepr_unicode(self, mode="default"):
    if mode == "cell":
        yield (astyle.style_default, repr(self.expandtabs(tab))[2:-1])
    else:
        yield (astyle.style_default, repr(self))
</t>
<t tx="ekr.20071201085751.807">xrepr.when_type(unicode)(xrepr_unicode)


def xrepr_number(self, mode="default"):
    yield (1, True)
    yield (astyle.style_type_number, repr(self))
</t>
<t tx="ekr.20071201085751.808">xrepr.when_type(int)(xrepr_number)
xrepr.when_type(long)(xrepr_number)
xrepr.when_type(float)(xrepr_number)


def xrepr_complex(self, mode="default"):
    yield (astyle.style_type_number, repr(self))
</t>
<t tx="ekr.20071201085751.809">xrepr.when_type(complex)(xrepr_number)


def xrepr_datetime(self, mode="default"):
    if mode == "cell":
        # Don't use strftime() here, as this requires year &gt;= 1900
        yield (astyle.style_type_datetime,
               "%04d-%02d-%02d %02d:%02d:%02d.%06d" % \
                    (self.year, self.month, self.day,
                     self.hour, self.minute, self.second,
                     self.microsecond),
                )
    else:
        yield (astyle.style_type_datetime, repr(self))
</t>
<t tx="ekr.20071201085751.810">xrepr.when_type(datetime.datetime)(xrepr_datetime)


def xrepr_date(self, mode="default"):
    if mode == "cell":
        yield (astyle.style_type_datetime,
               "%04d-%02d-%02d" % (self.year, self.month, self.day))
    else:
        yield (astyle.style_type_datetime, repr(self))
</t>
<t tx="ekr.20071201085751.811">xrepr.when_type(datetime.date)(xrepr_date)


def xrepr_time(self, mode="default"):
    if mode == "cell":
        yield (astyle.style_type_datetime,
                "%02d:%02d:%02d.%06d" % \
                    (self.hour, self.minute, self.second, self.microsecond))
    else:
        yield (astyle.style_type_datetime, repr(self))
</t>
<t tx="ekr.20071201085751.812">xrepr.when_type(datetime.time)(xrepr_time)


def xrepr_timedelta(self, mode="default"):
    yield (astyle.style_type_datetime, repr(self))
</t>
<t tx="ekr.20071201085751.813">xrepr.when_type(datetime.timedelta)(xrepr_timedelta)


def xrepr_type(self, mode="default"):
    if self.__module__ == "__builtin__":
        yield (astyle.style_type_type, self.__name__)
    else:
        yield (astyle.style_type_type, "%s.%s" % (self.__module__, self.__name__))
</t>
<t tx="ekr.20071201085751.814">xrepr.when_type(type)(xrepr_type)


def xrepr_exception(self, mode="default"):
    if self.__class__.__module__ == "exceptions":
        classname = self.__class__.__name__
    else:
        classname = "%s.%s" % \
            (self.__class__.__module__, self.__class__.__name__)
    if mode == "header" or mode == "footer":
        yield (astyle.style_error, "%s: %s" % (classname, self))
    else:
        yield (astyle.style_error, classname)
</t>
<t tx="ekr.20071201085751.815">xrepr.when_type(Exception)(xrepr_exception)


def xrepr_listtuple(self, mode="default"):
    if mode == "header" or mode == "footer":
        if self.__class__.__module__ == "__builtin__":
            classname = self.__class__.__name__
        else:
            classname = "%s.%s" % \
                (self.__class__.__module__,self.__class__.__name__)
        yield (astyle.style_default,
               "&lt;%s object with %d items at 0x%x&gt;" % \
                   (classname, len(self), id(self)))
    else:
        yield (-1, False)
        if isinstance(self, list):
            yield (astyle.style_default, "[")
            end = "]"
        else:
            yield (astyle.style_default, "(")
            end = ")"
        for (i, subself) in enumerate(self):
            if i:
                yield (astyle.style_default, ", ")
            for part in xrepr(subself, "default"):
                yield part
        yield (astyle.style_default, end)
</t>
<t tx="ekr.20071201085751.816">xrepr.when_type(list)(xrepr_listtuple)
xrepr.when_type(tuple)(xrepr_listtuple)


def xrepr_dict(self, mode="default"):
    if mode == "header" or mode == "footer":
        if self.__class__.__module__ == "__builtin__":
            classname = self.__class__.__name__
        else:
            classname = "%s.%s" % \
                (self.__class__.__module__,self.__class__.__name__)
        yield (astyle.style_default,
               "&lt;%s object with %d items at 0x%x&gt;" % \
                (classname, len(self), id(self)))
    else:
        yield (-1, False)
        if isinstance(self, dict):
            yield (astyle.style_default, "{")
            end = "}"
        else:
            yield (astyle.style_default, "dictproxy((")
            end = "})"
        for (i, (key, value)) in enumerate(self.iteritems()):
            if i:
                yield (astyle.style_default, ", ")
            for part in xrepr(key, "default"):
                yield part
            yield (astyle.style_default, ": ")
            for part in xrepr(value, "default"):
                yield part
        yield (astyle.style_default, end)
</t>
<t tx="ekr.20071201085751.817">xrepr.when_type(dict)(xrepr_dict)
xrepr.when_type(types.DictProxyType)(xrepr_dict)


def upgradexattr(attr):
    """
    Convert an attribute descriptor string to a real descriptor object.

    If attr already is a descriptor object return if unmodified. A
    ``SelfDescriptor`` will be returned if ``attr`` is ``None``. ``"foo"``
    returns an ``AttributeDescriptor`` for the attribute named ``"foo"``.
    ``"foo()"`` returns a ``MethodDescriptor`` for the method named ``"foo"``.
    ``"-foo"`` will return an ``IterAttributeDescriptor`` for the attribute
    named ``"foo"`` and ``"-foo()"`` will return an ``IterMethodDescriptor``
    for the method named ``"foo"``. Furthermore integer will return the appropriate
    ``IndexDescriptor`` and callables will return a ``FunctionDescriptor``.
    """
    if attr is None:
        return selfdescriptor
    elif isinstance(attr, Descriptor):
        return attr
    elif isinstance(attr, str):
        if attr.endswith("()"):
            if attr.startswith("-"):
                return IterMethodDescriptor(attr[1:-2])
            else:
                return MethodDescriptor(attr[:-2])
        else:
            if attr.startswith("-"):
                return IterAttributeDescriptor(attr[1:])
            else:
                return AttributeDescriptor(attr)
    elif isinstance(attr, (int, long)):
        return IndexDescriptor(attr)
    elif callable(attr):
        return FunctionDescriptor(attr)
    else:
        raise TypeError("can't handle descriptor %r" % attr)


</t>
<t tx="ekr.20071201085751.818">def xattrs(item, mode="default"):
    """
    Generic function that returns an iterable of attribute descriptors
    to be used for displaying the attributes ob the object ``item`` in display
    mode ``mode``.

    There are two possible modes:

    * ``"detail"``: The ``Display`` object wants to display a detailed list
      of the object attributes.
    * ``"default"``: The ``Display`` object wants to display the object in a
      list view.

    If no implementation is registered for the object ``item`` ``xattrs`` falls
    back to trying the ``__xattrs__`` method of the object. If this doesn't
    exist either, ``dir(item)`` is used for ``"detail"`` mode and ``(None,)``
    for ``"default"`` mode.

    The implementation must yield attribute descriptor (see the class
    ``Descriptor`` for more info). The ``__xattrs__`` method may also return
    attribute descriptor string (and ``None``) which will be converted to real
    descriptors by ``upgradexattr()``.
    """
    try:
        func = item.__xattrs__
    except AttributeError:
        if mode == "detail":
            for attrname in dir(item):
                yield AttributeDescriptor(attrname)
        else:
            yield selfdescriptor
    else:
        for attr in func(mode):
            yield upgradexattr(attr)
</t>
<t tx="ekr.20071201085751.819">xattrs = simplegeneric.generic(xattrs)


def xattrs_complex(self, mode="default"):
    if mode == "detail":
        return (AttributeDescriptor("real"), AttributeDescriptor("imag"))
    return (selfdescriptor,)
</t>
<t tx="ekr.20071201085751.820">xattrs.when_type(complex)(xattrs_complex)


def _isdict(item):
    try:
        itermeth = item.__class__.__iter__
    except (AttributeError, TypeError):
        return False
    return itermeth is dict.__iter__ or itermeth is types.DictProxyType.__iter__


</t>
<t tx="ekr.20071201085751.821">def _isstr(item):
    if not isinstance(item, basestring):
        return False
    try:
        itermeth = item.__class__.__iter__
    except AttributeError:
        return True
    return False # ``__iter__`` has been redefined


</t>
<t tx="ekr.20071201085751.822">def xiter(item):
    """
    Generic function that implements iteration for pipeline expression. If no
    implementation is registered for ``item`` ``xiter`` falls back to ``iter``.
    """
    try:
        func = item.__xiter__
    except AttributeError:
        if _isdict(item):
            def items(item):
                fields = ("key", "value")
                for (key, value) in item.iteritems():
                    yield Fields(fields, key=key, value=value)
            return items(item)
        elif isinstance(item, new.module):
            def items(item):
                fields = ("key", "value")
                for key in sorted(item.__dict__):
                    yield Fields(fields, key=key, value=getattr(item, key))
            return items(item)
        elif _isstr(item):
            if not item:
                raise ValueError("can't enter empty string")
            return iter(item.splitlines())
        return iter(item)
    else:
        return iter(func()) # iter() just to be safe
</t>
<t tx="ekr.20071201085751.823">xiter = simplegeneric.generic(xiter)


class ichain(Pipe):
    """
    Chains multiple ``Table``s into one.
    """
    @others
</t>
<t tx="ekr.20071201085751.824">
def __init__(self, *iters):
    self.iters = iters

</t>
<t tx="ekr.20071201085751.825">def __iter__(self):
    return itertools.chain(*self.iters)

</t>
<t tx="ekr.20071201085751.826">def __xrepr__(self, mode="default"):
    if mode == "header" or mode == "footer":
        for (i, item) in enumerate(self.iters):
            if i:
                yield (astyle.style_default, "+")
            if isinstance(item, Pipe):
                yield (astyle.style_default, "(")
            for part in xrepr(item, mode):
                yield part
            if isinstance(item, Pipe):
                yield (astyle.style_default, ")")
    else:
        yield (astyle.style_default, repr(self))

</t>
<t tx="ekr.20071201085751.827">def __repr__(self):
    args = ", ".join([repr(it) for it in self.iters])
    return "%s.%s(%s)" % \
        (self.__class__.__module__, self.__class__.__name__, args)


</t>
<t tx="ekr.20071201085751.828">class ifile(path.path):
    """
    file (or directory) object.
    """
    @others
</t>
<t tx="ekr.20071201085751.829">
def getmode(self):
    return self.stat().st_mode
</t>
<t tx="ekr.20071201085751.830">mode = property(getmode, None, None, "Access mode")

def gettype(self):
    data = [
        (stat.S_ISREG, "file"),
        (stat.S_ISDIR, "dir"),
        (stat.S_ISCHR, "chardev"),
        (stat.S_ISBLK, "blockdev"),
        (stat.S_ISFIFO, "fifo"),
        (stat.S_ISLNK, "symlink"),
        (stat.S_ISSOCK,"socket"),
    ]
    lstat = self.lstat()
    if lstat is not None:
        types = set([text for (func, text) in data if func(lstat.st_mode)])
    else:
        types = set()
    m = self.mode
    types.update([text for (func, text) in data if func(m)])
    return ", ".join(types)
</t>
<t tx="ekr.20071201085751.831">type = property(gettype, None, None, "file type (file, directory, link, etc.)")

def getmodestr(self):
    m = self.mode
    data = [
        (stat.S_IRUSR, "-r"),
        (stat.S_IWUSR, "-w"),
        (stat.S_IXUSR, "-x"),
        (stat.S_IRGRP, "-r"),
        (stat.S_IWGRP, "-w"),
        (stat.S_IXGRP, "-x"),
        (stat.S_IROTH, "-r"),
        (stat.S_IWOTH, "-w"),
        (stat.S_IXOTH, "-x"),
    ]
    return "".join([text[bool(m&amp;bit)] for (bit, text) in data])

</t>
<t tx="ekr.20071201085751.832">modestr = property(getmodestr, None, None, "Access mode as string")

def getblocks(self):
    return self.stat().st_blocks
</t>
<t tx="ekr.20071201085751.833">blocks = property(getblocks, None, None, "File size in blocks")

def getblksize(self):
    return self.stat().st_blksize
</t>
<t tx="ekr.20071201085751.834">blksize = property(getblksize, None, None, "Filesystem block size")

def getdev(self):
    return self.stat().st_dev
</t>
<t tx="ekr.20071201085751.835">dev = property(getdev)

def getnlink(self):
    return self.stat().st_nlink
</t>
<t tx="ekr.20071201085751.836">nlink = property(getnlink, None, None, "Number of links")

def getuid(self):
    return self.stat().st_uid
</t>
<t tx="ekr.20071201085751.837">uid = property(getuid, None, None, "User id of file owner")

def getgid(self):
    return self.stat().st_gid
</t>
<t tx="ekr.20071201085751.838">gid = property(getgid, None, None, "Group id of file owner")

def getowner(self):
    stat = self.stat()
    try:
        return pwd.getpwuid(stat.st_uid).pw_name
    except KeyError:
        return stat.st_uid
</t>
<t tx="ekr.20071201085751.839">owner = property(getowner, None, None, "Owner name (or id)")

def getgroup(self):
    stat = self.stat()
    try:
        return grp.getgrgid(stat.st_gid).gr_name
    except KeyError:
        return stat.st_gid
</t>
<t tx="ekr.20071201085751.840">group = property(getgroup, None, None, "Group name (or id)")

def getadate(self):
    return datetime.datetime.utcfromtimestamp(self.atime)
</t>
<t tx="ekr.20071201085751.841">adate = property(getadate, None, None, "Access date")

def getcdate(self):
    return datetime.datetime.utcfromtimestamp(self.ctime)
</t>
<t tx="ekr.20071201085751.842">cdate = property(getcdate, None, None, "Creation date")

def getmdate(self):
    return datetime.datetime.utcfromtimestamp(self.mtime)
</t>
<t tx="ekr.20071201085751.843">mdate = property(getmdate, None, None, "Modification date")

def mimetype(self):
    """
    Return MIME type guessed from the extension.
    """
    return mimetypes.guess_type(self.basename())[0]

</t>
<t tx="ekr.20071201085751.844">def encoding(self):
    """
    Return guessed compression (like "compress" or "gzip").
    """
    return mimetypes.guess_type(self.basename())[1]

</t>
<t tx="ekr.20071201085751.845">def __repr__(self):
    return "ifile(%s)" % path._base.__repr__(self)

</t>
<t tx="ekr.20071201085751.846">if sys.platform == "win32":
    defaultattrs = (None, "type", "size", "modestr", "mdate")
else:
    defaultattrs = (None, "type", "size", "modestr", "owner", "group", "mdate")

def __xattrs__(self, mode="default"):
    if mode == "detail":
        return (
            "name",
            "basename()",
            "abspath()",
            "realpath()",
            "type",
            "mode",
            "modestr",
            "stat()",
            "lstat()",
            "uid",
            "gid",
            "owner",
            "group",
            "dev",
            "nlink",
            "ctime",
            "mtime",
            "atime",
            "cdate",
            "mdate",
            "adate",
            "size",
            "blocks",
            "blksize",
            "isdir()",
            "islink()",
            "mimetype()",
            "encoding()",
            "-listdir()",
            "-dirs()",
            "-files()",
            "-walk()",
            "-walkdirs()",
            "-walkfiles()",
        )
    else:
        return self.defaultattrs


</t>
<t tx="ekr.20071201085751.847">def xiter_ifile(self):
    if self.isdir():
        yield (self / os.pardir).abspath()
        for child in sorted(self.listdir()):
            yield child
    else:
        f = self.open("rb")
        for line in f:
            yield line
        f.close()
</t>
<t tx="ekr.20071201085751.848">xiter.when_type(ifile)(xiter_ifile)


# We need to implement ``xrepr`` for ``ifile`` as a generic function, because
# otherwise ``xrepr_str`` would kick in.
def xrepr_ifile(self, mode="default"):
    try:
        if self.isdir():
            name = "idir"
            style = astyle.style_dir
        else:
            name = "ifile"
            style = astyle.style_file
    except IOError:
        name = "ifile"
        style = astyle.style_default
    if mode == "cell" or mode in "header" or mode == "footer":
        abspath = repr(path._base(self.normpath()))
        if abspath.startswith("u"):
            abspath = abspath[2:-1]
        else:
            abspath = abspath[1:-1]
        if mode == "cell":
            yield (style, abspath)
        else:
            yield (style, "%s(%s)" % (name, abspath))
    else:
        yield (style, repr(self))
</t>
<t tx="ekr.20071201085751.849">xrepr.when_type(ifile)(xrepr_ifile)


class ils(Table):
    """
    List the current (or a specified) directory.

    Examples:

        &gt;&gt;&gt; ils
        &gt;&gt;&gt; ils("/usr/local/lib/python2.4")
        &gt;&gt;&gt; ils("~")
    """
    @others
</t>
<t tx="ekr.20071201085751.850">def __init__(self, base=os.curdir, dirs=True, files=True):
    self.base = os.path.expanduser(base)
    self.dirs = dirs
    self.files = files

</t>
<t tx="ekr.20071201085751.851">def __iter__(self):
    base = ifile(self.base)
    yield (base / os.pardir).abspath()
    for child in base.listdir():
        if self.dirs:
            if self.files:
                yield child
            else:
                if child.isdir():
                    yield child
        elif self.files:
            if not child.isdir():
                yield child

</t>
<t tx="ekr.20071201085751.852">def __xrepr__(self, mode="default"):
   return xrepr(ifile(self.base), mode)

</t>
<t tx="ekr.20071201085751.853">def __repr__(self):
    return "%s.%s(%r)" % \
        (self.__class__.__module__, self.__class__.__name__, self.base)


</t>
<t tx="ekr.20071201085751.854">class iglob(Table):
    """
    List all files and directories matching a specified pattern.
    (See ``glob.glob()`` for more info.).

    Examples:

        &gt;&gt;&gt; iglob("*.py")
    """
    @others
</t>
<t tx="ekr.20071201085751.855">def __init__(self, glob):
    self.glob = glob

</t>
<t tx="ekr.20071201085751.856">def __iter__(self):
    for name in glob.glob(self.glob):
        yield ifile(name)

</t>
<t tx="ekr.20071201085751.857">def __xrepr__(self, mode="default"):
    if mode == "header" or mode == "footer" or mode == "cell":
        yield (astyle.style_default,
               "%s(%r)" % (self.__class__.__name__, self.glob))
    else:
        yield (astyle.style_default, repr(self))

</t>
<t tx="ekr.20071201085751.858">def __repr__(self):
    return "%s.%s(%r)" % \
        (self.__class__.__module__, self.__class__.__name__, self.glob)


</t>
<t tx="ekr.20071201085751.859">class iwalk(Table):
    """
    List all files and directories in a directory and it's subdirectory.

        &gt;&gt;&gt; iwalk
        &gt;&gt;&gt; iwalk("/usr/local/lib/python2.4")
        &gt;&gt;&gt; iwalk("~")
    """
    @others
</t>
<t tx="ekr.20071201085751.860">def __init__(self, base=os.curdir, dirs=True, files=True):
    self.base = os.path.expanduser(base)
    self.dirs = dirs
    self.files = files

</t>
<t tx="ekr.20071201085751.861">def __iter__(self):
    for (dirpath, dirnames, filenames) in os.walk(self.base):
        if self.dirs:
            for name in sorted(dirnames):
                yield ifile(os.path.join(dirpath, name))
        if self.files:
            for name in sorted(filenames):
                yield ifile(os.path.join(dirpath, name))

</t>
<t tx="ekr.20071201085751.862">def __xrepr__(self, mode="default"):
    if mode == "header" or mode == "footer" or mode == "cell":
        yield (astyle.style_default,
               "%s(%r)" % (self.__class__.__name__, self.base))
    else:
        yield (astyle.style_default, repr(self))

</t>
<t tx="ekr.20071201085751.863">def __repr__(self):
    return "%s.%s(%r)" % \
        (self.__class__.__module__, self.__class__.__name__, self.base)


</t>
<t tx="ekr.20071201085751.864">class ipwdentry(object):
    """
    ``ipwdentry`` objects encapsulate entries in the Unix user account and
    password database.
    """
    @others
</t>
<t tx="ekr.20071201085751.865">def __init__(self, id):
    self._id = id
    self._entry = None

</t>
<t tx="ekr.20071201085751.866">def __eq__(self, other):
    return self.__class__ is other.__class__ and self._id == other._id

</t>
<t tx="ekr.20071201085751.867">def __ne__(self, other):
    return self.__class__ is not other.__class__ or self._id != other._id

</t>
<t tx="ekr.20071201085751.868">def _getentry(self):
    if self._entry is None:
        if isinstance(self._id, basestring):
            self._entry = pwd.getpwnam(self._id)
        else:
            self._entry = pwd.getpwuid(self._id)
    return self._entry

</t>
<t tx="ekr.20071201085751.869">def getname(self):
    if isinstance(self._id, basestring):
        return self._id
    else:
        return self._getentry().pw_name
</t>
<t tx="ekr.20071201085751.870">name = property(getname, None, None, "User name")

def getpasswd(self):
    return self._getentry().pw_passwd
</t>
<t tx="ekr.20071201085751.871">passwd = property(getpasswd, None, None, "Password")

def getuid(self):
    if isinstance(self._id, basestring):
        return self._getentry().pw_uid
    else:
        return self._id
</t>
<t tx="ekr.20071201085751.872">uid = property(getuid, None, None, "User id")

def getgid(self):
    return self._getentry().pw_gid
</t>
<t tx="ekr.20071201085751.873">gid = property(getgid, None, None, "Primary group id")

def getgroup(self):
    return igrpentry(self.gid)
</t>
<t tx="ekr.20071201085751.874">group = property(getgroup, None, None, "Group")

def getgecos(self):
    return self._getentry().pw_gecos
</t>
<t tx="ekr.20071201085751.875">gecos = property(getgecos, None, None, "Information (e.g. full user name)")

def getdir(self):
    return self._getentry().pw_dir
</t>
<t tx="ekr.20071201085751.876">dir = property(getdir, None, None, "$HOME directory")

def getshell(self):
    return self._getentry().pw_shell
</t>
<t tx="ekr.20071201085751.877">shell = property(getshell, None, None, "Login shell")

def __xattrs__(self, mode="default"):
   return ("name", "passwd", "uid", "gid", "gecos", "dir", "shell")

</t>
<t tx="ekr.20071201085751.878">def __repr__(self):
    return "%s.%s(%r)" % \
        (self.__class__.__module__, self.__class__.__name__, self._id)


</t>
<t tx="ekr.20071201085751.879">class ipwd(Table):
    """
    List all entries in the Unix user account and password database.

    Example:

        &gt;&gt;&gt; ipwd | isort("uid")
    """
    @others
</t>
<t tx="ekr.20071201085751.880">def __iter__(self):
    for entry in pwd.getpwall():
        yield ipwdentry(entry.pw_name)

</t>
<t tx="ekr.20071201085751.881">def __xrepr__(self, mode="default"):
    if mode == "header" or mode == "footer" or mode == "cell":
        yield (astyle.style_default, "%s()" % self.__class__.__name__)
    else:
        yield (astyle.style_default, repr(self))


</t>
<t tx="ekr.20071201085751.882">class igrpentry(object):
    """
    ``igrpentry`` objects encapsulate entries in the Unix group database.
    """
    @others
</t>
<t tx="ekr.20071201085751.883">def __init__(self, id):
    self._id = id
    self._entry = None

</t>
<t tx="ekr.20071201085751.884">def __eq__(self, other):
    return self.__class__ is other.__class__ and self._id == other._id

</t>
<t tx="ekr.20071201085751.885">def __ne__(self, other):
    return self.__class__ is not other.__class__ or self._id != other._id

</t>
<t tx="ekr.20071201085751.886">def _getentry(self):
    if self._entry is None:
        if isinstance(self._id, basestring):
            self._entry = grp.getgrnam(self._id)
        else:
            self._entry = grp.getgrgid(self._id)
    return self._entry

</t>
<t tx="ekr.20071201085751.887">def getname(self):
    if isinstance(self._id, basestring):
        return self._id
    else:
        return self._getentry().gr_name
</t>
<t tx="ekr.20071201085751.888">name = property(getname, None, None, "Group name")

def getpasswd(self):
    return self._getentry().gr_passwd
</t>
<t tx="ekr.20071201085751.889">passwd = property(getpasswd, None, None, "Password")

def getgid(self):
    if isinstance(self._id, basestring):
        return self._getentry().gr_gid
    else:
        return self._id
</t>
<t tx="ekr.20071201085751.890">gid = property(getgid, None, None, "Group id")

def getmem(self):
    return self._getentry().gr_mem
</t>
<t tx="ekr.20071201085751.891">mem = property(getmem, None, None, "Members")

def __xattrs__(self, mode="default"):
    return ("name", "passwd", "gid", "mem")

</t>
<t tx="ekr.20071201085751.892">def __xrepr__(self, mode="default"):
    if mode == "header" or mode == "footer" or mode == "cell":
        yield (astyle.style_default, "group ")
        try:
            yield (astyle.style_default, self.name)
        except KeyError:
            if isinstance(self._id, basestring):
                yield (astyle.style_default, self.name_id)
            else:
                yield (astyle.style_type_number, str(self._id))
    else:
        yield (astyle.style_default, repr(self))

</t>
<t tx="ekr.20071201085751.893">def __iter__(self):
    for member in self.mem:
        yield ipwdentry(member)

</t>
<t tx="ekr.20071201085751.894">def __repr__(self):
    return "%s.%s(%r)" % \
        (self.__class__.__module__, self.__class__.__name__, self._id)


</t>
<t tx="ekr.20071201085751.895">class igrp(Table):
    """
    This ``Table`` lists all entries in the Unix group database.
    """
    @others
</t>
<t tx="ekr.20071201085751.896">def __iter__(self):
    for entry in grp.getgrall():
        yield igrpentry(entry.gr_name)

</t>
<t tx="ekr.20071201085751.897">def __xrepr__(self, mode="default"):
    if mode == "header" or mode == "footer":
        yield (astyle.style_default, "%s()" % self.__class__.__name__)
    else:
        yield (astyle.style_default, repr(self))


</t>
<t tx="ekr.20071201085751.898">class Fields(object):
    @others
</t>
<t tx="ekr.20071201085751.899">def __init__(self, fieldnames, **fields):
    self.__fieldnames = [upgradexattr(fieldname) for fieldname in fieldnames]
    for (key, value) in fields.iteritems():
        setattr(self, key, value)

</t>
<t tx="ekr.20071201085751.900">def __xattrs__(self, mode="default"):
    return self.__fieldnames

</t>
<t tx="ekr.20071201085751.901">def __xrepr__(self, mode="default"):
    yield (-1, False)
    if mode == "header" or mode == "cell":
        yield (astyle.style_default, self.__class__.__name__)
        yield (astyle.style_default, "(")
        for (i, f) in enumerate(self.__fieldnames):
            if i:
                yield (astyle.style_default, ", ")
            yield (astyle.style_default, f.name())
            yield (astyle.style_default, "=")
            for part in xrepr(getattr(self, f), "default"):
                yield part
        yield (astyle.style_default, ")")
    elif mode == "footer":
        yield (astyle.style_default, self.__class__.__name__)
        yield (astyle.style_default, "(")
        for (i, f) in enumerate(self.__fieldnames):
            if i:
                yield (astyle.style_default, ", ")
            yield (astyle.style_default, f.name())
        yield (astyle.style_default, ")")
    else:
        yield (astyle.style_default, repr(self))


</t>
<t tx="ekr.20071201085751.902">class FieldTable(Table, list):
    @others
</t>
<t tx="ekr.20071201085751.903">def __init__(self, *fields):
    Table.__init__(self)
    list.__init__(self)
    self.fields = fields

</t>
<t tx="ekr.20071201085751.904">def add(self, **fields):
    self.append(Fields(self.fields, **fields))

</t>
<t tx="ekr.20071201085751.905">def __xrepr__(self, mode="default"):
    yield (-1, False)
    if mode == "header" or mode == "footer":
        yield (astyle.style_default, self.__class__.__name__)
        yield (astyle.style_default, "(")
        for (i, f) in enumerate(self.__fieldnames):
            if i:
                yield (astyle.style_default, ", ")
            yield (astyle.style_default, f)
        yield (astyle.style_default, ")")
    else:
        yield (astyle.style_default, repr(self))

</t>
<t tx="ekr.20071201085751.906">def __repr__(self):
    return "&lt;%s.%s object with fields=%r at 0x%x&gt;" % \
        (self.__class__.__module__, self.__class__.__name__,
         ", ".join(map(repr, self.fields)), id(self))


</t>
<t tx="ekr.20071201085751.907">class List(list):
    @others
</t>
<t tx="ekr.20071201085751.908">def __xattrs__(self, mode="default"):
    return xrange(len(self))

</t>
<t tx="ekr.20071201085751.909">def __xrepr__(self, mode="default"):
    yield (-1, False)
    if mode == "header" or mode == "cell" or mode == "footer" or mode == "default":
        yield (astyle.style_default, self.__class__.__name__)
        yield (astyle.style_default, "(")
        for (i, item) in enumerate(self):
            if i:
                yield (astyle.style_default, ", ")
            for part in xrepr(item, "default"):
                yield part
        yield (astyle.style_default, ")")
    else:
        yield (astyle.style_default, repr(self))


</t>
<t tx="ekr.20071201085751.910">class ienv(Table):
    """
    List environment variables.

    Example:

        &gt;&gt;&gt; ienv
    """
    @others
</t>
<t tx="ekr.20071201085751.911">
def __iter__(self):
    fields = ("key", "value")
    for (key, value) in os.environ.iteritems():
        yield Fields(fields, key=key, value=value)

</t>
<t tx="ekr.20071201085751.912">def __xrepr__(self, mode="default"):
    if mode == "header" or mode == "cell":
        yield (astyle.style_default, "%s()" % self.__class__.__name__)
    else:
        yield (astyle.style_default, repr(self))


</t>
<t tx="ekr.20071201085751.913">class icsv(Pipe):
    """
    This ``Pipe`` lists turn the input (with must be a pipe outputting lines
    or an ``ifile``) into lines of CVS columns.
    """
    @others
</t>
<t tx="ekr.20071201085751.914">def __init__(self, **csvargs):
    """
    Create an ``icsv`` object. ``cvsargs`` will be passed through as
    keyword arguments to ``cvs.reader()``.
    """
    self.csvargs = csvargs

</t>
<t tx="ekr.20071201085751.915">def __iter__(self):
    input = self.input
    if isinstance(input, ifile):
        input = input.open("rb")
    reader = csv.reader(input, **self.csvargs)
    for line in reader:
        yield List(line)

</t>
<t tx="ekr.20071201085751.916">def __xrepr__(self, mode="default"):
    yield (-1, False)
    if mode == "header" or mode == "footer":
        input = getattr(self, "input", None)
        if input is not None:
            for part in xrepr(input, mode):
                yield part
            yield (astyle.style_default, " | ")
        yield (astyle.style_default, "%s(" % self.__class__.__name__)
        for (i, (name, value)) in enumerate(self.csvargs.iteritems()):
            if i:
                yield (astyle.style_default, ", ")
            yield (astyle.style_default, name)
            yield (astyle.style_default, "=")
            for part in xrepr(value, "default"):
                yield part
        yield (astyle.style_default, ")")
    else:
        yield (astyle.style_default, repr(self))

</t>
<t tx="ekr.20071201085751.917">def __repr__(self):
    args = ", ".join(["%s=%r" % item for item in self.csvargs.iteritems()])
    return "&lt;%s.%s %s at 0x%x&gt;" % \
    (self.__class__.__module__, self.__class__.__name__, args, id(self))


</t>
<t tx="ekr.20071201085751.918">class ix(Table):
    """
    Execute a system command and list its output as lines
    (similar to ``os.popen()``).

    Examples:

        &gt;&gt;&gt; ix("ps x")
        &gt;&gt;&gt; ix("find .") | ifile
    """
    @others
</t>
<t tx="ekr.20071201085751.919">def __init__(self, cmd):
    self.cmd = cmd
    self._pipeout = None

</t>
<t tx="ekr.20071201085751.920">def __iter__(self):
    (_pipein, self._pipeout) = os.popen4(self.cmd)
    _pipein.close()
    for l in self._pipeout:
        yield l.rstrip("\r\n")
    self._pipeout.close()
    self._pipeout = None

</t>
<t tx="ekr.20071201085751.921">def __del__(self):
    if self._pipeout is not None and not self._pipeout.closed:
        self._pipeout.close()
    self._pipeout = None

</t>
<t tx="ekr.20071201085751.922">def __xrepr__(self, mode="default"):
    if mode == "header" or mode == "footer":
        yield (astyle.style_default,
               "%s(%r)" % (self.__class__.__name__, self.cmd))
    else:
        yield (astyle.style_default, repr(self))

</t>
<t tx="ekr.20071201085751.923">def __repr__(self):
    return "%s.%s(%r)" % \
        (self.__class__.__module__, self.__class__.__name__, self.cmd)


</t>
<t tx="ekr.20071201085751.924">class ifilter(Pipe):
    """
    Filter an input pipe. Only objects where an expression evaluates to true
    (and doesn't raise an exception) are listed.

    Examples:

        &gt;&gt;&gt; ils | ifilter("_.isfile() and size&gt;1000")
        &gt;&gt;&gt; igrp | ifilter("len(mem)")
        &gt;&gt;&gt; sys.modules | ifilter(lambda _:_.value is not None)
    """
    @others
</t>
<t tx="ekr.20071201085751.925">
def __init__(self, expr, globals=None, errors="raiseifallfail"):
    """
    Create an ``ifilter`` object. ``expr`` can be a callable or a string
    containing an expression. ``globals`` will be used as the global
    namespace for calling string expressions (defaulting to IPython's
    user namespace). ``errors`` specifies how exception during evaluation
    of ``expr`` are handled:

    * ``drop``: drop all items that have errors;

    * ``keep``: keep all items that have errors;

    * ``keeperror``: keep the exception of all items that have errors;

    * ``raise``: raise the exception;

    * ``raiseifallfail``: raise the first exception if all items have errors;
      otherwise drop those with errors (this is the default).
    """
    self.expr = expr
    self.globals = globals
    self.errors = errors

</t>
<t tx="ekr.20071201085751.926">def __iter__(self):
    if callable(self.expr):
        test = self.expr
    else:
        g = getglobals(self.globals)
        expr = compile(self.expr, "ipipe-expression", "eval")
        def test(item):
            return eval(expr, g, AttrNamespace(item))

    ok = 0
    exc_info = None
    for item in xiter(self.input):
        try:
            if test(item):
                yield item
            ok += 1
        except (KeyboardInterrupt, SystemExit):
            raise
        except Exception, exc:
            if self.errors == "drop":
                pass # Ignore errors
            elif self.errors == "keep":
                yield item
            elif self.errors == "keeperror":
                yield exc
            elif self.errors == "raise":
                raise
            elif self.errors == "raiseifallfail":
                if exc_info is None:
                    exc_info = sys.exc_info()
    if not ok and exc_info is not None:
        raise exc_info[0], exc_info[1], exc_info[2]

</t>
<t tx="ekr.20071201085751.927">def __xrepr__(self, mode="default"):
    if mode == "header" or mode == "footer":
        input = getattr(self, "input", None)
        if input is not None:
            for part in xrepr(input, mode):
                yield part
            yield (astyle.style_default, " | ")
        yield (astyle.style_default, "%s(" % self.__class__.__name__)
        for part in xrepr(self.expr, "default"):
            yield part
        yield (astyle.style_default, ")")
    else:
        yield (astyle.style_default, repr(self))

</t>
<t tx="ekr.20071201085751.928">def __repr__(self):
    return "&lt;%s.%s expr=%r at 0x%x&gt;" % \
        (self.__class__.__module__, self.__class__.__name__,
         self.expr, id(self))


</t>
<t tx="ekr.20071201085751.929">class ieval(Pipe):
    """
    Evaluate an expression for each object in the input pipe.

    Examples:

        &gt;&gt;&gt; ils | ieval("_.abspath()")
        &gt;&gt;&gt; sys.path | ieval(ifile)
    """
    @others
</t>
<t tx="ekr.20071201085751.930">
def __init__(self, expr, globals=None, errors="raiseifallfail"):
    """
    Create an ``ieval`` object. ``expr`` can be a callable or a string
    containing an expression. For the meaning of ``globals`` and
    ``errors`` see ``ifilter``.
    """
    self.expr = expr
    self.globals = globals
    self.errors = errors

</t>
<t tx="ekr.20071201085751.931">def __iter__(self):
    if callable(self.expr):
        do = self.expr
    else:
        g = getglobals(self.globals)
        expr = compile(self.expr, "ipipe-expression", "eval")
        def do(item):
            return eval(expr, g, AttrNamespace(item))

    ok = 0
    exc_info = None
    for item in xiter(self.input):
        try:
            yield do(item)
        except (KeyboardInterrupt, SystemExit):
            raise
        except Exception, exc:
            if self.errors == "drop":
                pass # Ignore errors
            elif self.errors == "keep":
                yield item
            elif self.errors == "keeperror":
                yield exc
            elif self.errors == "raise":
                raise
            elif self.errors == "raiseifallfail":
                if exc_info is None:
                    exc_info = sys.exc_info()
    if not ok and exc_info is not None:
        raise exc_info[0], exc_info[1], exc_info[2]

</t>
<t tx="ekr.20071201085751.932">def __xrepr__(self, mode="default"):
    if mode == "header" or mode == "footer":
        input = getattr(self, "input", None)
        if input is not None:
            for part in xrepr(input, mode):
                yield part
            yield (astyle.style_default, " | ")
        yield (astyle.style_default, "%s(" % self.__class__.__name__)
        for part in xrepr(self.expr, "default"):
            yield part
        yield (astyle.style_default, ")")
    else:
        yield (astyle.style_default, repr(self))

</t>
<t tx="ekr.20071201085751.933">def __repr__(self):
    return "&lt;%s.%s expr=%r at 0x%x&gt;" % \
        (self.__class__.__module__, self.__class__.__name__,
         self.expr, id(self))


</t>
<t tx="ekr.20071201085751.934">class ienum(Pipe):
    """
    Enumerate the input pipe (i.e. wrap each input object in an object
    with ``index`` and ``object`` attributes).

    Examples:

        &gt;&gt;&gt; xrange(20) | ieval("_,_*_") | ienum | ifilter("index % 2 == 0") | ieval("object")
    """
    @others
</t>
<t tx="ekr.20071201085751.935">def __iter__(self):
    fields = ("index", "object")
    for (index, object) in enumerate(xiter(self.input)):
        yield Fields(fields, index=index, object=object)


</t>
<t tx="ekr.20071201085751.936">class isort(Pipe):
    """
    Sorts the input pipe.

    Examples:

        &gt;&gt;&gt; ils | isort("size")
        &gt;&gt;&gt; ils | isort("_.isdir(), _.lower()", reverse=True)
    """
    @others
</t>
<t tx="ekr.20071201085751.937">
def __init__(self, key=None, globals=None, reverse=False):
    """
    Create an ``isort`` object. ``key`` can be a callable or a string
    containing an expression (or ``None`` in which case the items
    themselves will be sorted). If ``reverse`` is true the sort order
    will be reversed. For the meaning of ``globals`` see ``ifilter``.
    """
    self.key = key
    self.globals = globals
    self.reverse = reverse

</t>
<t tx="ekr.20071201085751.938">def __iter__(self):
    if self.key is None:
        items = sorted(xiter(self.input), reverse=self.reverse)
    elif callable(self.key):
        items = sorted(xiter(self.input), key=self.key, reverse=self.reverse)
    else:
        g = getglobals(self.globals)
        key = compile(self.key, "ipipe-expression", "eval")
        def realkey(item):
            return eval(key, g, AttrNamespace(item))
        items = sorted(xiter(self.input), key=realkey, reverse=self.reverse)
    for item in items:
        yield item

</t>
<t tx="ekr.20071201085751.939">def __xrepr__(self, mode="default"):
    if mode == "header" or mode == "footer":
        input = getattr(self, "input", None)
        if input is not None:
            for part in xrepr(input, mode):
                yield part
            yield (astyle.style_default, " | ")
        yield (astyle.style_default, "%s(" % self.__class__.__name__)
        for part in xrepr(self.key, "default"):
            yield part
        if self.reverse:
            yield (astyle.style_default, ", ")
            for part in xrepr(True, "default"):
                yield part
        yield (astyle.style_default, ")")
    else:
        yield (astyle.style_default, repr(self))

</t>
<t tx="ekr.20071201085751.940">def __repr__(self):
    return "&lt;%s.%s key=%r reverse=%r at 0x%x&gt;" % \
        (self.__class__.__module__, self.__class__.__name__,
         self.key, self.reverse, id(self))


</t>
<t tx="ekr.20071201085751.941">tab = 3 # for expandtabs()

def _format(field):
    if isinstance(field, str):
        text = repr(field.expandtabs(tab))[1:-1]
    elif isinstance(field, unicode):
        text = repr(field.expandtabs(tab))[2:-1]
    elif isinstance(field, datetime.datetime):
        # Don't use strftime() here, as this requires year &gt;= 1900
        text = "%04d-%02d-%02d %02d:%02d:%02d.%06d" % \
            (field.year, field.month, field.day,
             field.hour, field.minute, field.second, field.microsecond)
    elif isinstance(field, datetime.date):
        text = "%04d-%02d-%02d" % (field.year, field.month, field.day)
    else:
        text = repr(field)
    return text


</t>
<t tx="ekr.20071201085751.942">class Display(object):
    @others
</t>
<t tx="ekr.20071201085751.943">class __metaclass__(type):
    @others
</t>
<t tx="ekr.20071201085751.944">def __ror__(self, input):
    return input | self()

</t>
<t tx="ekr.20071201085751.945">def __ror__(self, input):
    self.input = input
    return self

</t>
<t tx="ekr.20071201085751.946">def display(self):
    pass


</t>
<t tx="ekr.20071201085751.947">class iless(Display):
    cmd = "less --quit-if-one-screen --LONG-PROMPT --LINE-NUMBERS --chop-long-lines --shift=8 --RAW-CONTROL-CHARS"

    @others
</t>
<t tx="ekr.20071201085751.948">def display(self):
    try:
        pager = os.popen(self.cmd, "w")
        try:
            for item in xiter(self.input):
                first = False
                for attr in xattrs(item, "default"):
                    if first:
                        first = False
                    else:
                        pager.write(" ")
                    attr = upgradexattr(attr)
                    if not isinstance(attr, SelfDescriptor):
                        pager.write(attr.name())
                        pager.write("=")
                    pager.write(str(attr.value(item)))
                pager.write("\n")
        finally:
            pager.close()
    except Exception, exc:
        print "%s: %s" % (exc.__class__.__name__, str(exc))


</t>
<t tx="ekr.20071201085751.949">def xformat(value, mode, maxlength):
    align = None
    full = True
    width = 0
    text = astyle.Text()
    for (style, part) in xrepr(value, mode):
        # only consider the first result
        if align is None:
            if isinstance(style, int):
                # (style, text) really is (alignment, stop)
                align = style
                full = part
                continue
            else:
                align = -1
                full = True
        if not isinstance(style, int):
            text.append((style, part))
            width += len(part)
            if width &gt;= maxlength and not full:
                text.append((astyle.style_ellisis, "..."))
                width += 3
                break
    if align is None: # default to left alignment
        align = -1
    return (align, width, text)


</t>
<t tx="ekr.20071201085751.950">class idump(Display):
    # The approximate maximum length of a column entry
    maxattrlength = 200

    # Style for column names
    style_header = astyle.Style.fromstr("white:black:bold")

    @others
</t>
<t tx="ekr.20071201085751.951">def __init__(self, *attrs):
    self.attrs = [upgradexattr(attr) for attr in attrs]
    self.headerpadchar = " "
    self.headersepchar = "|"
    self.datapadchar = " "
    self.datasepchar = "|"

</t>
<t tx="ekr.20071201085751.952">def display(self):
    stream = genutils.Term.cout
    allattrs = []
    attrset = set()
    colwidths = {}
    rows = []
    for item in xiter(self.input):
        row = {}
        attrs = self.attrs
        if not attrs:
            attrs = xattrs(item, "default")
        for attr in attrs:
            if attr not in attrset:
                allattrs.append(attr)
                attrset.add(attr)
                colwidths[attr] = len(attr.name())
            try:
                value = attr.value(item)
            except (KeyboardInterrupt, SystemExit):
                raise
            except Exception, exc:
                value = exc
            (align, width, text) = xformat(value, "cell", self.maxattrlength)
            colwidths[attr] = max(colwidths[attr], width)
            # remember alignment, length and colored parts
            row[attr] = (align, width, text)
        rows.append(row)

    stream.write("\n")
    for (i, attr) in enumerate(allattrs):
        attrname = attr.name()
        self.style_header(attrname).write(stream)
        spc = colwidths[attr] - len(attrname)
        if i &lt; len(colwidths)-1:
            stream.write(self.headerpadchar*spc)
            stream.write(self.headersepchar)
    stream.write("\n")

    for row in rows:
        for (i, attr) in enumerate(allattrs):
            (align, width, text) = row[attr]
            spc = colwidths[attr] - width
            if align == -1:
                text.write(stream)
                if i &lt; len(colwidths)-1:
                    stream.write(self.datapadchar*spc)
            elif align == 0:
                spc = colwidths[attr] - width
                spc1 = spc//2
                spc2 = spc-spc1
                stream.write(self.datapadchar*spc1)
                text.write(stream)
                if i &lt; len(colwidths)-1:
                    stream.write(self.datapadchar*spc2)
            else:
                stream.write(self.datapadchar*spc)
                text.write(stream)
            if i &lt; len(colwidths)-1:
                stream.write(self.datasepchar)
        stream.write("\n")


</t>
<t tx="ekr.20071201085751.953">class AttributeDetail(Table):
    """
    ``AttributeDetail`` objects are use for displaying a detailed list of object
    attributes.
    """
    @others
</t>
<t tx="ekr.20071201085751.954">def __init__(self, object, descriptor):
    self.object = object
    self.descriptor = descriptor

</t>
<t tx="ekr.20071201085751.955">def __iter__(self):
    return self.descriptor.iter(self.object)

</t>
<t tx="ekr.20071201085751.956">def name(self):
    return self.descriptor.name()

</t>
<t tx="ekr.20071201085751.957">def attrtype(self):
    return self.descriptor.attrtype(self.object)

</t>
<t tx="ekr.20071201085751.958">def valuetype(self):
    return self.descriptor.valuetype(self.object)

</t>
<t tx="ekr.20071201085751.959">def doc(self):
    return self.descriptor.doc(self.object)

</t>
<t tx="ekr.20071201085751.960">def shortdoc(self):
    return self.descriptor.shortdoc(self.object)

</t>
<t tx="ekr.20071201085751.961">def value(self):
    return self.descriptor.value(self.object)

</t>
<t tx="ekr.20071201085751.962">def __xattrs__(self, mode="default"):
    attrs = ("name()", "attrtype()", "valuetype()", "value()", "shortdoc()")
    if mode == "detail":
        attrs += ("doc()",)
    return attrs

</t>
<t tx="ekr.20071201085751.963">def __xrepr__(self, mode="default"):
    yield (-1, True)
    valuetype = self.valuetype()
    if valuetype is not noitem:
        for part in xrepr(valuetype):
            yield part
        yield (astyle.style_default, " ")
    yield (astyle.style_default, self.attrtype())
    yield (astyle.style_default, " ")
    yield (astyle.style_default, self.name())
    yield (astyle.style_default, " of ")
    for part in xrepr(self.object):
        yield part


</t>
<t tx="ekr.20071201085751.964">""" Set default options for IPython. 

Just import this module to get reasonable defaults for everything.

These configurations used to be performed in ipythonrc (or ipythonrc.ini). 
Therefore importing this in your config files makes ipython basically
ignore your ipythonrc. This is *not* imported by default, you need to import 
this manually in one of your config files.

You can further override these defaults in e.g. your ipy_user_config.py,
ipy_profile_PROFILENAME etc.

"""

import IPython.rlineimpl as readline
import IPython.ipapi
ip = IPython.ipapi.get()

o = ip.options

o.colors = "Linux"
o.color_info=1
o.confirm_exit=1
o.pprint=1
o.multi_line_specials=1
o.xmode="Context"


o.prompt_in1='In [\#]: '
o.prompt_in2 ='   .\D.: '
o.prompt_out = 'Out[\#]: '
o.prompts_pad_left=1

o.readline_remove_delims="-/~"
o.readline_merge_completions=1

o.readline = 1

rlopts = """\
tab: complete
"\C-l": possible-completions
set show-all-if-ambiguous on
"\C-o": tab-insert
"\M-i": "    "
"\M-o": "\d\d\d\d"
"\M-I": "\d\d\d\d"
"\C-r": reverse-search-history
"\C-s": forward-search-history
"\C-p": history-search-backward
"\C-n": history-search-forward
"\e[A": history-search-backward
"\e[B": history-search-forward
"\C-k": kill-line
"\C-u": unix-line-discard"""

for cmd in rlopts.split('\n'):
    readline.parse_and_bind(cmd)
    
    
</t>
<t tx="ekr.20071201085751.965">import inspect
import IPython.ipapi
from IPython.genutils import arg_split
ip = IPython.ipapi.get()

from IPython import Debugger

</t>
<t tx="ekr.20071201085751.966">def call_pydb(self, args):
    """Invoke pydb with the supplied parameters."""
    try:
        import pydb
    except ImportError:
        raise ImportError("pydb doesn't seem to be installed.")

    if not hasattr(pydb.pydb, "runv"):
        raise ImportError("You need pydb version 1.19 or later installed.")

    argl = arg_split(args)
    # print argl # dbg
    if len(inspect.getargspec(pydb.runv)[0]) == 2:
        pdb = Debugger.Pdb()
        ip.IP.history_saving_wrapper( lambda : pydb.runv(argl, pdb) )()
    else:
        ip.IP.history_saving_wrapper( lambda : pydb.runv(argl) )()

    
</t>
<t tx="ekr.20071201085751.967">""" Advanced signal (e.g. ctrl+C) handling for IPython

So far, this only ignores ctrl + C in IPython file a subprocess
is executing, to get closer to how a "proper" shell behaves.

Other signal processing may be implemented later on.

If _ip.options.verbose is true, show exit status if nonzero

"""

import signal,os,sys
import IPython.ipapi
import subprocess

ip = IPython.ipapi.get()

</t>
<t tx="ekr.20071201085751.968">def new_ipsystem_posix(cmd):
    """ ctrl+c ignoring replacement for system() command in iplib.
    
    Ignore ctrl + c in IPython process during the command execution. 
    The subprocess will still get the ctrl + c signal.
    
    posix implementation
    """
    
    p =  subprocess.Popen(cmd, shell = True)
    
    old_handler = signal.signal(signal.SIGINT, signal.SIG_IGN)
    pid,status = os.waitpid(p.pid,0)
    signal.signal(signal.SIGINT, old_handler)
    if status and ip.options.verbose:
        print "[exit status: %d]" % status
    
</t>
<t tx="ekr.20071201085751.969">def new_ipsystem_win32(cmd):    
    """ ctrl+c ignoring replacement for system() command in iplib.
    
    Ignore ctrl + c in IPython process during the command execution. 
    The subprocess will still get the ctrl + c signal.
    
    win32 implementation
    """
    old_handler = signal.signal(signal.SIGINT, signal.SIG_IGN)
    status = os.system(cmd)
    signal.signal(signal.SIGINT, old_handler)
    if status and ip.options.verbose:
        print "[exit status: %d]" % status
    
    
</t>
<t tx="ekr.20071201085751.970">def init():
    o = ip.options
    try:
        o.verbose
    except AttributeError:
        o.allow_new_attr (True )
        o.verbose = 0
        
    ip.IP.system = (sys.platform == 'win32' and new_ipsystem_win32 or 
                    new_ipsystem_posix)
    
</t>
<t tx="ekr.20071201085751.971">""" System wide configuration file for IPython.

This will be imported by ipython for all users.

After this ipy_user_conf.py is imported, user specific configuration
should reside there. 

 """

import IPython.ipapi
ip = IPython.ipapi.get()

# add system wide configuration information, import extensions etc. here.
# nothing here is essential 

import sys

import ext_rehashdir # %rehashdir magic
import ext_rescapture # var = !ls and var = %magic
import pspersistence # %store magic
import clearcmd # %clear
# Basic readline config

o = ip.options
</t>
<t tx="ekr.20071201085751.972">""" Preliminary "job control" extensions for IPython 

requires python 2.4 (or separate 'subprocess' module

At the moment this is in a very "unhelpful" form, will be extended in the future.

Usage:

[ipython]|2&gt; import jobctrl
[ipython]|3&gt; &amp;ls
         &lt;3&gt; &lt;jobctrl.IpyPopen object at 0x00D87FD0&gt;
[ipython]|4&gt; _3.go
-----------&gt; _3.go()
ChangeLog
IPython
MANIFEST.in
README
README_Windows.txt

...                     
"""                     

from subprocess import Popen,PIPE
import os,shlex

from IPython import genutils

import IPython.ipapi

</t>
<t tx="ekr.20071201085751.973">class IpyPopen(Popen):
    @others
</t>
<t tx="ekr.20071201085751.974">def go(self):
    print self.communicate()[0]
</t>
<t tx="ekr.20071201085751.975">def __repr__(self):
    return '&lt;IPython job "%s" PID=%d&gt;' % (self.line, self.pid)

</t>
<t tx="ekr.20071201085751.976">def kill(self):
    assert os.name == 'nt' # xxx add posix version 
    os.system('taskkill /PID %d' % self.pid)
              
</t>
<t tx="ekr.20071201085751.977">def startjob(job):
    p = IpyPopen(shlex.split(job), stdout=PIPE, shell = False)
    p.line = job
    return p

</t>
<t tx="ekr.20071201085751.978">def jobctrl_prefilter_f(self,line):    
    if line.startswith('&amp;'):
        pre,fn,rest = self.split_user_input(line[1:])
        
        line = ip.IP.expand_aliases(fn,rest)
        return '_ip.startjob(%s)' % genutils.make_quoted_expr(line)

    raise IPython.ipapi.TryNext

</t>
<t tx="ekr.20071201085751.979">def install():
    global ip
    ip = IPython.ipapi.get()
    # needed to make startjob visible as _ip.startjob('blah')
    ip.startjob = startjob
    ip.set_hook('input_prefilter', jobctrl_prefilter_f)     
    
</t>
<t tx="ekr.20071201085751.980">""" Fun magic line editor for ipython 

Use this to easily edit lists of strings gradually without crafting long 
list comprehensions.

'l' is the magic variable name for every line (array element). Save the current 
result (or more exactly, retrieve the last ipython computation result into
%led work area) by running '%led s'. Just run '%led' to show the current work
area data.

Example use:

[ipython]|25&gt; setups = !ls *setup*.py
 ==
['eggsetup.py', 'setup.py', 'setup_bdist_egg.py']
[ipython]|26&gt; setups
         &lt;26&gt; ['eggsetup.py', 'setup.py', 'setup_bdist_egg.py']
[ipython]|27&gt; %led s
Data set from last result (_)
         &lt;27&gt; ['eggsetup.py', 'setup.py', 'setup_bdist_egg.py']
[ipython]|28&gt; %led upper
cmd translated =&gt; l.upper()
         &lt;28&gt; ['EGGSETUP.PY', 'SETUP.PY', 'SETUP_BDIST_EGG.PY']
[ipython]|29&gt; %led
Magic line editor (for lists of strings)
current data is:
['eggsetup.py', 'setup.py', 'setup_bdist_egg.py']
[ipython]|30&gt; %led upper
cmd translated =&gt; l.upper()
         &lt;30&gt; ['EGGSETUP.PY', 'SETUP.PY', 'SETUP_BDIST_EGG.PY']
[ipython]|31&gt; %led s
Data set from last result (_)
         &lt;31&gt; ['EGGSETUP.PY', 'SETUP.PY', 'SETUP_BDIST_EGG.PY']
[ipython]|32&gt; %led "n:" + l
         &lt;32&gt; ['n:EGGSETUP.PY', 'n:SETUP.PY', 'n:SETUP_BDIST_EGG.PY']
[ipython]|33&gt; %led s
Data set from last result (_)
         &lt;33&gt; ['n:EGGSETUP.PY', 'n:SETUP.PY', 'n:SETUP_BDIST_EGG.PY']
[ipython]|34&gt; %led l.
l.__add__          l.__gt__           l.__reduce_ex__    l.endswith         l.join             l.rstrip
l.__class__        l.__hash__         l.__repr__         l.expandtabs       l.ljust            l.split

... (completions for string variable shown ) ...

"""
import IPython.ipapi
import pprint
ip = IPython.ipapi.get()

curdata = []

</t>
<t tx="ekr.20071201085751.981">def line_edit_f(self, cmd ):
    global curdata
    
    if not cmd:
        
        print "Magic line editor (for lists of strings)"
        if curdata:
            print "current data is:"
            pprint.pprint(curdata)
        else:
            print "No current data, you should set it by running '%led s'"
            print "When you have your data in _ (result of last computation)."
        return
        
    if cmd == 's':
        curdata = ip.ev('_')
        print "Data set from last result (_)"
        newlines = curdata
        
    else:
        # simple method call, e.g. upper
        if cmd.isalpha():
            cmd = 'l.' + cmd + '()'
            print "cmd translated =&gt;",cmd

        newlines = []
        for l in curdata:
            try:
                l2 = eval(cmd)
            except Exception,e:
                print "Dropping exception",e,"on line:",l
                continue
            newlines.append(l2)

    
    return newlines

</t>
<t tx="ekr.20071201085751.982">def line_edit_complete_f(self,event):
    """ Show all string methods in completions """
    if event.symbol.startswith('l.'):
        return ['l.' + func for func in dir('')]
    
    return dir('') + ['l.' + func for func in dir('')]

</t>
<t tx="ekr.20071201085751.983"># -*- coding: utf-8 -*-
"""
Extension for printing Numeric Arrays in flexible ways.
"""

from Numeric import ArrayType

</t>
<t tx="ekr.20071201085751.984">def num_display(self,arg):
    """Display method for printing which treats Numeric arrays specially.
    """

    # Non-numpy variables are printed using the system default
    if type(arg) != ArrayType:
        self._display(arg)
        return
    # Otherwise, we do work.
    format = __IPYTHON__.runtime_rc.numarray_print_format
    print 'NumPy array, format:',format
    # Here is where all the printing logic needs to be implemented
    print arg # nothing yet :)


</t>
<t tx="ekr.20071201085751.985">def magic_format(self,parameter_s=''):
    """Specifies format of numerical output.

    This command is similar to Ocave's format command.
    """

    valid_formats = ['long','short']
    
    if parameter_s in valid_formats:
        self.runtime_rc.numarray_print_format = parameter_s
        print 'Numeric output format is now:',parameter_s
    else:
        print 'Invalid format:',parameter_s
        print 'Valid formats:',valid_formats

</t>
<t tx="ekr.20071201085751.986">""" path.py - An object representing a path to a file or directory.

Example:

from path import path
d = path('/home/guido/bin')
for f in d.files('*.py'):
    f.chmod(0755)

This module requires Python 2.2 or later.


URL:     http://www.jorendorff.com/articles/python/path
Author:  Jason Orendorff &lt;jason.orendorff\x40gmail\x2ecom&gt; (and others - see the url!)
Date:    7 Mar 2004
"""


# TODO
#   - Tree-walking functions don't avoid symlink loops.  Matt Harrison sent me a patch for this.
#   - Tree-walking functions can't ignore errors.  Matt Harrison asked for this.
#
#   - Two people asked for path.chdir().  This just seems wrong to me,
#     I dunno.  chdir() is moderately evil anyway.
#
#   - Bug in write_text().  It doesn't support Universal newline mode.
#   - Better error message in listdir() when self isn't a
#     directory. (On Windows, the error message really sucks.)
#   - Make sure everything has a good docstring.
#   - Add methods for regex find and replace.
#   - guess_content_type() method?
#   - Perhaps support arguments to touch().
#   - Could add split() and join() methods that generate warnings.

from __future__ import generators

import sys, warnings, os, fnmatch, glob, shutil, codecs, md5

__version__ = '2.1'
__all__ = ['path']

# Platform-specific support for path.owner
if os.name == 'nt':
    try:
        import win32security
    except ImportError:
        win32security = None
else:
    try:
        import pwd
    except ImportError:
        pwd = None

# Pre-2.3 support.  Are unicode filenames supported?
_base = str
_getcwd = os.getcwd
try:
    if os.path.supports_unicode_filenames:
        _base = unicode
        _getcwd = os.getcwdu
except AttributeError:
    pass

# Pre-2.3 workaround for booleans
try:
    True, False
except NameError:
    True, False = 1, 0

# Pre-2.3 workaround for basestring.
try:
    basestring
except NameError:
    basestring = (str, unicode)

# Universal newline support
_textmode = 'r'
if hasattr(file, 'newlines'):
    _textmode = 'U'


</t>
<t tx="ekr.20071201085751.987">class TreeWalkWarning(Warning):
    pass

</t>
<t tx="ekr.20071201085751.988">class path(_base):
    """ Represents a filesystem path.

    For documentation on individual methods, consult their
    counterparts in os.path.
    """
    @others
    # --- Links

    if hasattr(os, 'link'):
        def link(self, newpath):
            """ Create a hard link at 'newpath', pointing to this file. """
            os.link(self, newpath)

    if hasattr(os, 'symlink'):
        def symlink(self, newlink):
            """ Create a symbolic link at 'newlink', pointing here. """
            os.symlink(self, newlink)

    if hasattr(os, 'readlink'):
        def readlink(self):
            """ Return the path to which this symbolic link points.

            The result may be an absolute or a relative path.
            """
            return self.__class__(os.readlink(self))

        def readlinkabs(self):
            """ Return the path to which this symbolic link points.

            The result is always an absolute path.
            """
            p = self.readlink()
            if p.isabs():
                return p
            else:
                return (self.parent / p).abspath()


    # --- High-level functions from shutil

    copyfile = shutil.copyfile
    copymode = shutil.copymode
    copystat = shutil.copystat
    copy = shutil.copy
    copy2 = shutil.copy2
    copytree = shutil.copytree
    if hasattr(shutil, 'move'):
        move = shutil.move
    rmtree = shutil.rmtree


    # --- Special stuff from os

    if hasattr(os, 'chroot'):
        def chroot(self):
            os.chroot(self)

    if hasattr(os, 'startfile'):
        def startfile(self):
            os.startfile(self)

</t>
<t tx="ekr.20071201085751.989">
# --- Special Python methods.

def __repr__(self):
    return 'path(%s)' % _base.__repr__(self)

</t>
<t tx="ekr.20071201085751.990"># Adding a path and a string yields a path.
def __add__(self, more):
    try:
        resultStr = _base.__add__(self, more)
    except TypeError:  #Python bug
        resultStr = NotImplemented
    if resultStr is NotImplemented:
        return resultStr
    return self.__class__(resultStr)

</t>
<t tx="ekr.20071201085751.991">def __radd__(self, other):
    if isinstance(other, basestring):
        return self.__class__(other.__add__(self))
    else:
        return NotImplemented

</t>
<t tx="ekr.20071201085751.992"># The / operator joins paths.
def __div__(self, rel):
    """ fp.__div__(rel) == fp / rel == fp.joinpath(rel)

    Join two path components, adding a separator character if
    needed.
    """
    return self.__class__(os.path.join(self, rel))

</t>
<t tx="ekr.20071201085751.993"># Make the / operator work even when true division is enabled.
__truediv__ = __div__

def getcwd(cls):
    """ Return the current working directory as a path object. """
    return cls(_getcwd())
</t>
<t tx="ekr.20071201085751.994">getcwd = classmethod(getcwd)


# --- Operations on path strings.

isabs = os.path.isabs
def abspath(self):       return self.__class__(os.path.abspath(self))
</t>
<t tx="ekr.20071201085751.995">def normcase(self):      return self.__class__(os.path.normcase(self))
</t>
<t tx="ekr.20071201085751.996">def normpath(self):      return self.__class__(os.path.normpath(self))
</t>
<t tx="ekr.20071201085751.997">def realpath(self):      return self.__class__(os.path.realpath(self))
</t>
<t tx="ekr.20071201085751.998">def expanduser(self):    return self.__class__(os.path.expanduser(self))
</t>
<t tx="ekr.20071201085751.999">def expandvars(self):    return self.__class__(os.path.expandvars(self))
</t>
<t tx="ekr.20071201085751.1000">def dirname(self):       return self.__class__(os.path.dirname(self))
</t>
<t tx="ekr.20071201085751.1001">basename = os.path.basename

def expand(self):
    """ Clean up a filename by calling expandvars(),
    expanduser(), and normpath() on it.

    This is commonly everything needed to clean up a filename
    read from a configuration file, for example.
    """
    return self.expandvars().expanduser().normpath()

</t>
<t tx="ekr.20071201085751.1002">def _get_namebase(self):
    base, ext = os.path.splitext(self.name)
    return base

</t>
<t tx="ekr.20071201085751.1003">def _get_ext(self):
    f, ext = os.path.splitext(_base(self))
    return ext

</t>
<t tx="ekr.20071201085751.1004">def _get_drive(self):
    drive, r = os.path.splitdrive(self)
    return self.__class__(drive)

</t>
<t tx="ekr.20071201085751.1005">parent = property(
    dirname, None, None,
    """ This path's parent directory, as a new path object.

    For example, path('/usr/local/lib/libpython.so').parent == path('/usr/local/lib')
    """)

name = property(
    basename, None, None,
    """ The name of this file or directory without the full path.

    For example, path('/usr/local/lib/libpython.so').name == 'libpython.so'
    """)

namebase = property(
    _get_namebase, None, None,
    """ The same as path.name, but with one file extension stripped off.

    For example, path('/home/guido/python.tar.gz').name     == 'python.tar.gz',
    but          path('/home/guido/python.tar.gz').namebase == 'python.tar'
    """)

ext = property(
    _get_ext, None, None,
    """ The file extension, for example '.py'. """)

drive = property(
    _get_drive, None, None,
    """ The drive specifier, for example 'C:'.
    This is always empty on systems that don't use drive specifiers.
    """)

def splitpath(self):
    """ p.splitpath() -&gt; Return (p.parent, p.name). """
    parent, child = os.path.split(self)
    return self.__class__(parent), child

</t>
<t tx="ekr.20071201085751.1006">def splitdrive(self):
    """ p.splitdrive() -&gt; Return (p.drive, &lt;the rest of p&gt;).

    Split the drive specifier from this path.  If there is
    no drive specifier, p.drive is empty, so the return value
    is simply (path(''), p).  This is always the case on Unix.
    """
    drive, rel = os.path.splitdrive(self)
    return self.__class__(drive), rel

</t>
<t tx="ekr.20071201085751.1007">def splitext(self):
    """ p.splitext() -&gt; Return (p.stripext(), p.ext).

    Split the filename extension from this path and return
    the two parts.  Either part may be empty.

    The extension is everything from '.' to the end of the
    last path segment.  This has the property that if
    (a, b) == p.splitext(), then a + b == p.
    """
    filename, ext = os.path.splitext(self)
    return self.__class__(filename), ext

</t>
<t tx="ekr.20071201085751.1008">def stripext(self):
    """ p.stripext() -&gt; Remove one file extension from the path.

    For example, path('/home/guido/python.tar.gz').stripext()
    returns path('/home/guido/python.tar').
    """
    return self.splitext()[0]

</t>
<t tx="ekr.20071201085751.1009">if hasattr(os.path, 'splitunc'):
    def splitunc(self):
        unc, rest = os.path.splitunc(self)
        return self.__class__(unc), rest

    def _get_uncshare(self):
        unc, r = os.path.splitunc(self)
        return self.__class__(unc)

    uncshare = property(
        _get_uncshare, None, None,
        """ The UNC mount point for this path.
        This is empty for paths on local drives. """)

def joinpath(self, *args):
    """ Join two or more path components, adding a separator
    character (os.sep) if needed.  Returns a new path
    object.
    """
    return self.__class__(os.path.join(self, *args))

</t>
<t tx="ekr.20071201085751.1010">def splitall(self):
    r""" Return a list of the path components in this path.

    The first item in the list will be a path.  Its value will be
    either os.curdir, os.pardir, empty, or the root directory of
    this path (for example, '/' or 'C:\\').  The other items in
    the list will be strings.

    path.path.joinpath(*result) will yield the original path.
    """
    parts = []
    loc = self
    while loc != os.curdir and loc != os.pardir:
        prev = loc
        loc, child = prev.splitpath()
        if loc == prev:
            break
        parts.append(child)
    parts.append(loc)
    parts.reverse()
    return parts

</t>
<t tx="ekr.20071201085751.1011">def relpath(self):
    """ Return this path as a relative path,
    based from the current working directory.
    """
    cwd = self.__class__(os.getcwd())
    return cwd.relpathto(self)

</t>
<t tx="ekr.20071201085751.1012">def relpathto(self, dest):
    """ Return a relative path from self to dest.

    If there is no relative path from self to dest, for example if
    they reside on different drives in Windows, then this returns
    dest.abspath().
    """
    origin = self.abspath()
    dest = self.__class__(dest).abspath()

    orig_list = origin.normcase().splitall()
    # Don't normcase dest!  We want to preserve the case.
    dest_list = dest.splitall()

    if orig_list[0] != os.path.normcase(dest_list[0]):
        # Can't get here from there.
        return dest

    # Find the location where the two paths start to differ.
    i = 0
    for start_seg, dest_seg in zip(orig_list, dest_list):
        if start_seg != os.path.normcase(dest_seg):
            break
        i += 1

    # Now i is the point where the two paths diverge.
    # Need a certain number of "os.pardir"s to work up
    # from the origin to the point of divergence.
    segments = [os.pardir] * (len(orig_list) - i)
    # Need to add the diverging part of dest_list.
    segments += dest_list[i:]
    if len(segments) == 0:
        # If they happen to be identical, use os.curdir.
        relpath = os.curdir
    else:
        relpath = os.path.join(*segments)
    return self.__class__(relpath)

</t>
<t tx="ekr.20071201085751.1013"># --- Listing, searching, walking, and matching

def listdir(self, pattern=None):
    """ D.listdir() -&gt; List of items in this directory.

    Use D.files() or D.dirs() instead if you want a listing
    of just files or just subdirectories.

    The elements of the list are path objects.

    With the optional 'pattern' argument, this only lists
    items whose names match the given pattern.
    """
    names = os.listdir(self)
    if pattern is not None:
        names = fnmatch.filter(names, pattern)
    return [self / child for child in names]

</t>
<t tx="ekr.20071201085751.1014">def dirs(self, pattern=None):
    """ D.dirs() -&gt; List of this directory's subdirectories.

    The elements of the list are path objects.
    This does not walk recursively into subdirectories
    (but see path.walkdirs).

    With the optional 'pattern' argument, this only lists
    directories whose names match the given pattern.  For
    example, d.dirs('build-*').
    """
    return [p for p in self.listdir(pattern) if p.isdir()]

</t>
<t tx="ekr.20071201085751.1015">def files(self, pattern=None):
    """ D.files() -&gt; List of the files in this directory.

    The elements of the list are path objects.
    This does not walk into subdirectories (see path.walkfiles).

    With the optional 'pattern' argument, this only lists files
    whose names match the given pattern.  For example,
    d.files('*.pyc').
    """
    
    return [p for p in self.listdir(pattern) if p.isfile()]

</t>
<t tx="ekr.20071201085751.1016">def walk(self, pattern=None, errors='strict'):
    """ D.walk() -&gt; iterator over files and subdirs, recursively.

    The iterator yields path objects naming each child item of
    this directory and its descendants.  This requires that
    D.isdir().

    This performs a depth-first traversal of the directory tree.
    Each directory is returned just before all its children.

    The errors= keyword argument controls behavior when an
    error occurs.  The default is 'strict', which causes an
    exception.  The other allowed values are 'warn', which
    reports the error via warnings.warn(), and 'ignore'.
    """
    if errors not in ('strict', 'warn', 'ignore'):
        raise ValueError("invalid errors parameter")

    try:
        childList = self.listdir()
    except Exception:
        if errors == 'ignore':
            return
        elif errors == 'warn':
            warnings.warn(
                "Unable to list directory '%s': %s"
                % (self, sys.exc_info()[1]),
                TreeWalkWarning)
        else:
            raise

    for child in childList:
        if pattern is None or child.fnmatch(pattern):
            yield child
        try:
            isdir = child.isdir()
        except Exception:
            if errors == 'ignore':
                isdir = False
            elif errors == 'warn':
                warnings.warn(
                    "Unable to access '%s': %s"
                    % (child, sys.exc_info()[1]),
                    TreeWalkWarning)
                isdir = False
            else:
                raise

        if isdir:
            for item in child.walk(pattern, errors):
                yield item

</t>
<t tx="ekr.20071201085751.1017">def walkdirs(self, pattern=None, errors='strict'):
    """ D.walkdirs() -&gt; iterator over subdirs, recursively.

    With the optional 'pattern' argument, this yields only
    directories whose names match the given pattern.  For
    example, mydir.walkdirs('*test') yields only directories
    with names ending in 'test'.

    The errors= keyword argument controls behavior when an
    error occurs.  The default is 'strict', which causes an
    exception.  The other allowed values are 'warn', which
    reports the error via warnings.warn(), and 'ignore'.
    """
    if errors not in ('strict', 'warn', 'ignore'):
        raise ValueError("invalid errors parameter")

    try:
        dirs = self.dirs()
    except Exception:
        if errors == 'ignore':
            return
        elif errors == 'warn':
            warnings.warn(
                "Unable to list directory '%s': %s"
                % (self, sys.exc_info()[1]),
                TreeWalkWarning)
        else:
            raise

    for child in dirs:
        if pattern is None or child.fnmatch(pattern):
            yield child
        for subsubdir in child.walkdirs(pattern, errors):
            yield subsubdir

</t>
<t tx="ekr.20071201085751.1018">def walkfiles(self, pattern=None, errors='strict'):
    """ D.walkfiles() -&gt; iterator over files in D, recursively.

    The optional argument, pattern, limits the results to files
    with names that match the pattern.  For example,
    mydir.walkfiles('*.tmp') yields only files with the .tmp
    extension.
    """
    if errors not in ('strict', 'warn', 'ignore'):
        raise ValueError("invalid errors parameter")

    try:
        childList = self.listdir()
    except Exception:
        if errors == 'ignore':
            return
        elif errors == 'warn':
            warnings.warn(
                "Unable to list directory '%s': %s"
                % (self, sys.exc_info()[1]),
                TreeWalkWarning)
        else:
            raise

    for child in childList:
        try:
            isfile = child.isfile()
            isdir = not isfile and child.isdir()
        except:
            if errors == 'ignore':
                return
            elif errors == 'warn':
                warnings.warn(
                    "Unable to access '%s': %s"
                    % (self, sys.exc_info()[1]),
                    TreeWalkWarning)
            else:
                raise

        if isfile:
            if pattern is None or child.fnmatch(pattern):
                yield child
        elif isdir:
            for f in child.walkfiles(pattern, errors):
                yield f

</t>
<t tx="ekr.20071201085751.1019">def fnmatch(self, pattern):
    """ Return True if self.name matches the given pattern.

    pattern - A filename pattern with wildcards,
        for example '*.py'.
    """
    return fnmatch.fnmatch(self.name, pattern)

</t>
<t tx="ekr.20071201085751.1020">def glob(self, pattern):
    """ Return a list of path objects that match the pattern.

    pattern - a path relative to this directory, with wildcards.

    For example, path('/users').glob('*/bin/*') returns a list
    of all the files users have in their bin directories.
    """
    cls = self.__class__
    return [cls(s) for s in glob.glob(_base(self / pattern))]


</t>
<t tx="ekr.20071201085751.1021"># --- Reading or writing an entire file at once.

def open(self, mode='r'):
    """ Open this file.  Return a file object. """
    return file(self, mode)

</t>
<t tx="ekr.20071201085751.1022">def bytes(self):
    """ Open this file, read all bytes, return them as a string. """
    f = self.open('rb')
    try:
        return f.read()
    finally:
        f.close()

</t>
<t tx="ekr.20071201085751.1023">def write_bytes(self, bytes, append=False):
    """ Open this file and write the given bytes to it.

    Default behavior is to overwrite any existing file.
    Call p.write_bytes(bytes, append=True) to append instead.
    """
    if append:
        mode = 'ab'
    else:
        mode = 'wb'
    f = self.open(mode)
    try:
        f.write(bytes)
    finally:
        f.close()

</t>
<t tx="ekr.20071201085751.1024">def text(self, encoding=None, errors='strict'):
    r""" Open this file, read it in, return the content as a string.

    This uses 'U' mode in Python 2.3 and later, so '\r\n' and '\r'
    are automatically translated to '\n'.

    Optional arguments:

    encoding - The Unicode encoding (or character set) of
        the file.  If present, the content of the file is
        decoded and returned as a unicode object; otherwise
        it is returned as an 8-bit str.
    errors - How to handle Unicode errors; see help(str.decode)
        for the options.  Default is 'strict'.
    """
    if encoding is None:
        # 8-bit
        f = self.open(_textmode)
        try:
            return f.read()
        finally:
            f.close()
    else:
        # Unicode
        f = codecs.open(self, 'r', encoding, errors)
        # (Note - Can't use 'U' mode here, since codecs.open
        # doesn't support 'U' mode, even in Python 2.3.)
        try:
            t = f.read()
        finally:
            f.close()
        return (t.replace(u'\r\n', u'\n')
                 .replace(u'\r\x85', u'\n')
                 .replace(u'\r', u'\n')
                 .replace(u'\x85', u'\n')
                 .replace(u'\u2028', u'\n'))

</t>
<t tx="ekr.20071201085751.1025">def write_text(self, text, encoding=None, errors='strict', linesep=os.linesep, append=False):
    r""" Write the given text to this file.

    The default behavior is to overwrite any existing file;
    to append instead, use the 'append=True' keyword argument.

    There are two differences between path.write_text() and
    path.write_bytes(): newline handling and Unicode handling.
    See below.

    Parameters:

      - text - str/unicode - The text to be written.

      - encoding - str - The Unicode encoding that will be used.
        This is ignored if 'text' isn't a Unicode string.

      - errors - str - How to handle Unicode encoding errors.
        Default is 'strict'.  See help(unicode.encode) for the
        options.  This is ignored if 'text' isn't a Unicode
        string.

      - linesep - keyword argument - str/unicode - The sequence of
        characters to be used to mark end-of-line.  The default is
        os.linesep.  You can also specify None; this means to
        leave all newlines as they are in 'text'.

      - append - keyword argument - bool - Specifies what to do if
        the file already exists (True: append to the end of it;
        False: overwrite it.)  The default is False.


    --- Newline handling.

    write_text() converts all standard end-of-line sequences
    ('\n', '\r', and '\r\n') to your platform's default end-of-line
    sequence (see os.linesep; on Windows, for example, the
    end-of-line marker is '\r\n').

    If you don't like your platform's default, you can override it
    using the 'linesep=' keyword argument.  If you specifically want
    write_text() to preserve the newlines as-is, use 'linesep=None'.

    This applies to Unicode text the same as to 8-bit text, except
    there are three additional standard Unicode end-of-line sequences:
    u'\x85', u'\r\x85', and u'\u2028'.

    (This is slightly different from when you open a file for
    writing with fopen(filename, "w") in C or file(filename, 'w')
    in Python.)


    --- Unicode

    If 'text' isn't Unicode, then apart from newline handling, the
    bytes are written verbatim to the file.  The 'encoding' and
    'errors' arguments are not used and must be omitted.

    If 'text' is Unicode, it is first converted to bytes using the
    specified 'encoding' (or the default encoding if 'encoding'
    isn't specified).  The 'errors' argument applies only to this
    conversion.

    """
    if isinstance(text, unicode):
        if linesep is not None:
            # Convert all standard end-of-line sequences to
            # ordinary newline characters.
            text = (text.replace(u'\r\n', u'\n')
                        .replace(u'\r\x85', u'\n')
                        .replace(u'\r', u'\n')
                        .replace(u'\x85', u'\n')
                        .replace(u'\u2028', u'\n'))
            text = text.replace(u'\n', linesep)
        if encoding is None:
            encoding = sys.getdefaultencoding()
        bytes = text.encode(encoding, errors)
    else:
        # It is an error to specify an encoding if 'text' is
        # an 8-bit string.
        assert encoding is None

        if linesep is not None:
            text = (text.replace('\r\n', '\n')
                        .replace('\r', '\n'))
            bytes = text.replace('\n', linesep)

    self.write_bytes(bytes, append)

</t>
<t tx="ekr.20071201085751.1026">def lines(self, encoding=None, errors='strict', retain=True):
    r""" Open this file, read all lines, return them in a list.

    Optional arguments:
        encoding - The Unicode encoding (or character set) of
            the file.  The default is None, meaning the content
            of the file is read as 8-bit characters and returned
            as a list of (non-Unicode) str objects.
        errors - How to handle Unicode errors; see help(str.decode)
            for the options.  Default is 'strict'
        retain - If true, retain newline characters; but all newline
            character combinations ('\r', '\n', '\r\n') are
            translated to '\n'.  If false, newline characters are
            stripped off.  Default is True.

    This uses 'U' mode in Python 2.3 and later.
    """
    if encoding is None and retain:
        f = self.open(_textmode)
        try:
            return f.readlines()
        finally:
            f.close()
    else:
        return self.text(encoding, errors).splitlines(retain)

</t>
<t tx="ekr.20071201085751.1027">def write_lines(self, lines, encoding=None, errors='strict',
                linesep=os.linesep, append=False):
    r""" Write the given lines of text to this file.

    By default this overwrites any existing file at this path.

    This puts a platform-specific newline sequence on every line.
    See 'linesep' below.

    lines - A list of strings.

    encoding - A Unicode encoding to use.  This applies only if
        'lines' contains any Unicode strings.

    errors - How to handle errors in Unicode encoding.  This
        also applies only to Unicode strings.

    linesep - The desired line-ending.  This line-ending is
        applied to every line.  If a line already has any
        standard line ending ('\r', '\n', '\r\n', u'\x85',
        u'\r\x85', u'\u2028'), that will be stripped off and
        this will be used instead.  The default is os.linesep,
        which is platform-dependent ('\r\n' on Windows, '\n' on
        Unix, etc.)  Specify None to write the lines as-is,
        like file.writelines().

    Use the keyword argument append=True to append lines to the
    file.  The default is to overwrite the file.  Warning:
    When you use this with Unicode data, if the encoding of the
    existing data in the file is different from the encoding
    you specify with the encoding= parameter, the result is
    mixed-encoding data, which can really confuse someone trying
    to read the file later.
    """
    if append:
        mode = 'ab'
    else:
        mode = 'wb'
    f = self.open(mode)
    try:
        for line in lines:
            isUnicode = isinstance(line, unicode)
            if linesep is not None:
                # Strip off any existing line-end and add the
                # specified linesep string.
                if isUnicode:
                    if line[-2:] in (u'\r\n', u'\x0d\x85'):
                        line = line[:-2]
                    elif line[-1:] in (u'\r', u'\n',
                                       u'\x85', u'\u2028'):
                        line = line[:-1]
                else:
                    if line[-2:] == '\r\n':
                        line = line[:-2]
                    elif line[-1:] in ('\r', '\n'):
                        line = line[:-1]
                line += linesep
            if isUnicode:
                if encoding is None:
                    encoding = sys.getdefaultencoding()
                line = line.encode(encoding, errors)
            f.write(line)
    finally:
        f.close()

</t>
<t tx="ekr.20071201085751.1028">def read_md5(self):
    """ Calculate the md5 hash for this file.

    This reads through the entire file.
    """
    f = self.open('rb')
    try:
        m = md5.new()
        while True:
            d = f.read(8192)
            if not d:
                break
            m.update(d)
    finally:
        f.close()
    return m.digest()

</t>
<t tx="ekr.20071201085751.1029"># --- Methods for querying the filesystem.

exists = os.path.exists
isdir = os.path.isdir
isfile = os.path.isfile
islink = os.path.islink
ismount = os.path.ismount

if hasattr(os.path, 'samefile'):
    samefile = os.path.samefile

getatime = os.path.getatime
atime = property(
    getatime, None, None,
    """ Last access time of the file. """)

getmtime = os.path.getmtime
mtime = property(
    getmtime, None, None,
    """ Last-modified time of the file. """)

if hasattr(os.path, 'getctime'):
    getctime = os.path.getctime
    ctime = property(
        getctime, None, None,
        """ Creation time of the file. """)

getsize = os.path.getsize
size = property(
    getsize, None, None,
    """ Size of the file, in bytes. """)

if hasattr(os, 'access'):
    def access(self, mode):
        """ Return true if current user has access to this path.

        mode - One of the constants os.F_OK, os.R_OK, os.W_OK, os.X_OK
        """
        return os.access(self, mode)

def stat(self):
    """ Perform a stat() system call on this path. """
    return os.stat(self)

</t>
<t tx="ekr.20071201085751.1030">def lstat(self):
    """ Like path.stat(), but do not follow symbolic links. """
    return os.lstat(self)

</t>
<t tx="ekr.20071201085751.1031">def get_owner(self):
    r""" Return the name of the owner of this file or directory.

    This follows symbolic links.

    On Windows, this returns a name of the form ur'DOMAIN\User Name'.
    On Windows, a group can own a file or directory.
    """
    if os.name == 'nt':
        if win32security is None:
            raise Exception("path.owner requires win32all to be installed")
        desc = win32security.GetFileSecurity(
            self, win32security.OWNER_SECURITY_INFORMATION)
        sid = desc.GetSecurityDescriptorOwner()
        account, domain, typecode = win32security.LookupAccountSid(None, sid)
        return domain + u'\\' + account
    else:
        if pwd is None:
            raise NotImplementedError("path.owner is not implemented on this platform.")
        st = self.stat()
        return pwd.getpwuid(st.st_uid).pw_name

</t>
<t tx="ekr.20071201085751.1032">owner = property(
    get_owner, None, None,
    """ Name of the owner of this file or directory. """)

if hasattr(os, 'statvfs'):
    def statvfs(self):
        """ Perform a statvfs() system call on this path. """
        return os.statvfs(self)

if hasattr(os, 'pathconf'):
    def pathconf(self, name):
        return os.pathconf(self, name)


# --- Modifying operations on files and directories

def utime(self, times):
    """ Set the access and modified times of this file. """
    os.utime(self, times)

</t>
<t tx="ekr.20071201085751.1033">def chmod(self, mode):
    os.chmod(self, mode)

</t>
<t tx="ekr.20071201085751.1034">if hasattr(os, 'chown'):
    def chown(self, uid, gid):
        os.chown(self, uid, gid)

def rename(self, new):
    os.rename(self, new)

</t>
<t tx="ekr.20071201085751.1035">def renames(self, new):
    os.renames(self, new)


</t>
<t tx="ekr.20071201085751.1036"># --- Create/delete operations on directories

def mkdir(self, mode=0777):
    os.mkdir(self, mode)

</t>
<t tx="ekr.20071201085751.1037">def makedirs(self, mode=0777):
    os.makedirs(self, mode)

</t>
<t tx="ekr.20071201085751.1038">def rmdir(self):
    os.rmdir(self)

</t>
<t tx="ekr.20071201085751.1039">def removedirs(self):
    os.removedirs(self)


</t>
<t tx="ekr.20071201085751.1040"># --- Modifying operations on files

def touch(self):
    """ Set the access/modified times of this file to the current time.
    Create the file if it does not exist.
    """
    fd = os.open(self, os.O_WRONLY | os.O_CREAT, 0666)
    os.close(fd)
    os.utime(self, None)

</t>
<t tx="ekr.20071201085751.1041">def remove(self):
    os.remove(self)

</t>
<t tx="ekr.20071201085751.1042">def unlink(self):
    os.unlink(self)


</t>
<t tx="ekr.20071201085751.1043"># -*- coding: utf-8 -*-
"""Modified input prompt for entering quantities with units.

Modify the behavior of the interactive interpreter to allow direct input of
quantities with units without having to make a function call.

Now the following forms are accepted:

x = 4 m
y = -.45e3 m/s
g = 9.8 m/s**2
a = 2.3 m/s^2   # ^ -&gt; ** automatically

All other input is processed normally.
"""
#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

</t>
<t tx="ekr.20071201085751.1044"># This file is an example of how to modify IPython's line-processing behavior
# without touching the internal code. We'll define an alternate pre-processing
# stage which allows a special form of input (which is invalid Python syntax)
# for certain quantities, rewrites a line of proper Python in those cases, and
# then passes it off to IPython's normal processor for further work.

# With this kind of customization, IPython can be adapted for many
# special-purpose scenarios providing alternate input syntaxes.

# This file can be imported like a regular module.

# IPython has a prefilter() function that analyzes each input line. We redefine
# it here to first pre-process certain forms of input

# The prototype of any alternate prefilter must be like this one (the name
# doesn't matter):
# - line is a string containing the user input line.
# - continuation is a parameter which tells us if we are processing a first line of
#   user input or the second or higher of a multi-line statement.

def prefilter_PQ(self,line,continuation):
    """Alternate prefilter for input of PhysicalQuantityInteractive objects.

    This assumes that the function PhysicalQuantityInteractive() has been
    imported."""

    from re import match
    from IPython.iplib import InteractiveShell

    # This regexp is what does the real work
    unit_split = match(r'\s*(\w+)\s*=\s*(-?\d*\.?\d*[eE]?-?\d*)\s+([a-zA-Z].*)',
                       line)

    # If special input was ecnountered, process it:
    if unit_split:
        var,val,units = unit_split.groups()
        if var and val and units:
            units = units.replace('^','**')
            # Now a valid line needs to be constructed for IPython to process:
            line = var +" = PhysicalQuantityInteractive(" + val + ", '" + \
                   units + "')"
            #print 'New line:',line   # dbg
            
    # In the end, always call the default IPython _prefilter() function.  Note
    # that self must be passed explicitly, b/c we're calling the unbound class
    # method (since this method will overwrite the instance prefilter())
    return InteractiveShell._prefilter(self,line,continuation)

</t>
<t tx="ekr.20071201085751.1045"># -*- coding: utf-8 -*-
"""Modify the PhysicalQuantities class for more convenient interactive use.

Also redefine some math functions to operate on PhysQties with no need for
special method syntax. This just means moving them out to the global
namespace.

This module should always be loaded *after* math or Numeric, so it can
overwrite math functions with the versions that handle units."""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

from Scientific.Physics.PhysicalQuantities import PhysicalQuantity

# This code can be set up to work with Numeric or with math for providing the
# mathematical functions. Uncomment the one you prefer to use below.

# If you use math, sin(x) won't work for x an array, only float or PhysQty
import math

</t>
<t tx="ekr.20071201085751.1046"># If you use Numeric, sin(x) works for x a float, PhysQty an array.
#import Numeric as math

class PhysicalQuantityFunction:
    """Generic function wrapper for PhysicalQuantity instances.

    Calls functions from either the math library or the instance's methods as
    required.  Allows using sin(theta) or sqrt(v**2) syntax irrespective of
    whether theta is a pure number or a PhysicalQuantity.

    This is *slow*. It's meant for convenient interactive use, not for
    speed."""
    @others
</t>
<t tx="ekr.20071201085751.1047">
def __init__(self,name):
    self.name = name
    
</t>
<t tx="ekr.20071201085751.1048">def __call__(self,x):
    if isinstance(x,PhysicalQuantity):
        return PhysicalQuantity.__dict__[self.name](x)
    else:
        return math.__dict__[self.name](x)

</t>
<t tx="ekr.20071201085751.1049">class PhysicalQuantityInteractive(PhysicalQuantity):
    """Physical quantity with units - modified for Interactive use.

    Basically, the __str__ and __repr__ methods have been swapped for more
    convenient interactive use. Powers are shown as ^ instead of ** and only 4
    significant figures are shown.

    Also adds the following aliases for commonly used methods:
      b = PhysicalQuantity.inBaseUnits
      u = PhysicalQuantity.inUnitsOf
      
    These are useful when doing a lot of interactive calculations.
    """
    
    # shorthands for the most useful unit conversions
    b = PhysicalQuantity.inBaseUnits  # so you can just type x.b to get base units
    u = PhysicalQuantity.inUnitsOf

    @others
</t>
<t tx="ekr.20071201085751.1050"># This can be done, but it can get dangerous when coupled with IPython's
# auto-calling. Everything ends up shown in baseunits and things like x*2
# get automatically converted to k(*2), which doesn't work.
# Probably not a good idea in general...
#__call__ = b

def __str__(self):
    return PhysicalQuantity.__repr__(self)

</t>
<t tx="ekr.20071201085751.1051">def __repr__(self):
    value = '%.4G' % self.value
    units = self.unit.name().replace('**','^')
    return value + ' ' + units

</t>
<t tx="ekr.20071201085751.1052">#!/usr/bin/env python

""" PickleShare - a small 'shelve' like datastore with concurrency support

Like shelve, a PickleShareDB object acts like a normal dictionary. Unlike 
shelve, many processes can access the database simultaneously. Changing a 
value in database is immediately visible to other processes accessing the 
same database.

Concurrency is possible because the values are stored in separate files. Hence
the "database" is a directory where *all* files are governed by PickleShare.

Example usage::
    
    from pickleshare import *
    db = PickleShareDB('~/testpickleshare')
    db.clear()
    print "Should be empty:",db.items()
    db['hello'] = 15
    db['aku ankka'] = [1,2,313]
    db['paths/are/ok/key'] = [1,(5,46)]
    print db.keys()
    del db['aku ankka']

This module is certainly not ZODB, but can be used for low-load 
(non-mission-critical) situations where tiny code size trumps the 
advanced features of a "real" object database.

Installation guide: easy_install pickleshare

Author: Ville Vainio &lt;vivainio@gmail.com&gt;
License: MIT open source license.

"""

from path import path as Path
import os,stat,time
import cPickle as pickle
import UserDict
import warnings
import glob

</t>
<t tx="ekr.20071201085751.1053">class PickleShareDB(UserDict.DictMixin):
    """ The main 'connection' object for PickleShare database """
    @others
</t>
<t tx="ekr.20071201085751.1054">def __init__(self,root):
    """ Return a db object that will manage the specied directory"""
    self.root = Path(root).expanduser().abspath()
    if not self.root.isdir():
        self.root.makedirs()
    # cache has { 'key' : (obj, orig_mod_time) }
    self.cache = {}

</t>
<t tx="ekr.20071201085751.1055">def __getitem__(self,key):
    """ db['key'] reading """
    fil = self.root / key
    try:
        mtime = (fil.stat()[stat.ST_MTIME])
    except OSError:
        raise KeyError(key)

    if fil in self.cache and mtime == self.cache[fil][1]:
        return self.cache[fil][0]
    try:
        # The cached item has expired, need to read
        obj = pickle.load(fil.open())
    except:
        raise KeyError(key)
        
    self.cache[fil] = (obj,mtime)
    return obj

</t>
<t tx="ekr.20071201085751.1056">def __setitem__(self,key,value):
    """ db['key'] = 5 """
    fil = self.root / key
    parent = fil.parent
    if parent and not parent.isdir():
        parent.makedirs()
    pickled = pickle.dump(value,fil.open('w'))
    try:
        self.cache[fil] = (value,fil.mtime)
    except OSError,e:
        if e.errno != 2:
            raise

</t>
<t tx="ekr.20071201085751.1057">def __delitem__(self,key):
    """ del db["key"] """
    fil = self.root / key
    self.cache.pop(fil,None)
    try:
        fil.remove()
    except OSError:
        # notfound and permission denied are ok - we
        # lost, the other process wins the conflict
        pass
    
</t>
<t tx="ekr.20071201085751.1058">def _normalized(self, p):
    """ Make a key suitable for user's eyes """
    return str(self.root.relpathto(p)).replace('\\','/')

</t>
<t tx="ekr.20071201085751.1059">def keys(self, globpat = None):
    """ All keys in DB, or all keys matching a glob"""
    
    if globpat is None:
        files = self.root.walkfiles()
    else:
        files = [Path(p) for p in glob.glob(self.root/globpat)]
    return [self._normalized(p) for p in files if p.isfile()]

</t>
<t tx="ekr.20071201085751.1060">def uncache(self,*items):
    """ Removes all, or specified items from cache
    
    Use this after reading a large amount of large objects
    to free up memory, when you won't be needing the objects
    for a while.
     
    """
    if not items:
        self.cache = {}
    for it in items:
        self.cache.pop(it,None)
        
</t>
<t tx="ekr.20071201085751.1061">def waitget(self,key, maxwaittime = 60 ):
    """ Wait (poll) for a key to get a value
    
    Will wait for `maxwaittime` seconds before raising a KeyError.
    The call exits normally if the `key` field in db gets a value
    within the timeout period.
    
    Use this for synchronizing different processes or for ensuring
    that an unfortunately timed "db['key'] = newvalue" operation 
    in another process (which causes all 'get' operation to cause a 
    KeyError for the duration of pickling) won't screw up your program 
    logic. 
    """
    
    wtimes = [0.2] * 3 + [0.5] * 2 + [1]
    tries = 0
    waited = 0
    while 1:
        try:
            val = self[key]
            return val
        except KeyError:
            pass
        
        if waited &gt; maxwaittime:
            raise KeyError(key)
        
        time.sleep(wtimes[tries])
        waited+=wtimes[tries]
        if tries &lt; len(wtimes) -1:
            tries+=1

</t>
<t tx="ekr.20071201085751.1062">def getlink(self,folder):
    """ Get a convenient link for accessing items  """
    return PickleShareLink(self, folder)

</t>
<t tx="ekr.20071201085751.1063">def __repr__(self):
    return "PickleShareDB('%s')" % self.root
    
    
            
</t>
<t tx="ekr.20071201085751.1064">class PickleShareLink:
    """ A shortdand for accessing nested PickleShare data conveniently.

    Created through PickleShareDB.getlink(), example::

        lnk = db.getlink('myobjects/test')
        lnk.foo = 2
        lnk.bar = lnk.foo + 5
    
    """
    @others
</t>
<t tx="ekr.20071201085751.1065">def __init__(self, db, keydir ):    
    self.__dict__.update(locals())
    
</t>
<t tx="ekr.20071201085751.1066">def __getattr__(self,key):
    return self.__dict__['db'][self.__dict__['keydir']+'/' + key]
</t>
<t tx="ekr.20071201085751.1067">def __setattr__(self,key,val):
    self.db[self.keydir+'/' + key] = val
</t>
<t tx="ekr.20071201085751.1068">def __repr__(self):
    db = self.__dict__['db']
    keys = db.keys( self.__dict__['keydir'] +"/*")
    return "&lt;PickleShareLink '%s': %s&gt;" % (
        self.__dict__['keydir'],
        ";".join([Path(k).basename() for k in keys]))
        
    
</t>
<t tx="ekr.20071201085751.1069">def test():
    db = PickleShareDB('~/testpickleshare')
    db.clear()
    print "Should be empty:",db.items()
    db['hello'] = 15
    db['aku ankka'] = [1,2,313]
    db['paths/nest/ok/keyname'] = [1,(5,46)]
    print db.keys()
    print db.keys('paths/nest/ok/k*')
    print dict(db) # snapsot of whole db
    db.uncache() # frees memory, causes re-reads later

    # shorthand for accessing deeply nested files
    lnk = db.getlink('myobjects/test')
    lnk.foo = 2
    lnk.bar = lnk.foo + 5
    print lnk.bar # 7

</t>
<t tx="ekr.20071201085751.1070">def stress():
    db = PickleShareDB('~/fsdbtest')
    import time,sys
    for i in range(1000):
        for j in range(300):
            if i % 15 == 0 and i &lt; 200:
                if str(j) in db:
                    del db[str(j)]
                continue

            if j%33 == 0:
                time.sleep(0.02)
            
            db[str(j)] = db.get(str(j), []) + [(i,j,"proc %d" % os.getpid())]
        print i,
        sys.stdout.flush()
        if i % 10 == 0:
            db.uncache()
    
</t>
<t tx="ekr.20071201085751.1071">def main():
    import textwrap
    usage = textwrap.dedent("""\
    pickleshare - manage PickleShare databases 
    
    Usage:
        
        pickleshare dump /path/to/db &gt; dump.txt
        pickleshare load /path/to/db &lt; dump.txt
        pickleshare test /path/to/db
    """)
    DB = PickleShareDB
    import sys
    if len(sys.argv) &lt; 2:
        print usage
        return
        
    cmd = sys.argv[1]
    args = sys.argv[2:]
    if cmd == 'dump':
        if not args: args= ['.']
        db = DB(args[0])
        import pprint
        pprint.pprint(db.items())
    elif cmd == 'load':
        cont = sys.stdin.read()
        db = DB(args[0])
        data = eval(cont)
        db.clear()
        for k,v in db.items():
            db[k] = v
    elif cmd == 'testwait':
        db = DB(args[0])
        db.clear()
        print db.waitget('250')
    elif cmd == 'test':
        test()
        stress()
    
</t>
<t tx="ekr.20071201085751.1072"># -*- coding: utf-8 -*-
"""
%store magic for lightweight persistence.

Stores variables, aliases etc. in PickleShare database.

$Id$
"""

import IPython.ipapi
ip = IPython.ipapi.get()

import pickleshare

import inspect,pickle,os,sys,textwrap
from IPython.FakeModule import FakeModule

</t>
<t tx="ekr.20071201085751.1073">def restore_aliases(self):
    ip = self.getapi()
    staliases = ip.db.get('stored_aliases', {})
    for k,v in staliases.items():
        #print "restore alias",k,v # dbg
        self.alias_table[k] = v


</t>
<t tx="ekr.20071201085751.1074">def refresh_variables(ip):
    db = ip.db
    for key in db.keys('autorestore/*'):
        # strip autorestore
        justkey = os.path.basename(key)
        try:
            obj = db[key]
        except KeyError:
            print "Unable to restore variable '%s', ignoring (use %%store -d to forget!)" % justkey
            print "The error was:",sys.exc_info()[0]
        else:
            #print "restored",justkey,"=",obj #dbg
            ip.user_ns[justkey] = obj
    
    

</t>
<t tx="ekr.20071201085751.1075">def restore_data(self):
    ip = self.getapi()
    refresh_variables(ip)
    restore_aliases(self)
    raise IPython.ipapi.TryNext
    
</t>
<t tx="ekr.20071201085751.1076">ip.set_hook('late_startup_hook', restore_data)

def magic_store(self, parameter_s=''):
    """Lightweight persistence for python variables.

    Example:
    
    ville@badger[~]|1&gt; A = ['hello',10,'world']\\
    ville@badger[~]|2&gt; %store A\\
    ville@badger[~]|3&gt; Exit
    
    (IPython session is closed and started again...)
    
    ville@badger:~$ ipython -p pysh\\
    ville@badger[~]|1&gt; print A
    
    ['hello', 10, 'world']
    
    Usage:
    
    %store          - Show list of all variables and their current values\\
    %store &lt;var&gt;    - Store the *current* value of the variable to disk\\
    %store -d &lt;var&gt; - Remove the variable and its value from storage\\
    %store -z       - Remove all variables from storage\\
    %store -r       - Refresh all variables from store (delete current vals)\\
    %store foo &gt;a.txt  - Store value of foo to new file a.txt\\
    %store foo &gt;&gt;a.txt - Append value of foo to file a.txt\\   
    
    It should be noted that if you change the value of a variable, you
    need to %store it again if you want to persist the new value.
    
    Note also that the variables will need to be pickleable; most basic
    python types can be safely %stored.
    
    Also aliases can be %store'd across sessions.
    """
    
    opts,argsl = self.parse_options(parameter_s,'drz',mode='string')
    args = argsl.split(None,1)
    ip = self.getapi()
    db = ip.db
    # delete
    if opts.has_key('d'):
        try:
            todel = args[0]
        except IndexError:
            error('You must provide the variable to forget')
        else:
            try:
                del db['autorestore/' + todel]
            except:
                error("Can't delete variable '%s'" % todel)
    # reset
    elif opts.has_key('z'):
        for k in db.keys('autorestore/*'):
            del db[k]

    elif opts.has_key('r'):
        refresh_variables(ip)

    
    # run without arguments -&gt; list variables &amp; values
    elif not args:
        vars = self.db.keys('autorestore/*')
        vars.sort()            
        if vars:
            size = max(map(len,vars))
        else:
            size = 0
            
        print 'Stored variables and their in-db values:'
        fmt = '%-'+str(size)+'s -&gt; %s'
        get = db.get
        for var in vars:
            justkey = os.path.basename(var)
            # print 30 first characters from every var
            print fmt % (justkey,repr(get(var,'&lt;unavailable&gt;'))[:50])
    
    # default action - store the variable
    else:
        # %store foo &gt;file.txt or &gt;&gt;file.txt
        if len(args) &gt; 1 and args[1].startswith('&gt;'):
            fnam = os.path.expanduser(args[1].lstrip('&gt;').lstrip())
            if args[1].startswith('&gt;&gt;'):
                fil = open(fnam,'a')
            else:
                fil = open(fnam,'w')
            obj = ip.ev(args[0])
            print "Writing '%s' (%s) to file '%s'." % (args[0],
              obj.__class__.__name__, fnam)

            
            if not isinstance (obj,basestring):
                from pprint import pprint
                pprint(obj,fil)
            else:
                fil.write(obj)
                if not obj.endswith('\n'):
                    fil.write('\n')
            
            fil.close()
            return
        
        # %store foo
        try:
            obj = ip.user_ns[args[0]]
        except KeyError:
            # it might be an alias
            if args[0] in self.alias_table:
                staliases = db.get('stored_aliases',{})
                staliases[ args[0] ] = self.alias_table[ args[0] ]
                db['stored_aliases'] = staliases                
                print "Alias stored:", args[0], self.alias_table[ args[0] ]
                return
            else:
                print "Error: unknown variable '%s'" % args[0]
            
        else:
            if isinstance(inspect.getmodule(obj), FakeModule):
                print textwrap.dedent("""\
                Warning:%s is %s 
                Proper storage of interactively declared classes (or instances
                of those classes) is not possible! Only instances
                of classes in real modules on file system can be %%store'd.
                """ % (args[0], obj) ) 
                return
            #pickled = pickle.dumps(obj)
            self.db[ 'autorestore/' + args[0] ] = obj
            print "Stored '%s' (%s)" % (args[0], obj.__class__.__name__)

</t>
<t tx="ekr.20071201085751.1077">import IPython.ipapi

ip = IPython.ipapi.get()

</t>
<t tx="ekr.20071201085751.1078">def clip_f( self, parameter_s = '' ):
    """Save a set of lines to the clipboard.

    Usage:\\
      %clip n1-n2 n3-n4 ... n5 .. n6 ...

    This function uses the same syntax as %macro for line extraction, but
    instead of creating a macro it saves the resulting string to the
    clipboard.
    
    When used without arguments, this returns the text contents of the clipboard. 
    E.g.
    
    mytext = %clip
    
    """

    import win32clipboard as cl
    import win32con
    args = parameter_s.split()
    cl.OpenClipboard()
    if len( args ) == 0:
        data = cl.GetClipboardData( win32con.CF_TEXT )
        cl.CloseClipboard()
        return data
    api = self.getapi()
    
    if parameter_s.lstrip().startswith('='):
        rest = parameter_s[parameter_s.index('=')+1:].strip()
        val = str(api.ev(rest))
    else:
        ranges = args[0:]
        val = ''.join( self.extract_input_slices( ranges ) )

    cl.EmptyClipboard()
    cl.SetClipboardText( val )
    cl.CloseClipboard()
    print 'The following text was written to the clipboard'
    print val
    
</t>
<t tx="ekr.20071201085751.1079"># -*- coding: utf-8 -*-
"""This directory is meant for special-purpose extensions to IPython.

This can include things which alter the syntax processing stage (see
PhysicalQ_Input for an example of how to do this).

Any file located here can be called with an 'execfile =' option as

  execfile = Extensions/filename.py

since the IPython directory itself is already part of the search path for
files listed as 'execfile ='.
"""
</t>
<t tx="ekr.20071201085751.1080">"""Shell mode for IPython.

Start ipython in shell mode by invoking "ipython -p sh"

(the old version, "ipython -p pysh" still works but this is the more "modern" 
shell mode and is recommended for users who don't care about pysh-mode
compatibility)
"""

from IPython import ipapi
import os,textwrap

# The import below effectively obsoletes your old-style ipythonrc[.ini],
# so consider yourself warned!

import ipy_defaults

</t>
<t tx="ekr.20071201085751.1081">def main():
    ip = ipapi.get()
    o = ip.options
    # autocall to "full" mode (smart mode is default, I like full mode)
    
    o.autocall = 2
    
    # Jason Orendorff's path class is handy to have in user namespace
    # if you are doing shell-like stuff
    try:
        ip.ex("from path import path" )
    except ImportError:
        pass
    
    ip.ex('import os')
    ip.ex("def up(): os.chdir('..')")
        
    # Get pysh-like prompt for all profiles. 
    
    o.prompt_in1= '\C_LightBlue[\C_LightCyan\Y1\C_LightBlue]\C_Green|\#&gt; '
    o.prompt_in2= '\C_Green|\C_LightGreen\D\C_Green&gt; '
    o.prompt_out= '&lt;\#&gt; '
    
    from IPython import Release

    import sys
    # I like my banner minimal.
    o.banner = "Py %s IPy %s\n" % (sys.version.split('\n')[0],Release.version)
    
    # make 'd' an alias for ls -F
    
    ip.magic('alias d ls -F --color=auto')
    
    # Make available all system commands through "rehashing" immediately. 
    # You can comment these lines out to speed up startup on very slow 
    # machines, and to conserve a bit of memory. Note that pysh profile does this
    # automatically
    ip.IP.default_option('cd','-q')
    

    o.prompts_pad_left="1"
    # Remove all blank lines in between prompts, like a normal shell.
    o.separate_in="0"
    o.separate_out="0"
    o.separate_out2="0"
    
    # now alias all syscommands
    
    db = ip.db
    
    syscmds = db.get("syscmdlist",[] )
    if not syscmds:
        print textwrap.dedent("""
        System command list not initialized, probably the first run...
        running %rehashx to refresh the command list. Run %rehashx
        again to refresh command list (after installing new software etc.)
        """)
        ip.magic('rehashx')
        syscmds = db.get("syscmdlist")
    for cmd in syscmds:
        #print "al",cmd
        noext, ext = os.path.splitext(cmd)
        ip.IP.alias_table[noext] = (0,cmd)
    extend_shell_behavior(ip)

</t>
<t tx="ekr.20071201085751.1082">def extend_shell_behavior(ip):

    # Instead of making signature a global variable tie it to IPSHELL.
    # In future if it is required to distinguish between different
    # shells we can assign a signature per shell basis
    ip.IP.__sig__ = 0xa005
    # mark the IPSHELL with this signature
    ip.IP.user_ns['__builtins__'].__dict__['__sig__'] = ip.IP.__sig__

    from IPython.Itpl import ItplNS
    from IPython.genutils import shell
    # utility to expand user variables via Itpl
    # xxx do something sensible with depth?
    ip.IP.var_expand = lambda cmd, lvars=None, depth=2: \
        str(ItplNS(cmd.replace('#','\#'), ip.IP.user_ns, get_locals()))

    def get_locals():
        """ Substituting a variable through Itpl deep inside the IPSHELL stack
            requires the knowledge of all the variables in scope upto the last
            IPSHELL frame. This routine simply merges all the local variables
            on the IPSHELL stack without worrying about their scope rules
        """
        import sys
        # note lambda expression constitues a function call
        # hence fno should be incremented by one
        getsig = lambda fno: sys._getframe(fno+1).f_globals \
                             ['__builtins__'].__dict__['__sig__']
        getlvars = lambda fno: sys._getframe(fno+1).f_locals
        # trackback until we enter the IPSHELL
        frame_no = 1
        sig = ip.IP.__sig__
        fsig = ~sig
        while fsig != sig :
            try:
                fsig = getsig(frame_no)
            except (AttributeError, KeyError):
                frame_no += 1
            except ValueError:
                # stack is depleted
                # call did not originate from IPSHELL
                return {}
        first_frame = frame_no
        # walk further back until we exit from IPSHELL or deplete stack
        try:
            while(sig == getsig(frame_no+1)):
                frame_no += 1
        except (AttributeError, KeyError, ValueError):
            pass
        # merge the locals from top down hence overriding
        # any re-definitions of variables, functions etc.
        lvars = {}
        for fno in range(frame_no, first_frame-1, -1):
            lvars.update(getlvars(fno))
        #print '\n'*5, first_frame, frame_no, '\n', lvars, '\n'*5 #dbg
        return lvars

    def _runlines(lines):
        """Run a string of one or more lines of source.

        This method is capable of running a string containing multiple source
        lines, as if they had been entered at the IPython prompt.  Since it
        exposes IPython's processing machinery, the given strings can contain
        magic calls (%magic), special shell access (!cmd), etc."""

        # We must start with a clean buffer, in case this is run from an
        # interactive IPython session (via a magic, for example).
        ip.IP.resetbuffer()
        lines = lines.split('\n')
        more = 0
        command = ''
        for line in lines:
            # skip blank lines so we don't mess up the prompt counter, but do
            # NOT skip even a blank line if we are in a code block (more is
            # true)
            # if command is not empty trim the line
            if command != '' :
                line = line.strip()
            # add the broken line to the command
            if line and line[-1] == '\\' :
                command += line[0:-1] + ' '
                more = True
                continue
            else :
                # add the last (current) line to the command
                command += line
                if command or more:
                    more = ip.IP.push(ip.IP.prefilter(command,more))
                    command = ''
                    # IPython's runsource returns None if there was an error
                    # compiling the code.  This allows us to stop processing right
                    # away, so the user gets the error message at the right place.
                    if more is None:
                        break
        # final newline in case the input didn't have it, so that the code
        # actually does get executed
        if more:
            ip.IP.push('\n')

    ip.IP.runlines = _runlines

</t>
<t tx="ekr.20071201085751.1083">""" User configuration file for IPython

This is a more flexible and safe way to configure ipython than *rc files
(ipythonrc, ipythonrc-pysh etc.)

This file is always imported on ipython startup. You can import the
ipython extensions you need here (see IPython/Extensions directory).

Feel free to edit this file to customize your ipython experience.

Note that as such this file does nothing, for backwards compatibility.
Consult e.g. file 'ipy_profile_sh.py' for an example of the things 
you can do here.

See http://ipython.scipy.org/moin/IpythonExtensionApi for detailed
description on what you could do here.
"""

# Most of your config files and extensions will probably start with this import

import IPython.ipapi
ip = IPython.ipapi.get()

</t>
<t tx="ekr.20071201085751.1084"># You probably want to uncomment this if you did %upgrade -nolegacy
# import ipy_defaults    

def main():
    # Handy tab-completers for %cd, %run, import etc.
    # Try commenting this out if you have completion problems/slowness
    import ipy_stock_completers 
    
    o = ip.options
    # An example on how to set options
    #o.autocall = 1

</t>
<t tx="ekr.20071201085751.1085"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Jack Trainor.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
###################################
#
# Based on recipe posted to ctypes-users
# see archive
# http://aspn.activestate.com/ASPN/Mail/Message/ctypes-users/1771866
#
#


###################################################################################
#
# The Python win32clipboard lib functions work well enough ... except that they
# can only cut and paste items from within one application, not across
# applications or processes.
#
# I've written a number of Python text filters I like to run on the contents of
# the clipboard so I need to call the Windows clipboard API with global memory
# for my filters to work properly.
#
# Here's some sample code solving this problem using ctypes.
#
# This is my first work with ctypes.  It's powerful stuff, but passing arguments
# in and out of functions is tricky.  More sample code would have been helpful,
# hence this contribution.
#
###################################################################################

from ctypes import *
from winconstants import CF_TEXT, GHND
    
OpenClipboard = windll.user32.OpenClipboard
EmptyClipboard = windll.user32.EmptyClipboard
GetClipboardData = windll.user32.GetClipboardData
GetClipboardFormatName = windll.user32.GetClipboardFormatNameA
SetClipboardData = windll.user32.SetClipboardData
EnumClipboardFormats = windll.user32.EnumClipboardFormats
CloseClipboard = windll.user32.CloseClipboard
OpenClipboard.argtypes=[c_int]
EnumClipboardFormats.argtypes=[c_int]
CloseClipboard.argtypes=[]
GetClipboardFormatName.argtypes=[c_uint,c_char_p,c_int]
GetClipboardData.argtypes=[c_int]
SetClipboardData.argtypes=[c_int,c_int]

GlobalLock = windll.kernel32.GlobalLock
GlobalAlloc = windll.kernel32.GlobalAlloc
GlobalUnlock = windll.kernel32.GlobalUnlock
GlobalLock.argtypes=[c_int]
GlobalUnlock.argtypes=[c_int]
memcpy = cdll.msvcrt.memcpy

</t>
<t tx="ekr.20071201085751.1086">def enum():
    OpenClipboard(0)
    q=EnumClipboardFormats(0)
    while q:
        print q,
        q=EnumClipboardFormats(q)
    CloseClipboard()

</t>
<t tx="ekr.20071201085751.1087">def getformatname(format):
    buffer = c_buffer(" "*100)
    bufferSize = sizeof(buffer)
    OpenClipboard(0)
    GetClipboardFormatName(format,buffer,bufferSize)
    CloseClipboard()
    return buffer.value

</t>
<t tx="ekr.20071201085751.1088">def GetClipboardText():
    text = ""
    if OpenClipboard(0):
        hClipMem = GetClipboardData(CF_TEXT)
        if hClipMem:        
            GlobalLock.restype = c_char_p
            text = GlobalLock(hClipMem)
            GlobalUnlock(hClipMem)
        CloseClipboard()
    return text

</t>
<t tx="ekr.20071201085751.1089">def make_tab(lists):
    if hasattr(lists,"tolist"):
        lists=lists.tolist()
    ut=[]
    for rad in lists:
        if type(rad) in [list,tuple]:
            ut.append("\t".join(["%s"%x for x in rad]))
        else:
            ut.append("%s"%rad)
    return "\n".join(ut)            
    
</t>
<t tx="ekr.20071201085751.1090">def send_data(lists):
    SetClipboardText(make_tab(lists))
    
</t>
<t tx="ekr.20071201085751.1091">def SetClipboardText(text):
    buffer = c_buffer(text)
    bufferSize = sizeof(buffer)
    hGlobalMem = GlobalAlloc(c_int(GHND), c_int(bufferSize))
    GlobalLock.restype = c_void_p
    lpGlobalMem = GlobalLock(c_int(hGlobalMem))
    memcpy(lpGlobalMem, addressof(buffer), c_int(bufferSize))
    GlobalUnlock(c_int(hGlobalMem))
    if OpenClipboard(0):
        EmptyClipboard()
        SetClipboardData(c_int(CF_TEXT), c_int(hGlobalMem))
        CloseClipboard()


</t>
<t tx="ekr.20071201085751.1092">def set_clipboard_text(toclipboard):
    SetClipboardText(str(toclipboard))

</t>
<t tx="ekr.20071201085751.1093">def make_list_of_list(txt):
    def make_num(x):
        try:
            return int(x)
        except ValueError:
            try:
                return float(x)
            except ValueError:
                try:
                    return complex(x)
                except ValueError:
                    return x
        return x                
    ut=[]
    flag=False
    for rad in [x for x in txt.split("\r\n") if x!=""]:
        raden=[make_num(x) for x in rad.split("\t")]
        if str in map(type,raden):
            flag=True
        ut.append(raden)
    return ut,flag


</t>
<t tx="ekr.20071201085751.1094">def get_clipboard_text_and_convert(paste_list=False):
    """Get txt from clipboard. if paste_list==True the convert tab separated 
    data to list of lists. Enclose list of list in array() if all elements are 
    numeric"""
    txt=GetClipboardText()
    if txt:
        if paste_list and "\t" in txt:
            array,flag=make_list_of_list(txt)
            if flag:
                txt=repr(array)
            else:
                txt="array(%s)"%repr(array)
            txt="".join([c for c in txt if c not in " \t\r\n"])
    return txt

</t>
<t tx="ekr.20071201085751.1095"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************


class ReadlineError(Exception):
    pass

</t>
<t tx="ekr.20071201085751.1096">class GetSetError(ReadlineError):
    pass
</t>
<t tx="ekr.20071201085751.1097">from rlmain import *

rl = Readline()

</t>
<t tx="ekr.20071201085751.1098">def GetOutputFile():
    '''Return the console object used by readline so that it can be used for printing in color.'''
    return rl.console

</t>
<t tx="ekr.20071201085751.1099"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
import winconstants as c32
from ctypes import windll
import ctypes
# table for translating virtual keys to X windows key symbols
code2sym_map = {c32.VK_CANCEL: 'Cancel',
                c32.VK_BACK: 'BackSpace',
                c32.VK_TAB: 'Tab',
                c32.VK_CLEAR: 'Clear',
                c32.VK_RETURN: 'Return',
                c32.VK_SHIFT:'Shift_L',
                c32.VK_CONTROL: 'Control_L',
                c32.VK_MENU: 'Alt_L',
                c32.VK_PAUSE: 'Pause',
                c32.VK_CAPITAL: 'Caps_Lock',
                c32.VK_ESCAPE: 'Escape',
                c32.VK_SPACE: 'space',
                c32.VK_PRIOR: 'Prior',
                c32.VK_NEXT: 'Next',
                c32.VK_END: 'End',
                c32.VK_HOME: 'Home',
                c32.VK_LEFT: 'Left',
                c32.VK_UP: 'Up',
                c32.VK_RIGHT: 'Right',
                c32.VK_DOWN: 'Down',
                c32.VK_SELECT: 'Select',
                c32.VK_PRINT: 'Print',
                c32.VK_EXECUTE: 'Execute',
                c32.VK_SNAPSHOT: 'Snapshot',
                c32.VK_INSERT: 'Insert',
                c32.VK_DELETE: 'Delete',
                c32.VK_HELP: 'Help',
                c32.VK_F1: 'F1',
                c32.VK_F2: 'F2',
                c32.VK_F3: 'F3',
                c32.VK_F4: 'F4',
                c32.VK_F5: 'F5',
                c32.VK_F6: 'F6',
                c32.VK_F7: 'F7',
                c32.VK_F8: 'F8',
                c32.VK_F9: 'F9',
                c32.VK_F10: 'F10',
                c32.VK_F11: 'F11',
                c32.VK_F12: 'F12',
                c32.VK_F13: 'F13',
                c32.VK_F14: 'F14',
                c32.VK_F15: 'F15',
                c32.VK_F16: 'F16',
                c32.VK_F17: 'F17',
                c32.VK_F18: 'F18',
                c32.VK_F19: 'F19',
                c32.VK_F20: 'F20',
                c32.VK_F21: 'F21',
                c32.VK_F22: 'F22',
                c32.VK_F23: 'F23',
                c32.VK_F24: 'F24',
                c32.VK_NUMLOCK: 'Num_Lock,',
                c32.VK_SCROLL: 'Scroll_Lock',
                c32.VK_APPS: 'VK_APPS',
                c32.VK_PROCESSKEY: 'VK_PROCESSKEY',
                c32.VK_ATTN: 'VK_ATTN',
                c32.VK_CRSEL: 'VK_CRSEL',
                c32.VK_EXSEL: 'VK_EXSEL',
                c32.VK_EREOF: 'VK_EREOF',
                c32.VK_PLAY: 'VK_PLAY',
                c32.VK_ZOOM: 'VK_ZOOM',
                c32.VK_NONAME: 'VK_NONAME',
                c32.VK_PA1: 'VK_PA1',
                c32.VK_OEM_CLEAR: 'VK_OEM_CLEAR',
                c32.VK_NUMPAD0: 'NUMPAD0',
                c32.VK_NUMPAD1: 'NUMPAD1',
                c32.VK_NUMPAD2: 'NUMPAD2',
                c32.VK_NUMPAD3: 'NUMPAD3',
                c32.VK_NUMPAD4: 'NUMPAD4',
                c32.VK_NUMPAD5: 'NUMPAD5',
                c32.VK_NUMPAD6: 'NUMPAD6',
                c32.VK_NUMPAD7: 'NUMPAD7',
                c32.VK_NUMPAD8: 'NUMPAD8',
                c32.VK_NUMPAD9: 'NUMPAD9',
                c32.VK_DIVIDE: 'Divide',
                c32.VK_MULTIPLY: 'Multiply',
                c32.VK_ADD: 'Add',
                c32.VK_SUBTRACT: 'Subtract',
                c32.VK_DECIMAL: 'VK_DECIMAL'
               }

</t>
<t tx="ekr.20071201085751.1100"># function to handle the mapping
def make_keysym(keycode):
    try:
        sym = code2sym_map[keycode]
    except KeyError:
        sym = ''
    return sym

</t>
<t tx="ekr.20071201085751.1101">sym2code_map = {}
for code,sym in code2sym_map.iteritems():
    sym2code_map[sym.lower()] = code

def key_text_to_keyinfo(keytext):
    '''Convert a GNU readline style textual description of a key to keycode with modifiers'''
    if keytext.startswith('"'): # "
        return keyseq_to_keyinfo(keytext[1:-1])
    else:
        return keyname_to_keyinfo(keytext)

</t>
<t tx="ekr.20071201085751.1102">VkKeyScan = windll.user32.VkKeyScanA

def char_to_keyinfo(char, control=False, meta=False, shift=False):
    vk = VkKeyScan(ord(char))
    if vk &amp; 0xffff == 0xffff:
        print 'VkKeyScan("%s") = %x' % (char, vk)
        raise ValueError, 'bad key'
    if vk &amp; 0x100:
        shift = True
    if vk &amp; 0x200:
        control = True
    if vk &amp; 0x400:
        meta = True
    return (control, meta, shift, vk &amp; 0xff)

</t>
<t tx="ekr.20071201085751.1103">def keyname_to_keyinfo(keyname):
    control = False
    meta = False
    shift = False

    while 1:
        lkeyname = keyname.lower()
        if lkeyname.startswith('control-'):
            control = True
            keyname = keyname[8:]
        elif lkeyname.startswith('meta-'):
            meta = True
            keyname = keyname[5:]
        elif lkeyname.startswith('alt-'):
            meta = True
            keyname = keyname[4:]
        elif lkeyname.startswith('shift-'):
            shift = True
            keyname = keyname[6:]
        else:
            if len(keyname) &gt; 1:
                return (control, meta, shift, sym2code_map[keyname.lower()])
            else:
                return char_to_keyinfo(keyname, control, meta, shift)

</t>
<t tx="ekr.20071201085751.1104">def keyseq_to_keyinfo(keyseq):
    res = []
    control = False
    meta = False
    shift = False

    while 1:
        if keyseq.startswith('\\C-'):
            control = True
            keyseq = keyseq[3:]
        elif keyseq.startswith('\\M-'):
            meta = True
            keyseq = keyseq[3:]
        elif keyseq.startswith('\\e'):
            res.append(char_to_keyinfo('\033', control, meta, shift))
            control = meta = shift = False
            keyseq = keyseq[2:]
        elif len(keyseq) &gt;= 1:
            res.append(char_to_keyinfo(keyseq[0], control, meta, shift))
            control = meta = shift = False
            keyseq = keyseq[1:]
        else:
            return res[0]

</t>
<t tx="ekr.20071201085751.1105">def make_keyinfo(keycode, state):
    control = (state &amp; (4+8)) != 0
    meta = (state &amp; (1+2)) != 0
    shift = (state &amp; 0x10) != 0
    return (control, meta, shift, keycode)
</t>
<t tx="ekr.20071201085751.1106"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

import socket
_logfile=False

</t>
<t tx="ekr.20071201085751.1107">def start_log(on,filename):
    global _logfile
    if on=="on":
        _logfile=open(filename,"w")
    else:
        _logfile=False
        
</t>
<t tx="ekr.20071201085751.1108">def log(s):
    if _logfile:
        print &gt;&gt;_logfile, s
        _logfile.flush()


</t>
<t tx="ekr.20071201085751.1109">host="localhost"
port=8081
logsocket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

show_event=["keypress","bound_function","bind_key","console"]
show_event=["bound_function"]

sock_silent=True

def log_sock(s,event_type=None):
    if sock_silent:
        pass
    else:
        if event_type is None:
            logsocket.sendto(s,(host,port))
        elif event_type in show_event:
            logsocket.sendto(s,(host,port))
        else:
            pass

    
</t>
<t tx="ekr.20071201085751.1110"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
import socket


try:
    import msvcrt
except ImportError:
    msvcrt=None
    print "problem"
        


port =8081

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

s.bind(("",port))
s.settimeout(0.05)

print "Starting logserver on port:",port
print "Press q to quit logserver",port
singleline=False


</t>
<t tx="ekr.20071201085751.1111">def check_key():
    if msvcrt is None:
        return False
    else:
        if msvcrt.kbhit()!=0:
            q=msvcrt.getch()
            
            return q in "q" 
        else:
            return False


</t>
<t tx="ekr.20071201085751.1112"># -*- coding: utf-8 -*-
"""Release data for the pyreadline project.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

# Name of the package for release purposes.  This is the name which labels
# the tarballs and RPMs made by distutils, so it's best to lowercase it.
name = 'pyreadline'

# For versions with substrings (like 0.6.16.svn), use an extra . to separate
# the new substring.  We have to avoid using either dashes or underscores,
# because bdist_rpm does not accept dashes (an RPM) convention, and
# bdist_deb does not accept underscores (a Debian convention).

branch = ''

version = '1.4.4'

revision = '$Revision$'

description = "A python implmementation of GNU readline."

long_description = \
"""
The pyreadline package is a python implementation of GNU readline functionality
it is based on the ctypes based UNC readline package by Gary Bishop. 
It is not complete. It has been tested for use with windows 2000 and windows xp.

Features:
 *  NEW: keyboard text selection and copy/paste
 *  Shift-arrowkeys for text selection
 *  Control-c can be used for copy activate with allow_ctrl_c(True) is config file
 *  Double tapping ctrl-c will raise a KeyboardInterrupt, use ctrl_c_tap_time_interval(x)
    where x is your preferred tap time window, default 0.3 s.
 *  paste pastes first line of content on clipboard. 
 *  ipython_paste, pastes tab-separated data as list of lists or numpy array if all data is numeric
 *  paste_mulitline_code  pastes multi line code, removing any empty lines.
 *  Experimental support for ironpython. At this time Ironpython has to be patched for it to work.
 
 
 The latest development version is always available at the IPython subversion
 repository_.

.. _repository: http://ipython.scipy.org/svn/ipython/pyreadline/trunk#egg=pyreadline-dev
 """

license = 'BSD'

authors = {'Jorgen' : ('Jorgen Stenarson','jorgen.stenarson@bostream.nu'),
           'Gary':    ('Gary Bishop', ''),         
           'Jack':    ('Jack Trainor', ''),         
           }

url = 'http://ipython.scipy.org/moin/PyReadline/Intro'

download_url = ''

platforms = ['Windows XP/2000/NT','Windows 95/98/ME']

keywords = ['readline','pyreadline']

classifiers = ['Development Status :: 4 - Beta',
               'Environment :: Console',
               'Operating System :: Microsoft :: Windows',]
               
               
</t>
<t tx="ekr.20071201085751.1113"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
''' an attempt to implement readline for Python in Python using ctypes'''
import sys,os,re
from glob import glob

import clipboard,logger,console
from   logger import log,log_sock
from error import ReadlineError,GetSetError
from   pyreadline.keysyms.common import make_KeyPress_from_keydescr

import pyreadline.lineeditor.lineobj as lineobj
import pyreadline.lineeditor.history as history
import release

from modes import editingmodes

in_ironpython="IronPython" in sys.version
if in_ironpython:#ironpython does not provide a prompt string to readline
    import System    
    default_prompt="&gt;&gt;&gt; "
else:
    default_prompt=""
    import pdb


</t>
<t tx="ekr.20071201085751.1114">def quote_char(c):
    if ord(c)&gt;0:
        return c

</t>
<t tx="ekr.20071201085751.1115">def inword(buffer,point):
    return buffer[point:point+1] in [A-Za-z0-9]


</t>
<t tx="ekr.20071201085751.1116">class Readline(object):
    @others
</t>
<t tx="ekr.20071201085751.1117">def __init__(self):
    self.startup_hook = None
    self.pre_input_hook = None
    self.completer = None
    self.completer_delims = " \t\n\"\\'`@$&gt;&lt;=;|&amp;{("
    self.console = console.Console()
    self.size = self.console.size()
    self.prompt_color = None
    self.command_color = None
    self.selection_color = self.console.saveattr&lt;&lt;4
    self.key_dispatch = {}
    self.previous_func = None
    self.first_prompt = True
    self.next_meta = False # True to force meta on next character
    self.tabstop = 4
    self.allow_ctrl_c=False
    self.ctrl_c_tap_time_interval=0.3

    self.begidx = 0
    self.endidx = 0

    # variables you can control with parse_and_bind
    self.show_all_if_ambiguous = 'off'
    self.mark_directories = 'on'
    self.bell_style = 'none'
    self.mark=-1
    self.l_buffer=lineobj.ReadLineTextBuffer("")
    self._history=history.LineHistory()

    # this code needs to follow l_buffer and history creation
    self.editingmodes=[mode(self) for mode in editingmodes]
    for mode in self.editingmodes:
        mode.init_editing_mode(None)
    self.mode=self.editingmodes[0]

    self.read_inputrc()
    log("\n".join(self.rl_settings_to_string()))

    #Paste settings    
    #assumes data on clipboard is path if shorter than 300 characters and doesn't contain \t or \n
    #and replace \ with / for easier use in ipython
    self.enable_ipython_paste_for_paths=True

    #automatically convert tabseparated data to list of lists or array constructors
    self.enable_ipython_paste_list_of_lists=True
    self.enable_win32_clipboard=True

    self.paste_line_buffer=[]

</t>
<t tx="ekr.20071201085751.1118">#Below is for refactoring, raise errors when using old style attributes 
#that should be refactored out
def _g(x):
    def g(self):
        raise GetSetError("GET %s"%x)
    def s(self,q):
        raise GetSetError("SET %s"%x)
    return g,s
</t>
<t tx="ekr.20071201085751.1119">line_buffer=property(*_g("line_buffer"))
line_cursor=property(*_g("line_buffer"))
undo_stack =property(*_g("undo_stack")) # each entry is a tuple with cursor_position and line_text
history_length =property(*_g("history_length")) # each entry is a tuple with cursor_position and line_text
history =property(*_g("history")) # each entry is a tuple with cursor_position and line_text
history_cursor =property(*_g("history_cursor")) # each entry is a tuple with cursor_position and line_text


#  To export as readline interface

def parse_and_bind(self, string):
    '''Parse and execute single line of a readline init file.'''
    try:
        log('parse_and_bind("%s")' % string)
        if string.startswith('#'):
            return
        if string.startswith('set'):
            m = re.compile(r'set\s+([-a-zA-Z0-9]+)\s+(.+)\s*$').match(string)
            if m:
                var_name = m.group(1)
                val = m.group(2)
                try:
                    setattr(self, var_name.replace('-','_'), val)
                except AttributeError:
                    log('unknown var="%s" val="%s"' % (var_name, val))
            else:
                log('bad set "%s"' % string)
            return
        m = re.compile(r'\s*(.+)\s*:\s*([-a-zA-Z]+)\s*$').match(string)
        if m:
            key = m.group(1)
            func_name = m.group(2)
            py_name = func_name.replace('-', '_')
            try:
                func = getattr(self.mode, py_name)
            except AttributeError:
                log('unknown func key="%s" func="%s"' % (key, func_name))
                print 'unknown function to bind: "%s"' % func_name
            self.mode._bind_key(key, func)
    except:
        log('error')
        raise

</t>
<t tx="ekr.20071201085751.1120">def get_line_buffer(self):
    '''Return the current contents of the line buffer.'''
    return self.l_buffer.get_line_text()

</t>
<t tx="ekr.20071201085751.1121">def insert_text(self, string):
    '''Insert text into the command line.'''
    self.l_buffer.insert_text(string)
    
</t>
<t tx="ekr.20071201085751.1122">def read_init_file(self, filename=None): 
    '''Parse a readline initialization file. The default filename is the last filename used.'''
    log('read_init_file("%s")' % filename)

</t>
<t tx="ekr.20071201085751.1123">#History file book keeping methods (non-bindable)

def add_history(self, line):
    '''Append a line to the history buffer, as if it was the last line typed.'''
    self._history.add_history(line)

</t>
<t tx="ekr.20071201085751.1124">def get_history_length(self ):
    '''Return the desired length of the history file.

    Negative values imply unlimited history file size.'''
    return self._history.get_history_length()

</t>
<t tx="ekr.20071201085751.1125">def set_history_length(self, length): 
    '''Set the number of lines to save in the history file.

    write_history_file() uses this value to truncate the history file
    when saving. Negative values imply unlimited history file size.
    '''
    self._history.set_history_length(length)

</t>
<t tx="ekr.20071201085751.1126">def clear_history(self):
    '''Clear readline history'''
    self._history.clear_history()

</t>
<t tx="ekr.20071201085751.1127">def read_history_file(self, filename=None): 
    '''Load a readline history file. The default filename is ~/.history.'''
    self._history.read_history_file(filename)

</t>
<t tx="ekr.20071201085751.1128">def write_history_file(self, filename=None): 
    '''Save a readline history file. The default filename is ~/.history.'''
    self._history.write_history_file(filename)

</t>
<t tx="ekr.20071201085751.1129">#Completer functions

def set_completer(self, function=None): 
    '''Set or remove the completer function.

    If function is specified, it will be used as the new completer
    function; if omitted or None, any completer function already
    installed is removed. The completer function is called as
    function(text, state), for state in 0, 1, 2, ..., until it returns a
    non-string value. It should return the next possible completion
    starting with text.
    '''
    log('set_completer')
    self.completer = function

</t>
<t tx="ekr.20071201085751.1130">def get_completer(self): 
    '''Get the completer function. 
    ''' 

    log('get_completer') 
    return self.completer 

</t>
<t tx="ekr.20071201085751.1131">def get_begidx(self):
    '''Get the beginning index of the readline tab-completion scope.'''
    return self.begidx

</t>
<t tx="ekr.20071201085751.1132">def get_endidx(self):
    '''Get the ending index of the readline tab-completion scope.'''
    return self.endidx

</t>
<t tx="ekr.20071201085751.1133">def set_completer_delims(self, string):
    '''Set the readline word delimiters for tab-completion.'''
    self.completer_delims = string

</t>
<t tx="ekr.20071201085751.1134">def get_completer_delims(self):
    '''Get the readline word delimiters for tab-completion.'''
    return self.completer_delims

</t>
<t tx="ekr.20071201085751.1135">def set_startup_hook(self, function=None): 
    '''Set or remove the startup_hook function.

    If function is specified, it will be used as the new startup_hook
    function; if omitted or None, any hook function already installed is
    removed. The startup_hook function is called with no arguments just
    before readline prints the first prompt.

    '''
    self.startup_hook = function

</t>
<t tx="ekr.20071201085751.1136">def set_pre_input_hook(self, function=None):
    '''Set or remove the pre_input_hook function.

    If function is specified, it will be used as the new pre_input_hook
    function; if omitted or None, any hook function already installed is
    removed. The pre_input_hook function is called with no arguments
    after the first prompt has been printed and just before readline
    starts reading input characters.

    '''
    self.pre_input_hook = function

</t>
<t tx="ekr.20071201085751.1137">##  Internal functions

def rl_settings_to_string(self):
    out=["%-20s: %s"%("show all if ambigous",self.show_all_if_ambiguous)]
    out.append("%-20s: %s"%("mark_directories",self.mark_directories))
    out.append("%-20s: %s"%("bell_style",self.bell_style))
    out.append("%-20s: %s"%("mark_directories",self.mark_directories))
    out.append("------------- key bindings ------------")
    tablepat="%-7s %-7s %-7s %-15s %-15s "
    out.append(tablepat%("Control","Meta","Shift","Keycode/char","Function"))
    bindings=[(k[0],k[1],k[2],k[3],v.__name__) for k,v in self.mode.key_dispatch.iteritems()]
    bindings.sort()
    for key in bindings:
        out.append(tablepat%(key))
    return out

</t>
<t tx="ekr.20071201085751.1138">def _bell(self):
    '''ring the bell if requested.'''
    if self.bell_style == 'none':
        pass
    elif self.bell_style == 'visible':
        raise NotImplementedError("Bellstyle visible is not implemented yet.")
    elif self.bell_style == 'audible':
        self.console.bell()
    else:
        raise ReadlineError("Bellstyle %s unknown."%self.bell_style)

</t>
<t tx="ekr.20071201085751.1139">def _clear_after(self):
    c = self.console
    x, y = c.pos()
    w, h = c.size()
    c.rectangle((x, y, w+1, y+1))
    c.rectangle((0, y+1, w, min(y+3,h)))

</t>
<t tx="ekr.20071201085751.1140">def _set_cursor(self):
    c = self.console
    xc, yc = self.prompt_end_pos
    w, h = c.size()
    xc += self.l_buffer.visible_line_width()
    while(xc &gt;= w):
        xc -= w
        yc += 1
    c.pos(xc, yc)

</t>
<t tx="ekr.20071201085751.1141">def _print_prompt(self):
    c = self.console
    x, y = c.pos()
    
    n = c.write_scrolling(self.prompt, self.prompt_color)
    self.prompt_begin_pos = (x, y - n)
    self.prompt_end_pos = c.pos()
    self.size = c.size()

</t>
<t tx="ekr.20071201085751.1142">def _update_prompt_pos(self, n):
    if n != 0:
        bx, by = self.prompt_begin_pos
        ex, ey = self.prompt_end_pos
        self.prompt_begin_pos = (bx, by - n)
        self.prompt_end_pos = (ex, ey - n)

</t>
<t tx="ekr.20071201085751.1143">def _update_line(self):
    c=self.console
    c.pos(*self.prompt_end_pos)
    ltext = self.l_buffer.quoted_text()
    if self.l_buffer.enable_selection and self.l_buffer.selection_mark&gt;=0:
        start=len(self.l_buffer[:self.l_buffer.selection_mark].quoted_text())
        stop=len(self.l_buffer[:self.l_buffer.point].quoted_text())
        if start&gt;stop:
            stop,start=start,stop
        n = c.write_scrolling(ltext[:start], self.command_color)
        n = c.write_scrolling(ltext[start:stop], self.selection_color)
        n = c.write_scrolling(ltext[stop:], self.command_color)
    else:
        n = c.write_scrolling(ltext, self.command_color)
    self._update_prompt_pos(n)
    if hasattr(c,"clear_to_end_of_window"): #Work around function for ironpython due 
        c.clear_to_end_of_window()          #to System.Console's lack of FillFunction
    else:
        self._clear_after()
    self._set_cursor()

</t>
<t tx="ekr.20071201085751.1144">def readline(self, prompt=''):
    return self.mode.readline(prompt)

</t>
<t tx="ekr.20071201085751.1145">def read_inputrc(self,inputrcpath=os.path.expanduser("~/pyreadlineconfig.ini")):
    modes=dict([(x.mode,x) for x in self.editingmodes])
    mode=self.editingmodes[0].mode
    def setmode(name):
        self.mode=modes[name]
    def bind_key(key,name):
        log("bind %s %s"%(key,name))
        if hasattr(modes[mode],name):
            modes[mode]._bind_key(key,getattr(modes[mode],name))
        else:
            print "Trying to bind unknown command '%s' to key '%s'"%(name,key)
    def un_bind_key(key):
        keyinfo = make_KeyPress_from_keydescr(key).tuple()
        if keyinfo in modes[mode].key_dispatch:
            del modes[mode].key_dispatch[keyinfo]

    def bind_exit_key(key):
        modes[mode]._bind_exit_key(key)
    def un_bind_exit_key(key):
        keyinfo = make_KeyPress_from_keydescr(key).tuple()
        if keyinfo in modes[mode].exit_dispatch:
            del modes[mode].exit_dispatch[keyinfo]

    def sethistoryfilename(filename):
        self._history.history_filename=os.path.expanduser(filename)
    def setbellstyle(mode):
        self.bell_style=mode
    def sethistorylength(length):
        self._history.history_length=int(length)
    def allow_ctrl_c(mode):
        log_sock("allow_ctrl_c:%s:%s"%(self.allow_ctrl_c,mode))
        self.allow_ctrl_c=mode
    def setbellstyle(mode):
        self.bell_style=mode
    def show_all_if_ambiguous(mode):
        self.show_all_if_ambiguous=mode
    def ctrl_c_tap_time_interval(mode):
        self.ctrl_c_tap_time_interval=mode
    def mark_directories(mode):
        self.mark_directories=mode
    def completer_delims(mode):
        self.completer_delims=mode
    def debug_output(on,filename="pyreadline_debug_log.txt"):  #Not implemented yet
        logger.start_log(on,filename)
        logger.log("STARTING LOG")
#            print release.branch
    def set_prompt_color(color):
        trtable={"black":0,"darkred":4,"darkgreen":2,"darkyellow":6,"darkblue":1,"darkmagenta":5,"darkcyan":3,"gray":7,
                 "red":4+8,"green":2+8,"yellow":6+8,"blue":1+8,"magenta":5+8,"cyan":3+8,"white":7+8}
        self.prompt_color=trtable.get(color.lower(),7)            
        
    def set_input_color(color):
        trtable={"black":0,"darkred":4,"darkgreen":2,"darkyellow":6,"darkblue":1,"darkmagenta":5,"darkcyan":3,"gray":7,
                 "red":4+8,"green":2+8,"yellow":6+8,"blue":1+8,"magenta":5+8,"cyan":3+8,"white":7+8}
        self.command_color=trtable.get(color.lower(),7)            
    loc={"branch":release.branch,
         "version":release.version,
         "mode":mode,
         "modes":modes,
         "set_mode":setmode,
         "bind_key":bind_key,
         "bind_exit_key":bind_exit_key,
         "un_bind_key":un_bind_key,
         "un_bind_exit_key":un_bind_exit_key,
         "bell_style":setbellstyle,
         "mark_directories":mark_directories,
         "show_all_if_ambiguous":show_all_if_ambiguous,
         "completer_delims":completer_delims,
         "debug_output":debug_output,
         "history_filename":sethistoryfilename,
         "history_length":sethistorylength,
         "set_prompt_color":set_prompt_color,
         "set_input_color":set_input_color,
         "allow_ctrl_c":allow_ctrl_c,
         "ctrl_c_tap_time_interval":ctrl_c_tap_time_interval,
         }
    if os.path.isfile(inputrcpath): 
        try:
            execfile(inputrcpath,loc,loc)
        except Exception,x:
            raise
            import traceback
            print &gt;&gt;sys.stderr, "Error reading .pyinputrc"
            filepath,lineno=traceback.extract_tb(sys.exc_traceback)[1][:2]
            print &gt;&gt;sys.stderr, "Line: %s in file %s"%(lineno,filepath)
            print &gt;&gt;sys.stderr, x
            raise ReadlineError("Error reading .pyinputrc")




</t>
<t tx="ekr.20071201085751.1146">def CTRL(c):
    '''make a control character'''
    assert '@' &lt;= c &lt;= '_'
    return chr(ord(c) - ord('@'))

</t>
<t tx="ekr.20071201085751.1147"># create a Readline object to contain the state
rl = Readline()


def GetOutputFile():
    '''Return the console object used by readline so that it can be used for printing in color.'''
    return rl.console

</t>
<t tx="ekr.20071201085751.1148">#This file contains constants that are normally found in win32all
#But included here to avoid the dependency

VK_LBUTTON=1
VK_RBUTTON=2
VK_CANCEL=3
VK_MBUTTON=4
VK_XBUTTON1=5
VK_XBUTTON2=6
VK_BACK=8
VK_TAB=9
VK_CLEAR=12
VK_RETURN=13
VK_SHIFT=16
VK_CONTROL=17
VK_MENU=18
VK_PAUSE=19
VK_CAPITAL=20
VK_KANA=0x15
VK_HANGEUL=0x15
VK_HANGUL=0x15
VK_JUNJA=0x17
VK_FINAL=0x18
VK_HANJA=0x19
VK_KANJI=0x19
VK_ESCAPE=0x1B
VK_CONVERT=0x1C
VK_NONCONVERT=0x1D
VK_ACCEPT=0x1E
VK_MODECHANGE=0x1F
VK_SPACE=32
VK_PRIOR=33
VK_NEXT=34
VK_END=35
VK_HOME=36
VK_LEFT=37
VK_UP=38
VK_RIGHT=39
VK_DOWN=40
VK_SELECT=41
VK_PRINT=42
VK_EXECUTE=43
VK_SNAPSHOT=44
VK_INSERT=45
VK_DELETE=46
VK_HELP=47
VK_LWIN=0x5B
VK_RWIN=0x5C
VK_APPS=0x5D
VK_SLEEP=0x5F
VK_NUMPAD0=0x60
VK_NUMPAD1=0x61
VK_NUMPAD2=0x62
VK_NUMPAD3=0x63
VK_NUMPAD4=0x64
VK_NUMPAD5=0x65
VK_NUMPAD6=0x66
VK_NUMPAD7=0x67
VK_NUMPAD8=0x68
VK_NUMPAD9=0x69
VK_MULTIPLY=0x6A
VK_ADD=0x6B
VK_SEPARATOR=0x6C
VK_SUBTRACT=0x6D
VK_DECIMAL=0x6E
VK_DIVIDE=0x6F
VK_F1=0x70
VK_F2=0x71
VK_F3=0x72
VK_F4=0x73
VK_F5=0x74
VK_F6=0x75
VK_F7=0x76
VK_F8=0x77
VK_F9=0x78
VK_F10=0x79
VK_F11=0x7A
VK_F12=0x7B
VK_F13=0x7C
VK_F14=0x7D
VK_F15=0x7E
VK_F16=0x7F
VK_F17=0x80
VK_F18=0x81
VK_F19=0x82
VK_F20=0x83
VK_F21=0x84
VK_F22=0x85
VK_F23=0x86
VK_F24=0x87
VK_NUMLOCK=0x90
VK_SCROLL=0x91
VK_LSHIFT=0xA0
VK_RSHIFT=0xA1
VK_LCONTROL=0xA2
VK_RCONTROL=0xA3
VK_LMENU=0xA4
VK_RMENU=0xA5
VK_BROWSER_BACK=0xA6
VK_BROWSER_FORWARD=0xA7
VK_BROWSER_REFRESH=0xA8
VK_BROWSER_STOP=0xA9
VK_BROWSER_SEARCH=0xAA
VK_BROWSER_FAVORITES=0xAB
VK_BROWSER_HOME=0xAC
VK_VOLUME_MUTE=0xAD
VK_VOLUME_DOWN=0xAE
VK_VOLUME_UP=0xAF
VK_MEDIA_NEXT_TRACK=0xB0
VK_MEDIA_PREV_TRACK=0xB1
VK_MEDIA_STOP=0xB2
VK_MEDIA_PLAY_PAUSE=0xB3
VK_LAUNCH_MAIL=0xB4
VK_LAUNCH_MEDIA_SELECT=0xB5
VK_LAUNCH_APP1=0xB6
VK_LAUNCH_APP2=0xB7
VK_OEM_1=0xBA
VK_OEM_PLUS=0xBB
VK_OEM_COMMA=0xBC
VK_OEM_MINUS=0xBD
VK_OEM_PERIOD=0xBE
VK_OEM_2=0xBF
VK_OEM_3=0xC0
VK_OEM_4=0xDB
VK_OEM_5=0xDC
VK_OEM_6=0xDD
VK_OEM_7=0xDE
VK_OEM_8=0xDF
VK_OEM_102=0xE2
VK_PROCESSKEY=0xE5
VK_PACKET=0xE7
VK_ATTN=0xF6
VK_CRSEL=0xF7
VK_EXSEL=0xF8
VK_EREOF=0xF9
VK_PLAY=0xFA
VK_ZOOM=0xFB
VK_NONAME=0xFC
VK_PA1=0xFD
VK_OEM_CLEAR=0xFE

CF_TEXT=1
CF_BITMAP=2
CF_METAFILEPICT=3
CF_SYLK=4
CF_DIF=5
CF_TIFF=6
CF_OEMTEXT=7
CF_DIB=8
CF_PALETTE=9
CF_PENDATA=10
CF_RIFF=11
CF_WAVE=12
CF_UNICODETEXT=13
CF_ENHMETAFILE=14
CF_HDROP=15
CF_LOCALE=16
CF_MAX=17
CF_OWNERDISPLAY=128
CF_DSPTEXT=129
CF_DSPBITMAP=130
CF_DSPMETAFILEPICT=131
CF_DSPENHMETAFILE=142
CF_PRIVATEFIRST=512
CF_PRIVATELAST=767
CF_GDIOBJFIRST=768
CF_GDIOBJLAST=1023


GPTR=64
GHND=66
</t>
<t tx="ekr.20071201085751.1149"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
import logger,clipboard,lineeditor,modes
from rlmain import *
__all__ = [ 'parse_and_bind',
            'get_line_buffer',
            'insert_text',
            'clear_history',
            'read_init_file',
            'read_history_file',
            'write_history_file',
            'get_history_length',
            'set_history_length',
            'set_startup_hook',
            'set_pre_input_hook',
            'set_completer',
            'get_completer',
            'get_begidx',
            'get_endidx',
            'set_completer_delims',
            'get_completer_delims',
            'add_history',
            'GetOutputFile']

import release 
</t>
<t tx="ekr.20071201085751.1150"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
import clr
clr.AddReferenceByPartialName("System.Windows.Forms")
import System.Windows.Forms.Clipboard as cb

</t>
<t tx="ekr.20071201085751.1151">def GetClipboardText():
    text=""
    if cb.ContainsText():
        text=cb.GetText()

    return text

</t>
<t tx="ekr.20071201085751.1152">def SetClipboardText(text):
    cb.SetText(text)    

</t>
<t tx="ekr.20071201085751.1153"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Jack Trainor.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
###################################
#
# Based on recipe posted to ctypes-users
# see archive
# http://aspn.activestate.com/ASPN/Mail/Message/ctypes-users/1771866
#
#

###################################################################################
#
# The Python win32clipboard lib functions work well enough ... except that they
# can only cut and paste items from within one application, not across
# applications or processes.
#
# I've written a number of Python text filters I like to run on the contents of
# the clipboard so I need to call the Windows clipboard API with global memory
# for my filters to work properly.
#
# Here's some sample code solving this problem using ctypes.
#
# This is my first work with ctypes.  It's powerful stuff, but passing arguments
# in and out of functions is tricky.  More sample code would have been helpful,
# hence this contribution.
#
###################################################################################

from ctypes import *
from pyreadline.keysyms.winconstants import CF_TEXT, GHND

OpenClipboard = windll.user32.OpenClipboard
EmptyClipboard = windll.user32.EmptyClipboard
GetClipboardData = windll.user32.GetClipboardData
GetClipboardFormatName = windll.user32.GetClipboardFormatNameA
SetClipboardData = windll.user32.SetClipboardData
EnumClipboardFormats = windll.user32.EnumClipboardFormats
CloseClipboard = windll.user32.CloseClipboard
OpenClipboard.argtypes=[c_int]
EnumClipboardFormats.argtypes=[c_int]
CloseClipboard.argtypes=[]
GetClipboardFormatName.argtypes=[c_uint,c_char_p,c_int]
GetClipboardData.argtypes=[c_int]
SetClipboardData.argtypes=[c_int,c_int]

GlobalLock = windll.kernel32.GlobalLock
GlobalAlloc = windll.kernel32.GlobalAlloc
GlobalUnlock = windll.kernel32.GlobalUnlock
GlobalLock.argtypes=[c_int]
GlobalUnlock.argtypes=[c_int]
memcpy = cdll.msvcrt.memcpy

</t>
<t tx="ekr.20071201085751.1154">def enum():
    OpenClipboard(0)
    q=EnumClipboardFormats(0)
    while q:
        print q,
        q=EnumClipboardFormats(q)
    CloseClipboard()

</t>
<t tx="ekr.20071201085751.1155">def getformatname(format):
    buffer = c_buffer(" "*100)
    bufferSize = sizeof(buffer)
    OpenClipboard(0)
    GetClipboardFormatName(format,buffer,bufferSize)
    CloseClipboard()
    return buffer.value

</t>
<t tx="ekr.20071201085751.1156">def GetClipboardText():
    text = ""
    if OpenClipboard(0):
        hClipMem = GetClipboardData(CF_TEXT)
        if hClipMem:        
            GlobalLock.restype = c_char_p
            text = GlobalLock(hClipMem)
            GlobalUnlock(hClipMem)
        CloseClipboard()
    return text

</t>
<t tx="ekr.20071201085751.1157">def SetClipboardText(text):
    buffer = c_buffer(text)
    bufferSize = sizeof(buffer)
    hGlobalMem = GlobalAlloc(c_int(GHND), c_int(bufferSize))
    GlobalLock.restype = c_void_p
    lpGlobalMem = GlobalLock(c_int(hGlobalMem))
    memcpy(lpGlobalMem, addressof(buffer), c_int(bufferSize))
    GlobalUnlock(c_int(hGlobalMem))
    if OpenClipboard(0):
        EmptyClipboard()
        SetClipboardData(c_int(CF_TEXT), c_int(hGlobalMem))
        CloseClipboard()

</t>
<t tx="ekr.20071201085751.1158">import sys
success=False
in_ironpython="IronPython" in sys.version
if in_ironpython:
    try:
        from ironpython_clipboard import GetClipboardText,SetClipboardText
        success=True
    except ImportError:
        pass
else:
    try:
        from win32_clipboard import GetClipboardText,SetClipboardText
        success=True
    except ImportError:
        raise    
    

</t>
<t tx="ekr.20071201085751.1159">def send_data(lists):
    SetClipboardText(make_tab(lists))
    

</t>
<t tx="ekr.20071201085751.1160">def set_clipboard_text(toclipboard):
    SetClipboardText(str(toclipboard))

</t>
<t tx="ekr.20071201085751.1161">def make_tab(lists):
    if hasattr(lists,"tolist"):
        lists=lists.tolist()
    ut=[]
    for rad in lists:
        if type(rad) in [list,tuple]:
            ut.append("\t".join(["%s"%x for x in rad]))
        else:
            ut.append("%s"%rad)
    return "\n".join(ut)            
    
</t>
<t tx="ekr.20071201085751.1162">def make_list_of_list(txt):
    def make_num(x):
        try:
            return int(x)
        except ValueError:
            try:
                return float(x)
            except ValueError:
                try:
                    return complex(x)
                except ValueError:
                    return x
        return x                
    ut=[]
    flag=False
    for rad in [x for x in txt.split("\r\n") if x!=""]:
        raden=[make_num(x) for x in rad.split("\t")]
        if str in map(type,raden):
            flag=True
        ut.append(raden)
    return ut,flag


</t>
<t tx="ekr.20071201085751.1163">def get_clipboard_text_and_convert(paste_list=False):
    """Get txt from clipboard. if paste_list==True the convert tab separated 
    data to list of lists. Enclose list of list in array() if all elements are 
    numeric"""
    txt=GetClipboardText()
    if txt:
        if paste_list and "\t" in txt:
            array,flag=make_list_of_list(txt)
            if flag:
                txt=repr(array)
            else:
                txt="array(%s)"%repr(array)
            txt="".join([c for c in txt if c not in " \t\r\n"])
    return txt

</t>
<t tx="ekr.20071201085751.1164"># -*- coding: UTF-8 -*-
# Example snippet to use in a PYTHONSTARTUP file
try:
    import pyreadline.rlmain
    #pyreadline.rlmain.config_path=r"c:\xxx\pyreadlineconfig.ini"
    import readline,atexit
except ImportError:
    print "Module readline not available."
else:
    #import tab completion functionality
    import rlcompleter
    #activate tab completion
    readline.parse_and_bind("tab: complete")
    readline.read_history_file()
    atexit.register(readline.write_history_file)
    del readline,rlcompleter,atexit
</t>
<t tx="ekr.20071201085751.1165">class baseconsole:
    @others
    </t>
<t tx="ekr.20071201085751.1166">def __init__(self):
    pass
    
</t>
<t tx="ekr.20071201085751.1167">def bell(self):
    raise NotImplementedError

</t>
<t tx="ekr.20071201085751.1168">def pos(self, x=None, y=None):
    '''Move or query the window cursor.'''
    raise NotImplementedError

</t>
<t tx="ekr.20071201085751.1169">def size(self):
    raise NotImplementedError

</t>
<t tx="ekr.20071201085751.1170">def rectangle(self, rect, attr=None, fill=' '):
    '''Fill Rectangle.'''
    raise NotImplementedError

</t>
<t tx="ekr.20071201085751.1171">def write_scrolling(self, text, attr=None):
    '''write text at current cursor position while watching for scrolling.

    If the window scrolls because you are at the bottom of the screen
    buffer, all positions that you are storing will be shifted by the
    scroll amount. For example, I remember the cursor position of the
    prompt so that I can redraw the line but if the window scrolls,
    the remembered position is off.

    This variant of write tries to keep track of the cursor position
    so that it will know when the screen buffer is scrolled. It
    returns the number of lines that the buffer scrolled.

    '''
    raise NotImplementedError

</t>
<t tx="ekr.20071201085751.1172">def getkeypress(self):
    '''Return next key press event from the queue, ignoring others.'''
    raise NotImplementedError
    
</t>
<t tx="ekr.20071201085751.1173">def write(self, text):
    raise NotImplementedError

</t>
<t tx="ekr.20071201085751.1174">def page(self, attr=None, fill=' '):
    '''Fill the entire screen.'''
    raise NotImplementedError

</t>
<t tx="ekr.20071201085751.1175">def isatty(self):
    return True

</t>
<t tx="ekr.20071201085751.1176">def flush(self):
    pass

</t>
<t tx="ekr.20071201085751.1177">
FOREGROUND_BLUE           = 0x0001
FOREGROUND_GREEN          = 0x0002
FOREGROUND_RED            = 0x0004
FOREGROUND_INTENSITY      = 0x0008
BACKGROUND_BLUE           = 0x0010
BACKGROUND_GREEN          = 0x0020
BACKGROUND_RED            = 0x0040
BACKGROUND_INTENSITY      = 0x0080
COMMON_LVB_LEADING_BYTE   = 0x0100
COMMON_LVB_TRAILING_BYTE  = 0x0200
COMMON_LVB_GRID_HORIZONTAL= 0x0400
COMMON_LVB_GRID_LVERTICAL = 0x0800
COMMON_LVB_GRID_RVERTICAL = 0x1000
COMMON_LVB_REVERSE_VIDEO  = 0x2000
COMMON_LVB_UNDERSCORE     = 0x4000
</t>
<t tx="ekr.20071201085751.1178">class Event(object):
    '''Represent events from the console.'''
    @others
</t>
<t tx="ekr.20071201085751.1179">def __init__(self, console, input):
    pass
</t>
<t tx="ekr.20071201085751.1180">def __repr__(self):
    '''Display an event for debugging.'''
    if self.type in ['KeyPress', 'KeyRelease']:
        s = "%s char='%s'%d keysym='%s' keycode=%d:%x state=%x keyinfo=%s" % \
                (self.type, self.char, ord(self.char), self.keysym, self.keycode, self.keycode,
                 self.state, self.keyinfo)
    elif self.type in ['Motion', 'Button']:
        s = '%s x=%d y=%d state=%x' % (self.type, self.x, self.y, self.state)
    elif self.type == 'Configure':
        s = '%s w=%d h=%d' % (self.type, self.width, self.height)
    elif self.type in ['FocusIn', 'FocusOut']:
        s = self.type
    elif self.type == 'Menu':
        s = '%s state=%x' % (self.type, self.state)
    else:
        s = 'unknown event type'
    return s


</t>
<t tx="ekr.20071201085751.1181">import glob,sys

success=False
in_ironpython="IronPython" in sys.version

if in_ironpython:
    try:
        from ironpython_console import *
        success=True
    except ImportError:
        raise
else:
    try:
        from console import *
        success=True
    except ImportError:
        pass


if not success:
    raise ImportError("Could not find a console implementation for your platform")
</t>
<t tx="ekr.20071201085751.1182"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
# table for translating virtual keys to X windows key symbols

try:
    set
except NameError:
    from sets import Set as set
    


validkey =set(['cancel',     'backspace',    'tab',          'clear',
              'return',      'shift_l',      'control_l',    'alt_l',
              'pause',       'caps_lock',    'escape',       'space',
              'prior',       'next',         'end',          'home',
              'left',        'up',           'right',        'down',
              'select',      'print',        'execute',      'snapshot',
              'insert',      'delete',       'help',         'f1',
              'f2',          'f3',           'f4',           'f5',
              'f6',          'f7',           'f8',           'f9',
              'f10',         'f11',          'f12',          'f13',
              'f14',         'f15',          'f16',          'f17',
              'f18',         'f19',          'f20',          'f21',
              'f22',         'f23',          'f24',          'num_lock',
              'scroll_lock', 'vk_apps',      'vk_processkey','vk_attn',
              'vk_crsel',    'vk_exsel',     'vk_ereof',     'vk_play',
              'vk_zoom',     'vk_noname',    'vk_pa1',       'vk_oem_clear',
              'numpad0',     'numpad1',      'numpad2',      'numpad3',
              'numpad4',     'numpad5',      'numpad6',      'numpad7',
              'numpad8',     'numpad9',      'divide',       'multiply',
              'add',         'subtract',     'vk_decimal'])

escape_sequence_to_special_key={"\\e[a":"up","\\e[b":"down","del":"delete"}

</t>
<t tx="ekr.20071201085751.1183">class KeyPress(object):
    @others
</t>
<t tx="ekr.20071201085751.1184">def __init__(self,char="",shift=False,control=False,meta=False,keyname=""):
    if control or meta or shift:
        char=char.upper()
    self.info=dict(char=char,
                   shift=shift,
                   control=control,
                   meta=meta,
                   keyname=keyname)
    
</t>
<t tx="ekr.20071201085751.1185">def create(name):
    def get(self):
        return self.info[name]
    def set(self,value):
        self.info[name]=value
    return property(get,set)
</t>
<t tx="ekr.20071201085751.1186">char=create("char")
shift=create("shift")
control=create("control")
meta=create("meta")
keyname=create("keyname")
    
def __repr__(self):
    return "(%s,%s,%s,%s)"%self.tuple()

</t>
<t tx="ekr.20071201085751.1187">def tuple(self):
    if self.keyname:
        return (self.control,self.meta,self.shift,self.keyname)
    else:
        if self.control or self.meta or self.shift:
            return (self.control,self.meta,self.shift,self.char.upper())
        else:
            return (self.control,self.meta,self.shift,self.char)

</t>
<t tx="ekr.20071201085751.1188">def make_KeyPress_from_keydescr(keydescr):
    keyinfo=KeyPress()
    if len(keydescr)&gt;2 and keydescr[:1]=='"' and keydescr[-1:]=='"':
        keydescr=keydescr[1:-1]
        
    while 1:
        lkeyname = keydescr.lower()
        if lkeyname.startswith('control-'):
            keyinfo.control = True
            keydescr = keydescr[8:]
        elif lkeyname.startswith('ctrl-'):
            keyinfo.control = True
            keydescr = keydescr[5:]
        elif keydescr.lower().startswith('\\c-'):
            keyinfo.control = True
            keydescr = keydescr[3:]
        elif keydescr.lower().startswith('\\m-'):
            keyinfo.meta = True
            keydescr = keydescr[3:]
        elif keydescr in escape_sequence_to_special_key:
            keydescr = escape_sequence_to_special_key[keydescr]
        elif lkeyname.startswith('meta-'):
            keyinfo.meta = True
            keydescr = keydescr[5:]
        elif lkeyname.startswith('alt-'):
            keyinfo.meta = True
            keydescr = keydescr[4:]
        elif lkeyname.startswith('shift-'):
            keyinfo.shift = True
            keydescr = keydescr[6:]
        else:
            if len(keydescr) &gt; 1:
                if keydescr.strip().lower() in validkey:
                    keyinfo.keyname=keydescr.strip().lower()
                    keyinfo.char=""
                else:
                    raise IndexError("Not a valid key: '%s'"%keydescr)
            else:
                keyinfo.char=keydescr
            return keyinfo

</t>
<t tx="ekr.20071201085751.1189"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
import System
from common import validkey,KeyPress,make_KeyPress_from_keydescr
#from pyreadline.logger import log_sock
c32=System.ConsoleKey
Shift=System.ConsoleModifiers.Shift
Control=System.ConsoleModifiers.Control
Alt=System.ConsoleModifiers.Alt
# table for translating virtual keys to X windows key symbols
code2sym_map = {#c32.CANCEL: 'Cancel',
                c32.Backspace:  'BackSpace',
                c32.Tab:        'Tab',
                c32.Clear:      'Clear',
                c32.Enter:     'Return',
#                c32.Shift:      'Shift_L',
#                c32.Control:   'Control_L',
#                c32.Menu:      'Alt_L',
                c32.Pause:      'Pause',
#                c32.Capital:    'Caps_Lock',
                c32.Escape:     'Escape',
#                c32.Space:      'space',
                c32.PageUp:      'Prior',
                c32.PageDown:       'Next',
                c32.End:        'End',
                c32.Home:       'Home',
                c32.LeftArrow:       'Left',
                c32.UpArrow:         'Up',
                c32.RightArrow:      'Right',
                c32.DownArrow:       'Down',
                c32.Select:     'Select',
                c32.Print:      'Print',
                c32.Execute:    'Execute',
#                c32.Snapshot:   'Snapshot',
                c32.Insert:     'Insert',
                c32.Delete:     'Delete',
                c32.Help:       'Help',
                c32.F1:         'F1',
                c32.F2:         'F2',
                c32.F3:         'F3',
                c32.F4:         'F4',
                c32.F5:         'F5',
                c32.F6:         'F6',
                c32.F7:         'F7',
                c32.F8:         'F8',
                c32.F9:         'F9',
                c32.F10:        'F10',
                c32.F11:        'F11',
                c32.F12:        'F12',
                c32.F13:        'F13',
                c32.F14:        'F14',
                c32.F15:        'F15',
                c32.F16:        'F16',
                c32.F17:        'F17',
                c32.F18:        'F18',
                c32.F19:        'F19',
                c32.F20:        'F20',
                c32.F21:        'F21',
                c32.F22:        'F22',
                c32.F23:        'F23',
                c32.F24:        'F24',
#                c32.Numlock:    'Num_Lock,',
#                c32.Scroll:     'Scroll_Lock',
#                c32.Apps:       'VK_APPS',
#                c32.ProcesskeY: 'VK_PROCESSKEY',
#                c32.Attn:       'VK_ATTN',
#                c32.Crsel:      'VK_CRSEL',
#                c32.Exsel:      'VK_EXSEL',
#                c32.Ereof:      'VK_EREOF',
#                c32.Play:       'VK_PLAY',
#                c32.Zoom:       'VK_ZOOM',
#                c32.Noname:     'VK_NONAME',
#                c32.Pa1:        'VK_PA1',
                c32.OemClear:  'VK_OEM_CLEAR',
                c32.NumPad0:    'NUMPAD0',
                c32.NumPad1:    'NUMPAD1',
                c32.NumPad2:    'NUMPAD2',
                c32.NumPad3:    'NUMPAD3',
                c32.NumPad4:    'NUMPAD4',
                c32.NumPad5:    'NUMPAD5',
                c32.NumPad6:    'NUMPAD6',
                c32.NumPad7:    'NUMPAD7',
                c32.NumPad8:    'NUMPAD8',
                c32.NumPad9:    'NUMPAD9',
                c32.Divide:     'Divide',
                c32.Multiply:   'Multiply',
                c32.Add:        'Add',
                c32.Subtract:   'Subtract',
                c32.Decimal:    'VK_DECIMAL'
               }

</t>
<t tx="ekr.20071201085751.1190"># function to handle the mapping
def make_keysym(keycode):
    try:
        sym = code2sym_map[keycode]
    except KeyError:
        sym = ''
    return sym

</t>
<t tx="ekr.20071201085751.1191">sym2code_map = {}
for code,sym in code2sym_map.iteritems():
    sym2code_map[sym.lower()] = code

def key_text_to_keyinfo(keytext):
    '''Convert a GNU readline style textual description of a key to keycode with modifiers'''
    if keytext.startswith('"'): # "
        return keyseq_to_keyinfo(keytext[1:-1])
    else:
        return keyname_to_keyinfo(keytext)


</t>
<t tx="ekr.20071201085751.1192">def char_to_keyinfo(char, control=False, meta=False, shift=False):
    vk = (ord(char))
    if vk &amp; 0xffff == 0xffff:
        print 'VkKeyScan("%s") = %x' % (char, vk)
        raise ValueError, 'bad key'
    if vk &amp; 0x100:
        shift = True
    if vk &amp; 0x200:
        control = True
    if vk &amp; 0x400:
        meta = True
    return (control, meta, shift, vk &amp; 0xff)

</t>
<t tx="ekr.20071201085751.1193">def keyname_to_keyinfo(keyname):
    control = False
    meta = False
    shift = False

    while 1:
        lkeyname = keyname.lower()
        if lkeyname.startswith('control-'):
            control = True
            keyname = keyname[8:]
        elif lkeyname.startswith('ctrl-'):
            control = True
            keyname = keyname[5:]
        elif lkeyname.startswith('meta-'):
            meta = True
            keyname = keyname[5:]
        elif lkeyname.startswith('alt-'):
            meta = True
            keyname = keyname[4:]
        elif lkeyname.startswith('shift-'):
            shift = True
            keyname = keyname[6:]
        else:
            if len(keyname) &gt; 1:
                return (control, meta, shift, sym2code_map.get(keyname.lower()," "))
            else:
                return char_to_keyinfo(keyname, control, meta, shift)

</t>
<t tx="ekr.20071201085751.1194">def keyseq_to_keyinfo(keyseq):
    res = []
    control = False
    meta = False
    shift = False

    while 1:
        if keyseq.startswith('\\C-'):
            control = True
            keyseq = keyseq[3:]
        elif keyseq.startswith('\\M-'):
            meta = True
            keyseq = keyseq[3:]
        elif keyseq.startswith('\\e'):
            res.append(char_to_keyinfo('\033', control, meta, shift))
            control = meta = shift = False
            keyseq = keyseq[2:]
        elif len(keyseq) &gt;= 1:
            res.append(char_to_keyinfo(keyseq[0], control, meta, shift))
            control = meta = shift = False
            keyseq = keyseq[1:]
        else:
            return res[0]

</t>
<t tx="ekr.20071201085751.1195">def make_keyinfo(keycode, state):
#    control = (state &amp; (4+8)) != 0
#    meta = (state &amp; (1+2)) != 0
#    shift = (state &amp; 0x10) != 0
    control=False
    meta=False
    shift=False
    return (control, meta, shift, keycode)


</t>
<t tx="ekr.20071201085751.1196">def make_KeyPress(char,state,keycode):

    shift=bool(int(state)&amp;int(Shift))
    control=bool(int(state)&amp;int(Control))
    meta=bool(int(state)&amp;int(Alt))
    keyname=code2sym_map.get(keycode,"").lower()
#    log_sock("make key %s %s %s %s"%(shift,control,meta,keycode),"keysyms")
    if control and meta: #equivalent to altgr so clear flags
        control=False
        meta=False    
    elif control:
        char=str(keycode)
    return KeyPress(char,shift,control,meta,keyname)

</t>
<t tx="ekr.20071201085751.1197"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
import winconstants as c32
from ctypes import windll
import ctypes
# table for translating virtual keys to X windows key symbols

from common import validkey,KeyPress,make_KeyPress_from_keydescr

code2sym_map = {c32.VK_CANCEL:     'cancel',
                c32.VK_BACK:       'backspace',
                c32.VK_TAB:        'tab',
                c32.VK_CLEAR:      'clear',
                c32.VK_RETURN:     'return',
                c32.VK_SHIFT:      'shift_l',
                c32.VK_CONTROL:    'control_l',
                c32.VK_MENU:       'alt_l',
                c32.VK_PAUSE:      'pause',
                c32.VK_CAPITAL:    'caps_lock',
                c32.VK_ESCAPE:     'escape',
                c32.VK_SPACE:      'space',
                c32.VK_PRIOR:      'prior',
                c32.VK_NEXT:       'next',
                c32.VK_END:        'end',
                c32.VK_HOME:       'home',
                c32.VK_LEFT:       'left',
                c32.VK_UP:         'up',
                c32.VK_RIGHT:      'right',
                c32.VK_DOWN:       'down',
                c32.VK_SELECT:     'select',
                c32.VK_PRINT:      'print',
                c32.VK_EXECUTE:    'execute',
                c32.VK_SNAPSHOT:   'snapshot',
                c32.VK_INSERT:     'insert',
                c32.VK_DELETE:     'delete',
                c32.VK_HELP:       'help',
                c32.VK_F1:         'f1',
                c32.VK_F2:         'f2',
                c32.VK_F3:         'f3',
                c32.VK_F4:         'f4',
                c32.VK_F5:         'f5',
                c32.VK_F6:         'f6',
                c32.VK_F7:         'f7',
                c32.VK_F8:         'f8',
                c32.VK_F9:         'f9',
                c32.VK_F10:        'f10',
                c32.VK_F11:        'f11',
                c32.VK_F12:        'f12',
                c32.VK_F13:        'f13',
                c32.VK_F14:        'f14',
                c32.VK_F15:        'f15',
                c32.VK_F16:        'f16',
                c32.VK_F17:        'f17',
                c32.VK_F18:        'f18',
                c32.VK_F19:        'f19',
                c32.VK_F20:        'f20',
                c32.VK_F21:        'f21',
                c32.VK_F22:        'f22',
                c32.VK_F23:        'f23',
                c32.VK_F24:        'f24',
                c32.VK_NUMLOCK:    'num_lock,',
                c32.VK_SCROLL:     'scroll_lock',
                c32.VK_APPS:       'vk_apps',
                c32.VK_PROCESSKEY: 'vk_processkey',
                c32.VK_ATTN:       'vk_attn',
                c32.VK_CRSEL:      'vk_crsel',
                c32.VK_EXSEL:      'vk_exsel',
                c32.VK_EREOF:      'vk_ereof',
                c32.VK_PLAY:       'vk_play',
                c32.VK_ZOOM:       'vk_zoom',
                c32.VK_NONAME:     'vk_noname',
                c32.VK_PA1:        'vk_pa1',
                c32.VK_OEM_CLEAR   :'vk_oem_clear',
                c32.VK_NUMPAD0:    'numpad0',
                c32.VK_NUMPAD1:    'numpad1',
                c32.VK_NUMPAD2:    'numpad2',
                c32.VK_NUMPAD3:    'numpad3',
                c32.VK_NUMPAD4:    'numpad4',
                c32.VK_NUMPAD5:    'numpad5',
                c32.VK_NUMPAD6:    'numpad6',
                c32.VK_NUMPAD7:    'numpad7',
                c32.VK_NUMPAD8:    'numpad8',
                c32.VK_NUMPAD9:    'numpad9',
                c32.VK_DIVIDE:     'divide',
                c32.VK_MULTIPLY:   'multiply',
                c32.VK_ADD:        'add',
                c32.VK_SUBTRACT:   'subtract',
                c32.VK_DECIMAL:    'vk_decimal'
               }

VkKeyScan = windll.user32.VkKeyScanA

</t>
<t tx="ekr.20071201085751.1198">def char_to_keyinfo(char, control=False, meta=False, shift=False):
    k=KeyPress()
    vk = VkKeyScan(ord(char))
    if vk &amp; 0xffff == 0xffff:
        print 'VkKeyScan("%s") = %x' % (char, vk)
        raise ValueError, 'bad key'
    if vk &amp; 0x100:
        k.shift = True
    if vk &amp; 0x200:
        k.control = True
    if vk &amp; 0x400:
        k.meta = True
    k.char=chr(vk &amp; 0xff)
    return k

</t>
<t tx="ekr.20071201085751.1199">def make_KeyPress(char,state,keycode):
    control = (state &amp; (4+8)) != 0
    meta = (state &amp; (1+2)) != 0
    shift = (state &amp; 0x10) != 0
    if control and char !="\x00":
       char = chr(VkKeyScan(ord(char)) &amp; 0xff)
    elif control:
        char=chr(keycode)
    try:
        keyname=code2sym_map[keycode]
    except KeyError:
        keyname=""
    return KeyPress(char,shift,control,meta,keyname)

</t>
<t tx="ekr.20071201085751.1200">#This file contains constants that are normally found in win32all
#But included here to avoid the dependency

VK_LBUTTON=1
VK_RBUTTON=2
VK_CANCEL=3
VK_MBUTTON=4
VK_XBUTTON1=5
VK_XBUTTON2=6
VK_BACK=8
VK_TAB=9
VK_CLEAR=12
VK_RETURN=13
VK_SHIFT=16
VK_CONTROL=17
VK_MENU=18
VK_PAUSE=19
VK_CAPITAL=20
VK_KANA=0x15
VK_HANGEUL=0x15
VK_HANGUL=0x15
VK_JUNJA=0x17
VK_FINAL=0x18
VK_HANJA=0x19
VK_KANJI=0x19
VK_ESCAPE=0x1B
VK_CONVERT=0x1C
VK_NONCONVERT=0x1D
VK_ACCEPT=0x1E
VK_MODECHANGE=0x1F
VK_SPACE=32
VK_PRIOR=33
VK_NEXT=34
VK_END=35
VK_HOME=36
VK_LEFT=37
VK_UP=38
VK_RIGHT=39
VK_DOWN=40
VK_SELECT=41
VK_PRINT=42
VK_EXECUTE=43
VK_SNAPSHOT=44
VK_INSERT=45
VK_DELETE=46
VK_HELP=47
VK_LWIN=0x5B
VK_RWIN=0x5C
VK_APPS=0x5D
VK_SLEEP=0x5F
VK_NUMPAD0=0x60
VK_NUMPAD1=0x61
VK_NUMPAD2=0x62
VK_NUMPAD3=0x63
VK_NUMPAD4=0x64
VK_NUMPAD5=0x65
VK_NUMPAD6=0x66
VK_NUMPAD7=0x67
VK_NUMPAD8=0x68
VK_NUMPAD9=0x69
VK_MULTIPLY=0x6A
VK_ADD=0x6B
VK_SEPARATOR=0x6C
VK_SUBTRACT=0x6D
VK_DECIMAL=0x6E
VK_DIVIDE=0x6F
VK_F1=0x70
VK_F2=0x71
VK_F3=0x72
VK_F4=0x73
VK_F5=0x74
VK_F6=0x75
VK_F7=0x76
VK_F8=0x77
VK_F9=0x78
VK_F10=0x79
VK_F11=0x7A
VK_F12=0x7B
VK_F13=0x7C
VK_F14=0x7D
VK_F15=0x7E
VK_F16=0x7F
VK_F17=0x80
VK_F18=0x81
VK_F19=0x82
VK_F20=0x83
VK_F21=0x84
VK_F22=0x85
VK_F23=0x86
VK_F24=0x87
VK_NUMLOCK=0x90
VK_SCROLL=0x91
VK_LSHIFT=0xA0
VK_RSHIFT=0xA1
VK_LCONTROL=0xA2
VK_RCONTROL=0xA3
VK_LMENU=0xA4
VK_RMENU=0xA5
VK_BROWSER_BACK=0xA6
VK_BROWSER_FORWARD=0xA7
VK_BROWSER_REFRESH=0xA8
VK_BROWSER_STOP=0xA9
VK_BROWSER_SEARCH=0xAA
VK_BROWSER_FAVORITES=0xAB
VK_BROWSER_HOME=0xAC
VK_VOLUME_MUTE=0xAD
VK_VOLUME_DOWN=0xAE
VK_VOLUME_UP=0xAF
VK_MEDIA_NEXT_TRACK=0xB0
VK_MEDIA_PREV_TRACK=0xB1
VK_MEDIA_STOP=0xB2
VK_MEDIA_PLAY_PAUSE=0xB3
VK_LAUNCH_MAIL=0xB4
VK_LAUNCH_MEDIA_SELECT=0xB5
VK_LAUNCH_APP1=0xB6
VK_LAUNCH_APP2=0xB7
VK_OEM_1=0xBA
VK_OEM_PLUS=0xBB
VK_OEM_COMMA=0xBC
VK_OEM_MINUS=0xBD
VK_OEM_PERIOD=0xBE
VK_OEM_2=0xBF
VK_OEM_3=0xC0
VK_OEM_4=0xDB
VK_OEM_5=0xDC
VK_OEM_6=0xDD
VK_OEM_7=0xDE
VK_OEM_8=0xDF
VK_OEM_102=0xE2
VK_PROCESSKEY=0xE5
VK_PACKET=0xE7
VK_ATTN=0xF6
VK_CRSEL=0xF7
VK_EXSEL=0xF8
VK_EREOF=0xF9
VK_PLAY=0xFA
VK_ZOOM=0xFB
VK_NONAME=0xFC
VK_PA1=0xFD
VK_OEM_CLEAR=0xFE

CF_TEXT=1
CF_BITMAP=2
CF_METAFILEPICT=3
CF_SYLK=4
CF_DIF=5
CF_TIFF=6
CF_OEMTEXT=7
CF_DIB=8
CF_PALETTE=9
CF_PENDATA=10
CF_RIFF=11
CF_WAVE=12
CF_UNICODETEXT=13
CF_ENHMETAFILE=14
CF_HDROP=15
CF_LOCALE=16
CF_MAX=17
CF_OWNERDISPLAY=128
CF_DSPTEXT=129
CF_DSPBITMAP=130
CF_DSPMETAFILEPICT=131
CF_DSPENHMETAFILE=142
CF_PRIVATEFIRST=512
CF_PRIVATELAST=767
CF_GDIOBJFIRST=768
CF_GDIOBJLAST=1023


GPTR=64
GHND=66
</t>
<t tx="ekr.20071201085751.1201">import sys

success=False
in_ironpython="IronPython" in sys.version

if in_ironpython:
    try:
        from ironpython_keysyms import *
        success=True
    except ImportError,x:
        raise
else:
    try:
        from keysyms import *
        success=True
    except ImportError,x:
        pass
    
if not success:
    raise ImportError("Could not import keysym for local pythonversion",x)</t>
<t tx="ekr.20071201085751.1202"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
import re,operator,string,sys,os

#import wordmatcher
#import pyreadline.clipboard as clipboard
if "pyreadline" in sys.modules:
    pyreadline= sys.modules["pyreadline"]
else:
    import pyreadline

import lineobj

import exceptions

</t>
<t tx="ekr.20071201085751.1203">class EscapeHistory(exceptions.Exception):
    pass

</t>
<t tx="ekr.20071201085751.1204">from pyreadline.logger import log_sock

class LineHistory(object):
    @others
</t>
<t tx="ekr.20071201085751.1205">def __init__(self):
    self.history=[]
    self._history_length=100
    self._history_cursor=0
    self.history_filename=os.path.expanduser('~/.history')
    self.lastcommand=None
    self.query=""

</t>
<t tx="ekr.20071201085751.1206">def get_history_length(self):
    value=self._history_length
    log_sock("get_history_length:%d"%value,"history")
    return value

</t>
<t tx="ekr.20071201085751.1207">def set_history_length(self,value):
    log_sock("set_history_length: old:%d new:%d"%(self._history_length,value),"history")
    self._history_length=value

</t>
<t tx="ekr.20071201085751.1208">def get_history_cursor(self):
    value=self._history_cursor
    log_sock("get_history_cursor:%d"%value,"history")
    return value

</t>
<t tx="ekr.20071201085751.1209">def set_history_cursor(self,value):
    log_sock("set_history_cursor: old:%d new:%d"%(self._history_cursor,value),"history")
    self._history_cursor=value
    
</t>
<t tx="ekr.20071201085751.1210">history_length=property(get_history_length,set_history_length)
history_cursor=property(get_history_cursor,set_history_cursor)

def clear_history(self):
    '''Clear readline history.'''
    self.history[:] = []
    self.history_cursor = 0

</t>
<t tx="ekr.20071201085751.1211">def read_history_file(self, filename=None): 
    '''Load a readline history file.'''
    if filename is None:
        filename=self.history_filename
    try:
        for line in open(filename, 'r'):
            self.add_history(lineobj.ReadLineTextBuffer(line.rstrip()))
    except IOError:
        self.history = []
        self.history_cursor = 0

</t>
<t tx="ekr.20071201085751.1212">def write_history_file(self, filename=None): 
    '''Save a readline history file.'''
    if filename is None:
        filename=self.history_filename
    fp = open(filename, 'wb')
    for line in self.history[-self.history_length:]:
        fp.write(line.get_line_text())
        fp.write('\n')
    fp.close()


</t>
<t tx="ekr.20071201085751.1213">def add_history(self, line):
    '''Append a line to the history buffer, as if it was the last line typed.'''
    if not line.get_line_text():
        pass
    elif len(self.history) &gt; 0 and self.history[-1].get_line_text() == line.get_line_text():
        pass
    else:
        self.history.append(line)
    self.history_cursor = len(self.history)

</t>
<t tx="ekr.20071201085751.1214">def previous_history(self,current): # (C-p)
    '''Move back through the history list, fetching the previous command. '''
    if self.history_cursor==len(self.history):
        self.history.append(current.copy()) #do not use add_history since we do not want to increment cursor
        
    if self.history_cursor &gt; 0:
        self.history_cursor -= 1
        current.set_line(self.history[self.history_cursor].get_line_text())
        current.point=lineobj.EndOfLine

</t>
<t tx="ekr.20071201085751.1215">def next_history(self,current): # (C-n)
    '''Move forward through the history list, fetching the next command. '''
    if self.history_cursor &lt; len(self.history)-1:
        self.history_cursor += 1
        current.set_line(self.history[self.history_cursor].get_line_text())

</t>
<t tx="ekr.20071201085751.1216">def beginning_of_history(self): # (M-&lt;)
    '''Move to the first line in the history.'''
    self.history_cursor = 0
    if len(self.history) &gt; 0:
        self.l_buffer = self.history[0]

</t>
<t tx="ekr.20071201085751.1217">def end_of_history(self,current): # (M-&gt;)
    '''Move to the end of the input history, i.e., the line currently
    being entered.'''
    self.history_cursor=len(self.history)
    current.set_line(self.history[-1].get_line_text())

</t>
<t tx="ekr.20071201085751.1218">def reverse_search_history(self,searchfor,startpos=None):
    if startpos is None:
        startpos=self.history_cursor
    res=[(idx,line)  for idx,line in enumerate(self.history[startpos:0:-1]) if line.startswith(searchfor)]
    if res:
        self.history_cursor-=res[0][0]
        return res[0][1].get_line_text()
    return ""
    
</t>
<t tx="ekr.20071201085751.1219">def forward_search_history(self,searchfor,startpos=None):
    if startpos is None:
        startpos=self.history_cursor
    res=[(idx,line) for idx,line in enumerate(self.history[startpos:]) if line.startswith(searchfor)]
    if res:
        self.history_cursor+=res[0][0]
        return res[0][1].get_line_text()
    return ""

</t>
<t tx="ekr.20071201085751.1220">def _non_i_search(self, direction, current):
    c = pyreadline.rl.console
    line = current.get_line_text()
    query = ''
    while 1:
        c.pos(*pyreadline.rl.prompt_end_pos)
        scroll = c.write_scrolling(":%s" % query)
        pyreadline.rl._update_prompt_pos(scroll)
        pyreadline.rl._clear_after()

        event = c.getkeypress()
        log_sock(str(event),"history")
        
        if event.keyinfo.keyname == 'backspace':
            if len(query) &gt; 0:
                query = query[:-1]
            else:
                break
        elif event.char in string.letters + string.digits + string.punctuation + ' ':
            query += event.char
        elif event.keyinfo.keyname == 'return':
            break
        else:
            pyreadline.rl._bell()
    log_sock(query,"history")
    res=""
    if query:
        if direction==-1:
            res=self.reverse_search_history(query)
            
        else:
            res=self.forward_search_history(query)
        log_sock(res,"history")
    return lineobj.ReadLineTextBuffer(res,point=0)
    
</t>
<t tx="ekr.20071201085751.1221">def non_incremental_reverse_search_history(self,current): # (M-p)
    '''Search backward starting at the current line and moving up
    through the history as necessary using a non-incremental search for
    a string supplied by the user.'''
    return self._non_i_search(-1,current)

</t>
<t tx="ekr.20071201085751.1222">def non_incremental_forward_search_history(self,current): # (M-n)
    '''Search forward starting at the current line and moving down
    through the the history as necessary using a non-incremental search
    for a string supplied by the user.'''
    return self._non_i_search(1,current)

</t>
<t tx="ekr.20071201085751.1223">def _search(self, direction, partial):
    try:
        if (self.lastcommand != self.history_search_forward and
                self.lastcommand != self.history_search_backward):
            self.query = ''.join(partial[0:partial.point].get_line_text())
        hcstart=max(self.history_cursor,0) 
        log_sock("hcstart %s"%hcstart,"history")
        hc = self.history_cursor + direction
        while (direction &lt; 0 and hc &gt;= 0) or (direction &gt; 0 and hc &lt; len(self.history)):
            h = self.history[hc]
            if not self.query:
                self.history_cursor = hc
                result=lineobj.ReadLineTextBuffer(h,point=len(h.get_line_text()))
                return result
            elif h.get_line_text().startswith(self.query) and h != partial.get_line_text():
                self.history_cursor = hc
                result=lineobj.ReadLineTextBuffer(h,point=partial.point)
                return result
            hc += direction
        else:
            if len(self.history)==0:
                pass 
            elif hc&gt;=len(self.history) and not self.query:
                self.history_cursor=len(self.history)
                return lineobj.ReadLineTextBuffer("",point=0)
            elif self.history[max(min(hcstart,len(self.history)-1),0)].get_line_text().startswith(self.query) and self.query:
                return lineobj.ReadLineTextBuffer(self.history[max(min(hcstart,len(self.history)-1),0)],point=partial.point)
            else:                
                return lineobj.ReadLineTextBuffer(partial,point=partial.point)
            return lineobj.ReadLineTextBuffer(self.query,point=min(len(self.query),partial.point))
    except IndexError:
        log_sock("hcstart:%s %s"%(hcstart,len(self.history)),"history")
        raise

</t>
<t tx="ekr.20071201085751.1224">def history_search_forward(self,partial): # ()
    '''Search forward through the history for the string of characters
    between the start of the current line and the point. This is a
    non-incremental search. By default, this command is unbound.'''
    q= self._search(1,partial)
    return q

</t>
<t tx="ekr.20071201085751.1225">def history_search_backward(self,partial): # ()
    '''Search backward through the history for the string of characters
    between the start of the current line and the point. This is a
    non-incremental search. By default, this command is unbound.'''
    
    q= self._search(-1,partial)
    return q


    
</t>
<t tx="ekr.20071201085751.1226"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
import re,operator

import wordmatcher
import pyreadline.clipboard as clipboard
from pyreadline.logger import  log,log_sock
</t>
<t tx="ekr.20071201085751.1227">class NotAWordError(IndexError):
    pass


</t>
<t tx="ekr.20071201085751.1228">def quote_char(c):
    if ord(c)&gt;0:
        return c

</t>
<t tx="ekr.20071201085751.1229">############## Line positioner ########################

class LinePositioner(object):
    @others
</t>
<t tx="ekr.20071201085751.1230">def __call__(self,line):
    NotImplementedError("Base class !!!")

</t>
<t tx="ekr.20071201085751.1231">class NextChar(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1232">def __call__(self,line):
    if line.point&lt;len(line.line_buffer):
        return line.point+1
    else:
        return line.point
</t>
<t tx="ekr.20071201085751.1233">NextChar=NextChar()

class PrevChar(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1234">def __call__(self,line):
    if line.point&gt;0:
        return line.point-1
    else:
        return line.point
</t>
<t tx="ekr.20071201085751.1235">PrevChar=PrevChar()

class NextWordStart(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1236">def __call__(self,line):
    return line.next_start_segment(line.line_buffer,line.is_word_token)[line.point]
</t>
<t tx="ekr.20071201085751.1237">NextWordStart=NextWordStart()

class NextWordEnd(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1238">def __call__(self,line):
    return line.next_end_segment(line.line_buffer,line.is_word_token)[line.point]
</t>
<t tx="ekr.20071201085751.1239">NextWordEnd=NextWordEnd()

class PrevWordStart(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1240">def __call__(self,line):
    return line.prev_start_segment(line.line_buffer,line.is_word_token)[line.point]
</t>
<t tx="ekr.20071201085751.1241">PrevWordStart=PrevWordStart()


class WordStart(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1242">def __call__(self,line):
    if line.is_word_token(line.get_line_text()[Point(line):Point(line)+1]):
        if Point(line)&gt;0 and line.is_word_token(line.get_line_text()[Point(line)-1:Point(line)]):
            return PrevWordStart(line)
        else:
            return line.point
    else:   
        raise NotAWordError("Point is not in a word")
</t>
<t tx="ekr.20071201085751.1243">WordStart=WordStart()

class WordEnd(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1244">def __call__(self,line):
    if line.is_word_token(line.get_line_text()[Point(line):Point(line)+1]):
        if line.is_word_token(line.get_line_text()[Point(line)+1:Point(line)+2]):
            return NextWordEnd(line)
        else:
            return line.point
    else:   
        raise NotAWordError("Point is not in a word")
</t>
<t tx="ekr.20071201085751.1245">WordEnd=WordEnd()

class PrevWordEnd(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1246">def __call__(self,line):
    return line.prev_end_segment(line.line_buffer,line.is_word_token)[line.point]
</t>
<t tx="ekr.20071201085751.1247">PrevWordEnd=PrevWordEnd()

class PrevSpace(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1248">def __call__(self,line):
    point=line.point
    if line[point-1:point].get_line_text()==" ":
        while point&gt;0 and line[point-1:point].get_line_text()==" ":
            point-=1
    while point&gt;0 and line[point-1:point].get_line_text()!=" ":
        point-=1
    return point
</t>
<t tx="ekr.20071201085751.1249">PrevSpace=PrevSpace()


class StartOfLine(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1250">def __call__(self,line):
    return 0
</t>
<t tx="ekr.20071201085751.1251">StartOfLine=StartOfLine()

class EndOfLine(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1252">def __call__(self,line):
    return len(line.line_buffer)
</t>
<t tx="ekr.20071201085751.1253">EndOfLine=EndOfLine()

class Point(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1254">def __call__(self,line):
    return line.point
</t>
<t tx="ekr.20071201085751.1255">Point=Point()

class Mark(LinePositioner):
    @others
</t>
<t tx="ekr.20071201085751.1256">def __call__(self,line):
    return line.mark
</t>
<t tx="ekr.20071201085751.1257">Mark=Mark()

all_positioners=[(value.__class__.__name__,value) for key,value in globals().items() if isinstance(value,LinePositioner)]
all_positioners.sort()

############### LineSlice #################

class LineSlice(object):
    @others
</t>
<t tx="ekr.20071201085751.1258">def __call__(self,line):
    NotImplementedError("Base class !!!")


</t>
<t tx="ekr.20071201085751.1259">class CurrentWord(LineSlice):
    @others
</t>
<t tx="ekr.20071201085751.1260">def __call__(self,line):
    return slice(WordStart(line),WordEnd(line),None)
</t>
<t tx="ekr.20071201085751.1261">CurrentWord=CurrentWord()

class NextWord(LineSlice):
    @others
</t>
<t tx="ekr.20071201085751.1262">def __call__(self,line):
    work=TextLine(line)
    work.point=NextWordStart
    start=work.point
    stop=NextWordEnd(work)
    return slice(start,stop)
</t>
<t tx="ekr.20071201085751.1263">NextWord=NextWord()

class PrevWord(LineSlice):
    @others
</t>
<t tx="ekr.20071201085751.1264">def __call__(self,line):
    work=TextLine(line)
    work.point=PrevWordEnd
    stop=work.point
    start=PrevWordStart(work)
    return slice(start,stop)
</t>
<t tx="ekr.20071201085751.1265">PrevWord=PrevWord()

class PointSlice(LineSlice):
    @others
</t>
<t tx="ekr.20071201085751.1266">def __call__(self,line):
    return slice(Point(line),Point(line)+1,None)
</t>
<t tx="ekr.20071201085751.1267">PointSlice=PointSlice()


###############  TextLine  ######################

class TextLine(object):
    @others
</t>
<t tx="ekr.20071201085751.1268">def __init__(self,txtstr,point=None,mark=None):
    self.line_buffer=[]
    self._point=0
    self.mark=-1
    self.undo_stack=[]
    self.overwrite=False
    if isinstance(txtstr,TextLine): #copy 
        self.line_buffer=txtstr.line_buffer[:]
        if point is None:
            self.point=txtstr.point
        else:                
            self.point=point
        if mark is None:
            self.mark=txtstr.mark
        else:
            self.mark=mark
    else:            
        self._insert_text(txtstr)
        if point is None:
            self.point=0
        else:
            self.point=point
        if mark is None:
            self.mark=-1
        else:
            self.mark=mark

    self.is_word_token=wordmatcher.is_word_token
    self.next_start_segment=wordmatcher.next_start_segment
    self.next_end_segment=wordmatcher.next_end_segment
    self.prev_start_segment=wordmatcher.prev_start_segment
    self.prev_end_segment=wordmatcher.prev_end_segment

</t>
<t tx="ekr.20071201085751.1269">def push_undo(self):
    ltext = self.get_line_text()
    if self.undo_stack and ltext == self.undo_stack[-1].get_line_text():
        self.undo_stack[-1].point = self.point
    else:
        self.undo_stack.append(self.copy())

</t>
<t tx="ekr.20071201085751.1270">def pop_undo(self):
    if len(self.undo_stack) &gt;= 2:
        self.undo_stack.pop()
        self.set_top_undo()
        self.undo_stack.pop()
    else:
        self.reset_line()
        self.undo_stack = []

</t>
<t tx="ekr.20071201085751.1271">def set_top_undo(self):
    if self.undo_stack:
        undo=self.undo_stack[-1]
        self.line_buffer=undo.line_buffer
        self.point=undo.point
        self.mark=undo.mark
    else:
        pass

</t>
<t tx="ekr.20071201085751.1272">def __repr__(self):
    return 'TextLine("%s",point=%s,mark=%s)'%(self.line_buffer,self.point,self.mark)

</t>
<t tx="ekr.20071201085751.1273">def copy(self):
    return self.__class__(self)

</t>
<t tx="ekr.20071201085751.1274">def set_point(self,value):
    if isinstance(value,LinePositioner):
        value=value(self)
    assert  (value &lt;= len(self.line_buffer))           
    if value&gt;len(self.line_buffer):
        value=len(self.line_buffer)
    self._point=value
</t>
<t tx="ekr.20071201085751.1275">def get_point(self):
    return self._point
</t>
<t tx="ekr.20071201085751.1276">point=property(get_point,set_point)


def visible_line_width(self,position=Point):
    """Return the visible width of the text in line buffer up to position."""
    return len(self[:position].quoted_text())+self[:position].line_buffer.count("\t")*7

</t>
<t tx="ekr.20071201085751.1277">def quoted_text(self):
    quoted = [ quote_char(c) for c in self.line_buffer ]
    self.line_char_width = [ len(c) for c in quoted ]
    return ''.join(quoted)

</t>
<t tx="ekr.20071201085751.1278">def get_line_text(self):
    return ''.join(self.line_buffer)

</t>
<t tx="ekr.20071201085751.1279">def set_line(self, text, cursor=None):
    self.line_buffer = [ c for c in str(text) ]
    if cursor is None:
        self.point = len(self.line_buffer)
    else:
        self.point = cursor

</t>
<t tx="ekr.20071201085751.1280">def reset_line(self):
    self.line_buffer = []
    self.point = 0

</t>
<t tx="ekr.20071201085751.1281">def end_of_line(self):
    self.point = len(self.line_buffer)

</t>
<t tx="ekr.20071201085751.1282">def _insert_text(self, text):
    if self.overwrite:
        for c in text:
            #if self.point:
            self.line_buffer[self.point]= c
            self.point += 1
    else:            
        for c in text:
            self.line_buffer.insert(self.point, c)
            self.point += 1

</t>
<t tx="ekr.20071201085751.1283">def __getitem__(self,key):
    #Check if key is LineSlice, convert to regular slice
    #and continue processing
    if isinstance(key,LineSlice): 
        key=key(self)
    if isinstance(key,slice):
        if key.step is None:
            pass
        else:
            raise Error
        if key.start is None:
            start=StartOfLine(self)
        elif isinstance(key.start,LinePositioner):
            start=key.start(self)
        else:
            start=key.start
        if key.stop is None:                   
            stop=EndOfLine(self)
        elif isinstance(key.stop,LinePositioner):
            stop=key.stop(self)
        else:
            stop=key.stop
        return self.__class__(self.line_buffer[start:stop],point=0)
    elif isinstance(key,LinePositioner):
        return self.line_buffer[key(self)]
    elif isinstance(key,tuple):
        raise IndexError("Cannot use step in line buffer indexing") #Multiple slice not allowed
    else:
        # return TextLine(self.line_buffer[key])
        return self.line_buffer[key]

</t>
<t tx="ekr.20071201085751.1284">def __delitem__(self,key):
    point=self.point
    if isinstance(key,LineSlice):
        key=key(self)
    if isinstance(key,slice):
        start=key.start
        stop=key.stop
        if isinstance(start,LinePositioner):
            start=start(self)
        elif start is None:
            start=0
        if isinstance(stop,LinePositioner):
            stop=stop(self)
        elif stop is None:
            stop=EndOfLine(self)
    elif isinstance(key,LinePositioner):
        start=key(self)
        stop=start+1
    else:
        start=key
        stop=key+1
    prev=self.line_buffer[:start]
    rest=self.line_buffer[stop:]
    self.line_buffer=prev+rest
    if point&gt;stop:
        self.point=point-(stop-start)
    elif point&gt;=start and point &lt;=stop:
        self.point=start


</t>
<t tx="ekr.20071201085751.1285">def __setitem__(self,key,value):
    if isinstance(key,LineSlice):
        key=key(self)
    if isinstance(key,slice):
        start=key.start
        stop=key.stop
    elif isinstance(key,LinePositioner):
        start=key(self)
        stop=start+1
    else:
        start=key
        stop=key+1
    prev=self.line_buffer[:start]
    value=self.__class__(value).line_buffer
    rest=self.line_buffer[stop:]
    out=prev+value+rest
    if len(out)&gt;=len(self):
        self.point=len(self)
    self.line_buffer=out

</t>
<t tx="ekr.20071201085751.1286">def __len__(self):
    return len(self.line_buffer)

</t>
<t tx="ekr.20071201085751.1287">def upper(self):
    self.line_buffer=[x.upper() for x in self.line_buffer]
    return self

</t>
<t tx="ekr.20071201085751.1288">def lower(self):
    self.line_buffer=[x.lower() for x in self.line_buffer]
    return self

</t>
<t tx="ekr.20071201085751.1289">def capitalize(self):
    self.set_line(self.get_line_text().capitalize(),self.point)
    return self

</t>
<t tx="ekr.20071201085751.1290">def startswith(self,txt):
    return self.get_line_text().startswith(txt)

</t>
<t tx="ekr.20071201085751.1291">def endswith(self,txt):
    return self.get_line_text().endswith(txt)

</t>
<t tx="ekr.20071201085751.1292">def __contains__(self,txt):
    return txt in self.get_line_text()


</t>
<t tx="ekr.20071201085751.1293">lines=[TextLine("abc"),
       TextLine("abc def"),
       TextLine("abc def  ghi"),
       TextLine("  abc  def  "),
      ]
l=lines[2]
l.point=5



class ReadLineTextBuffer(TextLine):
    @others
</t>
<t tx="ekr.20071201085751.1294">def __init__(self,txtstr,point=None,mark=None):
    super(ReadLineTextBuffer,self).__init__(txtstr,point,mark)
    self.enable_win32_clipboard=True
    self.selection_mark=-1
    self.enable_selection=True
    self.kill_ring=[]
</t>
<t tx="ekr.20071201085751.1295">def __repr__(self):
    return 'ReadLineTextBuffer("%s",point=%s,mark=%s,selection_mark=%s)'%(self.line_buffer,self.point,self.mark,self.selection_mark)


</t>
<t tx="ekr.20071201085751.1296">def insert_text(self,char):
    self.delete_selection()
    self.selection_mark=-1
    self._insert_text(char)

</t>
<t tx="ekr.20071201085751.1297">def to_clipboard(self):
    if self.enable_win32_clipboard:
            clipboard.set_clipboard_text(self.get_line_text())

</t>
<t tx="ekr.20071201085751.1298">######### Movement

def beginning_of_line(self):
    self.selection_mark=-1
    self.point=StartOfLine

</t>
<t tx="ekr.20071201085751.1299">def end_of_line(self):
    self.selection_mark=-1
    self.point=EndOfLine

</t>
<t tx="ekr.20071201085751.1300">def forward_char(self,argument=1):
    if argument&lt;0:
        self.backward_char(-argument)
    self.selection_mark=-1
    for x in range(argument):
        self.point=NextChar

</t>
<t tx="ekr.20071201085751.1301">def backward_char(self,argument=1):
    if argument&lt;0:
        self.forward_char(-argument)
    self.selection_mark=-1
    for x in range(argument):
        self.point=PrevChar

</t>
<t tx="ekr.20071201085751.1302">def forward_word(self,argument=1):
    if argument&lt;0:
        self.backward_word(-argument)
    self.selection_mark=-1
    for x in range(argument):
        self.point=NextWordStart

</t>
<t tx="ekr.20071201085751.1303">def backward_word(self,argument=1):
    if argument&lt;0:
        self.forward_word(-argument)
    self.selection_mark=-1
    for x in range(argument):
        self.point=PrevWordStart

</t>
<t tx="ekr.20071201085751.1304">def forward_word_end(self,argument=1):
    if argument&lt;0:
        self.backward_word_end(-argument)
    self.selection_mark=-1
    for x in range(argument):
        self.point=NextWordEnd

</t>
<t tx="ekr.20071201085751.1305">def backward_word_end(self,argument=1):
    if argument&lt;0:
        self.forward_word_end(-argument)
    self.selection_mark=-1
    for x in range(argument):
        self.point=NextWordEnd

</t>
<t tx="ekr.20071201085751.1306">######### Movement select
def beginning_of_line_extend_selection(self):
    if self.enable_selection and self.selection_mark&lt;0:
        self.selection_mark=self.point
    self.point=StartOfLine

</t>
<t tx="ekr.20071201085751.1307">def end_of_line_extend_selection(self):
    if self.enable_selection and self.selection_mark&lt;0:
        self.selection_mark=self.point
    self.point=EndOfLine

</t>
<t tx="ekr.20071201085751.1308">def forward_char_extend_selection(self,argument=1):
    if argument&lt;0:
        self.backward_char_extend_selection(-argument)
    if self.enable_selection and self.selection_mark&lt;0:
        self.selection_mark=self.point
    for x in range(argument):
        self.point=NextChar

</t>
<t tx="ekr.20071201085751.1309">def backward_char_extend_selection(self,argument=1):
    if argument&lt;0:
        self.forward_char_extend_selection(-argument)
    if self.enable_selection and self.selection_mark&lt;0:
        self.selection_mark=self.point
    for x in range(argument):
        self.point=PrevChar

</t>
<t tx="ekr.20071201085751.1310">def forward_word_extend_selection(self,argument=1):
    if argument&lt;0:
        self.backward_word_extend_selection(-argument)
    if self.enable_selection and self.selection_mark&lt;0:
        self.selection_mark=self.point
    for x in range(argument):
        self.point=NextWordStart

</t>
<t tx="ekr.20071201085751.1311">def backward_word_extend_selection(self,argument=1):
    if argument&lt;0:
        self.forward_word_extend_selection(-argument)
    if self.enable_selection and self.selection_mark&lt;0:
        self.selection_mark=self.point
    for x in range(argument):
        self.point=PrevWordStart


</t>
<t tx="ekr.20071201085751.1312">def forward_word_end_extend_selection(self,argument=1):
    if argument&lt;0:
        self.backward_word_end_extend_selection(-argument)
    if self.enable_selection and self.selection_mark&lt;0:
        self.selection_mark=self.point
    for x in range(argument):
        self.point=NextWordEnd

</t>
<t tx="ekr.20071201085751.1313">def backward_word_end_extend_selection(self,argument=1):
    if argument&lt;0:
        self.forward_word_end_extend_selection(-argument)
    if self.enable_selection and self.selection_mark&lt;0:
        self.selection_mark=self.point
    for x in range(argument):
        self.point=PrevWordEnd


</t>
<t tx="ekr.20071201085751.1314">######### delete       

def delete_selection(self):
    if self.enable_selection and self.selection_mark&gt;=0:
        if self.selection_mark&lt;self.point:
            del self[self.selection_mark:self.point]
            self.selection_mark=-1
        else:                
            del self[self.point:self.selection_mark]
            self.selection_mark=-1
        return True
    else:
        self.selection_mark=-1
        return False

</t>
<t tx="ekr.20071201085751.1315">def delete_char(self,argument=1):
    if argument&lt;0:
        self.backward_delete_char(-argument)
    if self.delete_selection():
        argument-=1
    for x in range(argument):
        del self[Point]

</t>
<t tx="ekr.20071201085751.1316">def backward_delete_char(self,argument=1):
    if argument&lt;0:
        self.delete_char(-argument)
    if self.delete_selection():
        argument-=1
    for x in range(argument):
        if self.point&gt;0:
            self.backward_char()
            self.delete_char()

</t>
<t tx="ekr.20071201085751.1317">def forward_delete_word(self,argument=1):
    if argument&lt;0:
        self.backward_delete_word(-argument)
    if self.delete_selection():
        argument-=1
    for x in range(argument):
        del self[Point:NextWordStart]

</t>
<t tx="ekr.20071201085751.1318">def backward_delete_word(self,argument=1):
    if argument&lt;0:
        self.forward_delete_word(-argument)
    if self.delete_selection():
        argument-=1
    for x in range(argument):
        del self[PrevWordStart:Point]

</t>
<t tx="ekr.20071201085751.1319">def delete_current_word(self):
    if not self.delete_selection():
        del self[CurrentWord]
    self.selection_mark=-1

</t>
<t tx="ekr.20071201085751.1320">def delete_horizontal_space(self):
    if self[Point] in " \t":
        del self[PrevWordEnd:NextWordStart]
    self.selection_mark=-1
</t>
<t tx="ekr.20071201085751.1321">######### Case

def upcase_word(self):
    p=self.point
    try:
        self[CurrentWord]=self[CurrentWord].upper()
        self.point=p
    except NotAWordError:
        pass

</t>
<t tx="ekr.20071201085751.1322">def downcase_word(self):
    p=self.point
    try:
        self[CurrentWord]=self[CurrentWord].lower()
        self.point=p
    except NotAWordError:
        pass

</t>
<t tx="ekr.20071201085751.1323">def capitalize_word(self):
    p=self.point
    try:
        self[CurrentWord]=self[CurrentWord].capitalize()
        self.point=p
    except NotAWordError:
        pass
</t>
<t tx="ekr.20071201085751.1324">########### Transpose
def transpose_chars(self):
    p2=Point(self)
    if p2==0:
        return
    elif p2==len(self):
        p2=p2-1
    p1=p2-1
    self[p2],self[p1]=self[p1],self[p2]
    self.point=p2+1

</t>
<t tx="ekr.20071201085751.1325">def transpose_words(self):
    word1=TextLine(self)
    word2=TextLine(self)
    if self.point==len(self):
        word2.point=PrevWordStart
        word1.point=PrevWordStart(word2)
    else:
        word1.point=PrevWordStart
        word2.point=NextWordStart
    stop1=NextWordEnd(word1)
    stop2=NextWordEnd(word2)
    start1=word1.point
    start2=word2.point
    self[start2:stop2]=word1[Point:NextWordEnd]
    self[start1:stop1]=word2[Point:NextWordEnd]
    self.point=stop2


</t>
<t tx="ekr.20071201085751.1326">############ Kill

def kill_line(self):
    #self[self.point:].to_clipboard()
    self.add_to_kill_ring(self[self.point:])
    del self.line_buffer[self.point:]

</t>
<t tx="ekr.20071201085751.1327">def kill_whole_line(self):
    #self[:].to_clipboard()
    self.add_to_kill_ring(self[:])
    del self[:]

</t>
<t tx="ekr.20071201085751.1328">def backward_kill_line(self):
    #self[StartOfLine:Point].to_clipboard()
    del self[StartOfLine:Point]

</t>
<t tx="ekr.20071201085751.1329">def unix_line_discard(self):
    del self[StartOfLine:Point]
    pass

</t>
<t tx="ekr.20071201085751.1330">def kill_word(self):
    """Kills to next word ending"""
    #self[Point:NextWordEnd].to_clipboard()
    del self[Point:NextWordEnd]

</t>
<t tx="ekr.20071201085751.1331">def backward_kill_word(self):
    """Kills to next word ending"""
    #self[PrevWordStart:Point].to_clipboard()
    if not self.delete_selection():
        del self[PrevWordStart:Point]
    self.selection_mark=-1

</t>
<t tx="ekr.20071201085751.1332">def forward_kill_word(self):
    """Kills to next word ending"""
    #self[Point:NextWordEnd].to_clipboard()
    if not self.delete_selection():
        del self[Point:NextWordEnd]
    self.selection_mark=-1

</t>
<t tx="ekr.20071201085751.1333">def unix_word_rubout(self):
    if not self.delete_selection():
        del self[PrevSpace:Point]
    self.selection_mark=-1

</t>
<t tx="ekr.20071201085751.1334">def kill_region(self):
    pass

</t>
<t tx="ekr.20071201085751.1335">def copy_region_as_kill(self):
    pass

</t>
<t tx="ekr.20071201085751.1336">def copy_backward_word(self):
    pass

</t>
<t tx="ekr.20071201085751.1337">def copy_forward_word(self):
    pass


</t>
<t tx="ekr.20071201085751.1338">def yank(self):
    self.paste_from_kill_ring()

</t>
<t tx="ekr.20071201085751.1339">def yank_pop(self):
    pass

</t>
<t tx="ekr.20071201085751.1340">##############  Mark 

def set_mark(self):
    self.mark=self.point

</t>
<t tx="ekr.20071201085751.1341">def exchange_point_and_mark(self):
    pass


</t>
<t tx="ekr.20071201085751.1342">def copy_region_to_clipboard(self): # ()
    '''Copy the text in the region to the windows clipboard.'''
    if self.enable_win32_clipboard:
            mark=min(self.mark,len(self.line_buffer))
            cursor=min(self.point,len(self.line_buffer))
            if self.mark==-1:
                    return
            begin=min(cursor,mark)
            end=max(cursor,mark)
            toclipboard="".join(self.line_buffer[begin:end])
            clipboard.SetClipboardText(str(toclipboard))

</t>
<t tx="ekr.20071201085751.1343">def copy_selection_to_clipboard(self): # ()
    '''Copy the text in the region to the windows clipboard.'''
    if self.enable_win32_clipboard and self.enable_selection and self.selection_mark&gt;=0:
            selection_mark=min(self.selection_mark,len(self.line_buffer))
            cursor=min(self.point,len(self.line_buffer))
            if self.selection_mark==-1:
                    return
            begin=min(cursor,selection_mark)
            end=max(cursor,selection_mark)
            toclipboard="".join(self.line_buffer[begin:end])
            clipboard.SetClipboardText(str(toclipboard))


</t>
<t tx="ekr.20071201085751.1344">def cut_selection_to_clipboard(self): # ()
    self.copy_selection_to_clipboard()
    self.delete_selection()
</t>
<t tx="ekr.20071201085751.1345">##############  Paste


############## Kill ring
def add_to_kill_ring(self,txt):
    self.kill_ring=[txt]


</t>
<t tx="ekr.20071201085751.1346">def paste_from_kill_ring(self):
    if self.kill_ring:
        self.insert_text(self.kill_ring[0])


</t>
<t tx="ekr.20071201085751.1347">##################################################################
q=ReadLineTextBuffer("asff asFArw  ewrWErhg",point=8)
q=TextLine("asff asFArw  ewrWErhg",point=8)

def show_pos(buff,pos,chr="."):
    l=len(buff.line_buffer)
    def choice(bool):
        if bool:
            return chr
        else:
            return " "
    return "".join([choice(pos==idx) for idx in range(l+1)])


</t>
<t tx="ekr.20071201085751.1348">def test_positioner(buff,points,positioner):
    print (" %s "%positioner.__class__.__name__).center(40,"-")
    buffstr=buff.line_buffer
    
    print '"%s"'%(buffstr)
    for point in points:
        b=TextLine(buff,point=point)
        out=[" "]*(len(buffstr)+1)
        pos=positioner(b)
        if pos==point:
            out[pos]="&amp;"
        else:
            out[point]="."
            out[pos]="^"
        print '"%s"'%("".join(out))
    
</t>
<t tx="ekr.20071201085751.1349"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

import re,operator


</t>
<t tx="ekr.20071201085751.1350">def str_find_all(str,ch):
    result=[]
    index=0
    while index&gt;=0:
        index=str.find(ch,index)
        if index&gt;=0:
            result.append(index)
            index+=1
    return result
        

</t>
<t tx="ekr.20071201085751.1351">word_pattern=re.compile("(x*)")

def markwords(str,iswordfun):
    markers={True:"x",False:"o"}
    return "".join([markers[iswordfun(ch)] for ch in str])

</t>
<t tx="ekr.20071201085751.1352">def split_words(str,iswordfun):
    return [x for x in word_pattern.split(markwords(str,iswordfun)) if x !=""]

</t>
<t tx="ekr.20071201085751.1353">def mark_start_segment(str,is_segment):
    def mark_start(s):
        if s[0:1]=="x":
            return "s"+s[1:]
        else:
            return s
    return "".join(map(mark_start,split_words(str,is_segment)))

</t>
<t tx="ekr.20071201085751.1354">def mark_end_segment(str,is_segment):
    def mark_start(s):
        if s[0:1]=="x":
            return s[:-1]+"s"
        else:
            return s
    return "".join(map(mark_start,split_words(str,is_segment)))
    
</t>
<t tx="ekr.20071201085751.1355">def mark_start_segment_index(str,is_segment):
    return str_find_all(mark_start_segment(str,is_segment),"s")

</t>
<t tx="ekr.20071201085751.1356">def mark_end_segment_index(str,is_segment):
    return [x+1 for x in str_find_all(mark_end_segment(str,is_segment),"s")]


</t>
<t tx="ekr.20071201085751.1357">################  Following are used in lineobj  ###########################

def is_word_token(str):
    return not is_non_word_token(str)
    
</t>
<t tx="ekr.20071201085751.1358">def is_non_word_token(str):
    if len(str)!=1 or str in " \t\n":
        return True
    else:
        return False

</t>
<t tx="ekr.20071201085751.1359">def next_start_segment(str,is_segment):
    str="".join(str)
    result=[]
    for start in mark_start_segment_index(str,is_segment):
        result[len(result):start]=[start for x in range(start-len(result))]
    result[len(result):len(str)]=[len(str) for x in range(len(str)-len(result)+1)]            
    return result
    
</t>
<t tx="ekr.20071201085751.1360">def next_end_segment(str,is_segment):
    str="".join(str)
    result=[]
    for start in mark_end_segment_index(str,is_segment):
        result[len(result):start]=[start for x in range(start-len(result))]
    result[len(result):len(str)]=[len(str) for x in range(len(str)-len(result)+1)]            
    return result    


</t>
<t tx="ekr.20071201085751.1361">def prev_start_segment(str,is_segment):
    str="".join(str)
    result=[]
    prev=0
    for start in mark_start_segment_index(str,is_segment):
        result[len(result):start+1]=[prev for x in range(start-len(result)+1)]
        prev=start
    result[len(result):len(str)]=[prev for x in range(len(str)-len(result)+1)]            
    return result

</t>
<t tx="ekr.20071201085751.1362">def prev_end_segment(str,is_segment):
    str="".join(str)
    result=[]
    prev=0
    for start in mark_end_segment_index(str,is_segment):
        result[len(result):start+1]=[prev for x in range(start-len(result)+1)]
        prev=start
    result[len(result):len(str)]=[len(str) for x in range(len(str)-len(result)+1)]            
    return result    


</t>
<t tx="ekr.20071201085751.1363"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
import os,re,math,glob,sys
import pyreadline.logger as logger
from   pyreadline.logger import log,log_sock
from   pyreadline.keysyms.common import make_KeyPress_from_keydescr
import pyreadline.lineeditor.lineobj as lineobj
import pyreadline.lineeditor.history as history
import pyreadline.clipboard as clipboard
from pyreadline.error import ReadlineError,GetSetError
in_ironpython="IronPython" in sys.version

</t>
<t tx="ekr.20071201085751.1364">class BaseMode(object):
    mode="base"
    @others
</t>
<t tx="ekr.20071201085751.1365">def __init__(self,rlobj):
    self.rlobj=rlobj
    self.exit_dispatch = {}
    self.key_dispatch = {}
    self.argument=1
    self.prevargument=None
    
</t>
<t tx="ekr.20071201085751.1366">def __repr__(self):
    return "&lt;BaseMode&gt;"

</t>
<t tx="ekr.20071201085751.1367">def _gs(x):
    def g(self):
        return getattr(self.rlobj,x)
    def s(self,q):
        setattr(self.rlobj,x,q)
    return g,s
    
</t>
<t tx="ekr.20071201085751.1368">def _g(x):
    def g(self):
        return getattr(self.rlobj,x)
    return g

</t>
<t tx="ekr.20071201085751.1369">def _argreset(self):
    val=self.argument
    self.argument=1
    return val
</t>
<t tx="ekr.20071201085751.1370">argument_reset=property(_argreset)
    
ctrl_c_tap_time_interval=property(*_gs("ctrl_c_tap_time_interval"))
allow_ctrl_c=property(*_gs("allow_ctrl_c"))
l_buffer=property(*_gs("l_buffer"))
next_meta=property(*_gs("next_meta"))
first_prompt=property(*_gs("first_prompt"))
prompt=property(*_gs("prompt"))
paste_line_buffer=property(*_gs("paste_line_buffer"))
completer_delims=property(*_gs("completer_delims"))
show_all_if_ambiguous=property(*_gs("show_all_if_ambiguous"))
mark_directories=property(*_gs("mark_directories"))
completer=property(*_gs("completer"))
begidx=property(*_gs("begidx"))
startup_hook=property(*_gs("startup_hook"))
pre_input_hook=property(*_gs("pre_input_hook"))
endidx=property(*_gs("endidx"))

console=property(_g("console"))
insert_text=property(_g("insert_text"))
_print_prompt=property(_g("_print_prompt"))
_update_line=property(_g("_update_line"))
add_history=property(_g("add_history"))
_bell=property(_g("_bell"))
_clear_after=property(_g("_clear_after"))
_set_cursor=property(_g("_set_cursor"))
_update_prompt_pos=property(_g("_update_prompt_pos"))
_update_line=property(_g("_update_line"))
enable_win32_clipboard=property(_g("enable_win32_clipboard"))
enable_ipython_paste_list_of_lists=property(_g("enable_ipython_paste_list_of_lists"))
enable_ipython_paste_for_paths=property(_g("enable_ipython_paste_for_paths"))
_bell=property(_g("_bell"))
_history=property(_g("_history"))
prompt_end_pos=property(_g("prompt_end_pos"))
prompt_begin_pos=property(_g("prompt_begin_pos"))

rl_settings_to_string=property(_g("rl_settings_to_string"))

def _readline_from_keyboard(self):
    raise NotImplementedError

</t>
<t tx="ekr.20071201085751.1371">def readline(self, prompt=''):
    raise NotImplementedError

</t>
<t tx="ekr.20071201085751.1372">#Create key bindings:

def _bind_key(self, key, func):
    '''setup the mapping from key to call the function.'''
    if type(func) != type(self._bind_key):
        print "Trying to bind non method to keystroke:%s,%s"%(key,func)
        raise PyreadlineError("Trying to bind non method to keystroke:%s,%s,%s,%s"%(key,func,type(func),type(self._bind_key)))
    keyinfo = make_KeyPress_from_keydescr(key.lower()).tuple()
    log("&gt;&gt;&gt;%s -&gt; %s&lt;&lt;&lt;"%(keyinfo,func.__name__))
    self.key_dispatch[keyinfo] = func

</t>
<t tx="ekr.20071201085751.1373">def _bind_exit_key(self, key):
    '''setup the mapping from key to call the function.'''
    keyinfo = make_KeyPress_from_keydescr(key.lower()).tuple()
    self.exit_dispatch[keyinfo] = None

</t>
<t tx="ekr.20071201085751.1374">def init_editing_mode(self, e): # (C-e)
    '''When in vi command mode, this causes a switch to emacs editing
    mode.'''

    raise NotImplementedError
</t>
<t tx="ekr.20071201085751.1375">#completion commands    
    
def _get_completions(self):
   
    '''Return a list of possible completions for the string ending at the point.

    Also set begidx and endidx in the process.'''
    completions = []
    self.begidx = self.l_buffer.point
    self.endidx = self.l_buffer.point
    buf=self.l_buffer.line_buffer
    if self.completer:
        # get the string to complete
        while self.begidx &gt; 0:
            self.begidx -= 1
            if buf[self.begidx] in self.completer_delims:
                self.begidx += 1
                break
        text = ''.join(buf[self.begidx:self.endidx])
        log('complete text="%s"' % text)
        i = 0
        while 1:
            try:
                r = self.completer(text, i)
            except:
                break
            i += 1
            if r and r not in completions:
                completions.append(r)
            else:
                break
        log('text completions=%s' % completions)
    if not completions:
        # get the filename to complete
        while self.begidx &gt; 0:
            self.begidx -= 1
            if buf[self.begidx] in ' \t\n':
                self.begidx += 1
                break
        text = ''.join(buf[self.begidx:self.endidx])
        log('file complete text="%s"' % text)
        completions = glob.glob(os.path.expanduser(text) + '*')
        if self.mark_directories == 'on':
            mc = []
            for f in completions:
                if os.path.isdir(f):
                    mc.append(f + os.sep)
                else:
                    mc.append(f)
            completions = mc
        log('fnames=%s' % completions)
    return completions

   
</t>
<t tx="ekr.20071201085751.1376">def _display_completions(self, completions):
    if not completions:
        return
    self.console.write('\n')
    wmax = max(map(len, completions))
    w, h = self.console.size()
    cols = max(1, int((w-1) / (wmax+1)))
    rows = int(math.ceil(float(len(completions)) / cols))
    for row in range(rows):
        s = ''
        for col in range(cols):
            i = col*rows + row
            if i &lt; len(completions):
                self.console.write(completions[i].ljust(wmax+1))
        self.console.write('\n')
    if in_ironpython:
        self.prompt=sys.ps1
    self._print_prompt()

</t>
<t tx="ekr.20071201085751.1377">def complete(self, e): # (TAB)
    '''Attempt to perform completion on the text before point. The
    actual completion performed is application-specific. The default is
    filename completion.'''
    completions = self._get_completions()
    if completions:
        cprefix = commonprefix(completions)
        rep = [ c for c in cprefix ]
        point=self.l_buffer.point
        self.l_buffer[self.begidx:self.endidx] = rep
        self.l_buffer.point = point + len(rep) - (self.endidx - self.begidx)
        if len(completions) &gt; 1:
            if self.show_all_if_ambiguous == 'on':
                self._display_completions(completions)
            else:
                self._bell()
    else:
        self._bell()

</t>
<t tx="ekr.20071201085751.1378">def possible_completions(self, e): # (M-?)
    '''List the possible completions of the text before point. '''
    completions = self._get_completions()
    self._display_completions(completions)

</t>
<t tx="ekr.20071201085751.1379">def insert_completions(self, e): # (M-*)
    '''Insert all completions of the text before point that would have
    been generated by possible-completions.'''
    completions = self._get_completions()
    b = self.begidx
    e = self.endidx
    for comp in completions:
        rep = [ c for c in comp ]
        rep.append(' ')
        self.l_buffer[b:e] = rep
        b += len(rep)
        e = b
    self.line_cursor = b    

</t>
<t tx="ekr.20071201085751.1380">def menu_complete(self, e): # ()
    '''Similar to complete, but replaces the word to be completed with a
    single match from the list of possible completions. Repeated
    execution of menu-complete steps through the list of possible
    completions, inserting each match in turn. At the end of the list of
    completions, the bell is rung (subject to the setting of bell-style)
    and the original text is restored. An argument of n moves n
    positions forward in the list of matches; a negative argument may be
    used to move backward through the list. This command is intended to
    be bound to TAB, but is unbound by default.'''
    pass

</t>
<t tx="ekr.20071201085751.1381">### Methods below here are bindable emacs functions

def beginning_of_line(self, e): # (C-a)
    '''Move to the start of the current line. '''
    self.l_buffer.beginning_of_line()

</t>
<t tx="ekr.20071201085751.1382">def end_of_line(self, e): # (C-e)
    '''Move to the end of the line. '''
    self.l_buffer.end_of_line()

</t>
<t tx="ekr.20071201085751.1383">def forward_char(self, e): # (C-f)
    '''Move forward a character. '''
    self.l_buffer.forward_char(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1384">def backward_char(self, e): # (C-b)
    '''Move back a character. '''
    self.l_buffer.backward_char(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1385">def forward_word(self, e): # (M-f)
    '''Move forward to the end of the next word. Words are composed of
    letters and digits.'''
    self.l_buffer.forward_word(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1386">def backward_word(self, e): # (M-b)
    '''Move back to the start of the current or previous word. Words are
    composed of letters and digits.'''
    self.l_buffer.backward_word(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1387">def forward_word_end(self, e): # ()
    '''Move forward to the end of the next word. Words are composed of
    letters and digits.'''
    self.l_buffer.forward_word_end(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1388">def backward_word_end(self, e): # ()
    '''Move forward to the end of the next word. Words are composed of
    letters and digits.'''
    self.l_buffer.backward_word_end(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1389">### Movement with extend selection
def beginning_of_line_extend_selection(self, e): # 
    '''Move to the start of the current line. '''
    self.l_buffer.beginning_of_line_extend_selection()

</t>
<t tx="ekr.20071201085751.1390">def end_of_line_extend_selection(self, e): # 
    '''Move to the end of the line. '''
    self.l_buffer.end_of_line_extend_selection()

</t>
<t tx="ekr.20071201085751.1391">def forward_char_extend_selection(self, e): # 
    '''Move forward a character. '''
    self.l_buffer.forward_char_extend_selection(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1392">def backward_char_extend_selection(self, e): #
    '''Move back a character. '''
    self.l_buffer.backward_char_extend_selection(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1393">def forward_word_extend_selection(self, e): # 
    '''Move forward to the end of the next word. Words are composed of
    letters and digits.'''
    self.l_buffer.forward_word_extend_selection(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1394">def backward_word_extend_selection(self, e): # 
    '''Move back to the start of the current or previous word. Words are
    composed of letters and digits.'''
    self.l_buffer.backward_word_extend_selection(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1395">def forward_word_end_extend_selection(self, e): # 
    '''Move forward to the end of the next word. Words are composed of
    letters and digits.'''
    self.l_buffer.forward_word_end_extend_selection(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1396">def backward_word_end_extend_selection(self, e): # 
    '''Move forward to the end of the next word. Words are composed of
    letters and digits.'''
    self.l_buffer.forward_word_end_extend_selection(self.argument_reset)


</t>
<t tx="ekr.20071201085751.1397">######## Change case

def upcase_word(self, e): # (M-u)
    '''Uppercase the current (or following) word. With a negative
    argument, uppercase the previous word, but do not move the cursor.'''
    self.l_buffer.upcase_word()

</t>
<t tx="ekr.20071201085751.1398">def downcase_word(self, e): # (M-l)
    '''Lowercase the current (or following) word. With a negative
    argument, lowercase the previous word, but do not move the cursor.'''
    self.l_buffer.downcase_word()

</t>
<t tx="ekr.20071201085751.1399">def capitalize_word(self, e): # (M-c)
    '''Capitalize the current (or following) word. With a negative
    argument, capitalize the previous word, but do not move the cursor.'''
    self.l_buffer.capitalize_word()


</t>
<t tx="ekr.20071201085751.1400">########
def clear_screen(self, e): # (C-l)
    '''Clear the screen and redraw the current line, leaving the current
    line at the top of the screen.'''
    self.console.page()

</t>
<t tx="ekr.20071201085751.1401">def redraw_current_line(self, e): # ()
    '''Refresh the current line. By default, this is unbound.'''
    pass

</t>
<t tx="ekr.20071201085751.1402">def accept_line(self, e): # (Newline or Return)
    '''Accept the line regardless of where the cursor is. If this line
    is non-empty, it may be added to the history list for future recall
    with add_history(). If this line is a modified history line, the
    history line is restored to its original state.'''
    return True


</t>
<t tx="ekr.20071201085751.1403">def delete_char(self, e): # (C-d)
    '''Delete the character at point. If point is at the beginning of
    the line, there are no characters in the line, and the last
    character typed was not bound to delete-char, then return EOF.'''
    self.l_buffer.delete_char(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1404">def backward_delete_char(self, e): # (Rubout)
    '''Delete the character behind the cursor. A numeric argument means
    to kill the characters instead of deleting them.'''
    self.l_buffer.backward_delete_char(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1405">def backward_delete_word(self, e): # (Control-Rubout)
    '''Delete the character behind the cursor. A numeric argument means
    to kill the characters instead of deleting them.'''
    self.l_buffer.backward_delete_word(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1406">def forward_delete_word(self, e): # (Control-Delete)
    '''Delete the character behind the cursor. A numeric argument means
    to kill the characters instead of deleting them.'''
    self.l_buffer.forward_delete_word(self.argument_reset)

</t>
<t tx="ekr.20071201085751.1407">def delete_horizontal_space(self, e): # ()
    '''Delete all spaces and tabs around point. By default, this is unbound. '''
    self.l_buffer.delete_horizontal_space()

</t>
<t tx="ekr.20071201085751.1408">def self_insert(self, e): # (a, b, A, 1, !, ...)
    '''Insert yourself. '''
    
    if e.char and ord(e.char)!=0: #don't insert null character in buffer, can happen with dead keys.
        self.insert_text(e.char)


</t>
<t tx="ekr.20071201085751.1409">#   Paste from clipboard

def paste(self,e):
    '''Paste windows clipboard.
    Assume single line strip other lines and end of line markers and trailing spaces''' #(Control-v)
    if self.enable_win32_clipboard:
            txt=clipboard.get_clipboard_text_and_convert(False)
            txt=txt.split("\n")[0].strip("\r").strip("\n")
            log("paste: &gt;%s&lt;"%map(ord,txt))
            self.insert_text(txt)

</t>
<t tx="ekr.20071201085751.1410">def paste_mulitline_code(self,e):
    '''Paste windows clipboard as multiline code.
    Removes any empty lines in the code'''
    reg=re.compile("\r?\n")
    if self.enable_win32_clipboard:
            txt=clipboard.get_clipboard_text_and_convert(False)
            t=reg.split(txt)
            t=[row for row in t if row.strip()!=""] #remove empty lines
            if t!=[""]:
                self.insert_text(t[0])
                self.add_history(self.l_buffer.copy())
                self.paste_line_buffer=t[1:]
                log("multi: %s"%self.paste_line_buffer)
                return True
            else:
                return False
    
</t>
<t tx="ekr.20071201085751.1411">def ipython_paste(self,e):
    '''Paste windows clipboard. If enable_ipython_paste_list_of_lists is 
    True then try to convert tabseparated data to repr of list of lists or 
    repr of array.
    If enable_ipython_paste_for_paths==True then change \\ to / and spaces to \space'''
    if self.enable_win32_clipboard:
            txt=clipboard.get_clipboard_text_and_convert(
                                            self.enable_ipython_paste_list_of_lists)
            if self.enable_ipython_paste_for_paths:
                    if len(txt)&lt;300 and ("\t" not in txt) and ("\n" not in txt):
                            txt=txt.replace("\\","/").replace(" ",r"\ ")
            self.insert_text(txt)


</t>
<t tx="ekr.20071201085751.1412">def copy_region_to_clipboard(self, e): # ()
    '''Copy the text in the region to the windows clipboard.'''
    self.l_buffer.copy_region_to_clipboard()

</t>
<t tx="ekr.20071201085751.1413">def copy_selection_to_clipboard(self, e): # ()
    '''Copy the text in the region to the windows clipboard.'''
    self.l_buffer.copy_selection_to_clipboard()

</t>
<t tx="ekr.20071201085751.1414">def cut_selection_to_clipboard(self, e): # ()
    '''Copy the text in the region to the windows clipboard.'''
    self.l_buffer.cut_selection_to_clipboard()


</t>
<t tx="ekr.20071201085751.1415">def dump_functions(self, e): # ()
    '''Print all of the functions and their key bindings to the Readline
    output stream. If a numeric argument is supplied, the output is
    formatted in such a way that it can be made part of an inputrc
    file. This command is unbound by default.'''
    print
    txt="\n".join(self.rl_settings_to_string())
    print txt
    self._print_prompt()




</t>
<t tx="ekr.20071201085751.1416">def commonprefix(m):
    "Given a list of pathnames, returns the longest common leading component"
    if not m: return ''
    prefix = m[0]
    for item in m:
        for i in range(len(prefix)):
            if prefix[:i+1].lower() != item[:i+1].lower():
                prefix = prefix[:i]
                if i == 0: return ''
                break
    return prefix
</t>
<t tx="ekr.20071201085751.1417"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
import os,sys,time
import pyreadline.logger as logger
from   pyreadline.logger import log,log_sock
from pyreadline.lineeditor.lineobj import Point
import pyreadline.lineeditor.lineobj as lineobj
import pyreadline.lineeditor.history as history
import basemode
import string
</t>
<t tx="ekr.20071201085751.1418">def format(keyinfo):
    if len(keyinfo[-1])!=1:
        k=keyinfo+(-1,)
    else:
        k=keyinfo+(ord(keyinfo[-1]),)
    
    return "(%s,%s,%s,%s,%x)"%k
</t>
<t tx="ekr.20071201085751.1419">in_ironpython="IronPython" in sys.version


class EmacsMode(basemode.BaseMode):
    mode="emacs"
    @others
</t>
<t tx="ekr.20071201085751.1420">def __init__(self,rlobj):
    super(EmacsMode,self).__init__(rlobj)
    self._keylog=(lambda x,y: None)
    self.previous_func=None
    self.prompt="&gt;&gt;&gt;"
</t>
<t tx="ekr.20071201085751.1421">def __repr__(self):
    return "&lt;EmacsMode&gt;"

</t>
<t tx="ekr.20071201085751.1422">def add_key_logger(self,logfun):
    """logfun should be function that takes disp_fun and line_buffer object """
    self._keylog=logfun
    
</t>
<t tx="ekr.20071201085751.1423">def _readline_from_keyboard(self):
    c=self.console
    def nop(e):
        pass
    while 1:
        self._update_line()
        try:
            event = c.getkeypress()
        except KeyboardInterrupt:
            from pyreadline.keysyms.common import KeyPress
            from pyreadline.console.event import Event
            event=Event(0,0)
            event.char="c"
            event.keyinfo=KeyPress("c",shift=False,control=True,meta=False,keyname=None)
            log_sock("KBDIRQ")
            if self.allow_ctrl_c:
                now=time.time()
                if (now-self.ctrl_c_timeout)&lt;self.ctrl_c_tap_time_interval:
                    raise
                else:
                    self.ctrl_c_timeout=now
                pass
            else:
                raise
        if self.next_meta:
            self.next_meta = False
            control, meta, shift, code = event.keyinfo
            event.keyinfo = (control, True, shift, code)

        #Process exit keys. Only exit on empty line
        keyinfo=event.keyinfo.tuple()
        if keyinfo in self.exit_dispatch:
            if lineobj.EndOfLine(self.l_buffer) == 0:
                raise EOFError
        if len(keyinfo[-1])&gt;1:
            default=nop
        else:
            default=self.self_insert
        dispatch_func = self.key_dispatch.get(keyinfo,default)
        
        log("readline from keyboard:%s,%s"%(keyinfo,dispatch_func))
        log_sock("%s|%s"%(format(keyinfo),dispatch_func.__name__),"bound_function")
        r = None
        if dispatch_func:
            r = dispatch_func(event)
            self._keylog(dispatch_func,self.l_buffer)
            self.l_buffer.push_undo()

        self.previous_func = dispatch_func
        if r:
            self._update_line()
            break

</t>
<t tx="ekr.20071201085751.1424">def readline(self, prompt=''):
    '''Try to act like GNU readline.'''
    # handle startup_hook
    self.ctrl_c_timeout=time.time()
    self.l_buffer.selection_mark=-1
    if self.first_prompt:
        self.first_prompt = False
        if self.startup_hook:
            try:
                self.startup_hook()
            except:
                print 'startup hook failed'
                traceback.print_exc()

    c = self.console
    self.l_buffer.reset_line()
    self.prompt = prompt
    self._print_prompt()

    if self.pre_input_hook:
        try:
            self.pre_input_hook()
        except:
            print 'pre_input_hook failed'
            traceback.print_exc()
            self.pre_input_hook = None

    log("in readline: %s"%self.paste_line_buffer)
    if len(self.paste_line_buffer)&gt;0:
        self.l_buffer=lineobj.ReadLineTextBuffer(self.paste_line_buffer[0])
        self._update_line()
        self.paste_line_buffer=self.paste_line_buffer[1:]
        c.write('\r\n')
    else:
        self._readline_from_keyboard()
        c.write('\r\n')

    self.add_history(self.l_buffer.copy())

    log('returning(%s)' % self.l_buffer.get_line_text())
    return self.l_buffer.get_line_text() + '\n'

</t>
<t tx="ekr.20071201085751.1425">#########  History commands
def previous_history(self, e): # (C-p)
    '''Move back through the history list, fetching the previous command. '''
    self._history.previous_history(self.l_buffer)
    self.l_buffer.point=lineobj.EndOfLine
    
</t>
<t tx="ekr.20071201085751.1426">def next_history(self, e): # (C-n)
    '''Move forward through the history list, fetching the next command. '''
    self._history.next_history(self.l_buffer)

</t>
<t tx="ekr.20071201085751.1427">def beginning_of_history(self, e): # (M-&lt;)
    '''Move to the first line in the history.'''
    self._history.beginning_of_history()

</t>
<t tx="ekr.20071201085751.1428">def end_of_history(self, e): # (M-&gt;)
    '''Move to the end of the input history, i.e., the line currently
    being entered.'''
    self._history.end_of_history(self.l_buffer)

</t>
<t tx="ekr.20071201085751.1429">def _i_search(self, searchfun, direction, init_event):
    c = self.console
    line = self.l_buffer.get_line_text()
    log_sock(str(line))
    query = ''
    if (self.previous_func != self.history_search_forward and
            self.previous_func != self.history_search_backward):
        self.query = ''.join(self.l_buffer[0:Point].get_line_text())
    hc_start = self._history.history_cursor #+ direction
    while 1:
        x, y = self.prompt_end_pos
        c.pos(0, y)
        if direction &lt; 0:
            prompt = 'reverse-i-search'
        else:
            prompt = 'forward-i-search'

        scroll = c.write_scrolling("%s`%s': %s" % (prompt, query, line))
        self._update_prompt_pos(scroll)
        self._clear_after()

        event = c.getkeypress()
        if event.keyinfo.keyname == 'backspace':
            query = query[:-1]
            if len(query) &gt; 0:
                #self._history.history_cursor = hc_start  #forces search to restart when search empty
                line=searchfun(query)                
            else:
                self._bell()
                line=""   #empty query means no search result
        elif event.char in string.letters + string.digits + string.punctuation + ' ':
            #self._history.history_cursor = hc_start
            query += event.char
            line=searchfun(query)
        elif event.keyinfo == init_event.keyinfo:
            self._history.history_cursor += direction
            line=searchfun(query)                
        else:
            if event.keyinfo.keyname != 'return':
                self._bell()
            break

    px, py = self.prompt_begin_pos
    c.pos(0, py)
    self.l_buffer.set_line(line)
    self._print_prompt()
    self._history.history_cursor=len(self._history.history)

</t>
<t tx="ekr.20071201085751.1430">def reverse_search_history(self, e): # (C-r)
    '''Search backward starting at the current line and moving up
    through the history as necessary. This is an incremental search.'''
    self._i_search(self._history.reverse_search_history, -1, e)

</t>
<t tx="ekr.20071201085751.1431">def forward_search_history(self, e): # (C-s)
    '''Search forward starting at the current line and moving down
    through the the history as necessary. This is an incremental search.'''
    self._i_search(self._history.forward_search_history, 1, e)


</t>
<t tx="ekr.20071201085751.1432">def non_incremental_reverse_search_history(self, e): # (M-p)
    '''Search backward starting at the current line and moving up
    through the history as necessary using a non-incremental search for
    a string supplied by the user.'''
    q=self._history.non_incremental_reverse_search_history(self.l_buffer)
    self.l_buffer=q

</t>
<t tx="ekr.20071201085751.1433">def non_incremental_forward_search_history(self, e): # (M-n)
    '''Search forward starting at the current line and moving down
    through the the history as necessary using a non-incremental search
    for a string supplied by the user.'''
    q=self._history.non_incremental_reverse_search_history(self.l_buffer)
    self.l_buffer=q

</t>
<t tx="ekr.20071201085751.1434">def history_search_forward(self, e): # ()
    '''Search forward through the history for the string of characters
    between the start of the current line and the point. This is a
    non-incremental search. By default, this command is unbound.'''
    if self.previous_func and hasattr(self._history,self.previous_func.__name__):
        self._history.lastcommand=getattr(self._history,self.previous_func.__name__)
    else:
        self._history.lastcommand=None
    q=self._history.history_search_forward(self.l_buffer)
    self.l_buffer=q
    self.l_buffer.point=q.point

</t>
<t tx="ekr.20071201085751.1435">def history_search_backward(self, e): # ()
    '''Search backward through the history for the string of characters
    between the start of the current line and the point. This is a
    non-incremental search. By default, this command is unbound.'''
    if self.previous_func and hasattr(self._history,self.previous_func.__name__):
        self._history.lastcommand=getattr(self._history,self.previous_func.__name__)
    else:
        self._history.lastcommand=None
    q=self._history.history_search_backward(self.l_buffer)
    self.l_buffer=q
    self.l_buffer.point=q.point


</t>
<t tx="ekr.20071201085751.1436">def yank_nth_arg(self, e): # (M-C-y)
    '''Insert the first argument to the previous command (usually the
    second word on the previous line) at point. With an argument n,
    insert the nth word from the previous command (the words in the
    previous command begin with word 0). A negative argument inserts the
    nth word from the end of the previous command.'''
    pass

</t>
<t tx="ekr.20071201085751.1437">def yank_last_arg(self, e): # (M-. or M-_)
    '''Insert last argument to the previous command (the last word of
    the previous history entry). With an argument, behave exactly like
    yank-nth-arg. Successive calls to yank-last-arg move back through
    the history list, inserting the last argument of each line in turn.'''
    pass

</t>
<t tx="ekr.20071201085751.1438">def forward_backward_delete_char(self, e): # ()
    '''Delete the character under the cursor, unless the cursor is at
    the end of the line, in which case the character behind the cursor
    is deleted. By default, this is not bound to a key.'''
    pass

</t>
<t tx="ekr.20071201085751.1439">def quoted_insert(self, e): # (C-q or C-v)
    '''Add the next character typed to the line verbatim. This is how to
    insert key sequences like C-q, for example.'''
    e = self.console.getkeypress()
    self.insert_text(e.char)

</t>
<t tx="ekr.20071201085751.1440">def tab_insert(self, e): # (M-TAB)
    '''Insert a tab character. '''
    ws = ' ' * (self.tabstop - (self.line_cursor%self.tabstop))
    self.insert_text(ws)

</t>
<t tx="ekr.20071201085751.1441">def transpose_chars(self, e): # (C-t)
    '''Drag the character before the cursor forward over the character
    at the cursor, moving the cursor forward as well. If the insertion
    point is at the end of the line, then this transposes the last two
    characters of the line. Negative arguments have no effect.'''
    self.l_buffer.transpose_chars()

</t>
<t tx="ekr.20071201085751.1442">def transpose_words(self, e): # (M-t)
    '''Drag the word before point past the word after point, moving
    point past that word as well. If the insertion point is at the end
    of the line, this transposes the last two words on the line.'''
    self.l_buffer.transpose_words()

</t>
<t tx="ekr.20071201085751.1443">def overwrite_mode(self, e): # ()
    '''Toggle overwrite mode. With an explicit positive numeric
    argument, switches to overwrite mode. With an explicit non-positive
    numeric argument, switches to insert mode. This command affects only
    emacs mode; vi mode does overwrite differently. Each call to
    readline() starts in insert mode. In overwrite mode, characters
    bound to self-insert replace the text at point rather than pushing
    the text to the right. Characters bound to backward-delete-char
    replace the character before point with a space.'''
    pass
    
</t>
<t tx="ekr.20071201085751.1444">def kill_line(self, e): # (C-k)
    '''Kill the text from point to the end of the line. '''
    self.l_buffer.kill_line()
    
</t>
<t tx="ekr.20071201085751.1445">def backward_kill_line(self, e): # (C-x Rubout)
    '''Kill backward to the beginning of the line. '''
    self.l_buffer.backward_kill_line()

</t>
<t tx="ekr.20071201085751.1446">def unix_line_discard(self, e): # (C-u)
    '''Kill backward from the cursor to the beginning of the current line. '''
    # how is this different from backward_kill_line?
    self.l_buffer.unix_line_discard()

</t>
<t tx="ekr.20071201085751.1447">def kill_whole_line(self, e): # ()
    '''Kill all characters on the current line, no matter where point
    is. By default, this is unbound.'''
    self.l_buffer.kill_whole_line()

</t>
<t tx="ekr.20071201085751.1448">def kill_word(self, e): # (M-d)
    '''Kill from point to the end of the current word, or if between
    words, to the end of the next word. Word boundaries are the same as
    forward-word.'''
    self.l_buffer.kill_word()
</t>
<t tx="ekr.20071201085751.1449">forward_kill_word=kill_word

def backward_kill_word(self, e): # (M-DEL)
    '''Kill the word behind point. Word boundaries are the same as
    backward-word. '''
    self.l_buffer.backward_kill_word()

</t>
<t tx="ekr.20071201085751.1450">def unix_word_rubout(self, e): # (C-w)
    '''Kill the word behind point, using white space as a word
    boundary. The killed text is saved on the kill-ring.'''
    self.l_buffer.unix_word_rubout()

</t>
<t tx="ekr.20071201085751.1451">def kill_region(self, e): # ()
    '''Kill the text in the current region. By default, this command is unbound. '''
    pass

</t>
<t tx="ekr.20071201085751.1452">def copy_region_as_kill(self, e): # ()
    '''Copy the text in the region to the kill buffer, so it can be
    yanked right away. By default, this command is unbound.'''
    pass

</t>
<t tx="ekr.20071201085751.1453">def copy_backward_word(self, e): # ()
    '''Copy the word before point to the kill buffer. The word
    boundaries are the same as backward-word. By default, this command
    is unbound.'''
    pass

</t>
<t tx="ekr.20071201085751.1454">def copy_forward_word(self, e): # ()
    '''Copy the word following point to the kill buffer. The word
    boundaries are the same as forward-word. By default, this command is
    unbound.'''
    pass


</t>
<t tx="ekr.20071201085751.1455">def yank(self, e): # (C-y)
    '''Yank the top of the kill ring into the buffer at point. '''
    self.l_buffer.yank()

</t>
<t tx="ekr.20071201085751.1456">def yank_pop(self, e): # (M-y)
    '''Rotate the kill-ring, and yank the new top. You can only do this
    if the prior command is yank or yank-pop.'''
    self.l_buffer.yank_pop()


</t>
<t tx="ekr.20071201085751.1457">def digit_argument(self, e): # (M-0, M-1, ... M--)
    '''Add this digit to the argument already accumulating, or start a
    new argument. M-- starts a negative argument.'''
    args=e.char

    c = self.console
    line = self.l_buffer.get_line_text()
    oldprompt=self.prompt
    def nop(e):
        pass
    while 1:
        x, y = self.prompt_end_pos
        c.pos(0, y)
        self.prompt="(arg: %s) "%args
        self._print_prompt()
        self._update_line()

        event = c.getkeypress()
        if event.keyinfo.keyname == 'enter':
            break
        elif event.char in "0123456789":
            args+=event.char
        else:
            self.argument=int(args)
            keyinfo=event.keyinfo.tuple()
            if len(keyinfo[-1])&gt;1:
                default=nop
            else:
                default=self.self_insert
            dispatch_func = self.key_dispatch.get(keyinfo,default)
            log_sock("%s|%s"%(dispatch_func,str(keyinfo)))
            dispatch_func(event)
            break
    log_sock("END arg=%s"%(self.argument))
    self.prompt=oldprompt
    x, y = self.prompt_end_pos
    c.pos(0, y)
    self._print_prompt()
    self._update_line()

        


</t>
<t tx="ekr.20071201085751.1458">def universal_argument(self, e): # ()
    '''This is another way to specify an argument. If this command is
    followed by one or more digits, optionally with a leading minus
    sign, those digits define the argument. If the command is followed
    by digits, executing universal-argument again ends the numeric
    argument, but is otherwise ignored. As a special case, if this
    command is immediately followed by a character that is neither a
    digit or minus sign, the argument count for the next command is
    multiplied by four. The argument count is initially one, so
    executing this function the first time makes the argument count
    four, a second time makes the argument count sixteen, and so on. By
    default, this is not bound to a key.'''
    pass

</t>
<t tx="ekr.20071201085751.1459">def delete_char_or_list(self, e): # ()
    '''Deletes the character under the cursor if not at the beginning or
    end of the line (like delete-char). If at the end of the line,
    behaves identically to possible-completions. This command is unbound
    by default.'''
    pass

</t>
<t tx="ekr.20071201085751.1460">def start_kbd_macro(self, e): # (C-x ()
    '''Begin saving the characters typed into the current keyboard macro. '''
    pass

</t>
<t tx="ekr.20071201085751.1461">def end_kbd_macro(self, e): # (C-x ))
    '''Stop saving the characters typed into the current keyboard macro
    and save the definition.'''
    pass

</t>
<t tx="ekr.20071201085751.1462">def call_last_kbd_macro(self, e): # (C-x e)
    '''Re-execute the last keyboard macro defined, by making the
    characters in the macro appear as if typed at the keyboard.'''
    pass

</t>
<t tx="ekr.20071201085751.1463">def re_read_init_file(self, e): # (C-x C-r)
    '''Read in the contents of the inputrc file, and incorporate any
    bindings or variable assignments found there.'''
    pass

</t>
<t tx="ekr.20071201085751.1464">def abort(self, e): # (C-g)
    '''Abort the current editing command and ring the terminals bell
         (subject to the setting of bell-style).'''
    self._bell()

</t>
<t tx="ekr.20071201085751.1465">def do_uppercase_version(self, e): # (M-a, M-b, M-x, ...)
    '''If the metafied character x is lowercase, run the command that is
    bound to the corresponding uppercase character.'''
    pass

</t>
<t tx="ekr.20071201085751.1466">def prefix_meta(self, e): # (ESC)
    '''Metafy the next character typed. This is for keyboards without a
    meta key. Typing ESC f is equivalent to typing M-f. '''
    self.next_meta = True

</t>
<t tx="ekr.20071201085751.1467">def undo(self, e): # (C-_ or C-x C-u)
    '''Incremental undo, separately remembered for each line.'''
    self.l_buffer.pop_undo()

</t>
<t tx="ekr.20071201085751.1468">def revert_line(self, e): # (M-r)
    '''Undo all changes made to this line. This is like executing the
    undo command enough times to get back to the beginning.'''
    pass

</t>
<t tx="ekr.20071201085751.1469">def tilde_expand(self, e): # (M-~)
    '''Perform tilde expansion on the current word.'''
    pass

</t>
<t tx="ekr.20071201085751.1470">def set_mark(self, e): # (C-@)
    '''Set the mark to the point. If a numeric argument is supplied, the
    mark is set to that position.'''
    self.l_buffer.set_mark()

</t>
<t tx="ekr.20071201085751.1471">def exchange_point_and_mark(self, e): # (C-x C-x)
    '''Swap the point with the mark. The current cursor position is set
    to the saved position, and the old cursor position is saved as the
    mark.'''
    pass

</t>
<t tx="ekr.20071201085751.1472">def character_search(self, e): # (C-])
    '''A character is read and point is moved to the next occurrence of
    that character. A negative count searches for previous occurrences.'''
    pass

</t>
<t tx="ekr.20071201085751.1473">def character_search_backward(self, e): # (M-C-])
    '''A character is read and point is moved to the previous occurrence
    of that character. A negative count searches for subsequent
    occurrences.'''
    pass

</t>
<t tx="ekr.20071201085751.1474">def insert_comment(self, e): # (M-#)
    '''Without a numeric argument, the value of the comment-begin
    variable is inserted at the beginning of the current line. If a
    numeric argument is supplied, this command acts as a toggle: if the
    characters at the beginning of the line do not match the value of
    comment-begin, the value is inserted, otherwise the characters in
    comment-begin are deleted from the beginning of the line. In either
    case, the line is accepted as if a newline had been typed.'''
    pass

</t>
<t tx="ekr.20071201085751.1475">def dump_variables(self, e): # ()
    '''Print all of the settable variables and their values to the
    Readline output stream. If a numeric argument is supplied, the
    output is formatted in such a way that it can be made part of an
    inputrc file. This command is unbound by default.'''
    pass

</t>
<t tx="ekr.20071201085751.1476">def dump_macros(self, e): # ()
    '''Print all of the Readline key sequences bound to macros and the
    strings they output. If a numeric argument is supplied, the output
    is formatted in such a way that it can be made part of an inputrc
    file. This command is unbound by default.'''
    pass


</t>
<t tx="ekr.20071201085751.1477">#Create key bindings:

def init_editing_mode(self, e): # (C-e)
    '''When in vi command mode, this causes a switch to emacs editing
    mode.'''
    self._bind_exit_key('Control-d')
    self._bind_exit_key('Control-z')

    # I often accidentally hold the shift or control while typing space
    self._bind_key('space',       self.self_insert)
    self._bind_key('Shift-space',       self.self_insert)
    self._bind_key('Control-space',     self.self_insert)
    self._bind_key('Return',            self.accept_line)
    self._bind_key('Left',              self.backward_char)
    self._bind_key('Control-b',         self.backward_char)
    self._bind_key('Right',             self.forward_char)
    self._bind_key('Control-f',         self.forward_char)
    self._bind_key('BackSpace',         self.backward_delete_char)
    self._bind_key('Control-BackSpace', self.backward_delete_word)
    
    self._bind_key('Home',              self.beginning_of_line)
    self._bind_key('End',               self.end_of_line)
    self._bind_key('Delete',            self.delete_char)
    self._bind_key('Control-d',         self.delete_char)
    self._bind_key('Clear',             self.clear_screen)
    self._bind_key('Alt-f',             self.forward_word)
    self._bind_key('Alt-b',             self.backward_word)
    self._bind_key('Control-l',         self.clear_screen)
    self._bind_key('Control-p',         self.previous_history)
    self._bind_key('Up',                self.history_search_backward)
    self._bind_key('Control-n',         self.next_history)
    self._bind_key('Down',              self.history_search_forward)
    self._bind_key('Control-a',         self.beginning_of_line)
    self._bind_key('Control-e',         self.end_of_line)
    self._bind_key('Alt-&lt;',             self.beginning_of_history)
    self._bind_key('Alt-&gt;',             self.end_of_history)
    self._bind_key('Control-r',         self.reverse_search_history)
    self._bind_key('Control-s',         self.forward_search_history)
    self._bind_key('Alt-p',             self.non_incremental_reverse_search_history)
    self._bind_key('Alt-n',             self.non_incremental_forward_search_history)
    self._bind_key('Control-z',         self.undo)
    self._bind_key('Control-_',         self.undo)
    self._bind_key('Escape',            self.kill_whole_line)
    self._bind_key('Meta-d',            self.kill_word)
    self._bind_key('Control-Delete',       self.forward_delete_word)
    self._bind_key('Control-w',         self.unix_word_rubout)
    #self._bind_key('Control-Shift-v',   self.quoted_insert)
    self._bind_key('Control-v',         self.paste)
    self._bind_key('Alt-v',             self.ipython_paste)
    self._bind_key('Control-y',         self.yank)
    self._bind_key('Control-k',         self.kill_line)
    self._bind_key('Control-m',         self.set_mark)
    self._bind_key('Control-q',         self.copy_region_to_clipboard)
#        self._bind_key('Control-shift-k',  self.kill_whole_line)
    self._bind_key('Control-Shift-v',   self.paste_mulitline_code)
    self._bind_key("Control-Right",     self.forward_word_end)
    self._bind_key("Control-Left",      self.backward_word)
    self._bind_key("Shift-Right",       self.forward_char_extend_selection)
    self._bind_key("Shift-Left",        self.backward_char_extend_selection)
    self._bind_key("Shift-Control-Right",     self.forward_word_end_extend_selection)
    self._bind_key("Shift-Control-Left",     self.backward_word_extend_selection)
    self._bind_key("Shift-Home",        self.beginning_of_line_extend_selection)
    self._bind_key("Shift-End",         self.end_of_line_extend_selection)
    self._bind_key("numpad0",           self.self_insert)
    self._bind_key("numpad1",           self.self_insert)
    self._bind_key("numpad2",           self.self_insert)
    self._bind_key("numpad3",           self.self_insert)
    self._bind_key("numpad4",           self.self_insert)
    self._bind_key("numpad5",           self.self_insert)
    self._bind_key("numpad6",           self.self_insert)
    self._bind_key("numpad7",           self.self_insert)
    self._bind_key("numpad8",           self.self_insert)
    self._bind_key("numpad9",           self.self_insert)
    self._bind_key("add",               self.self_insert)
    self._bind_key("subtract",          self.self_insert)
    self._bind_key("multiply",          self.self_insert)
    self._bind_key("divide",            self.self_insert)
    self._bind_key("vk_decimal",        self.self_insert)
    log("RUNNING INIT EMACS")

</t>
<t tx="ekr.20071201085751.1478"># make it case insensitive
def commonprefix(m):
    "Given a list of pathnames, returns the longest common leading component"
    if not m: return ''
    prefix = m[0]
    for item in m:
        for i in range(len(prefix)):
            if prefix[:i+1].lower() != item[:i+1].lower():
                prefix = prefix[:i]
                if i == 0: return ''
                break
    return prefix

</t>
<t tx="ekr.20071201085751.1479"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
import os
import pyreadline.logger as logger
from   pyreadline.logger import log
import pyreadline.lineeditor.lineobj as lineobj
import pyreadline.lineeditor.history as history
import basemode

</t>
<t tx="ekr.20071201085751.1480">class NotEmacsMode(basemode.BaseMode):
    mode="notemacs"
    @others
</t>
<t tx="ekr.20071201085751.1481">def __init__(self,rlobj):
    super(NotEmacsMode,self).__init__(rlobj)

</t>
<t tx="ekr.20071201085751.1482">def __repr__(self):
    return "&lt;NotEmacsMode&gt;"

</t>
<t tx="ekr.20071201085751.1483">def _readline_from_keyboard(self):
    c=self.console
    while 1:
        self._update_line()
        event = c.getkeypress()
        if self.next_meta:
            self.next_meta = False
            control, meta, shift, code = event.keyinfo
            event.keyinfo = (control, True, shift, code)

        #Process exit keys. Only exit on empty line
        if event.keyinfo in self.exit_dispatch:
            if lineobj.EndOfLine(self.l_buffer) == 0:
                raise EOFError

        dispatch_func = self.key_dispatch.get(event.keyinfo,self.self_insert)
        log("readline from keyboard:%s"%(event.keyinfo,))
        r = None
        if dispatch_func:
            r = dispatch_func(event)
            self.l_buffer.push_undo()

        self.previous_func = dispatch_func
        if r:
            self._update_line()
            break

</t>
<t tx="ekr.20071201085751.1484">def readline(self, prompt=''):
    '''Try to act like GNU readline.'''
    # handle startup_hook
    if self.first_prompt:
        self.first_prompt = False
        if self.startup_hook:
            try:
                self.startup_hook()
            except:
                print 'startup hook failed'
                traceback.print_exc()

    c = self.console
    self.l_buffer.reset_line()
    self.prompt = prompt
    self._print_prompt()

    if self.pre_input_hook:
        try:
            self.pre_input_hook()
        except:
            print 'pre_input_hook failed'
            traceback.print_exc()
            self.pre_input_hook = None

    log("in readline: %s"%self.paste_line_buffer)
    if len(self.paste_line_buffer)&gt;0:
        self.l_buffer=lineobj.ReadlineTextBuffer(self.paste_line_buffer[0])
        self._update_line()
        self.paste_line_buffer=self.paste_line_buffer[1:]
        c.write('\r\n')
    else:
        self._readline_from_keyboard()
        c.write('\r\n')

    self.add_history(self.l_buffer.copy())

    log('returning(%s)' % self.l_buffer.get_line_text())
    return self.l_buffer.get_line_text() + '\n'

</t>
<t tx="ekr.20071201085751.1485">### Methods below here are bindable emacs functions

def beginning_of_line(self, e): # (C-a)
    '''Move to the start of the current line. '''
    self.l_buffer.beginning_of_line()

</t>
<t tx="ekr.20071201085751.1486">def end_of_line(self, e): # (C-e)
    '''Move to the end of the line. '''
    self.l_buffer.end_of_line()

</t>
<t tx="ekr.20071201085751.1487">def forward_char(self, e): # (C-f)
    '''Move forward a character. '''
    self.l_buffer.forward_char()

</t>
<t tx="ekr.20071201085751.1488">def backward_char(self, e): # (C-b)
    '''Move back a character. '''
    self.l_buffer.backward_char()

</t>
<t tx="ekr.20071201085751.1489">def forward_word(self, e): # (M-f)
    '''Move forward to the end of the next word. Words are composed of
    letters and digits.'''
    self.l_buffer.forward_word()

</t>
<t tx="ekr.20071201085751.1490">def backward_word(self, e): # (M-b)
    '''Move back to the start of the current or previous word. Words are
    composed of letters and digits.'''
    self.l_buffer.backward_word()

</t>
<t tx="ekr.20071201085751.1491">def clear_screen(self, e): # (C-l)
    '''Clear the screen and redraw the current line, leaving the current
    line at the top of the screen.'''
    self.console.page()

</t>
<t tx="ekr.20071201085751.1492">def redraw_current_line(self, e): # ()
    '''Refresh the current line. By default, this is unbound.'''
    pass

</t>
<t tx="ekr.20071201085751.1493">def accept_line(self, e): # (Newline or Return)
    '''Accept the line regardless of where the cursor is. If this line
    is non-empty, it may be added to the history list for future recall
    with add_history(). If this line is a modified history line, the
    history line is restored to its original state.'''
    return True

</t>
<t tx="ekr.20071201085751.1494">#########  History commands
def previous_history(self, e): # (C-p)
    '''Move back through the history list, fetching the previous command. '''
    self._history.previous_history(self.l_buffer)

</t>
<t tx="ekr.20071201085751.1495">def next_history(self, e): # (C-n)
    '''Move forward through the history list, fetching the next command. '''
    self._history.next_history(self.l_buffer)

</t>
<t tx="ekr.20071201085751.1496">def beginning_of_history(self, e): # (M-&lt;)
    '''Move to the first line in the history.'''
    self._history.beginning_of_history()

</t>
<t tx="ekr.20071201085751.1497">def end_of_history(self, e): # (M-&gt;)
    '''Move to the end of the input history, i.e., the line currently
    being entered.'''
    self._history.end_of_history(self.l_buffer)

</t>
<t tx="ekr.20071201085751.1498">def _i_search(self, searchfun, direction, init_event):
    c = self.console
    line = self.get_line_buffer()
    query = ''
    hc_start = self._history.history_cursor #+ direction
    while 1:
        x, y = self.prompt_end_pos
        c.pos(0, y)
        if direction &lt; 0:
            prompt = 'reverse-i-search'
        else:
            prompt = 'forward-i-search'

        scroll = c.write_scrolling("%s`%s': %s" % (prompt, query, line))
        self._update_prompt_pos(scroll)
        self._clear_after()

        event = c.getkeypress()
        if event.keysym == 'BackSpace':
            if len(query) &gt; 0:
                query = query[:-1]
                self._history.history_cursor = hc_start
            else:
                self._bell()
        elif event.char in string.letters + string.digits + string.punctuation + ' ':
            self._history.history_cursor = hc_start
            query += event.char
        elif event.keyinfo == init_event.keyinfo:
            self._history.history_cursor += direction
            line=searchfun(query)                
            pass
        else:
            if event.keysym != 'Return':
                self._bell()
            break
        line=searchfun(query)

    px, py = self.prompt_begin_pos
    c.pos(0, py)
    self.l_buffer.set_line(line)
    self._print_prompt()
    self._history.history_cursor=len(self._history.history)

</t>
<t tx="ekr.20071201085751.1499">def reverse_search_history(self, e): # (C-r)
    '''Search backward starting at the current line and moving up
    through the history as necessary. This is an incremental search.'''
#        print "HEJ"
#        self.console.bell()
    self._i_search(self._history.reverse_search_history, -1, e)

</t>
<t tx="ekr.20071201085751.1500">def forward_search_history(self, e): # (C-s)
    '''Search forward starting at the current line and moving down
    through the the history as necessary. This is an incremental search.'''
#        print "HEJ"
#        self.console.bell()
    self._i_search(self._history.forward_search_history, 1, e)


</t>
<t tx="ekr.20071201085751.1501">def non_incremental_reverse_search_history(self, e): # (M-p)
    '''Search backward starting at the current line and moving up
    through the history as necessary using a non-incremental search for
    a string supplied by the user.'''
    self._history.non_incremental_reverse_search_history(self.l_buffer)

</t>
<t tx="ekr.20071201085751.1502">def non_incremental_forward_search_history(self, e): # (M-n)
    '''Search forward starting at the current line and moving down
    through the the history as necessary using a non-incremental search
    for a string supplied by the user.'''
    self._history.non_incremental_reverse_search_history(self.l_buffer)

</t>
<t tx="ekr.20071201085751.1503">def history_search_forward(self, e): # ()
    '''Search forward through the history for the string of characters
    between the start of the current line and the point. This is a
    non-incremental search. By default, this command is unbound.'''
    self.l_buffer=self._history.history_search_forward(self.l_buffer)

</t>
<t tx="ekr.20071201085751.1504">def history_search_backward(self, e): # ()
    '''Search backward through the history for the string of characters
    between the start of the current line and the point. This is a
    non-incremental search. By default, this command is unbound.'''
    self.l_buffer=self._history.history_search_backward(self.l_buffer)

</t>
<t tx="ekr.20071201085751.1505">def yank_nth_arg(self, e): # (M-C-y)
    '''Insert the first argument to the previous command (usually the
    second word on the previous line) at point. With an argument n,
    insert the nth word from the previous command (the words in the
    previous command begin with word 0). A negative argument inserts the
    nth word from the end of the previous command.'''
    pass

</t>
<t tx="ekr.20071201085751.1506">def yank_last_arg(self, e): # (M-. or M-_)
    '''Insert last argument to the previous command (the last word of
    the previous history entry). With an argument, behave exactly like
    yank-nth-arg. Successive calls to yank-last-arg move back through
    the history list, inserting the last argument of each line in turn.'''
    pass

</t>
<t tx="ekr.20071201085751.1507">def delete_char(self, e): # (C-d)
    '''Delete the character at point. If point is at the beginning of
    the line, there are no characters in the line, and the last
    character typed was not bound to delete-char, then return EOF.'''
    self.l_buffer.delete_char()

</t>
<t tx="ekr.20071201085751.1508">def backward_delete_char(self, e): # (Rubout)
    '''Delete the character behind the cursor. A numeric argument means
    to kill the characters instead of deleting them.'''
    self.l_buffer.backward_delete_char()

</t>
<t tx="ekr.20071201085751.1509">def forward_backward_delete_char(self, e): # ()
    '''Delete the character under the cursor, unless the cursor is at
    the end of the line, in which case the character behind the cursor
    is deleted. By default, this is not bound to a key.'''
    pass

</t>
<t tx="ekr.20071201085751.1510">def quoted_insert(self, e): # (C-q or C-v)
    '''Add the next character typed to the line verbatim. This is how to
    insert key sequences like C-q, for example.'''
    e = self.console.getkeypress()
    self.insert_text(e.char)

</t>
<t tx="ekr.20071201085751.1511">def tab_insert(self, e): # (M-TAB)
    '''Insert a tab character. '''
    ws = ' ' * (self.tabstop - (self.line_cursor%self.tabstop))
    self.insert_text(ws)

</t>
<t tx="ekr.20071201085751.1512">def self_insert(self, e): # (a, b, A, 1, !, ...)
    '''Insert yourself. '''
    if ord(e.char)!=0: #don't insert null character in buffer, can happen with dead keys.
        self.insert_text(e.char)

</t>
<t tx="ekr.20071201085751.1513">def transpose_chars(self, e): # (C-t)
    '''Drag the character before the cursor forward over the character
    at the cursor, moving the cursor forward as well. If the insertion
    point is at the end of the line, then this transposes the last two
    characters of the line. Negative arguments have no effect.'''
    self.l_buffer.transpose_chars()

</t>
<t tx="ekr.20071201085751.1514">def transpose_words(self, e): # (M-t)
    '''Drag the word before point past the word after point, moving
    point past that word as well. If the insertion point is at the end
    of the line, this transposes the last two words on the line.'''
    self.l_buffer.transpose_words()

</t>
<t tx="ekr.20071201085751.1515">def upcase_word(self, e): # (M-u)
    '''Uppercase the current (or following) word. With a negative
    argument, uppercase the previous word, but do not move the cursor.'''
    self.l_buffer.upcase_word()

</t>
<t tx="ekr.20071201085751.1516">def downcase_word(self, e): # (M-l)
    '''Lowercase the current (or following) word. With a negative
    argument, lowercase the previous word, but do not move the cursor.'''
    self.l_buffer.downcase_word()

</t>
<t tx="ekr.20071201085751.1517">def capitalize_word(self, e): # (M-c)
    '''Capitalize the current (or following) word. With a negative
    argument, capitalize the previous word, but do not move the cursor.'''
    self.l_buffer.capitalize_word()

</t>
<t tx="ekr.20071201085751.1518">def overwrite_mode(self, e): # ()
    '''Toggle overwrite mode. With an explicit positive numeric
    argument, switches to overwrite mode. With an explicit non-positive
    numeric argument, switches to insert mode. This command affects only
    emacs mode; vi mode does overwrite differently. Each call to
    readline() starts in insert mode. In overwrite mode, characters
    bound to self-insert replace the text at point rather than pushing
    the text to the right. Characters bound to backward-delete-char
    replace the character before point with a space.'''
    pass
    
</t>
<t tx="ekr.20071201085751.1519">def kill_line(self, e): # (C-k)
    '''Kill the text from point to the end of the line. '''
    self.l_buffer.kill_line()
    
</t>
<t tx="ekr.20071201085751.1520">def backward_kill_line(self, e): # (C-x Rubout)
    '''Kill backward to the beginning of the line. '''
    self.l_buffer.backward_kill_line()

</t>
<t tx="ekr.20071201085751.1521">def unix_line_discard(self, e): # (C-u)
    '''Kill backward from the cursor to the beginning of the current line. '''
    # how is this different from backward_kill_line?
    self.l_buffer.unix_line_discard()

</t>
<t tx="ekr.20071201085751.1522">def kill_whole_line(self, e): # ()
    '''Kill all characters on the current line, no matter where point
    is. By default, this is unbound.'''
    self.l_buffer.kill_whole_line()

</t>
<t tx="ekr.20071201085751.1523">def kill_word(self, e): # (M-d)
    '''Kill from point to the end of the current word, or if between
    words, to the end of the next word. Word boundaries are the same as
    forward-word.'''
    self.l_buffer.kill_word()

</t>
<t tx="ekr.20071201085751.1524">def backward_kill_word(self, e): # (M-DEL)
    '''Kill the word behind point. Word boundaries are the same as
    backward-word. '''
    self.l_buffer.backward_kill_word()

</t>
<t tx="ekr.20071201085751.1525">def unix_word_rubout(self, e): # (C-w)
    '''Kill the word behind point, using white space as a word
    boundary. The killed text is saved on the kill-ring.'''
    self.l_buffer.unix_word_rubout()

</t>
<t tx="ekr.20071201085751.1526">def delete_horizontal_space(self, e): # ()
    '''Delete all spaces and tabs around point. By default, this is unbound. '''
    pass

</t>
<t tx="ekr.20071201085751.1527">def kill_region(self, e): # ()
    '''Kill the text in the current region. By default, this command is unbound. '''
    pass

</t>
<t tx="ekr.20071201085751.1528">def copy_region_as_kill(self, e): # ()
    '''Copy the text in the region to the kill buffer, so it can be
    yanked right away. By default, this command is unbound.'''
    pass

</t>
<t tx="ekr.20071201085751.1529">def copy_region_to_clipboard(self, e): # ()
    '''Copy the text in the region to the windows clipboard.'''
    if self.enable_win32_clipboard:
            mark=min(self.l_buffer.mark,len(self.l_buffer.line_buffer))
            cursor=min(self.l_buffer.point,len(self.l_buffer.line_buffer))
            if self.l_buffer.mark==-1:
                    return
            begin=min(cursor,mark)
            end=max(cursor,mark)
            toclipboard="".join(self.l_buffer.line_buffer[begin:end])
            clipboard.SetClipboardText(str(toclipboard))

</t>
<t tx="ekr.20071201085751.1530">def copy_backward_word(self, e): # ()
    '''Copy the word before point to the kill buffer. The word
    boundaries are the same as backward-word. By default, this command
    is unbound.'''
    pass

</t>
<t tx="ekr.20071201085751.1531">def copy_forward_word(self, e): # ()
    '''Copy the word following point to the kill buffer. The word
    boundaries are the same as forward-word. By default, this command is
    unbound.'''
    pass

</t>
<t tx="ekr.20071201085751.1532">def paste(self,e):
    '''Paste windows clipboard'''
    if self.enable_win32_clipboard:
            txt=clipboard.get_clipboard_text_and_convert(False)
            self.insert_text(txt)

</t>
<t tx="ekr.20071201085751.1533">def paste_mulitline_code(self,e):
    '''Paste windows clipboard'''
    reg=re.compile("\r?\n")
    if self.enable_win32_clipboard:
            txt=clipboard.get_clipboard_text_and_convert(False)
            t=reg.split(txt)
            t=[row for row in t if row.strip()!=""] #remove empty lines
            if t!=[""]:
                self.insert_text(t[0])
                self.add_history(self.l_buffer.copy())
                self.paste_line_buffer=t[1:]
                log("multi: %s"%self.paste_line_buffer)
                return True
            else:
                return False
    
</t>
<t tx="ekr.20071201085751.1534">def ipython_paste(self,e):
    '''Paste windows clipboard. If enable_ipython_paste_list_of_lists is 
    True then try to convert tabseparated data to repr of list of lists or 
    repr of array'''
    if self.enable_win32_clipboard:
            txt=clipboard.get_clipboard_text_and_convert(
                                            self.enable_ipython_paste_list_of_lists)
            if self.enable_ipython_paste_for_paths:
                    if len(txt)&lt;300 and ("\t" not in txt) and ("\n" not in txt):
                            txt=txt.replace("\\","/").replace(" ",r"\ ")
            self.insert_text(txt)

</t>
<t tx="ekr.20071201085751.1535">def yank(self, e): # (C-y)
    '''Yank the top of the kill ring into the buffer at point. '''
    pass

</t>
<t tx="ekr.20071201085751.1536">def yank_pop(self, e): # (M-y)
    '''Rotate the kill-ring, and yank the new top. You can only do this
    if the prior command is yank or yank-pop.'''
    pass


</t>
<t tx="ekr.20071201085751.1537">def digit_argument(self, e): # (M-0, M-1, ... M--)
    '''Add this digit to the argument already accumulating, or start a
    new argument. M-- starts a negative argument.'''
    pass

</t>
<t tx="ekr.20071201085751.1538">def universal_argument(self, e): # ()
    '''This is another way to specify an argument. If this command is
    followed by one or more digits, optionally with a leading minus
    sign, those digits define the argument. If the command is followed
    by digits, executing universal-argument again ends the numeric
    argument, but is otherwise ignored. As a special case, if this
    command is immediately followed by a character that is neither a
    digit or minus sign, the argument count for the next command is
    multiplied by four. The argument count is initially one, so
    executing this function the first time makes the argument count
    four, a second time makes the argument count sixteen, and so on. By
    default, this is not bound to a key.'''
    pass

</t>
<t tx="ekr.20071201085751.1539">def delete_char_or_list(self, e): # ()
    '''Deletes the character under the cursor if not at the beginning or
    end of the line (like delete-char). If at the end of the line,
    behaves identically to possible-completions. This command is unbound
    by default.'''
    pass

</t>
<t tx="ekr.20071201085751.1540">def start_kbd_macro(self, e): # (C-x ()
    '''Begin saving the characters typed into the current keyboard macro. '''
    pass

</t>
<t tx="ekr.20071201085751.1541">def end_kbd_macro(self, e): # (C-x ))
    '''Stop saving the characters typed into the current keyboard macro
    and save the definition.'''
    pass

</t>
<t tx="ekr.20071201085751.1542">def call_last_kbd_macro(self, e): # (C-x e)
    '''Re-execute the last keyboard macro defined, by making the
    characters in the macro appear as if typed at the keyboard.'''
    pass

</t>
<t tx="ekr.20071201085751.1543">def re_read_init_file(self, e): # (C-x C-r)
    '''Read in the contents of the inputrc file, and incorporate any
    bindings or variable assignments found there.'''
    pass

</t>
<t tx="ekr.20071201085751.1544">def abort(self, e): # (C-g)
    '''Abort the current editing command and ring the terminals bell
         (subject to the setting of bell-style).'''
    self._bell()

</t>
<t tx="ekr.20071201085751.1545">def do_uppercase_version(self, e): # (M-a, M-b, M-x, ...)
    '''If the metafied character x is lowercase, run the command that is
    bound to the corresponding uppercase character.'''
    pass

</t>
<t tx="ekr.20071201085751.1546">def prefix_meta(self, e): # (ESC)
    '''Metafy the next character typed. This is for keyboards without a
    meta key. Typing ESC f is equivalent to typing M-f. '''
    self.next_meta = True

</t>
<t tx="ekr.20071201085751.1547">def undo(self, e): # (C-_ or C-x C-u)
    '''Incremental undo, separately remembered for each line.'''
    self.l_buffer.pop_undo()

</t>
<t tx="ekr.20071201085751.1548">def revert_line(self, e): # (M-r)
    '''Undo all changes made to this line. This is like executing the
    undo command enough times to get back to the beginning.'''
    pass

</t>
<t tx="ekr.20071201085751.1549">def tilde_expand(self, e): # (M-~)
    '''Perform tilde expansion on the current word.'''
    pass

</t>
<t tx="ekr.20071201085751.1550">def set_mark(self, e): # (C-@)
    '''Set the mark to the point. If a numeric argument is supplied, the
    mark is set to that position.'''
    self.l_buffer.set_mark()

</t>
<t tx="ekr.20071201085751.1551">def exchange_point_and_mark(self, e): # (C-x C-x)
    '''Swap the point with the mark. The current cursor position is set
    to the saved position, and the old cursor position is saved as the
    mark.'''
    pass

</t>
<t tx="ekr.20071201085751.1552">def character_search(self, e): # (C-])
    '''A character is read and point is moved to the next occurrence of
    that character. A negative count searches for previous occurrences.'''
    pass

</t>
<t tx="ekr.20071201085751.1553">def character_search_backward(self, e): # (M-C-])
    '''A character is read and point is moved to the previous occurrence
    of that character. A negative count searches for subsequent
    occurrences.'''
    pass

</t>
<t tx="ekr.20071201085751.1554">def insert_comment(self, e): # (M-#)
    '''Without a numeric argument, the value of the comment-begin
    variable is inserted at the beginning of the current line. If a
    numeric argument is supplied, this command acts as a toggle: if the
    characters at the beginning of the line do not match the value of
    comment-begin, the value is inserted, otherwise the characters in
    comment-begin are deleted from the beginning of the line. In either
    case, the line is accepted as if a newline had been typed.'''
    pass

</t>
<t tx="ekr.20071201085751.1555">def dump_functions(self, e): # ()
    '''Print all of the functions and their key bindings to the Readline
    output stream. If a numeric argument is supplied, the output is
    formatted in such a way that it can be made part of an inputrc
    file. This command is unbound by default.'''
    pass

</t>
<t tx="ekr.20071201085751.1556">def dump_variables(self, e): # ()
    '''Print all of the settable variables and their values to the
    Readline output stream. If a numeric argument is supplied, the
    output is formatted in such a way that it can be made part of an
    inputrc file. This command is unbound by default.'''
    pass

</t>
<t tx="ekr.20071201085751.1557">def dump_macros(self, e): # ()
    '''Print all of the Readline key sequences bound to macros and the
    strings they output. If a numeric argument is supplied, the output
    is formatted in such a way that it can be made part of an inputrc
    file. This command is unbound by default.'''
    pass


</t>
<t tx="ekr.20071201085751.1558">#Create key bindings:

def init_editing_mode(self, e): # (C-e)
    '''When in vi command mode, this causes a switch to emacs editing
    mode.'''

    self._bind_exit_key('Control-d')
    self._bind_exit_key('Control-z')

    # I often accidentally hold the shift or control while typing space
    self._bind_key('Shift-space',       self.self_insert)
    self._bind_key('Control-space',     self.self_insert)
    self._bind_key('Return',            self.accept_line)
    self._bind_key('Left',              self.backward_char)
    self._bind_key('Control-b',         self.backward_char)
    self._bind_key('Right',             self.forward_char)
    self._bind_key('Control-f',         self.forward_char)
    self._bind_key('BackSpace',         self.backward_delete_char)
    self._bind_key('Home',              self.beginning_of_line)
    self._bind_key('End',               self.end_of_line)
    self._bind_key('Delete',            self.delete_char)
    self._bind_key('Control-d',         self.delete_char)
    self._bind_key('Clear',             self.clear_screen)


</t>
<t tx="ekr.20071201085751.1559"># make it case insensitive
def commonprefix(m):
    "Given a list of pathnames, returns the longest common leading component"
    if not m: return ''
    prefix = m[0]
    for item in m:
        for i in range(len(prefix)):
            if prefix[:i+1].lower() != item[:i+1].lower():
                prefix = prefix[:i]
                if i == 0: return ''
                break
    return prefix

</t>
<t tx="ekr.20071201085751.1560"># -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2003-2006 Gary Bishop.
#       Copyright (C) 2006  Michael Graz. &lt;mgraz@plan10.com&gt;
#       Copyright (C) 2006  Jorgen Stenarson. &lt;jorgen.stenarson@bostream.nu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************
import os
import pyreadline.logger as logger
from   pyreadline.logger import log,log_sock
import pyreadline.lineeditor.lineobj as lineobj
import pyreadline.lineeditor.history as history
import basemode

</t>
<t tx="ekr.20071201085751.1561">class ViMode(basemode.BaseMode):
    mode="vi"
    @others
</t>
<t tx="ekr.20071201085751.1562">def __init__(self,rlobj):
    super(ViMode,self).__init__(rlobj)
    self.__vi_insert_mode = None

</t>
<t tx="ekr.20071201085751.1563">def __repr__(self):
    return "&lt;ViMode&gt;"

</t>
<t tx="ekr.20071201085751.1564">def _readline_from_keyboard(self):
    c=self.console
    while 1:
        self._update_line()
        event = c.getkeypress()
        if self.next_meta:
            self.next_meta = False
            control, meta, shift, code = event.keyinfo
            event.keyinfo = (control, True, shift, code)

        #Process exit keys. Only exit on empty line
        if event.keyinfo in self.exit_dispatch:
            if lineobj.EndOfLine(self.l_buffer) == 0:
                raise EOFError

        dispatch_func = self.key_dispatch.get(event.keyinfo.tuple(),self.vi_key)
        log("readline from keyboard:%s-&gt;%s"%(event.keyinfo.tuple(),dispatch_func))
        r = None
        if dispatch_func:
            r = dispatch_func(event)
            self.l_buffer.push_undo()

        self.previous_func = dispatch_func
        if r:
            self._update_line()
            break

</t>
<t tx="ekr.20071201085751.1565">def readline(self, prompt=''):
    '''Try to act like GNU readline.'''
    # handle startup_hook
    if self.first_prompt:
        self.first_prompt = False
        if self.startup_hook:
            try:
                self.startup_hook()
            except:
                print 'startup hook failed'
                traceback.print_exc()

    c = self.console
    self.l_buffer.reset_line()
    self.prompt = prompt
    self._print_prompt()

    if self.pre_input_hook:
        try:
            self.pre_input_hook()
        except:
            print 'pre_input_hook failed'
            traceback.print_exc()
            self.pre_input_hook = None

    log("in readline: %s"%self.paste_line_buffer)
    if len(self.paste_line_buffer)&gt;0:
        self.l_buffer=lineobj.ReadlineTextBuffer(self.paste_line_buffer[0])
        self._update_line()
        self.paste_line_buffer=self.paste_line_buffer[1:]
        c.write('\r\n')
    else:
        self._readline_from_keyboard()
        c.write('\r\n')

    self.add_history(self.l_buffer.copy())

    log('returning(%s)' % self.l_buffer.get_line_text())
    return self.l_buffer.get_line_text() + '\n'

</t>
<t tx="ekr.20071201085751.1566">### Methods below here are bindable emacs functions

def init_editing_mode(self, e): # (M-C-j)
    '''Initialize vi editingmode'''
    self.show_all_if_ambiguous = 'on'
    self.key_dispatch = {}
    self.__vi_insert_mode = None
    self._vi_command = None
    self._vi_command_edit = None
    self._vi_key_find_char = None
    self._vi_key_find_direction = True
    self._vi_yank_buffer = None
    self._vi_multiplier1 = ''
    self._vi_multiplier2 = ''
    self._vi_undo_stack = []
    self._vi_undo_cursor = -1
    self._vi_current = None
    self._vi_search_text = ''
    self.vi_save_line ()
    self.vi_set_insert_mode (True)
    # make ' ' to ~ self insert
    for c in range(ord(' '), 127):
        self._bind_key('%s' % chr(c), self.vi_key)
    self._bind_key('BackSpace', self.vi_backspace)
    self._bind_key('Escape', self.vi_escape)
    self._bind_key('Return', self.vi_accept_line)

    self._bind_key('Left', self.backward_char)
    self._bind_key('Right', self.forward_char)
    self._bind_key('Home', self.beginning_of_line)
    self._bind_key('End', self.end_of_line)
    self._bind_key('Delete', self.delete_char)

    self._bind_key('Control-d', self.vi_eof)
    self._bind_key('Control-z', self.vi_eof)
    self._bind_key('Control-r', self.vi_redo)
    self._bind_key('Up', self.vi_arrow_up)
    self._bind_key('Control-p', self.vi_up)
    self._bind_key('Down', self.vi_arrow_down)
    self._bind_key('Control-n', self.vi_down)
    self._bind_key('Tab', self.vi_complete)
</t>
<t tx="ekr.20071201085751.1567">#        self._bind_key('Control-e', self.emacs)

def vi_key (self, e):
    if not self._vi_command:
        self._vi_command = ViCommand (self)
    elif self._vi_command.is_end:
        if self._vi_command.is_edit:
            self._vi_command_edit = self._vi_command
        self._vi_command = ViCommand (self)
    self._vi_command.add_char (e.char)

</t>
<t tx="ekr.20071201085751.1568">def vi_error (self):
    self._bell ()

</t>
<t tx="ekr.20071201085751.1569">def vi_get_is_insert_mode (self):
    return self.__vi_insert_mode
</t>
<t tx="ekr.20071201085751.1570">vi_is_insert_mode = property (vi_get_is_insert_mode)

def vi_escape (self, e):
    if self.vi_is_insert_mode:
        if self._vi_command:
            self._vi_command.add_char (e.char)
        else:
            self._vi_command = ViCommand (self)
        self.vi_set_insert_mode (False)
#            if self.line_cursor &gt; 0:
#                self.line_cursor -= 1
        self.l_buffer.point=lineobj.PrevChar
    elif self._vi_command and self._vi_command.is_replace_one:
        self._vi_command.add_char (e.char)
    else:
        self.vi_error ()

</t>
<t tx="ekr.20071201085751.1571">def vi_backspace (self, e):
    if self._vi_command:
        self._vi_command.add_char (e.char)
    else:
        self._vi_do_backspace (self._vi_command)

</t>
<t tx="ekr.20071201085751.1572">def _vi_do_backspace (self, vi_cmd):
    if self.vi_is_insert_mode or (self._vi_command and self._vi_command.is_search):
        if self.l_buffer.point &gt; 0:
            self.l_buffer.point -= 1
            if self.l_buffer.overwrite:
                try:
                    prev = self._vi_undo_stack [self._vi_undo_cursor][1][self.l_buffer.point ]
                    self.l_buffer.line_buffer [self.l_buffer.point] = prev
                except IndexError:
                    del self.l_buffer.line_buffer [self.l_buffer.point ]
            else:
                self.vi_save_line ()
                del self.l_buffer.line_buffer [self.l_buffer.point ]

</t>
<t tx="ekr.20071201085751.1573">def vi_accept_line (self, e):
    if self._vi_command and self._vi_command.is_search:
        self._vi_command.do_search ()
        return False
    self._vi_command = None
    self.vi_set_insert_mode (True)
    self._vi_undo_stack = []
    self._vi_undo_cursor = -1
    self._vi_current = None
    return self.accept_line (e)

</t>
<t tx="ekr.20071201085751.1574">def vi_eof (self, e):
    raise EOFError

</t>
<t tx="ekr.20071201085751.1575">def vi_set_insert_mode (self, value):
    if self.__vi_insert_mode == value:
        return
    self.__vi_insert_mode = value
    if value:
        self.vi_save_line ()
        self.console.cursor (size=25)
    else:
        self.console.cursor (size=100)

</t>
<t tx="ekr.20071201085751.1576">def vi_undo_restart (self):
    tpl_undo = (self.l_buffer.point, self.l_buffer.line_buffer[:], )
    self._vi_undo_stack = [tpl_undo]
    self._vi_undo_cursor = 0

</t>
<t tx="ekr.20071201085751.1577">def vi_save_line (self):
    if self._vi_undo_stack and self._vi_undo_cursor &gt;= 0:
        del self._vi_undo_stack [self._vi_undo_cursor + 1 : ]
    # tpl_undo = (self.l_buffer.point, self.l_buffer[:], )
    tpl_undo = (self.l_buffer.point, self.l_buffer.line_buffer[:], )
    if not self._vi_undo_stack or self._vi_undo_stack[self._vi_undo_cursor][1] != tpl_undo[1]:
        self._vi_undo_stack.append (tpl_undo)
        self._vi_undo_cursor += 1

</t>
<t tx="ekr.20071201085751.1578">def vi_undo_prepare (self):
    if self._vi_undo_cursor == len(self._vi_undo_stack)-1:
        self.vi_save_line ()

</t>
<t tx="ekr.20071201085751.1579">def vi_undo (self, do_pop=True):
    self.vi_undo_prepare ()
    if not self._vi_undo_stack or self._vi_undo_cursor &lt;= 0:
        self.vi_error ()
        return
    self._vi_undo_cursor -= 1
    self.vi_undo_assign ()

</t>
<t tx="ekr.20071201085751.1580">def vi_undo_all (self):
    self.vi_undo_prepare ()
    if self._vi_undo_cursor &gt; 0:
        self._vi_undo_cursor = 0
        self.vi_undo_assign ()
    else:
        self.vi_error ()

</t>
<t tx="ekr.20071201085751.1581">def vi_undo_assign (self):
    tpl_undo = self._vi_undo_stack [self._vi_undo_cursor]
    self.l_buffer.line_buffer = tpl_undo [1][:]
    self.l_buffer.point = tpl_undo [0]

</t>
<t tx="ekr.20071201085751.1582">def vi_redo (self, e):
    if self._vi_undo_cursor &gt;= len(self._vi_undo_stack)-1:
        self.vi_error ()
        return
    self._vi_undo_cursor += 1
    self.vi_undo_assign ()

</t>
<t tx="ekr.20071201085751.1583">def vi_search (self, rng):
    for i in rng:
        line_history = self._history.history [i]
        pos = line_history.get_line_text().find (self._vi_search_text)
        if pos &gt;= 0:
            self._history.history_cursor = i
            self.l_buffer.line_buffer = list (line_history.line_buffer)
            self.l_buffer.point = pos
            self.vi_undo_restart ()
            return True
    self._bell ()
    return False

</t>
<t tx="ekr.20071201085751.1584">def vi_search_first (self):
    text = ''.join (self.l_buffer.line_buffer [1:])
    if text:
        self._vi_search_text = text
        position = len (self._history.history) - 1
    elif self._vi_search_text:
        position = self._history.history_cursor - 1
    else:
        self.vi_error ()
        self.vi_undo ()
        return
    if not self.vi_search (range (position, -1, -1)):
        # Here: search text not found
        self.vi_undo ()

</t>
<t tx="ekr.20071201085751.1585">def vi_search_again_backward (self):
    self.vi_search (range (self._history.history_cursor-1, -1, -1))

</t>
<t tx="ekr.20071201085751.1586">def vi_search_again_forward (self):
    self.vi_search (range (self._history.history_cursor+1, len(self._history.history)))

</t>
<t tx="ekr.20071201085751.1587">def vi_up (self, e):
    if self._history.history_cursor == len(self._history.history):
        self._vi_current = self.l_buffer.line_buffer [:]
    # self._history.previous_history (e)
    self._history.previous_history (self.l_buffer)
    if self.vi_is_insert_mode:
        self.end_of_line (e)
    else:
        self.beginning_of_line (e)
    self.vi_undo_restart ()

</t>
<t tx="ekr.20071201085751.1588">def vi_down (self, e):
    if self._history.history_cursor &gt;= len(self._history.history):
        self.vi_error ()
        return
    if self._history.history_cursor &lt; len(self._history.history) - 1:
        # self._history.next_history (e)
        self._history.next_history (self.l_buffer)
        if self.vi_is_insert_mode:
            self.end_of_line (e)
        else:
            self.beginning_of_line (e)
        self.vi_undo_restart ()
    elif self._vi_current is not None:
        self._history.history_cursor = len(self._history.history)
        self.l_buffer.line_buffer = self._vi_current
        self.end_of_line (e)
        if not self.vi_is_insert_mode and self.l_buffer.point &gt; 0:
            self.l_buffer.point -= 1
        self._vi_current = None
    else:
        self.vi_error ()
        return

</t>
<t tx="ekr.20071201085751.1589">def vi_arrow_up (self, e):
    self.vi_set_insert_mode (True)
    self.vi_up (e)
    self.vi_save_line ()

</t>
<t tx="ekr.20071201085751.1590">def vi_arrow_down (self, e):
    self.vi_set_insert_mode (True)
    self.vi_down (e)
    self.vi_save_line ()

</t>
<t tx="ekr.20071201085751.1591">def vi_complete (self, e):
    text = self.l_buffer.get_line_text ()
    if text and not text.isspace ():
        return self.complete (e)
    else:
        return self.vi_key (e)

</t>
<t tx="ekr.20071201085751.1592"># vi input states
# sequence of possible states are in the order below
_VI_BEGIN           = 'vi_begin'
_VI_MULTI1          = 'vi_multi1'
_VI_ACTION          = 'vi_action'
_VI_MULTI2          = 'vi_multi2'
_VI_MOTION          = 'vi_motion'
_VI_MOTION_ARGUMENT = 'vi_motion_argument'
_VI_REPLACE_ONE     = 'vi_replace_one'
_VI_TEXT            = 'vi_text'
_VI_SEARCH          = 'vi_search'
_VI_END             = 'vi_end'

# vi helper class
class ViCommand:
    @others
</t>
<t tx="ekr.20071201085751.1593">def __init__ (self, readline):
    self.readline = readline
    self.lst_char = []
    self.state = _VI_BEGIN
    self.action = self.movement
    self.motion = None
    self.motion_argument = None
    self.text = None
    self.pos_motion = None
    self.is_edit = False
    self.is_overwrite = False
    self.is_error = False
    self.is_star = False
    self.delete_left = 0
    self.delete_right = 0
    self.readline._vi_multiplier1 = ''
    self.readline._vi_multiplier2 = ''
    self.set_override_multiplier (0)
    self.skip_multipler = False
    self.dct_fcn = {
        ord('$') : self.key_dollar,
        ord('^') : self.key_hat,
        ord(';') : self.key_semicolon,
        ord(',') : self.key_comma,
        ord('%') : self.key_percent,
        ord('.') : self.key_dot,
        ord('/') : self.key_slash,
        ord('*') : self.key_star,
        ord('|') : self.key_bar,
        ord('~') : self.key_tilde,
        8 : self.key_backspace,
    }

</t>
<t tx="ekr.20071201085751.1594">def add_char (self, char):
    self.lst_char.append (char)
    if self.state == _VI_BEGIN and self.readline.vi_is_insert_mode:
        self.readline.vi_save_line ()
        self.state = _VI_TEXT
    if self.state == _VI_SEARCH:
        if char == '\x08':  # backspace
            self.key_backspace (char)
        else:
            self.set_text (char)
        return
    if self.state == _VI_TEXT:
        if char == '\x1b':  # escape
            self.escape (char)
        elif char == '\x09':  # tab
            ts = self.readline.tabstop
            ws = ' ' * (ts - (self.readline.l_buffer.point%ts))
            self.set_text (ws)
        elif char == '\x08':  # backspace
            self.key_backspace (char)
        else:
            self.set_text (char)
        return
    if self.state == _VI_MOTION_ARGUMENT:
        self.set_motion_argument (char)
        return
    if self.state == _VI_REPLACE_ONE:
        self.replace_one (char)
        return
    try:
        fcn_instance = self.dct_fcn [ord(char)]
    except:
        fcn_instance = getattr (self, 'key_%s' % char, None)
    if fcn_instance:
        fcn_instance (char)
        return
    if char.isdigit ():
        self.key_digit (char)
        return
    # Here: could not process key
    self.error ()

</t>
<t tx="ekr.20071201085751.1595">def set_text (self, text):
    if self.text is None:
        self.text = text
    else:
        self.text += text
    self.set_buffer (text)

</t>
<t tx="ekr.20071201085751.1596">def set_buffer (self, text):
    for char in text:
        if not self.char_isprint (char):
            continue
#             self.readline.l_buffer.insert_text(char)
#             continue
#             #overwrite in l_buffer obj
        if self.is_overwrite:
            if self.readline.l_buffer.point &lt; len (self.readline.l_buffer.line_buffer):
                # self.readline.l_buffer[self.l_buffer.point]=char
                self.readline.l_buffer.line_buffer [self.readline.l_buffer.point] = char
            else:
                # self.readline.l_buffer.insert_text(char)
                self.readline.l_buffer.line_buffer.append (char)
        else:
            # self.readline.l_buffer.insert_text(char)
            self.readline.l_buffer.line_buffer.insert (self.readline.l_buffer.point, char)
        self.readline.l_buffer.point += 1

</t>
<t tx="ekr.20071201085751.1597">def replace_one (self, char):
    if char == '\x1b':  # escape
        self.end ()
        return
    self.is_edit = True
    self.readline.vi_save_line ()
    times = self.get_multiplier ()
    cursor = self.readline.l_buffer.point
    self.readline.l_buffer.line_buffer [cursor : cursor + times] = char * times
    if times &gt; 1:
        self.readline.l_buffer.point += (times - 1)
    self.end ()

</t>
<t tx="ekr.20071201085751.1598">def char_isprint (self, char):
    return ord(char) &gt;= ord(' ') and ord(char) &lt;= ord('~')

</t>
<t tx="ekr.20071201085751.1599">def key_dollar (self, char):
    self.motion = self.motion_end_in_line
    self.delete_right = 1
    self.state = _VI_MOTION
    self.apply ()

</t>
<t tx="ekr.20071201085751.1600">def key_hat (self, char):
    self.motion = self.motion_beginning_of_line
    self.state = _VI_MOTION
    self.apply ()

</t>
<t tx="ekr.20071201085751.1601">def key_0 (self, char):
    if self.state in [_VI_BEGIN, _VI_ACTION]:
        self.key_hat (char)
    else:
        self.key_digit (char)

</t>
<t tx="ekr.20071201085751.1602">def key_digit (self, char):
    if self.state in [_VI_BEGIN, _VI_MULTI1]:
        self.readline._vi_multiplier1 += char
        self.readline._vi_multiplier2 = ''
        self.state = _VI_MULTI1
    elif self.state in [_VI_ACTION, _VI_MULTI2]:
        self.readline._vi_multiplier2 += char
        self.state = _VI_MULTI2

</t>
<t tx="ekr.20071201085751.1603">def key_w (self, char):
    if self.action == self.change:
        self.key_e (char)
        return
    self.motion = self.motion_word_short
    self.state = _VI_MOTION
    self.apply ()

</t>
<t tx="ekr.20071201085751.1604">def key_W (self, char):
    if self.action == self.change:
        self.key_E (char)
        return
    self.motion = self.motion_word_long
    self.state = _VI_MOTION
    self.apply ()

</t>
<t tx="ekr.20071201085751.1605">def key_e (self, char):
    self.motion = self.motion_end_short
    self.state = _VI_MOTION
    self.delete_right = 1
    self.apply ()

</t>
<t tx="ekr.20071201085751.1606">def key_E (self, char):
    self.motion = self.motion_end_long
    self.state = _VI_MOTION
    self.delete_right = 1
    self.apply ()

</t>
<t tx="ekr.20071201085751.1607">def key_b (self, char):
    self.motion = self.motion_back_short
    self.state = _VI_MOTION
    self.apply ()

</t>
<t tx="ekr.20071201085751.1608">def key_B (self, char):
    self.motion = self.motion_back_long
    self.state = _VI_MOTION
    self.apply ()

</t>
<t tx="ekr.20071201085751.1609">def key_f (self, char):
    self.readline._vi_key_find_direction = True
    self.motion = self.motion_find_char_forward
    self.delete_right = 1
    self.state = _VI_MOTION_ARGUMENT

</t>
<t tx="ekr.20071201085751.1610">def key_F (self, char):
    self.readline._vi_key_find_direction = False
    self.motion = self.motion_find_char_backward
    self.delete_left = 1
    self.state = _VI_MOTION_ARGUMENT

</t>
<t tx="ekr.20071201085751.1611">def key_t (self, char):
    self.motion = self.motion_to_char_forward
    self.delete_right = 1
    self.state = _VI_MOTION_ARGUMENT

</t>
<t tx="ekr.20071201085751.1612">def key_T (self, char):
    self.motion = self.motion_to_char_backward
    self.state = _VI_MOTION_ARGUMENT

</t>
<t tx="ekr.20071201085751.1613">def key_j (self, char):
    self.readline.vi_down (ViEvent (char))
    self.state = _VI_END

</t>
<t tx="ekr.20071201085751.1614">def key_k (self, char):
    self.readline.vi_up (ViEvent (char))
    self.state = _VI_END

</t>
<t tx="ekr.20071201085751.1615">def key_semicolon (self, char):
    if self.readline._vi_key_find_char is None:
        self.error ()
        return
    if self.readline._vi_key_find_direction:
        self.motion = self.motion_find_char_forward
    else:
        self.motion = self.motion_find_char_backward
    self.set_motion_argument (self.readline._vi_key_find_char)

</t>
<t tx="ekr.20071201085751.1616">def key_comma (self, char):
    if self.readline._vi_key_find_char is None:
        self.error ()
        return
    if self.readline._vi_key_find_direction:
        self.motion = self.motion_find_char_backward
    else:
        self.motion = self.motion_find_char_forward
    self.set_motion_argument (self.readline._vi_key_find_char)

</t>
<t tx="ekr.20071201085751.1617">def key_percent (self, char):
    '''find matching &lt;([{}])&gt;'''
    self.motion = self.motion_matching
    self.delete_right = 1
    self.state = _VI_MOTION
    self.apply ()

</t>
<t tx="ekr.20071201085751.1618">def key_dot (self, char):
    vi_cmd_edit = self.readline._vi_command_edit
    if not vi_cmd_edit:
        return
    if vi_cmd_edit.is_star:
        self.key_star (char)
        return
    if self.has_multiplier ():
        count = self.get_multiplier ()
    else:
        count = 0
    # Create the ViCommand object after getting multipler from self
    # Side effect of the ViCommand creation is resetting of global multipliers
    vi_cmd = ViCommand (self.readline)
    if count &gt;= 1:
        vi_cmd.set_override_multiplier (count)
        vi_cmd_edit.set_override_multiplier (count)
    elif vi_cmd_edit.override_multiplier:
        vi_cmd.set_override_multiplier (vi_cmd_edit.override_multiplier)
    for char in vi_cmd_edit.lst_char:
        vi_cmd.add_char (char)
    if vi_cmd_edit.is_overwrite and self.readline.l_buffer.point &gt; 0:
        self.readline.l_buffer.point -= 1
    self.readline.vi_set_insert_mode (False)
    self.end ()

</t>
<t tx="ekr.20071201085751.1619">def key_slash (self, char):
    self.readline.vi_save_line ()
    self.readline.l_buffer.line_buffer=['/']
    self.readline.l_buffer.point= 1
    self.state = _VI_SEARCH

</t>
<t tx="ekr.20071201085751.1620">def key_star (self, char):
    self.is_star = True
    self.is_edit = True
    self.readline.vi_save_line ()
    completions = self.readline._get_completions()
    if completions:
        text = ' '.join (completions) + ' '
        self.readline.l_buffer.line_buffer [self.readline.begidx : self.readline.endidx + 1] = list (text)
        prefix_len = self.readline.endidx - self.readline.begidx
        self.readline.l_buffer.point += len(text) - prefix_len
        self.readline.vi_set_insert_mode (True)
    else:
        self.error ()
    self.state = _VI_TEXT

</t>
<t tx="ekr.20071201085751.1621">def key_bar (self, char):
    self.motion = self.motion_column
    self.state = _VI_MOTION
    self.apply ()

</t>
<t tx="ekr.20071201085751.1622">def key_tilde (self, char):
    self.is_edit = True
    self.readline.vi_save_line ()
    for i in range (self.get_multiplier()):
        try:
            c = self.readline.l_buffer.line_buffer [self.readline.l_buffer.point]
            if c.isupper ():
                self.readline.l_buffer.line_buffer [self.readline.l_buffer.point] = c.lower()
            elif c.islower ():
                self.readline.l_buffer.line_buffer [self.readline.l_buffer.point] = c.upper()
            self.readline.l_buffer.point += 1
        except IndexError:
            break
    self.end ()

</t>
<t tx="ekr.20071201085751.1623">def key_h (self, char):
    self.motion = self.motion_left
    self.state = _VI_MOTION
    self.apply ()

</t>
<t tx="ekr.20071201085751.1624">def key_backspace (self, char):
    if self.state in [_VI_TEXT, _VI_SEARCH]:
        if self.text and len(self.text):
            self.text = self.text [:-1]
            try:
                # Remove backspaces for potential dot command
                self.lst_char.pop ()
                self.lst_char.pop ()
            except IndexError:
                pass
    else:
        self.key_h (char)
    self.readline._vi_do_backspace (self)
    if self.state == _VI_SEARCH and not (self.readline.l_buffer.line_buffer):
        self.state = _VI_BEGIN

</t>
<t tx="ekr.20071201085751.1625">def key_l (self, char):
    self.motion = self.motion_right
    self.state = _VI_MOTION
    self.apply ()

</t>
<t tx="ekr.20071201085751.1626">def key_i (self, char):
    self.is_edit = True
    self.state = _VI_TEXT
    self.readline.vi_set_insert_mode (True)

</t>
<t tx="ekr.20071201085751.1627">def key_I (self, char):
    self.is_edit = True
    self.state = _VI_TEXT
    self.readline.vi_set_insert_mode (True)
    self.readline.l_buffer.point = 0

</t>
<t tx="ekr.20071201085751.1628">def key_a (self, char):
    self.is_edit = True
    self.state = _VI_TEXT
    self.readline.vi_set_insert_mode (True)
    if len (self.readline.l_buffer.line_buffer):
        self.readline.l_buffer.point += 1

</t>
<t tx="ekr.20071201085751.1629">def key_A (self, char):
    self.is_edit = True
    self.state = _VI_TEXT
    self.readline.vi_set_insert_mode (True)
    self.readline.l_buffer.point = len (self.readline.l_buffer.line_buffer)

</t>
<t tx="ekr.20071201085751.1630">def key_d (self, char):
    self.is_edit = True
    self.state = _VI_ACTION
    self.action = self.delete

</t>
<t tx="ekr.20071201085751.1631">def key_D (self, char):
    self.is_edit = True
    self.state = _VI_ACTION
    self.action = self.delete_end_of_line
    self.apply ()

</t>
<t tx="ekr.20071201085751.1632">def key_x (self, char):
    self.is_edit = True
    self.state = _VI_ACTION
    self.action = self.delete_char
    self.apply ()

</t>
<t tx="ekr.20071201085751.1633">def key_X (self, char):
    self.is_edit = True
    self.state = _VI_ACTION
    self.action = self.delete_prev_char
    self.apply ()

</t>
<t tx="ekr.20071201085751.1634">def key_s (self, char):
    self.is_edit = True
    i1 = self.readline.l_buffer.point
    i2 = self.readline.l_buffer.point + self.get_multiplier ()
    self.skip_multipler = True
    self.readline.vi_set_insert_mode (True)
    del self.readline.l_buffer.line_buffer [i1 : i2]
    self.state = _VI_TEXT

</t>
<t tx="ekr.20071201085751.1635">def key_S (self, char):
    self.is_edit = True
    self.readline.vi_set_insert_mode (True)
    self.readline.l_buffer.line_buffer = []
    self.readline.l_buffer.point = 0
    self.state = _VI_TEXT

</t>
<t tx="ekr.20071201085751.1636">def key_c (self, char):
    self.is_edit = True
    self.state = _VI_ACTION
    self.action = self.change

</t>
<t tx="ekr.20071201085751.1637">def key_C (self, char):
    self.is_edit = True
    self.readline.vi_set_insert_mode (True)
    del self.readline.l_buffer.line_buffer [self.readline.l_buffer.point : ]
    self.state = _VI_TEXT

</t>
<t tx="ekr.20071201085751.1638">def key_r (self, char):
    self.state = _VI_REPLACE_ONE

</t>
<t tx="ekr.20071201085751.1639">def key_R (self, char):
    self.is_edit = True
    self.is_overwrite = True
    self.readline.l_buffer.overwrite=True
    self.readline.vi_set_insert_mode (True)
    self.state = _VI_TEXT

</t>
<t tx="ekr.20071201085751.1640">def key_y (self, char):
    self._state = _VI_ACTION
    self.action = self.yank

</t>
<t tx="ekr.20071201085751.1641">def key_Y (self, char):
    self.readline._vi_yank_buffer = self.readline.l_buffer.get_line_text()
    self.end ()

</t>
<t tx="ekr.20071201085751.1642">def key_p (self, char):
    if not self.readline._vi_yank_buffer:
        return
    self.is_edit = True
    self.readline.vi_save_line ()
    self.readline.l_buffer.point += 1
    self.readline.l_buffer.insert_text (self.readline._vi_yank_buffer * self.get_multiplier ())
    self.readline.l_buffer.point -= 1
    self.state = _VI_END

</t>
<t tx="ekr.20071201085751.1643">def key_P (self, char):
    if not self.readline._vi_yank_buffer:
        return
    self.is_edit = True
    self.readline.vi_save_line ()
    self.readline.l_buffer.insert_text (self.readline._vi_yank_buffer * self.get_multiplier ())
    self.readline.l_buffer.point -= 1
    self.state = _VI_END

</t>
<t tx="ekr.20071201085751.1644">def key_u (self, char):
    self.readline.vi_undo ()
    self.state = _VI_END

</t>
<t tx="ekr.20071201085751.1645">def key_U (self, char):
    self.readline.vi_undo_all ()
    self.state = _VI_END

</t>
<t tx="ekr.20071201085751.1646">def key_v (self, char):
    editor = ViExternalEditor (self.readline.l_buffer.line_buffer)
    self.readline.l_buffer.line_buffer = list (editor.result)
    self.readline.l_buffer.point = 0
    self.is_edit = True
    self.state = _VI_END

</t>
<t tx="ekr.20071201085751.1647">def error (self):
    self.readline._bell ()
    self.is_error = True

</t>
<t tx="ekr.20071201085751.1648">def state_is_end (self):
    return self.state == _VI_END
</t>
<t tx="ekr.20071201085751.1649">is_end = property (state_is_end)

def state_is_search (self):
    return self.state == _VI_SEARCH
</t>
<t tx="ekr.20071201085751.1650">is_search = property (state_is_search)

def state_is_replace_one (self):
    return self.state == _VI_REPLACE_ONE
</t>
<t tx="ekr.20071201085751.1651">is_replace_one = property (state_is_replace_one)

def do_search (self):
    self.readline.vi_search_first ()
    self.state = _VI_END

</t>
<t tx="ekr.20071201085751.1652">def key_n (self, char):
    self.readline.vi_search_again_backward ()
    self.state = _VI_END

</t>
<t tx="ekr.20071201085751.1653">def key_N (self, char):
    self.readline.vi_search_again_forward ()
    self.state = _VI_END

</t>
<t tx="ekr.20071201085751.1654">def motion_beginning_of_line (self, line, index=0, count=1, **kw):
    return 0

</t>
<t tx="ekr.20071201085751.1655">def motion_end_in_line (self, line, index=0, count=1, **kw):
    return max (0, len (self.readline.l_buffer.line_buffer)-1)

</t>
<t tx="ekr.20071201085751.1656">def motion_word_short (self, line, index=0, count=1, **kw):
    return vi_pos_word_short (line, index, count)

</t>
<t tx="ekr.20071201085751.1657">def motion_word_long (self, line, index=0, count=1, **kw):
    return vi_pos_word_long (line, index, count)

</t>
<t tx="ekr.20071201085751.1658">def motion_end_short (self, line, index=0, count=1, **kw):
    return vi_pos_end_short (line, index, count)

</t>
<t tx="ekr.20071201085751.1659">def motion_end_long (self, line, index=0, count=1, **kw):
    return vi_pos_end_long (line, index, count)

</t>
<t tx="ekr.20071201085751.1660">def motion_back_short (self, line, index=0, count=1, **kw):
    return vi_pos_back_short (line, index, count)

</t>
<t tx="ekr.20071201085751.1661">def motion_back_long (self, line, index=0, count=1, **kw):
    return vi_pos_back_long (line, index, count)

</t>
<t tx="ekr.20071201085751.1662">def motion_find_char_forward (self, line, index=0, count=1, char=None):
    self.readline._vi_key_find_char = char
    return vi_pos_find_char_forward (line, char, index, count)

</t>
<t tx="ekr.20071201085751.1663">def motion_find_char_backward (self, line, index=0, count=1, char=None):
    self.readline._vi_key_find_char = char
    return vi_pos_find_char_backward (line, char, index, count)

</t>
<t tx="ekr.20071201085751.1664">def motion_to_char_forward  (self, line, index=0, count=1, char=None):
    return vi_pos_to_char_forward (line, char, index, count)

</t>
<t tx="ekr.20071201085751.1665">def motion_to_char_backward  (self, line, index=0, count=1, char=None):
    return vi_pos_to_char_backward (line, char, index, count)

</t>
<t tx="ekr.20071201085751.1666">def motion_left (self, line, index=0, count=1, char=None):
    return max (0, index - count)

</t>
<t tx="ekr.20071201085751.1667">def motion_right (self, line, index=0, count=1, char=None):
    return min (len(line), index + count)

</t>
<t tx="ekr.20071201085751.1668">def motion_matching (self, line, index=0, count=1, char=None):
    return vi_pos_matching (line, index)

</t>
<t tx="ekr.20071201085751.1669">def motion_column (self, line, index=0, count=1, char=None):
    return max (0, count-1)

</t>
<t tx="ekr.20071201085751.1670">def has_multiplier (self):
    return self.override_multiplier or self.readline._vi_multiplier1 or self.readline._vi_multiplier2

</t>
<t tx="ekr.20071201085751.1671">def get_multiplier (self):
    if self.override_multiplier:
        return int (self.override_multiplier)
    if self.readline._vi_multiplier1 == '': m1 = 1
    else: m1 = int(self.readline._vi_multiplier1)
    if self.readline._vi_multiplier2 == '': m2 = 1
    else: m2 = int(self.readline._vi_multiplier2)
    return m1 * m2

</t>
<t tx="ekr.20071201085751.1672">def set_override_multiplier (self, count):
    self.override_multiplier = count

</t>
<t tx="ekr.20071201085751.1673">def apply (self):
    if self.motion:
        self.pos_motion = self.motion (self.readline.l_buffer.line_buffer, self.readline.l_buffer.point,
                self.get_multiplier(), char=self.motion_argument)
        if self.pos_motion &lt; 0:
            self.error ()
            return
    self.action ()
    if self.state != _VI_TEXT:
        self.end ()

</t>
<t tx="ekr.20071201085751.1674">def movement (self):
    if self.pos_motion &lt;= len(self.readline.l_buffer.line_buffer):
        self.readline.l_buffer.point = self.pos_motion
    else:
        self.readline.l_buffer.point = len(self.readline.l_buffer.line_buffer) - 1

</t>
<t tx="ekr.20071201085751.1675">def yank (self):
    if self.pos_motion &gt; self.readline.l_buffer.point:
        s = self.readline.l_buffer.line_buffer [self.readline.l_buffer.point : self.pos_motion + self.delete_right]
    else:
        index = max (0, self.pos_motion - self.delete_left)
        s = self.readline.l_buffer.line_buffer [index : self.readline.l_buffer.point + self.delete_right]
    self.readline._vi_yank_buffer = s

</t>
<t tx="ekr.20071201085751.1676">def delete (self):
    self.readline.vi_save_line ()
    self.yank ()
#         point=lineobj.Point(self.readline.l_buffer)
#         pm=self.pos_motion
#         del self.readline.l_buffer[point:pm]
#         return
    if self.pos_motion &gt; self.readline.l_buffer.point:
        del self.readline.l_buffer.line_buffer [self.readline.l_buffer.point : self.pos_motion + self.delete_right]
        if self.readline.l_buffer.point &gt; len (self.readline.l_buffer.line_buffer):
            self.readline.l_buffer.point = len (self.readline.l_buffer.line_buffer)
    else:
        index = max (0, self.pos_motion - self.delete_left)
        del self.readline.l_buffer.line_buffer [index : self.readline.l_buffer.point + self.delete_right]
        self.readline.l_buffer.point = index

</t>
<t tx="ekr.20071201085751.1677">def delete_end_of_line (self):
    self.readline.vi_save_line ()
    # del self.readline.l_buffer [self.readline.l_buffer.point : ]
    line_text = self.readline.l_buffer.get_line_text ()
    line_text = line_text [ : self.readline.l_buffer.point]
    self.readline.l_buffer.set_line (line_text)
    if self.readline.l_buffer.point &gt; 0:
        self.readline.l_buffer.point -= 1

</t>
<t tx="ekr.20071201085751.1678">def delete_char (self):
#         point=lineobj.Point(self.readline.l_buffer)
#         del self.readline.l_buffer[point:point+self.get_multiplier ()]
#         return
    self.pos_motion = self.readline.l_buffer.point + self.get_multiplier ()
    self.delete ()
    end = max (0, len (self.readline.l_buffer) - 1)
    if self.readline.l_buffer.point &gt; end:
        self.readline.l_buffer.point = end

</t>
<t tx="ekr.20071201085751.1679">def delete_prev_char (self):
    self.pos_motion = self.readline.l_buffer.point - self.get_multiplier ()
    self.delete ()

</t>
<t tx="ekr.20071201085751.1680">def change (self):
    self.readline.vi_set_insert_mode (True)
    self.delete ()
    self.skip_multipler = True
    self.state = _VI_TEXT

</t>
<t tx="ekr.20071201085751.1681">def escape (self, char):
    if self.state == _VI_TEXT:
        if not self.skip_multipler:
            times = self.get_multiplier ()
            if times &gt; 1 and self.text:
                extra = self.text * (times - 1)
                self.set_buffer (extra)
    self.state = _VI_END

</t>
<t tx="ekr.20071201085751.1682">def set_motion_argument (self, char):
    self.motion_argument = char
    self.apply ()

</t>
<t tx="ekr.20071201085751.1683">def end (self):
    self.state = _VI_END
    if self.readline.l_buffer.point &gt;= len(self.readline.l_buffer.line_buffer):
        self.readline.l_buffer.point = max (0, len(self.readline.l_buffer.line_buffer) - 1)

</t>
<t tx="ekr.20071201085751.1684">class ViExternalEditor:
    @others
</t>
<t tx="ekr.20071201085751.1685">def __init__ (self, line):
    if type(line) is type([]):
        line = ''.join (line)
    file_tmp = self.get_tempfile ()
    fp_tmp = self.file_open (file_tmp, 'w')
    fp_tmp.write (line)
    fp_tmp.close ()
    self.run_editor (file_tmp)
    fp_tmp = self.file_open (file_tmp, 'r')
    self.result = fp_tmp.read ()
    fp_tmp.close ()
    self.file_remove (file_tmp)

</t>
<t tx="ekr.20071201085751.1686">def get_tempfile (self):
    import tempfile
    return tempfile.mktemp (prefix='readline-', suffix='.py')

</t>
<t tx="ekr.20071201085751.1687">def file_open (self, filename, mode):
    return file (filename, mode)

</t>
<t tx="ekr.20071201085751.1688">def file_remove (self, filename):
    os.remove (filename)

</t>
<t tx="ekr.20071201085751.1689">def get_editor (self):
    try:
        return os.environ ['EDITOR']
    except KeyError:
        return 'notepad'  # ouch

</t>
<t tx="ekr.20071201085751.1690">def run_editor (self, filename):
    cmd = '%s %s' % (self.get_editor(), filename, )
    self.run_command (cmd)

</t>
<t tx="ekr.20071201085751.1691">def run_command (self, command):
    os.system (command)

</t>
<t tx="ekr.20071201085751.1692">class ViEvent:
    @others
</t>
<t tx="ekr.20071201085751.1693">def __init__ (self, char):
    self.char = char

</t>
<t tx="ekr.20071201085751.1694"># vi standalone functions
def vi_is_word (char):
    log ('xx vi_is_word: type(%s), %s' % (type(char), char, ))
    return char.isalpha() or char.isdigit() or char == '_'

</t>
<t tx="ekr.20071201085751.1695">def vi_is_space (char):
    return char.isspace ()

</t>
<t tx="ekr.20071201085751.1696">def vi_is_word_or_space (char):
    return vi_is_word (char) or vi_is_space (char)

</t>
<t tx="ekr.20071201085751.1697">def vi_pos_word_short (line, index=0, count=1):
    try:
        for i in range(count):
            in_word = vi_is_word (line[index])
            if not in_word:
                while not vi_is_word (line[index]):
                    index += 1
            else:
                while vi_is_word (line[index]):
                    index += 1
            while vi_is_space (line[index]):
                index += 1
        return index
    except IndexError:
        return len(line)

</t>
<t tx="ekr.20071201085751.1698">def vi_pos_word_long (line, index=0, count=1):
    try:
        for i in range(count):
            in_space = vi_is_space (line[index])
            if not in_space:
                while not vi_is_space (line[index]):
                    index += 1
            while vi_is_space (line[index]):
                index += 1
        return index
    except IndexError:
        return len(line)

</t>
<t tx="ekr.20071201085751.1699">def vi_pos_end_short (line, index=0, count=1):
    try:
        for i in range(count):
            index += 1
            while vi_is_space (line[index]):
                index += 1
            in_word = vi_is_word (line[index])
            if not in_word:
                while not vi_is_word_or_space (line[index]):
                    index += 1
            else:
                while vi_is_word (line[index]):
                    index += 1
        return index - 1
    except IndexError:
        return max (0, len(line)-1)

</t>
<t tx="ekr.20071201085751.1700">def vi_pos_end_long (line, index=0, count=1):
    try:
        for i in range(count):
            index += 1
            while vi_is_space (line[index]):
                index += 1
            while not vi_is_space (line[index]):
                index += 1
        return index - 1
    except IndexError:
        return max (0, len(line)-1)

</t>
<t tx="ekr.20071201085751.1701">class vi_list (list):
    '''This is a list that cannot have a negative index'''
    @others
</t>
<t tx="ekr.20071201085751.1702">def __getitem__ (self, key):
    try:
        if int(key) &lt; 0:
            raise IndexError
    except ValueError:
        pass
    return list.__getitem__ (self, key)

</t>
<t tx="ekr.20071201085751.1703">def vi_pos_back_short (line, index=0, count=1):
    line = vi_list (line)
    try:
        for i in range(count):
            index -= 1
            while vi_is_space (line[index]):
                index -= 1
            in_word = vi_is_word (line[index])
            if in_word:
                while vi_is_word (line[index]):
                    index -= 1
            else:
                while not vi_is_word_or_space (line[index]):
                    index -= 1
        return index + 1
    except IndexError:
        return 0

</t>
<t tx="ekr.20071201085751.1704">def vi_pos_back_long (line, index=0, count=1):
    line = vi_list (line)
    try:
        for i in range(count):
            index -= 1
            while vi_is_space (line[index]):
                index -= 1
            while not vi_is_space (line[index]):
                index -= 1
        return index + 1
    except IndexError:
        return 0

</t>
<t tx="ekr.20071201085751.1705">def vi_pos_find_char_forward (line, char, index=0, count=1):
    try:
        for i in range(count):
            index += 1
            while line [index] != char:
                index += 1
        return index
    except IndexError:
        return -1

</t>
<t tx="ekr.20071201085751.1706">def vi_pos_find_char_backward (line, char, index=0, count=1):
    try:
        for i in range(count):
            index -= 1
            while 1:
                if index &lt; 0:
                    return -1
                if line[index] == char:
                    break
                index -= 1
        return index
    except IndexError:
        return -1

</t>
<t tx="ekr.20071201085751.1707">def vi_pos_to_char_forward (line, char, index=0, count=1):
    index = vi_pos_find_char_forward (line, char, index, count)
    if index &gt; 0:
        return index - 1
    return index

</t>
<t tx="ekr.20071201085751.1708">def vi_pos_to_char_backward (line, char, index=0, count=1):
    index = vi_pos_find_char_backward (line, char, index, count)
    if index &gt;= 0:
        return index + 1
    return index

</t>
<t tx="ekr.20071201085751.1709">_vi_dct_matching = {
    '&lt;': ('&gt;', +1), '&gt;': ('&lt;', -1),
    '(': (')', +1), ')': ('(', -1),
    '[': (']', +1), ']': ('[', -1),
    '{': ('}', +1), '}': ('{', -1),
}

def vi_pos_matching (line, index=0):
    '''find matching &lt;([{}])&gt;'''
    anchor = None
    target = None
    delta = 1
    count = 0
    try:
        while 1:
            if anchor is None:
                # first find anchor
                try:
                    target, delta = _vi_dct_matching [line [index]]
                    anchor = line [index]
                    count = 1
                except KeyError:
                    index += 1
                    continue
            else:
                # Here the anchor has been found
                # Need to get corresponding target
                if index &lt; 0:
                    return -1
                if line [index] == anchor:
                    count += 1
                elif line [index] == target:
                    count -= 1
                    if count == 0:
                        return index
            index += delta
    except IndexError:
        return -1

</t>
<t tx="ekr.20071201085751.1710">__all__=["emacs","notemacs","vi"]
import emacs,notemacs,vi
editingmodes=[emacs.EmacsMode,notemacs.NotEmacsMode,vi.ViMode]

</t>
<t tx="ekr.20071201085901"># All files imported correctly except those marked with 'import error'
</t>
</tnodes>
</leo_file>
